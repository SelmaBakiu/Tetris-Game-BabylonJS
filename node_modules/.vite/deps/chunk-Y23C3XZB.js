import {
  InternalTexture,
  InternalTextureSource,
  IsDocumentAvailable,
  IsWindowObjectExist,
  Logger,
  PerfCounter,
  PrecisionDate,
  ThinEngine,
  WebGLDataBuffer,
  WebGLHardwareTexture,
  _WarnImport,
  init_devTools,
  init_domManagement,
  init_internalTexture,
  init_logger,
  init_perfCounter,
  init_precisionDate,
  init_thinEngine,
  init_webGLDataBuffer,
  init_webGLHardwareTexture
} from "./chunk-YCJ6WHUD.js";
import {
  EngineStore,
  Observable,
  __esm,
  init_engineStore,
  init_observable
} from "./chunk-N3NUGEQO.js";

// node_modules/@babylonjs/core/Misc/performanceMonitor.js
var PerformanceMonitor, RollingAverage;
var init_performanceMonitor = __esm({
  "node_modules/@babylonjs/core/Misc/performanceMonitor.js"() {
    init_precisionDate();
    PerformanceMonitor = class {
      constructor(frameSampleSize = 30) {
        this._enabled = true;
        this._rollingFrameTime = new RollingAverage(frameSampleSize);
      }
      sampleFrame(timeMs = PrecisionDate.Now) {
        if (!this._enabled) {
          return;
        }
        if (this._lastFrameTimeMs != null) {
          const dt = timeMs - this._lastFrameTimeMs;
          this._rollingFrameTime.add(dt);
        }
        this._lastFrameTimeMs = timeMs;
      }
      get averageFrameTime() {
        return this._rollingFrameTime.average;
      }
      get averageFrameTimeVariance() {
        return this._rollingFrameTime.variance;
      }
      get instantaneousFrameTime() {
        return this._rollingFrameTime.history(0);
      }
      get averageFPS() {
        return 1e3 / this._rollingFrameTime.average;
      }
      get instantaneousFPS() {
        const history = this._rollingFrameTime.history(0);
        if (history === 0) {
          return 0;
        }
        return 1e3 / history;
      }
      get isSaturated() {
        return this._rollingFrameTime.isSaturated();
      }
      enable() {
        this._enabled = true;
      }
      disable() {
        this._enabled = false;
        this._lastFrameTimeMs = null;
      }
      get isEnabled() {
        return this._enabled;
      }
      reset() {
        this._lastFrameTimeMs = null;
        this._rollingFrameTime.reset();
      }
    };
    RollingAverage = class {
      constructor(length) {
        this._samples = new Array(length);
        this.reset();
      }
      add(v) {
        let delta;
        if (this.isSaturated()) {
          const bottomValue = this._samples[this._pos];
          delta = bottomValue - this.average;
          this.average -= delta / (this._sampleCount - 1);
          this._m2 -= delta * (bottomValue - this.average);
        } else {
          this._sampleCount++;
        }
        delta = v - this.average;
        this.average += delta / this._sampleCount;
        this._m2 += delta * (v - this.average);
        this.variance = this._m2 / (this._sampleCount - 1);
        this._samples[this._pos] = v;
        this._pos++;
        this._pos %= this._samples.length;
      }
      history(i) {
        if (i >= this._sampleCount || i >= this._samples.length) {
          return 0;
        }
        const i0 = this._wrapPosition(this._pos - 1);
        return this._samples[this._wrapPosition(i0 - i)];
      }
      isSaturated() {
        return this._sampleCount >= this._samples.length;
      }
      reset() {
        this.average = 0;
        this.variance = 0;
        this._sampleCount = 0;
        this._pos = 0;
        this._m2 = 0;
      }
      _wrapPosition(i) {
        const max = this._samples.length;
        return (i % max + max) % max;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js
function allocateAndCopyTypedBuffer(type, sizeOrDstBuffer, sizeInBytes = false, copyBuffer) {
  switch (type) {
    case 3: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int8Array(sizeOrDstBuffer) : new Int8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Int8Array(copyBuffer));
      }
      return buffer2;
    }
    case 0: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Uint8Array(copyBuffer));
      }
      return buffer2;
    }
    case 4: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int16Array(sizeOrDstBuffer) : new Int16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Int16Array(copyBuffer));
      }
      return buffer2;
    }
    case 5:
    case 8:
    case 9:
    case 10:
    case 2: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint16Array(sizeOrDstBuffer) : new Uint16Array(sizeInBytes ? sizeOrDstBuffer / 2 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Uint16Array(copyBuffer));
      }
      return buffer2;
    }
    case 6: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Int32Array(sizeOrDstBuffer) : new Int32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Int32Array(copyBuffer));
      }
      return buffer2;
    }
    case 7:
    case 11:
    case 12:
    case 13:
    case 14:
    case 15: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint32Array(sizeOrDstBuffer) : new Uint32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Uint32Array(copyBuffer));
      }
      return buffer2;
    }
    case 1: {
      const buffer2 = sizeOrDstBuffer instanceof ArrayBuffer ? new Float32Array(sizeOrDstBuffer) : new Float32Array(sizeInBytes ? sizeOrDstBuffer / 4 : sizeOrDstBuffer);
      if (copyBuffer) {
        buffer2.set(new Float32Array(copyBuffer));
      }
      return buffer2;
    }
  }
  const buffer = sizeOrDstBuffer instanceof ArrayBuffer ? new Uint8Array(sizeOrDstBuffer) : new Uint8Array(sizeOrDstBuffer);
  if (copyBuffer) {
    buffer.set(new Uint8Array(copyBuffer));
  }
  return buffer;
}
var init_engine_readTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.readTexture.js"() {
    init_thinEngine();
    ThinEngine.prototype._readTexturePixelsSync = function(texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
      var _a, _b;
      const gl = this._gl;
      if (!gl) {
        throw new Error("Engine does not have gl rendering context.");
      }
      if (!this._dummyFramebuffer) {
        const dummy = gl.createFramebuffer();
        if (!dummy) {
          throw new Error("Unable to create dummy framebuffer");
        }
        this._dummyFramebuffer = dummy;
      }
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._dummyFramebuffer);
      if (faceIndex > -1) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, level);
      } else {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, (_b = texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, level);
      }
      let readType = texture.type !== void 0 ? this._getWebGLTextureType(texture.type) : gl.UNSIGNED_BYTE;
      if (!noDataConversion) {
        switch (readType) {
          case gl.UNSIGNED_BYTE:
            if (!buffer) {
              buffer = new Uint8Array(4 * width * height);
            }
            readType = gl.UNSIGNED_BYTE;
            break;
          default:
            if (!buffer) {
              buffer = new Float32Array(4 * width * height);
            }
            readType = gl.FLOAT;
            break;
        }
      } else if (!buffer) {
        buffer = allocateAndCopyTypedBuffer(texture.type, 4 * width * height);
      }
      if (flushRenderer) {
        this.flushFramebuffer();
      }
      gl.readPixels(x, y, width, height, gl.RGBA, readType, buffer);
      gl.bindFramebuffer(gl.FRAMEBUFFER, this._currentFramebuffer);
      return buffer;
    };
    ThinEngine.prototype._readTexturePixels = function(texture, width, height, faceIndex = -1, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0) {
      return Promise.resolve(this._readTexturePixelsSync(texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y));
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js
var init_engine_alpha = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.alpha.js"() {
    init_thinEngine();
    ThinEngine.prototype.setAlphaConstants = function(r, g, b, a) {
      this._alphaState.setAlphaBlendConstants(r, g, b, a);
    };
    ThinEngine.prototype.setAlphaMode = function(mode, noDepthWriteChange = false) {
      if (this._alphaMode === mode) {
        if (!noDepthWriteChange) {
          const depthMask = mode === 0;
          if (this.depthCullingState.depthMask !== depthMask) {
            this.depthCullingState.depthMask = depthMask;
          }
        }
        return;
      }
      switch (mode) {
        case 0:
          this._alphaState.alphaBlend = false;
          break;
        case 7:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 8:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 2:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 6:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 1:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 3:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ZERO, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 4:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_COLOR, this._gl.ZERO, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 5:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 9:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.CONSTANT_COLOR, this._gl.ONE_MINUS_CONSTANT_COLOR, this._gl.CONSTANT_ALPHA, this._gl.ONE_MINUS_CONSTANT_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 10:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 11:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 12:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.DST_ALPHA, this._gl.ONE, this._gl.ZERO, this._gl.ZERO);
          this._alphaState.alphaBlend = true;
          break;
        case 13:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ONE_MINUS_DST_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 14:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
        case 15:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE, this._gl.ONE, this._gl.ONE, this._gl.ZERO);
          this._alphaState.alphaBlend = true;
          break;
        case 16:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.ONE_MINUS_DST_COLOR, this._gl.ONE_MINUS_SRC_COLOR, this._gl.ZERO, this._gl.ONE);
          this._alphaState.alphaBlend = true;
          break;
        case 17:
          this._alphaState.setAlphaBlendFunctionParameters(this._gl.SRC_ALPHA, this._gl.ONE_MINUS_SRC_ALPHA, this._gl.ONE, this._gl.ONE_MINUS_SRC_ALPHA);
          this._alphaState.alphaBlend = true;
          break;
      }
      if (!noDepthWriteChange) {
        this.depthCullingState.depthMask = mode === 0;
      }
      this._alphaMode = mode;
    };
    ThinEngine.prototype.getAlphaMode = function() {
      return this._alphaMode;
    };
    ThinEngine.prototype.setAlphaEquation = function(equation) {
      if (this._alphaEquation === equation) {
        return;
      }
      switch (equation) {
        case 0:
          this._alphaState.setAlphaEquationParameters(32774, 32774);
          break;
        case 1:
          this._alphaState.setAlphaEquationParameters(32778, 32778);
          break;
        case 2:
          this._alphaState.setAlphaEquationParameters(32779, 32779);
          break;
        case 3:
          this._alphaState.setAlphaEquationParameters(32776, 32776);
          break;
        case 4:
          this._alphaState.setAlphaEquationParameters(32775, 32775);
          break;
        case 5:
          this._alphaState.setAlphaEquationParameters(32775, 32774);
          break;
      }
      this._alphaEquation = equation;
    };
    ThinEngine.prototype.getAlphaEquation = function() {
      return this._alphaEquation;
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js
var init_engine_dynamicBuffer = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.dynamicBuffer.js"() {
    init_thinEngine();
    ThinEngine.prototype.updateDynamicIndexBuffer = function(indexBuffer, indices, offset = 0) {
      this._currentBoundBuffer[this._gl.ELEMENT_ARRAY_BUFFER] = null;
      this.bindIndexBuffer(indexBuffer);
      let view;
      if (indexBuffer.is32Bits) {
        view = indices instanceof Uint32Array ? indices : new Uint32Array(indices);
      } else {
        view = indices instanceof Uint16Array ? indices : new Uint16Array(indices);
      }
      this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, view, this._gl.DYNAMIC_DRAW);
      this._resetIndexBufferBinding();
    };
    ThinEngine.prototype.updateDynamicVertexBuffer = function(vertexBuffer, data, byteOffset, byteLength) {
      this.bindArrayBuffer(vertexBuffer);
      if (byteOffset === void 0) {
        byteOffset = 0;
      }
      const dataLength = data.byteLength || data.length;
      if (byteLength === void 0 || byteLength >= dataLength && byteOffset === 0) {
        if (data instanceof Array) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, new Float32Array(data));
        } else {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, byteOffset, data);
        }
      } else {
        if (data instanceof Array) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, new Float32Array(data).subarray(byteOffset, byteOffset + byteLength));
        } else {
          if (data instanceof ArrayBuffer) {
            data = new Uint8Array(data, byteOffset, byteLength);
          } else {
            data = new Uint8Array(data.buffer, data.byteOffset + byteOffset, byteLength);
          }
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
        }
      }
      this._resetVertexBufferBinding();
    };
  }
});

// node_modules/@babylonjs/core/Engines/engine.js
var Engine;
var init_engine = __esm({
  "node_modules/@babylonjs/core/Engines/engine.js"() {
    init_observable();
    init_internalTexture();
    init_domManagement();
    init_engineStore();
    init_devTools();
    init_thinEngine();
    init_performanceMonitor();
    init_perfCounter();
    init_webGLDataBuffer();
    init_logger();
    init_webGLHardwareTexture();
    init_engine_alpha();
    init_engine_readTexture();
    init_engine_dynamicBuffer();
    Engine = class extends ThinEngine {
      static get NpmPackage() {
        return ThinEngine.NpmPackage;
      }
      static get Version() {
        return ThinEngine.Version;
      }
      static get Instances() {
        return EngineStore.Instances;
      }
      static get LastCreatedEngine() {
        return EngineStore.LastCreatedEngine;
      }
      static get LastCreatedScene() {
        return EngineStore.LastCreatedScene;
      }
      _createImageBitmapFromSource(imageSource, options) {
        const promise = new Promise((resolve, reject) => {
          const image = new Image();
          image.onload = () => {
            image.decode().then(() => {
              this.createImageBitmap(image, options).then((imageBitmap) => {
                resolve(imageBitmap);
              });
            });
          };
          image.onerror = () => {
            reject(`Error loading image ${image.src}`);
          };
          image.src = imageSource;
        });
        return promise;
      }
      createImageBitmap(image, options) {
        return createImageBitmap(image, options);
      }
      resizeImageBitmap(image, bufferWidth, bufferHeight) {
        const canvas = this.createCanvas(bufferWidth, bufferHeight);
        const context = canvas.getContext("2d");
        if (!context) {
          throw new Error("Unable to get 2d context for resizeImageBitmap");
        }
        context.drawImage(image, 0, 0);
        const buffer = context.getImageData(0, 0, bufferWidth, bufferHeight).data;
        return buffer;
      }
      static MarkAllMaterialsAsDirty(flag, predicate) {
        for (let engineIndex = 0; engineIndex < Engine.Instances.length; engineIndex++) {
          const engine = Engine.Instances[engineIndex];
          for (let sceneIndex = 0; sceneIndex < engine.scenes.length; sceneIndex++) {
            engine.scenes[sceneIndex].markAllMaterialsAsDirty(flag, predicate);
          }
        }
      }
      static DefaultLoadingScreenFactory(canvas) {
        throw _WarnImport("LoadingScreen");
      }
      get _supportsHardwareTextureRescaling() {
        return !!Engine._RescalePostProcessFactory;
      }
      get performanceMonitor() {
        return this._performanceMonitor;
      }
      get compatibilityMode() {
        return this._compatibilityMode;
      }
      set compatibilityMode(mode) {
        this._compatibilityMode = true;
      }
      getInputElement() {
        return this._renderingCanvas;
      }
      constructor(canvasOrContext, antialias, options, adaptToDeviceRatio = false) {
        super(canvasOrContext, antialias, options, adaptToDeviceRatio);
        this.enableOfflineSupport = false;
        this.disableManifestCheck = false;
        this.disableContextMenu = true;
        this.scenes = new Array();
        this._virtualScenes = new Array();
        this.onNewSceneAddedObservable = new Observable();
        this.postProcesses = new Array();
        this.isPointerLock = false;
        this.onResizeObservable = new Observable();
        this.onCanvasBlurObservable = new Observable();
        this.onCanvasFocusObservable = new Observable();
        this.onCanvasPointerOutObservable = new Observable();
        this.onBeginFrameObservable = new Observable();
        this.customAnimationFrameRequester = null;
        this.onEndFrameObservable = new Observable();
        this.onBeforeShaderCompilationObservable = new Observable();
        this.onAfterShaderCompilationObservable = new Observable();
        this._deterministicLockstep = false;
        this._lockstepMaxSteps = 4;
        this._timeStep = 1 / 60;
        this._fps = 60;
        this._deltaTime = 0;
        this._drawCalls = new PerfCounter();
        this.canvasTabIndex = 1;
        this.disablePerformanceMonitorInBackground = false;
        this._performanceMonitor = new PerformanceMonitor();
        this._compatibilityMode = true;
        this.currentRenderPassId = 0;
        this._renderPassNames = ["main"];
        Engine.Instances.push(this);
        if (!canvasOrContext) {
          return;
        }
        this._features.supportRenderPasses = true;
        options = this._creationOptions;
        if (canvasOrContext.getContext) {
          const canvas = canvasOrContext;
          this._sharedInit(canvas);
          this._connectVREvents();
        }
        this._prepareVRComponent();
        if (options.autoEnableWebVR) {
          this.initWebVR();
        }
      }
      _initGLContext() {
        super._initGLContext();
        this._rescalePostProcess = null;
      }
      _sharedInit(canvas) {
        super._sharedInit(canvas);
        this._onCanvasFocus = () => {
          this.onCanvasFocusObservable.notifyObservers(this);
        };
        this._onCanvasBlur = () => {
          this.onCanvasBlurObservable.notifyObservers(this);
        };
        this._onCanvasContextMenu = (evt) => {
          if (this.disableContextMenu) {
            evt.preventDefault();
          }
        };
        canvas.addEventListener("focus", this._onCanvasFocus);
        canvas.addEventListener("blur", this._onCanvasBlur);
        canvas.addEventListener("contextmenu", this._onCanvasContextMenu);
        this._onBlur = () => {
          if (this.disablePerformanceMonitorInBackground) {
            this._performanceMonitor.disable();
          }
          this._windowIsBackground = true;
        };
        this._onFocus = () => {
          if (this.disablePerformanceMonitorInBackground) {
            this._performanceMonitor.enable();
          }
          this._windowIsBackground = false;
        };
        this._onCanvasPointerOut = (ev) => {
          if (document.elementFromPoint(ev.clientX, ev.clientY) !== canvas) {
            this.onCanvasPointerOutObservable.notifyObservers(ev);
          }
        };
        const hostWindow = this.getHostWindow();
        if (hostWindow && typeof hostWindow.addEventListener === "function") {
          hostWindow.addEventListener("blur", this._onBlur);
          hostWindow.addEventListener("focus", this._onFocus);
        }
        canvas.addEventListener("pointerout", this._onCanvasPointerOut);
        if (!this._creationOptions.doNotHandleTouchAction) {
          this._disableTouchAction();
        }
        if (!Engine.audioEngine && this._creationOptions.audioEngine && Engine.AudioEngineFactory) {
          Engine.audioEngine = Engine.AudioEngineFactory(this.getRenderingCanvas(), this.getAudioContext(), this.getAudioDestination());
        }
        if (IsDocumentAvailable()) {
          this._onFullscreenChange = () => {
            this.isFullscreen = !!document.fullscreenElement;
            if (this.isFullscreen && this._pointerLockRequested && canvas) {
              Engine._RequestPointerlock(canvas);
            }
          };
          document.addEventListener("fullscreenchange", this._onFullscreenChange, false);
          document.addEventListener("webkitfullscreenchange", this._onFullscreenChange, false);
          this._onPointerLockChange = () => {
            this.isPointerLock = document.pointerLockElement === canvas;
          };
          document.addEventListener("pointerlockchange", this._onPointerLockChange, false);
          document.addEventListener("webkitpointerlockchange", this._onPointerLockChange, false);
        }
        this.enableOfflineSupport = Engine.OfflineProviderFactory !== void 0;
        this._deterministicLockstep = !!this._creationOptions.deterministicLockstep;
        this._lockstepMaxSteps = this._creationOptions.lockstepMaxSteps || 0;
        this._timeStep = this._creationOptions.timeStep || 1 / 60;
      }
      _verifyPointerLock() {
        var _a;
        (_a = this._onPointerLockChange) === null || _a === void 0 ? void 0 : _a.call(this);
      }
      getAspectRatio(viewportOwner, useScreen = false) {
        const viewport = viewportOwner.viewport;
        return this.getRenderWidth(useScreen) * viewport.width / (this.getRenderHeight(useScreen) * viewport.height);
      }
      getScreenAspectRatio() {
        return this.getRenderWidth(true) / this.getRenderHeight(true);
      }
      getRenderingCanvasClientRect() {
        if (!this._renderingCanvas) {
          return null;
        }
        return this._renderingCanvas.getBoundingClientRect();
      }
      getInputElementClientRect() {
        if (!this._renderingCanvas) {
          return null;
        }
        return this.getInputElement().getBoundingClientRect();
      }
      isDeterministicLockStep() {
        return this._deterministicLockstep;
      }
      getLockstepMaxSteps() {
        return this._lockstepMaxSteps;
      }
      getTimeStep() {
        return this._timeStep * 1e3;
      }
      generateMipMapsForCubemap(texture, unbind = true) {
        if (texture.generateMipMaps) {
          const gl = this._gl;
          this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
          if (unbind) {
            this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
          }
        }
      }
      getDepthWrite() {
        return this._depthCullingState.depthMask;
      }
      setDepthWrite(enable) {
        this._depthCullingState.depthMask = enable;
      }
      getStencilBuffer() {
        return this._stencilState.stencilTest;
      }
      setStencilBuffer(enable) {
        this._stencilState.stencilTest = enable;
      }
      getStencilMask() {
        return this._stencilState.stencilMask;
      }
      setStencilMask(mask) {
        this._stencilState.stencilMask = mask;
      }
      getStencilFunction() {
        return this._stencilState.stencilFunc;
      }
      getStencilFunctionReference() {
        return this._stencilState.stencilFuncRef;
      }
      getStencilFunctionMask() {
        return this._stencilState.stencilFuncMask;
      }
      setStencilFunction(stencilFunc) {
        this._stencilState.stencilFunc = stencilFunc;
      }
      setStencilFunctionReference(reference) {
        this._stencilState.stencilFuncRef = reference;
      }
      setStencilFunctionMask(mask) {
        this._stencilState.stencilFuncMask = mask;
      }
      getStencilOperationFail() {
        return this._stencilState.stencilOpStencilFail;
      }
      getStencilOperationDepthFail() {
        return this._stencilState.stencilOpDepthFail;
      }
      getStencilOperationPass() {
        return this._stencilState.stencilOpStencilDepthPass;
      }
      setStencilOperationFail(operation) {
        this._stencilState.stencilOpStencilFail = operation;
      }
      setStencilOperationDepthFail(operation) {
        this._stencilState.stencilOpDepthFail = operation;
      }
      setStencilOperationPass(operation) {
        this._stencilState.stencilOpStencilDepthPass = operation;
      }
      setDitheringState(value) {
        if (value) {
          this._gl.enable(this._gl.DITHER);
        } else {
          this._gl.disable(this._gl.DITHER);
        }
      }
      setRasterizerState(value) {
        if (value) {
          this._gl.disable(this._gl.RASTERIZER_DISCARD);
        } else {
          this._gl.enable(this._gl.RASTERIZER_DISCARD);
        }
      }
      getDepthFunction() {
        return this._depthCullingState.depthFunc;
      }
      setDepthFunction(depthFunc) {
        this._depthCullingState.depthFunc = depthFunc;
      }
      setDepthFunctionToGreater() {
        this.setDepthFunction(516);
      }
      setDepthFunctionToGreaterOrEqual() {
        this.setDepthFunction(518);
      }
      setDepthFunctionToLess() {
        this.setDepthFunction(513);
      }
      setDepthFunctionToLessOrEqual() {
        this.setDepthFunction(515);
      }
      cacheStencilState() {
        this._cachedStencilBuffer = this.getStencilBuffer();
        this._cachedStencilFunction = this.getStencilFunction();
        this._cachedStencilMask = this.getStencilMask();
        this._cachedStencilOperationPass = this.getStencilOperationPass();
        this._cachedStencilOperationFail = this.getStencilOperationFail();
        this._cachedStencilOperationDepthFail = this.getStencilOperationDepthFail();
        this._cachedStencilReference = this.getStencilFunctionReference();
      }
      restoreStencilState() {
        this.setStencilFunction(this._cachedStencilFunction);
        this.setStencilMask(this._cachedStencilMask);
        this.setStencilBuffer(this._cachedStencilBuffer);
        this.setStencilOperationPass(this._cachedStencilOperationPass);
        this.setStencilOperationFail(this._cachedStencilOperationFail);
        this.setStencilOperationDepthFail(this._cachedStencilOperationDepthFail);
        this.setStencilFunctionReference(this._cachedStencilReference);
      }
      setDirectViewport(x, y, width, height) {
        const currentViewport = this._cachedViewport;
        this._cachedViewport = null;
        this._viewport(x, y, width, height);
        return currentViewport;
      }
      scissorClear(x, y, width, height, clearColor) {
        this.enableScissor(x, y, width, height);
        this.clear(clearColor, true, true, true);
        this.disableScissor();
      }
      enableScissor(x, y, width, height) {
        const gl = this._gl;
        gl.enable(gl.SCISSOR_TEST);
        gl.scissor(x, y, width, height);
      }
      disableScissor() {
        const gl = this._gl;
        gl.disable(gl.SCISSOR_TEST);
      }
      _reportDrawCall(numDrawCalls = 1) {
        this._drawCalls.addCount(numDrawCalls, false);
      }
      initWebVR() {
        throw _WarnImport("WebVRCamera");
      }
      _prepareVRComponent() {
      }
      _connectVREvents(canvas, document2) {
      }
      _submitVRFrame() {
      }
      disableVR() {
      }
      isVRPresenting() {
        return false;
      }
      _requestVRFrame() {
      }
      _loadFileAsync(url, offlineProvider, useArrayBuffer) {
        return new Promise((resolve, reject) => {
          this._loadFile(url, (data) => {
            resolve(data);
          }, void 0, offlineProvider, useArrayBuffer, (request, exception) => {
            reject(exception);
          });
        });
      }
      getVertexShaderSource(program) {
        const shaders = this._gl.getAttachedShaders(program);
        if (!shaders) {
          return null;
        }
        return this._gl.getShaderSource(shaders[0]);
      }
      getFragmentShaderSource(program) {
        const shaders = this._gl.getAttachedShaders(program);
        if (!shaders) {
          return null;
        }
        return this._gl.getShaderSource(shaders[1]);
      }
      setDepthStencilTexture(channel, uniform, texture, name) {
        if (channel === void 0) {
          return;
        }
        if (uniform) {
          this._boundUniforms[channel] = uniform;
        }
        if (!texture || !texture.depthStencilTexture) {
          this._setTexture(channel, null, void 0, void 0, name);
        } else {
          this._setTexture(channel, texture, false, true, name);
        }
      }
      setTextureFromPostProcess(channel, postProcess, name) {
        var _a;
        let postProcessInput = null;
        if (postProcess) {
          if (postProcess._forcedOutputTexture) {
            postProcessInput = postProcess._forcedOutputTexture;
          } else if (postProcess._textures.data[postProcess._currentRenderTextureInd]) {
            postProcessInput = postProcess._textures.data[postProcess._currentRenderTextureInd];
          }
        }
        this._bindTexture(channel, (_a = postProcessInput === null || postProcessInput === void 0 ? void 0 : postProcessInput.texture) !== null && _a !== void 0 ? _a : null, name);
      }
      setTextureFromPostProcessOutput(channel, postProcess, name) {
        var _a, _b;
        this._bindTexture(channel, (_b = (_a = postProcess === null || postProcess === void 0 ? void 0 : postProcess._outputTexture) === null || _a === void 0 ? void 0 : _a.texture) !== null && _b !== void 0 ? _b : null, name);
      }
      _rebuildBuffers() {
        for (const scene of this.scenes) {
          scene.resetCachedMaterial();
          scene._rebuildGeometries();
          scene._rebuildTextures();
        }
        for (const scene of this._virtualScenes) {
          scene.resetCachedMaterial();
          scene._rebuildGeometries();
          scene._rebuildTextures();
        }
        super._rebuildBuffers();
      }
      _renderFrame() {
        for (let index = 0; index < this._activeRenderLoops.length; index++) {
          const renderFunction = this._activeRenderLoops[index];
          renderFunction();
        }
      }
      _cancelFrame() {
        if (this._renderingQueueLaunched && this.customAnimationFrameRequester) {
          this._renderingQueueLaunched = false;
          const { cancelAnimationFrame } = this.customAnimationFrameRequester;
          if (cancelAnimationFrame) {
            cancelAnimationFrame(this.customAnimationFrameRequester.requestID);
          }
        } else {
          super._cancelFrame();
        }
      }
      _renderLoop() {
        if (!this._contextWasLost) {
          let shouldRender = true;
          if (this.isDisposed || !this.renderEvenInBackground && this._windowIsBackground) {
            shouldRender = false;
          }
          if (shouldRender) {
            this.beginFrame();
            if (!this._renderViews()) {
              this._renderFrame();
            }
            this.endFrame();
          }
        }
        if (this._activeRenderLoops.length > 0) {
          if (this.customAnimationFrameRequester) {
            this.customAnimationFrameRequester.requestID = this._queueNewFrame(this.customAnimationFrameRequester.renderFunction || this._boundRenderFunction, this.customAnimationFrameRequester);
            this._frameHandler = this.customAnimationFrameRequester.requestID;
          } else if (this.isVRPresenting()) {
            this._requestVRFrame();
          } else {
            this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
          }
        } else {
          this._renderingQueueLaunched = false;
        }
      }
      _renderViews() {
        return false;
      }
      switchFullscreen(requestPointerLock) {
        if (this.isFullscreen) {
          this.exitFullscreen();
        } else {
          this.enterFullscreen(requestPointerLock);
        }
      }
      enterFullscreen(requestPointerLock) {
        if (!this.isFullscreen) {
          this._pointerLockRequested = requestPointerLock;
          if (this._renderingCanvas) {
            Engine._RequestFullscreen(this._renderingCanvas);
          }
        }
      }
      exitFullscreen() {
        if (this.isFullscreen) {
          Engine._ExitFullscreen();
        }
      }
      enterPointerlock() {
        if (this._renderingCanvas) {
          Engine._RequestPointerlock(this._renderingCanvas);
        }
      }
      exitPointerlock() {
        Engine._ExitPointerlock();
      }
      beginFrame() {
        this._measureFps();
        this.onBeginFrameObservable.notifyObservers(this);
        super.beginFrame();
      }
      endFrame() {
        super.endFrame();
        this._submitVRFrame();
        this.onEndFrameObservable.notifyObservers(this);
      }
      resize(forceSetSize = false) {
        if (this.isVRPresenting()) {
          return;
        }
        super.resize(forceSetSize);
      }
      setSize(width, height, forceSetSize = false) {
        if (!this._renderingCanvas) {
          return false;
        }
        if (!super.setSize(width, height, forceSetSize)) {
          return false;
        }
        if (this.scenes) {
          for (let index = 0; index < this.scenes.length; index++) {
            const scene = this.scenes[index];
            for (let camIndex = 0; camIndex < scene.cameras.length; camIndex++) {
              const cam = scene.cameras[camIndex];
              cam._currentRenderId = 0;
            }
          }
          if (this.onResizeObservable.hasObservers()) {
            this.onResizeObservable.notifyObservers(this);
          }
        }
        return true;
      }
      _deletePipelineContext(pipelineContext) {
        const webGLPipelineContext = pipelineContext;
        if (webGLPipelineContext && webGLPipelineContext.program) {
          if (webGLPipelineContext.transformFeedback) {
            this.deleteTransformFeedback(webGLPipelineContext.transformFeedback);
            webGLPipelineContext.transformFeedback = null;
          }
        }
        super._deletePipelineContext(pipelineContext);
      }
      createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
        context = context || this._gl;
        this.onBeforeShaderCompilationObservable.notifyObservers(this);
        const program = super.createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings);
        this.onAfterShaderCompilationObservable.notifyObservers(this);
        return program;
      }
      _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
        const shaderProgram = context.createProgram();
        pipelineContext.program = shaderProgram;
        if (!shaderProgram) {
          throw new Error("Unable to create program");
        }
        context.attachShader(shaderProgram, vertexShader);
        context.attachShader(shaderProgram, fragmentShader);
        if (this.webGLVersion > 1 && transformFeedbackVaryings) {
          const transformFeedback = this.createTransformFeedback();
          this.bindTransformFeedback(transformFeedback);
          this.setTranformFeedbackVaryings(shaderProgram, transformFeedbackVaryings);
          pipelineContext.transformFeedback = transformFeedback;
        }
        context.linkProgram(shaderProgram);
        if (this.webGLVersion > 1 && transformFeedbackVaryings) {
          this.bindTransformFeedback(null);
        }
        pipelineContext.context = context;
        pipelineContext.vertexShader = vertexShader;
        pipelineContext.fragmentShader = fragmentShader;
        if (!pipelineContext.isParallelCompiled) {
          this._finalizePipelineContext(pipelineContext);
        }
        return shaderProgram;
      }
      _releaseTexture(texture) {
        super._releaseTexture(texture);
      }
      _releaseRenderTargetWrapper(rtWrapper) {
        super._releaseRenderTargetWrapper(rtWrapper);
        this.scenes.forEach((scene) => {
          scene.postProcesses.forEach((postProcess) => {
            if (postProcess._outputTexture === rtWrapper) {
              postProcess._outputTexture = null;
            }
          });
          scene.cameras.forEach((camera) => {
            camera._postProcesses.forEach((postProcess) => {
              if (postProcess) {
                if (postProcess._outputTexture === rtWrapper) {
                  postProcess._outputTexture = null;
                }
              }
            });
          });
        });
      }
      getRenderPassNames() {
        return this._renderPassNames;
      }
      getCurrentRenderPassName() {
        return this._renderPassNames[this.currentRenderPassId];
      }
      createRenderPassId(name) {
        const id = ++Engine._RenderPassIdCounter;
        this._renderPassNames[id] = name !== null && name !== void 0 ? name : "NONAME";
        return id;
      }
      releaseRenderPassId(id) {
        this._renderPassNames[id] = void 0;
        for (let s = 0; s < this.scenes.length; ++s) {
          const scene = this.scenes[s];
          for (let m = 0; m < scene.meshes.length; ++m) {
            const mesh = scene.meshes[m];
            if (mesh.subMeshes) {
              for (let b = 0; b < mesh.subMeshes.length; ++b) {
                const subMesh = mesh.subMeshes[b];
                subMesh._removeDrawWrapper(id);
              }
            }
          }
        }
      }
      _rescaleTexture(source, destination, scene, internalFormat, onComplete) {
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, this._gl.LINEAR);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, this._gl.LINEAR);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_S, this._gl.CLAMP_TO_EDGE);
        this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_WRAP_T, this._gl.CLAMP_TO_EDGE);
        const rtt = this.createRenderTargetTexture({
          width: destination.width,
          height: destination.height
        }, {
          generateMipMaps: false,
          type: 0,
          samplingMode: 2,
          generateDepthBuffer: false,
          generateStencilBuffer: false
        });
        if (!this._rescalePostProcess && Engine._RescalePostProcessFactory) {
          this._rescalePostProcess = Engine._RescalePostProcessFactory(this);
        }
        if (this._rescalePostProcess) {
          this._rescalePostProcess.externalTextureSamplerBinding = true;
          this._rescalePostProcess.getEffect().executeWhenCompiled(() => {
            this._rescalePostProcess.onApply = function(effect) {
              effect._bindTexture("textureSampler", source);
            };
            let hostingScene = scene;
            if (!hostingScene) {
              hostingScene = this.scenes[this.scenes.length - 1];
            }
            hostingScene.postProcessManager.directRender([this._rescalePostProcess], rtt, true);
            this._bindTextureDirectly(this._gl.TEXTURE_2D, destination, true);
            this._gl.copyTexImage2D(this._gl.TEXTURE_2D, 0, internalFormat, 0, 0, destination.width, destination.height, 0);
            this.unBindFramebuffer(rtt);
            rtt.dispose();
            if (onComplete) {
              onComplete();
            }
          });
        }
      }
      getFps() {
        return this._fps;
      }
      getDeltaTime() {
        return this._deltaTime;
      }
      _measureFps() {
        this._performanceMonitor.sampleFrame();
        this._fps = this._performanceMonitor.averageFPS;
        this._deltaTime = this._performanceMonitor.instantaneousFrameTime || 0;
      }
      wrapWebGLTexture(texture, hasMipMaps = false, samplingMode = 3) {
        const hardwareTexture = new WebGLHardwareTexture(texture, this._gl);
        const internalTexture = new InternalTexture(this, InternalTextureSource.Unknown, true);
        internalTexture._hardwareTexture = hardwareTexture;
        internalTexture.isReady = true;
        internalTexture.useMipMaps = hasMipMaps;
        this.updateTextureSamplingMode(samplingMode, internalTexture);
        return internalTexture;
      }
      _uploadImageToTexture(texture, image, faceIndex = 0, lod = 0) {
        const gl = this._gl;
        const textureType = this._getWebGLTextureType(texture.type);
        const format = this._getInternalFormat(texture.format);
        const internalFormat = this._getRGBABufferInternalSizedFormat(texture.type, format);
        const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        this._bindTextureDirectly(bindTarget, texture, true);
        this._unpackFlipY(texture.invertY);
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        gl.texImage2D(target, lod, internalFormat, format, textureType, image);
        this._bindTextureDirectly(bindTarget, null, true);
      }
      updateTextureComparisonFunction(texture, comparisonFunction) {
        if (this.webGLVersion === 1) {
          Logger.Error("WebGL 1 does not support texture comparison.");
          return;
        }
        const gl = this._gl;
        if (texture.isCube) {
          this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
          if (comparisonFunction === 0) {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, 515);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.NONE);
          } else {
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
            gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          }
          this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
        } else {
          this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
          if (comparisonFunction === 0) {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, 515);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.NONE);
          } else {
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          }
          this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
        }
        texture._comparisonFunction = comparisonFunction;
      }
      createInstancesBuffer(capacity) {
        const buffer = this._gl.createBuffer();
        if (!buffer) {
          throw new Error("Unable to create instance buffer");
        }
        const result = new WebGLDataBuffer(buffer);
        result.capacity = capacity;
        this.bindArrayBuffer(result);
        this._gl.bufferData(this._gl.ARRAY_BUFFER, capacity, this._gl.DYNAMIC_DRAW);
        result.references = 1;
        return result;
      }
      deleteInstancesBuffer(buffer) {
        this._gl.deleteBuffer(buffer);
      }
      _clientWaitAsync(sync, flags = 0, intervalms = 10) {
        const gl = this._gl;
        return new Promise((resolve, reject) => {
          const check = () => {
            const res = gl.clientWaitSync(sync, flags, 0);
            if (res == gl.WAIT_FAILED) {
              reject();
              return;
            }
            if (res == gl.TIMEOUT_EXPIRED) {
              setTimeout(check, intervalms);
              return;
            }
            resolve();
          };
          check();
        });
      }
      _readPixelsAsync(x, y, w, h, format, type, outputBuffer) {
        if (this._webGLVersion < 2) {
          throw new Error("_readPixelsAsync only work on WebGL2+");
        }
        const gl = this._gl;
        const buf = gl.createBuffer();
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
        gl.bufferData(gl.PIXEL_PACK_BUFFER, outputBuffer.byteLength, gl.STREAM_READ);
        gl.readPixels(x, y, w, h, format, type, 0);
        gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
        const sync = gl.fenceSync(gl.SYNC_GPU_COMMANDS_COMPLETE, 0);
        if (!sync) {
          return null;
        }
        gl.flush();
        return this._clientWaitAsync(sync, 0, 10).then(() => {
          gl.deleteSync(sync);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, buf);
          gl.getBufferSubData(gl.PIXEL_PACK_BUFFER, 0, outputBuffer);
          gl.bindBuffer(gl.PIXEL_PACK_BUFFER, null);
          gl.deleteBuffer(buf);
          return outputBuffer;
        });
      }
      dispose() {
        this.hideLoadingUI();
        this.onNewSceneAddedObservable.clear();
        while (this.postProcesses.length) {
          this.postProcesses[0].dispose();
        }
        if (this._rescalePostProcess) {
          this._rescalePostProcess.dispose();
        }
        while (this.scenes.length) {
          this.scenes[0].dispose();
        }
        while (this._virtualScenes.length) {
          this._virtualScenes[0].dispose();
        }
        if (EngineStore.Instances.length === 1 && Engine.audioEngine) {
          Engine.audioEngine.dispose();
          Engine.audioEngine = null;
        }
        this.disableVR();
        const hostWindow = this.getHostWindow();
        if (hostWindow && typeof hostWindow.removeEventListener === "function") {
          hostWindow.removeEventListener("blur", this._onBlur);
          hostWindow.removeEventListener("focus", this._onFocus);
        }
        if (this._renderingCanvas) {
          this._renderingCanvas.removeEventListener("focus", this._onCanvasFocus);
          this._renderingCanvas.removeEventListener("blur", this._onCanvasBlur);
          this._renderingCanvas.removeEventListener("pointerout", this._onCanvasPointerOut);
          this._renderingCanvas.removeEventListener("contextmenu", this._onCanvasContextMenu);
        }
        if (IsDocumentAvailable()) {
          document.removeEventListener("fullscreenchange", this._onFullscreenChange);
          document.removeEventListener("mozfullscreenchange", this._onFullscreenChange);
          document.removeEventListener("webkitfullscreenchange", this._onFullscreenChange);
          document.removeEventListener("msfullscreenchange", this._onFullscreenChange);
          document.removeEventListener("pointerlockchange", this._onPointerLockChange);
          document.removeEventListener("mspointerlockchange", this._onPointerLockChange);
          document.removeEventListener("mozpointerlockchange", this._onPointerLockChange);
          document.removeEventListener("webkitpointerlockchange", this._onPointerLockChange);
        }
        super.dispose();
        const index = EngineStore.Instances.indexOf(this);
        if (index >= 0) {
          EngineStore.Instances.splice(index, 1);
        }
        if (!Engine.Instances.length) {
          EngineStore.OnEnginesDisposedObservable.notifyObservers(this);
        }
        this.onResizeObservable.clear();
        this.onCanvasBlurObservable.clear();
        this.onCanvasFocusObservable.clear();
        this.onCanvasPointerOutObservable.clear();
        this.onBeginFrameObservable.clear();
        this.onEndFrameObservable.clear();
      }
      _disableTouchAction() {
        if (!this._renderingCanvas || !this._renderingCanvas.setAttribute) {
          return;
        }
        this._renderingCanvas.setAttribute("touch-action", "none");
        this._renderingCanvas.style.touchAction = "none";
        this._renderingCanvas.style.webkitTapHighlightColor = "transparent";
      }
      displayLoadingUI() {
        if (!IsWindowObjectExist()) {
          return;
        }
        const loadingScreen = this.loadingScreen;
        if (loadingScreen) {
          loadingScreen.displayLoadingUI();
        }
      }
      hideLoadingUI() {
        if (!IsWindowObjectExist()) {
          return;
        }
        const loadingScreen = this._loadingScreen;
        if (loadingScreen) {
          loadingScreen.hideLoadingUI();
        }
      }
      get loadingScreen() {
        if (!this._loadingScreen && this._renderingCanvas) {
          this._loadingScreen = Engine.DefaultLoadingScreenFactory(this._renderingCanvas);
        }
        return this._loadingScreen;
      }
      set loadingScreen(loadingScreen) {
        this._loadingScreen = loadingScreen;
      }
      set loadingUIText(text) {
        this.loadingScreen.loadingUIText = text;
      }
      set loadingUIBackgroundColor(color) {
        this.loadingScreen.loadingUIBackgroundColor = color;
      }
      createVideoElement(constraints) {
        return document.createElement("video");
      }
      static _RequestPointerlock(element) {
        if (element.requestPointerLock) {
          const promise = element.requestPointerLock();
          if (promise instanceof Promise)
            promise.then(() => {
              element.focus();
            }).catch(() => {
            });
          else
            element.focus();
        }
      }
      static _ExitPointerlock() {
        if (document.exitPointerLock) {
          document.exitPointerLock();
        }
      }
      static _RequestFullscreen(element) {
        const requestFunction = element.requestFullscreen || element.webkitRequestFullscreen;
        if (!requestFunction) {
          return;
        }
        requestFunction.call(element);
      }
      static _ExitFullscreen() {
        const anyDoc = document;
        if (document.exitFullscreen) {
          document.exitFullscreen();
        } else if (anyDoc.webkitCancelFullScreen) {
          anyDoc.webkitCancelFullScreen();
        }
      }
      getFontOffset(font) {
        const text = document.createElement("span");
        text.innerHTML = "Hg";
        text.setAttribute("style", `font: ${font} !important`);
        const block = document.createElement("div");
        block.style.display = "inline-block";
        block.style.width = "1px";
        block.style.height = "0px";
        block.style.verticalAlign = "bottom";
        const div = document.createElement("div");
        div.style.whiteSpace = "nowrap";
        div.appendChild(text);
        div.appendChild(block);
        document.body.appendChild(div);
        let fontAscent = 0;
        let fontHeight = 0;
        try {
          fontHeight = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
          block.style.verticalAlign = "baseline";
          fontAscent = block.getBoundingClientRect().top - text.getBoundingClientRect().top;
        } finally {
          document.body.removeChild(div);
        }
        return { ascent: fontAscent, height: fontHeight, descent: fontHeight - fontAscent };
      }
    };
    Engine.ALPHA_DISABLE = 0;
    Engine.ALPHA_ADD = 1;
    Engine.ALPHA_COMBINE = 2;
    Engine.ALPHA_SUBTRACT = 3;
    Engine.ALPHA_MULTIPLY = 4;
    Engine.ALPHA_MAXIMIZED = 5;
    Engine.ALPHA_ONEONE = 6;
    Engine.ALPHA_PREMULTIPLIED = 7;
    Engine.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
    Engine.ALPHA_INTERPOLATE = 9;
    Engine.ALPHA_SCREENMODE = 10;
    Engine.DELAYLOADSTATE_NONE = 0;
    Engine.DELAYLOADSTATE_LOADED = 1;
    Engine.DELAYLOADSTATE_LOADING = 2;
    Engine.DELAYLOADSTATE_NOTLOADED = 4;
    Engine.NEVER = 512;
    Engine.ALWAYS = 519;
    Engine.LESS = 513;
    Engine.EQUAL = 514;
    Engine.LEQUAL = 515;
    Engine.GREATER = 516;
    Engine.GEQUAL = 518;
    Engine.NOTEQUAL = 517;
    Engine.KEEP = 7680;
    Engine.REPLACE = 7681;
    Engine.INCR = 7682;
    Engine.DECR = 7683;
    Engine.INVERT = 5386;
    Engine.INCR_WRAP = 34055;
    Engine.DECR_WRAP = 34056;
    Engine.TEXTURE_CLAMP_ADDRESSMODE = 0;
    Engine.TEXTURE_WRAP_ADDRESSMODE = 1;
    Engine.TEXTURE_MIRROR_ADDRESSMODE = 2;
    Engine.TEXTUREFORMAT_ALPHA = 0;
    Engine.TEXTUREFORMAT_LUMINANCE = 1;
    Engine.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
    Engine.TEXTUREFORMAT_RGB = 4;
    Engine.TEXTUREFORMAT_RGBA = 5;
    Engine.TEXTUREFORMAT_RED = 6;
    Engine.TEXTUREFORMAT_R = 6;
    Engine.TEXTUREFORMAT_RG = 7;
    Engine.TEXTUREFORMAT_RED_INTEGER = 8;
    Engine.TEXTUREFORMAT_R_INTEGER = 8;
    Engine.TEXTUREFORMAT_RG_INTEGER = 9;
    Engine.TEXTUREFORMAT_RGB_INTEGER = 10;
    Engine.TEXTUREFORMAT_RGBA_INTEGER = 11;
    Engine.TEXTURETYPE_UNSIGNED_BYTE = 0;
    Engine.TEXTURETYPE_UNSIGNED_INT = 0;
    Engine.TEXTURETYPE_FLOAT = 1;
    Engine.TEXTURETYPE_HALF_FLOAT = 2;
    Engine.TEXTURETYPE_BYTE = 3;
    Engine.TEXTURETYPE_SHORT = 4;
    Engine.TEXTURETYPE_UNSIGNED_SHORT = 5;
    Engine.TEXTURETYPE_INT = 6;
    Engine.TEXTURETYPE_UNSIGNED_INTEGER = 7;
    Engine.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
    Engine.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
    Engine.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
    Engine.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
    Engine.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
    Engine.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
    Engine.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
    Engine.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
    Engine.TEXTURE_NEAREST_SAMPLINGMODE = 1;
    Engine.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
    Engine.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
    Engine.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
    Engine.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
    Engine.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
    Engine.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
    Engine.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
    Engine.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
    Engine.TEXTURE_NEAREST_LINEAR = 7;
    Engine.TEXTURE_NEAREST_NEAREST = 1;
    Engine.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
    Engine.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
    Engine.TEXTURE_LINEAR_LINEAR = 2;
    Engine.TEXTURE_LINEAR_NEAREST = 12;
    Engine.TEXTURE_EXPLICIT_MODE = 0;
    Engine.TEXTURE_SPHERICAL_MODE = 1;
    Engine.TEXTURE_PLANAR_MODE = 2;
    Engine.TEXTURE_CUBIC_MODE = 3;
    Engine.TEXTURE_PROJECTION_MODE = 4;
    Engine.TEXTURE_SKYBOX_MODE = 5;
    Engine.TEXTURE_INVCUBIC_MODE = 6;
    Engine.TEXTURE_EQUIRECTANGULAR_MODE = 7;
    Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
    Engine.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
    Engine.SCALEMODE_FLOOR = 1;
    Engine.SCALEMODE_NEAREST = 2;
    Engine.SCALEMODE_CEILING = 3;
    Engine._RescalePostProcessFactory = null;
    Engine._RenderPassIdCounter = 0;
  }
});

export {
  PerformanceMonitor,
  RollingAverage,
  init_performanceMonitor,
  init_engine_alpha,
  allocateAndCopyTypedBuffer,
  init_engine_readTexture,
  init_engine_dynamicBuffer,
  Engine,
  init_engine
};
//# sourceMappingURL=chunk-Y23C3XZB.js.map
