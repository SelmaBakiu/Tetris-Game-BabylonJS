import {
  ArrayTools,
  EngineStore,
  GetClass,
  Matrix,
  Observable,
  PerformanceConfigurator,
  Quaternion,
  RegisterClass,
  Scalar,
  TmpVectors,
  ToGammaSpace,
  ToLinearSpace,
  Vector2,
  Vector3,
  _ObserveArray,
  __esm,
  init_arrayTools,
  init_engineStore,
  init_math_constants,
  init_math_scalar,
  init_math_vector,
  init_observable,
  init_performanceConfigurator,
  init_typeStore
} from "./chunk-N3NUGEQO.js";

// node_modules/@babylonjs/core/Misc/domManagement.js
function IsWindowObjectExist() {
  return typeof window !== "undefined";
}
function IsNavigatorAvailable() {
  return typeof navigator !== "undefined";
}
function IsDocumentAvailable() {
  return typeof document !== "undefined";
}
function GetDOMTextContent(element) {
  let result = "";
  let child = element.firstChild;
  while (child) {
    if (child.nodeType === 3) {
      result += child.textContent;
    }
    child = child.nextSibling;
  }
  return result;
}
var DomManagement;
var init_domManagement = __esm({
  "node_modules/@babylonjs/core/Misc/domManagement.js"() {
    DomManagement = {
      IsWindowObjectExist,
      IsNavigatorAvailable,
      IsDocumentAvailable,
      GetDOMTextContent
    };
  }
});

// node_modules/@babylonjs/core/Misc/logger.js
var Logger;
var init_logger = __esm({
  "node_modules/@babylonjs/core/Misc/logger.js"() {
    Logger = class {
      static _CheckLimit(message, limit) {
        let entry = Logger._LogLimitOutputs[message];
        if (!entry) {
          entry = { limit, current: 1 };
          Logger._LogLimitOutputs[message] = entry;
        } else {
          entry.current++;
        }
        return entry.current <= entry.limit;
      }
      static _GenerateLimitMessage(message, level = 1) {
        var _a;
        const entry = Logger._LogLimitOutputs[message];
        if (!entry || !Logger.MessageLimitReached) {
          return;
        }
        const type = this._Levels[level];
        if (entry.current === entry.limit) {
          Logger[type.name](Logger.MessageLimitReached.replace(/%LIMIT%/g, "" + entry.limit).replace(/%TYPE%/g, (_a = type.name) !== null && _a !== void 0 ? _a : ""));
        }
      }
      static _AddLogEntry(entry) {
        Logger._LogCache = entry + Logger._LogCache;
        if (Logger.OnNewCacheEntry) {
          Logger.OnNewCacheEntry(entry);
        }
      }
      static _FormatMessage(message) {
        const padStr = (i) => i < 10 ? "0" + i : "" + i;
        const date = new Date();
        return "[" + padStr(date.getHours()) + ":" + padStr(date.getMinutes()) + ":" + padStr(date.getSeconds()) + "]: " + message;
      }
      static _LogDisabled(message, limit) {
      }
      static _LogEnabled(level = 1, message, limit) {
        if (limit !== void 0 && !Logger._CheckLimit(message, limit)) {
          return;
        }
        const formattedMessage = Logger._FormatMessage(message);
        const type = this._Levels[level];
        type.logFunc && type.logFunc("BJS - " + formattedMessage);
        const entry = `<div style='color:${type.color}'>${formattedMessage}</div><br>`;
        Logger._AddLogEntry(entry);
        Logger._GenerateLimitMessage(message, level);
      }
      static get LogCache() {
        return Logger._LogCache;
      }
      static ClearLogCache() {
        Logger._LogCache = "";
        Logger._LogLimitOutputs = {};
        Logger.errorsCount = 0;
      }
      static set LogLevels(level) {
        Logger.Log = Logger._LogDisabled;
        Logger.Warn = Logger._LogDisabled;
        Logger.Error = Logger._LogDisabled;
        [Logger.MessageLogLevel, Logger.WarningLogLevel, Logger.ErrorLogLevel].forEach((l) => {
          if ((level & l) === l) {
            const type = this._Levels[l];
            Logger[type.name] = Logger._LogEnabled.bind(Logger, l);
          }
        });
      }
    };
    Logger.NoneLogLevel = 0;
    Logger.MessageLogLevel = 1;
    Logger.WarningLogLevel = 2;
    Logger.ErrorLogLevel = 4;
    Logger.AllLogLevel = 7;
    Logger.MessageLimitReached = "Too many %TYPE%s (%LIMIT%), no more %TYPE%s will be reported for this message.";
    Logger._LogCache = "";
    Logger._LogLimitOutputs = {};
    Logger._Levels = [
      {},
      { color: "white", logFunc: console.log, name: "Log" },
      { color: "orange", logFunc: console.warn, name: "Warn" },
      {},
      { color: "red", logFunc: console.error, name: "Error" }
    ];
    Logger.errorsCount = 0;
    Logger.Log = Logger._LogEnabled.bind(Logger, Logger.MessageLogLevel);
    Logger.Warn = Logger._LogEnabled.bind(Logger, Logger.WarningLogLevel);
    Logger.Error = Logger._LogEnabled.bind(Logger, Logger.ErrorLogLevel);
  }
});

// node_modules/@babylonjs/core/Misc/deepCopier.js
function GetAllPropertyNames(obj) {
  const props = [];
  do {
    Object.getOwnPropertyNames(obj).forEach(function(prop) {
      if (props.indexOf(prop) === -1) {
        props.push(prop);
      }
    });
  } while (obj = Object.getPrototypeOf(obj));
  return props;
}
var CloneValue, DeepCopier;
var init_deepCopier = __esm({
  "node_modules/@babylonjs/core/Misc/deepCopier.js"() {
    init_logger();
    CloneValue = (source, destinationObject) => {
      if (!source) {
        return null;
      }
      if (source.getClassName && source.getClassName() === "Mesh") {
        return null;
      }
      if (source.getClassName && (source.getClassName() === "SubMesh" || source.getClassName() === "PhysicsBody")) {
        return source.clone(destinationObject);
      } else if (source.clone) {
        return source.clone();
      } else if (Array.isArray(source)) {
        return source.slice();
      }
      return null;
    };
    DeepCopier = class {
      static DeepCopy(source, destination, doNotCopyList, mustCopyList) {
        const properties = GetAllPropertyNames(source);
        for (const prop of properties) {
          if (prop[0] === "_" && (!mustCopyList || mustCopyList.indexOf(prop) === -1)) {
            continue;
          }
          if (prop.endsWith("Observable")) {
            continue;
          }
          if (doNotCopyList && doNotCopyList.indexOf(prop) !== -1) {
            continue;
          }
          const sourceValue = source[prop];
          const typeOfSourceValue = typeof sourceValue;
          if (typeOfSourceValue === "function") {
            continue;
          }
          try {
            if (typeOfSourceValue === "object") {
              if (sourceValue instanceof Uint8Array) {
                destination[prop] = Uint8Array.from(sourceValue);
              } else if (sourceValue instanceof Array) {
                destination[prop] = [];
                if (sourceValue.length > 0) {
                  if (typeof sourceValue[0] == "object") {
                    for (let index = 0; index < sourceValue.length; index++) {
                      const clonedValue = CloneValue(sourceValue[index], destination);
                      if (destination[prop].indexOf(clonedValue) === -1) {
                        destination[prop].push(clonedValue);
                      }
                    }
                  } else {
                    destination[prop] = sourceValue.slice(0);
                  }
                }
              } else {
                destination[prop] = CloneValue(sourceValue, destination);
              }
            } else {
              destination[prop] = sourceValue;
            }
          } catch (e) {
            Logger.Warn(e.message);
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/precisionDate.js
var PrecisionDate;
var init_precisionDate = __esm({
  "node_modules/@babylonjs/core/Misc/precisionDate.js"() {
    init_domManagement();
    PrecisionDate = class {
      static get Now() {
        if (IsWindowObjectExist() && window.performance && window.performance.now) {
          return window.performance.now();
        }
        return Date.now();
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/devTools.js
function _WarnImport(name) {
  return `${name} needs to be imported before as it contains a side-effect required by your code.`;
}
var init_devTools = __esm({
  "node_modules/@babylonjs/core/Misc/devTools.js"() {
  }
});

// node_modules/@babylonjs/core/Misc/webRequest.js
function createXMLHttpRequest() {
  if (typeof _native !== "undefined" && _native.XMLHttpRequest) {
    return new _native.XMLHttpRequest();
  } else {
    return new XMLHttpRequest();
  }
}
var WebRequest;
var init_webRequest = __esm({
  "node_modules/@babylonjs/core/Misc/webRequest.js"() {
    WebRequest = class {
      constructor() {
        this._xhr = createXMLHttpRequest();
        this._requestURL = "";
      }
      _injectCustomRequestHeaders() {
        if (this._shouldSkipRequestModifications(this._requestURL)) {
          return;
        }
        for (const key in WebRequest.CustomRequestHeaders) {
          const val = WebRequest.CustomRequestHeaders[key];
          if (val) {
            this._xhr.setRequestHeader(key, val);
          }
        }
      }
      _shouldSkipRequestModifications(url) {
        return WebRequest.SkipRequestModificationForBabylonCDN && (url.includes("preview.babylonjs.com") || url.includes("cdn.babylonjs.com"));
      }
      get onprogress() {
        return this._xhr.onprogress;
      }
      set onprogress(value) {
        this._xhr.onprogress = value;
      }
      get readyState() {
        return this._xhr.readyState;
      }
      get status() {
        return this._xhr.status;
      }
      get statusText() {
        return this._xhr.statusText;
      }
      get response() {
        return this._xhr.response;
      }
      get responseURL() {
        return this._xhr.responseURL;
      }
      get responseText() {
        return this._xhr.responseText;
      }
      get responseType() {
        return this._xhr.responseType;
      }
      set responseType(value) {
        this._xhr.responseType = value;
      }
      get timeout() {
        return this._xhr.timeout;
      }
      set timeout(value) {
        this._xhr.timeout = value;
      }
      addEventListener(type, listener, options) {
        this._xhr.addEventListener(type, listener, options);
      }
      removeEventListener(type, listener, options) {
        this._xhr.removeEventListener(type, listener, options);
      }
      abort() {
        this._xhr.abort();
      }
      send(body) {
        if (WebRequest.CustomRequestHeaders) {
          this._injectCustomRequestHeaders();
        }
        this._xhr.send(body);
      }
      open(method, url) {
        for (const update of WebRequest.CustomRequestModifiers) {
          if (this._shouldSkipRequestModifications(url)) {
            return;
          }
          update(this._xhr, url);
        }
        url = url.replace("file:http:", "http:");
        url = url.replace("file:https:", "https:");
        this._requestURL = url;
        return this._xhr.open(method, url, true);
      }
      setRequestHeader(name, value) {
        this._xhr.setRequestHeader(name, value);
      }
      getResponseHeader(name) {
        return this._xhr.getResponseHeader(name);
      }
    };
    WebRequest.CustomRequestHeaders = {};
    WebRequest.CustomRequestModifiers = new Array();
    WebRequest.SkipRequestModificationForBabylonCDN = true;
  }
});

// node_modules/@babylonjs/core/Misc/filesInputStore.js
var FilesInputStore;
var init_filesInputStore = __esm({
  "node_modules/@babylonjs/core/Misc/filesInputStore.js"() {
    FilesInputStore = class {
    };
    FilesInputStore.FilesToLoad = {};
  }
});

// node_modules/@babylonjs/core/Misc/retryStrategy.js
var RetryStrategy;
var init_retryStrategy = __esm({
  "node_modules/@babylonjs/core/Misc/retryStrategy.js"() {
    RetryStrategy = class {
      static ExponentialBackoff(maxRetries = 3, baseInterval = 500) {
        return (url, request, retryIndex) => {
          if (request.status !== 0 || retryIndex >= maxRetries || url.indexOf("file:") !== -1) {
            return -1;
          }
          return Math.pow(2, retryIndex) * baseInterval;
        };
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/error.js
var BaseError, ErrorCodes, RuntimeError;
var init_error = __esm({
  "node_modules/@babylonjs/core/Misc/error.js"() {
    BaseError = class extends Error {
    };
    BaseError._setPrototypeOf = Object.setPrototypeOf || ((o, proto) => {
      o.__proto__ = proto;
      return o;
    });
    ErrorCodes = {
      MeshInvalidPositionsError: 0,
      UnsupportedTextureError: 1e3,
      GLTFLoaderUnexpectedMagicError: 2e3,
      SceneLoaderError: 3e3,
      LoadFileError: 4e3,
      RequestFileError: 4001,
      ReadFileError: 4002
    };
    RuntimeError = class extends BaseError {
      constructor(message, errorCode, innerError) {
        super(message);
        this.errorCode = errorCode;
        this.innerError = innerError;
        this.name = "RuntimeError";
        BaseError._setPrototypeOf(this, RuntimeError.prototype);
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/stringTools.js
var EndsWith, StartsWith, Decode, EncodeArrayBufferToBase64, DecodeBase64ToString, DecodeBase64ToBinary, PadNumber, StringTools;
var init_stringTools = __esm({
  "node_modules/@babylonjs/core/Misc/stringTools.js"() {
    EndsWith = (str, suffix) => {
      return str.endsWith(suffix);
    };
    StartsWith = (str, suffix) => {
      if (!str) {
        return false;
      }
      return str.startsWith(suffix);
    };
    Decode = (buffer) => {
      if (typeof TextDecoder !== "undefined") {
        return new TextDecoder().decode(buffer);
      }
      let result = "";
      for (let i = 0; i < buffer.byteLength; i++) {
        result += String.fromCharCode(buffer[i]);
      }
      return result;
    };
    EncodeArrayBufferToBase64 = (buffer) => {
      const keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
      let output = "";
      let chr1, chr2, chr3, enc1, enc2, enc3, enc4;
      let i = 0;
      const bytes = ArrayBuffer.isView(buffer) ? new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength) : new Uint8Array(buffer);
      while (i < bytes.length) {
        chr1 = bytes[i++];
        chr2 = i < bytes.length ? bytes[i++] : Number.NaN;
        chr3 = i < bytes.length ? bytes[i++] : Number.NaN;
        enc1 = chr1 >> 2;
        enc2 = (chr1 & 3) << 4 | chr2 >> 4;
        enc3 = (chr2 & 15) << 2 | chr3 >> 6;
        enc4 = chr3 & 63;
        if (isNaN(chr2)) {
          enc3 = enc4 = 64;
        } else if (isNaN(chr3)) {
          enc4 = 64;
        }
        output += keyStr.charAt(enc1) + keyStr.charAt(enc2) + keyStr.charAt(enc3) + keyStr.charAt(enc4);
      }
      return output;
    };
    DecodeBase64ToString = (base64Data) => {
      return atob(base64Data);
    };
    DecodeBase64ToBinary = (base64Data) => {
      const decodedString = DecodeBase64ToString(base64Data);
      const bufferLength = decodedString.length;
      const bufferView = new Uint8Array(new ArrayBuffer(bufferLength));
      for (let i = 0; i < bufferLength; i++) {
        bufferView[i] = decodedString.charCodeAt(i);
      }
      return bufferView.buffer;
    };
    PadNumber = (num, length) => {
      let str = String(num);
      while (str.length < length) {
        str = "0" + str;
      }
      return str;
    };
    StringTools = {
      EndsWith,
      StartsWith,
      Decode,
      EncodeArrayBufferToBase64,
      DecodeBase64ToString,
      DecodeBase64ToBinary,
      PadNumber
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js
var defaultAttributeKeywordName, defaultVaryingKeywordName, ShaderCodeNode;
var init_shaderCodeNode = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeNode.js"() {
    defaultAttributeKeywordName = "attribute";
    defaultVaryingKeywordName = "varying";
    ShaderCodeNode = class {
      constructor() {
        this.children = [];
      }
      isValid(preprocessors) {
        return true;
      }
      process(preprocessors, options) {
        var _a, _b, _c, _d, _e, _f, _g;
        let result = "";
        if (this.line) {
          let value = this.line;
          const processor = options.processor;
          if (processor) {
            if (processor.lineProcessor) {
              value = processor.lineProcessor(value, options.isFragment, options.processingContext);
            }
            const attributeKeyword = (_b = (_a = options.processor) === null || _a === void 0 ? void 0 : _a.attributeKeywordName) !== null && _b !== void 0 ? _b : defaultAttributeKeywordName;
            const varyingKeyword = options.isFragment && ((_c = options.processor) === null || _c === void 0 ? void 0 : _c.varyingFragmentKeywordName) ? (_d = options.processor) === null || _d === void 0 ? void 0 : _d.varyingFragmentKeywordName : !options.isFragment && ((_e = options.processor) === null || _e === void 0 ? void 0 : _e.varyingVertexKeywordName) ? (_f = options.processor) === null || _f === void 0 ? void 0 : _f.varyingVertexKeywordName : defaultVaryingKeywordName;
            if (!options.isFragment && processor.attributeProcessor && this.line.startsWith(attributeKeyword)) {
              value = processor.attributeProcessor(this.line, preprocessors, options.processingContext);
            } else if (processor.varyingProcessor && (((_g = processor.varyingCheck) === null || _g === void 0 ? void 0 : _g.call(processor, this.line, options.isFragment)) || !processor.varyingCheck && this.line.startsWith(varyingKeyword))) {
              value = processor.varyingProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            } else if (processor.uniformProcessor && processor.uniformRegexp && processor.uniformRegexp.test(this.line)) {
              if (!options.lookForClosingBracketForUniformBuffer) {
                value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
              }
            } else if (processor.uniformBufferProcessor && processor.uniformBufferRegexp && processor.uniformBufferRegexp.test(this.line)) {
              if (!options.lookForClosingBracketForUniformBuffer) {
                value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
                options.lookForClosingBracketForUniformBuffer = true;
              }
            } else if (processor.textureProcessor && processor.textureRegexp && processor.textureRegexp.test(this.line)) {
              value = processor.textureProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
            } else if ((processor.uniformProcessor || processor.uniformBufferProcessor) && this.line.startsWith("uniform") && !options.lookForClosingBracketForUniformBuffer) {
              const regex = /uniform\s+(?:(?:highp)?|(?:lowp)?)\s*(\S+)\s+(\S+)\s*;/;
              if (regex.test(this.line)) {
                if (processor.uniformProcessor) {
                  value = processor.uniformProcessor(this.line, options.isFragment, preprocessors, options.processingContext);
                }
              } else {
                if (processor.uniformBufferProcessor) {
                  value = processor.uniformBufferProcessor(this.line, options.isFragment, options.processingContext);
                  options.lookForClosingBracketForUniformBuffer = true;
                }
              }
            }
            if (options.lookForClosingBracketForUniformBuffer && this.line.indexOf("}") !== -1) {
              options.lookForClosingBracketForUniformBuffer = false;
              if (processor.endOfUniformBufferProcessor) {
                value = processor.endOfUniformBufferProcessor(this.line, options.isFragment, options.processingContext);
              }
            }
          }
          result += value + "\n";
        }
        this.children.forEach((child) => {
          result += child.process(preprocessors, options);
        });
        if (this.additionalDefineKey) {
          preprocessors[this.additionalDefineKey] = this.additionalDefineValue || "true";
        }
        return result;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js
var ShaderCodeCursor;
var init_shaderCodeCursor = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeCursor.js"() {
    ShaderCodeCursor = class {
      constructor() {
        this._lines = [];
      }
      get currentLine() {
        return this._lines[this.lineIndex];
      }
      get canRead() {
        return this.lineIndex < this._lines.length - 1;
      }
      set lines(value) {
        this._lines.length = 0;
        for (const line of value) {
          if (!line || line === "\r") {
            continue;
          }
          if (line[0] === "#") {
            this._lines.push(line);
            continue;
          }
          const trimmedLine = line.trim();
          if (!trimmedLine) {
            continue;
          }
          if (trimmedLine.startsWith("//")) {
            this._lines.push(line);
            continue;
          }
          const semicolonIndex = trimmedLine.indexOf(";");
          if (semicolonIndex === -1) {
            this._lines.push(trimmedLine);
          } else if (semicolonIndex === trimmedLine.length - 1) {
            if (trimmedLine.length > 1) {
              this._lines.push(trimmedLine);
            }
          } else {
            const split = line.split(";");
            for (let index = 0; index < split.length; index++) {
              let subLine = split[index];
              if (!subLine) {
                continue;
              }
              subLine = subLine.trim();
              if (!subLine) {
                continue;
              }
              this._lines.push(subLine + (index !== split.length - 1 ? ";" : ""));
            }
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js
var ShaderCodeConditionNode;
var init_shaderCodeConditionNode = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeConditionNode.js"() {
    init_shaderCodeNode();
    ShaderCodeConditionNode = class extends ShaderCodeNode {
      process(preprocessors, options) {
        for (let index = 0; index < this.children.length; index++) {
          const node = this.children[index];
          if (node.isValid(preprocessors)) {
            return node.process(preprocessors, options);
          }
        }
        return "";
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js
var ShaderCodeTestNode;
var init_shaderCodeTestNode = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderCodeTestNode.js"() {
    init_shaderCodeNode();
    ShaderCodeTestNode = class extends ShaderCodeNode {
      isValid(preprocessors) {
        return this.testExpression.isTrue(preprocessors);
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js
var ShaderDefineExpression;
var init_shaderDefineExpression = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/shaderDefineExpression.js"() {
    ShaderDefineExpression = class {
      isTrue(preprocessors) {
        return true;
      }
      static postfixToInfix(postfix) {
        const stack = [];
        for (const c of postfix) {
          if (ShaderDefineExpression._OperatorPriority[c] === void 0) {
            stack.push(c);
          } else {
            const v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
            stack.length -= 2;
            stack.push(`(${v2}${c}${v1})`);
          }
        }
        return stack[stack.length - 1];
      }
      static infixToPostfix(infix) {
        const cacheItem = ShaderDefineExpression._InfixToPostfixCache.get(infix);
        if (cacheItem) {
          cacheItem.accessTime = Date.now();
          return cacheItem.result;
        }
        if (!infix.includes("&&") && !infix.includes("||") && !infix.includes(")") && !infix.includes("(")) {
          return [infix];
        }
        const result = [];
        let stackIdx = -1;
        const pushOperand = () => {
          operand = operand.trim();
          if (operand !== "") {
            result.push(operand);
            operand = "";
          }
        };
        const push = (s) => {
          if (stackIdx < ShaderDefineExpression._Stack.length - 1) {
            ShaderDefineExpression._Stack[++stackIdx] = s;
          }
        };
        const peek = () => ShaderDefineExpression._Stack[stackIdx];
        const pop = () => stackIdx === -1 ? "!!INVALID EXPRESSION!!" : ShaderDefineExpression._Stack[stackIdx--];
        let idx = 0, operand = "";
        while (idx < infix.length) {
          const c = infix.charAt(idx), token = idx < infix.length - 1 ? infix.substr(idx, 2) : "";
          if (c === "(") {
            operand = "";
            push(c);
          } else if (c === ")") {
            pushOperand();
            while (stackIdx !== -1 && peek() !== "(") {
              result.push(pop());
            }
            pop();
          } else if (ShaderDefineExpression._OperatorPriority[token] > 1) {
            pushOperand();
            while (stackIdx !== -1 && ShaderDefineExpression._OperatorPriority[peek()] >= ShaderDefineExpression._OperatorPriority[token]) {
              result.push(pop());
            }
            push(token);
            idx++;
          } else {
            operand += c;
          }
          idx++;
        }
        pushOperand();
        while (stackIdx !== -1) {
          if (peek() === "(") {
            pop();
          } else {
            result.push(pop());
          }
        }
        if (ShaderDefineExpression._InfixToPostfixCache.size >= ShaderDefineExpression.InfixToPostfixCacheLimitSize) {
          ShaderDefineExpression.ClearCache();
        }
        ShaderDefineExpression._InfixToPostfixCache.set(infix, { result, accessTime: Date.now() });
        return result;
      }
      static ClearCache() {
        const sortedCache = Array.from(ShaderDefineExpression._InfixToPostfixCache.entries()).sort((a, b) => a[1].accessTime - b[1].accessTime);
        for (let i = 0; i < ShaderDefineExpression.InfixToPostfixCacheCleanupSize; i++) {
          ShaderDefineExpression._InfixToPostfixCache.delete(sortedCache[i][0]);
        }
      }
    };
    ShaderDefineExpression.InfixToPostfixCacheLimitSize = 5e4;
    ShaderDefineExpression.InfixToPostfixCacheCleanupSize = 25e3;
    ShaderDefineExpression._InfixToPostfixCache = /* @__PURE__ */ new Map();
    ShaderDefineExpression._OperatorPriority = {
      ")": 0,
      "(": 1,
      "||": 2,
      "&&": 3
    };
    ShaderDefineExpression._Stack = ["", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", "", ""];
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js
var ShaderDefineIsDefinedOperator;
var init_shaderDefineIsDefinedOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineIsDefinedOperator.js"() {
    init_shaderDefineExpression();
    ShaderDefineIsDefinedOperator = class extends ShaderDefineExpression {
      constructor(define, not = false) {
        super();
        this.define = define;
        this.not = not;
      }
      isTrue(preprocessors) {
        let condition = preprocessors[this.define] !== void 0;
        if (this.not) {
          condition = !condition;
        }
        return condition;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js
var ShaderDefineOrOperator;
var init_shaderDefineOrOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineOrOperator.js"() {
    init_shaderDefineExpression();
    ShaderDefineOrOperator = class extends ShaderDefineExpression {
      isTrue(preprocessors) {
        return this.leftOperand.isTrue(preprocessors) || this.rightOperand.isTrue(preprocessors);
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js
var ShaderDefineAndOperator;
var init_shaderDefineAndOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineAndOperator.js"() {
    init_shaderDefineExpression();
    ShaderDefineAndOperator = class extends ShaderDefineExpression {
      isTrue(preprocessors) {
        return this.leftOperand.isTrue(preprocessors) && this.rightOperand.isTrue(preprocessors);
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js
var ShaderDefineArithmeticOperator;
var init_shaderDefineArithmeticOperator = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/Expressions/Operators/shaderDefineArithmeticOperator.js"() {
    init_shaderDefineExpression();
    ShaderDefineArithmeticOperator = class extends ShaderDefineExpression {
      constructor(define, operand, testValue) {
        super();
        this.define = define;
        this.operand = operand;
        this.testValue = testValue;
      }
      isTrue(preprocessors) {
        let value = preprocessors[this.define];
        if (value === void 0) {
          value = this.define;
        }
        let condition = false;
        const left = parseInt(value);
        const right = parseInt(this.testValue);
        switch (this.operand) {
          case ">":
            condition = left > right;
            break;
          case "<":
            condition = left < right;
            break;
          case "<=":
            condition = left <= right;
            break;
          case ">=":
            condition = left >= right;
            break;
          case "==":
            condition = left === right;
            break;
          case "!=":
            condition = left !== right;
            break;
        }
        return condition;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/shaderLanguage.js
var ShaderLanguage;
var init_shaderLanguage = __esm({
  "node_modules/@babylonjs/core/Materials/shaderLanguage.js"() {
    (function(ShaderLanguage2) {
      ShaderLanguage2[ShaderLanguage2["GLSL"] = 0] = "GLSL";
      ShaderLanguage2[ShaderLanguage2["WGSL"] = 1] = "WGSL";
    })(ShaderLanguage || (ShaderLanguage = {}));
  }
});

// node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js
var regexSE, regexSERevert, regexShaderInclude, regexShaderDecl, regexLightX, regexX, reusableMatches, ShaderProcessor;
var init_shaderProcessor = __esm({
  "node_modules/@babylonjs/core/Engines/Processors/shaderProcessor.js"() {
    init_shaderCodeNode();
    init_shaderCodeCursor();
    init_shaderCodeConditionNode();
    init_shaderCodeTestNode();
    init_shaderDefineIsDefinedOperator();
    init_shaderDefineOrOperator();
    init_shaderDefineAndOperator();
    init_shaderDefineExpression();
    init_shaderDefineArithmeticOperator();
    init_devTools();
    init_shaderLanguage();
    regexSE = /defined\s*?\((.+?)\)/g;
    regexSERevert = /defined\s*?\[(.+?)\]/g;
    regexShaderInclude = /#include\s?<(.+)>(\((.*)\))*(\[(.*)\])*/g;
    regexShaderDecl = /__decl__/;
    regexLightX = /light\{X\}.(\w*)/g;
    regexX = /\{X\}/g;
    reusableMatches = [];
    ShaderProcessor = class {
      static Initialize(options) {
        if (options.processor && options.processor.initializeShaders) {
          options.processor.initializeShaders(options.processingContext);
        }
      }
      static Process(sourceCode, options, callback, engine) {
        var _a;
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
          sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
        }
        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {
          if (options.processCodeAfterIncludes) {
            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
          }
          const migratedCode = this._ProcessShaderConversion(codeWithIncludes, options, engine);
          callback(migratedCode, codeWithIncludes);
        });
      }
      static PreProcess(sourceCode, options, callback, engine) {
        var _a;
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessShaderCode) {
          sourceCode = options.processor.preProcessShaderCode(sourceCode, options.isFragment);
        }
        this._ProcessIncludes(sourceCode, options, (codeWithIncludes) => {
          if (options.processCodeAfterIncludes) {
            codeWithIncludes = options.processCodeAfterIncludes(options.isFragment ? "fragment" : "vertex", codeWithIncludes);
          }
          const migratedCode = this._ApplyPreProcessing(codeWithIncludes, options, engine);
          callback(migratedCode, codeWithIncludes);
        });
      }
      static Finalize(vertexCode, fragmentCode, options) {
        if (!options.processor || !options.processor.finalizeShaders) {
          return { vertexCode, fragmentCode };
        }
        return options.processor.finalizeShaders(vertexCode, fragmentCode, options.processingContext);
      }
      static _ProcessPrecision(source, options) {
        var _a;
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.noPrecision) {
          return source;
        }
        const shouldUseHighPrecisionShader = options.shouldUseHighPrecisionShader;
        if (source.indexOf("precision highp float") === -1) {
          if (!shouldUseHighPrecisionShader) {
            source = "precision mediump float;\n" + source;
          } else {
            source = "precision highp float;\n" + source;
          }
        } else {
          if (!shouldUseHighPrecisionShader) {
            source = source.replace("precision highp float", "precision mediump float");
          }
        }
        return source;
      }
      static _ExtractOperation(expression) {
        const regex = /defined\((.+)\)/;
        const match = regex.exec(expression);
        if (match && match.length) {
          return new ShaderDefineIsDefinedOperator(match[1].trim(), expression[0] === "!");
        }
        const operators = ["==", "!=", ">=", "<=", "<", ">"];
        let operator = "";
        let indexOperator = 0;
        for (operator of operators) {
          indexOperator = expression.indexOf(operator);
          if (indexOperator > -1) {
            break;
          }
        }
        if (indexOperator === -1) {
          return new ShaderDefineIsDefinedOperator(expression);
        }
        const define = expression.substring(0, indexOperator).trim();
        const value = expression.substring(indexOperator + operator.length).trim();
        return new ShaderDefineArithmeticOperator(define, operator, value);
      }
      static _BuildSubExpression(expression) {
        expression = expression.replace(regexSE, "defined[$1]");
        const postfix = ShaderDefineExpression.infixToPostfix(expression);
        const stack = [];
        for (const c of postfix) {
          if (c !== "||" && c !== "&&") {
            stack.push(c);
          } else if (stack.length >= 2) {
            let v1 = stack[stack.length - 1], v2 = stack[stack.length - 2];
            stack.length -= 2;
            const operator = c == "&&" ? new ShaderDefineAndOperator() : new ShaderDefineOrOperator();
            if (typeof v1 === "string") {
              v1 = v1.replace(regexSERevert, "defined($1)");
            }
            if (typeof v2 === "string") {
              v2 = v2.replace(regexSERevert, "defined($1)");
            }
            operator.leftOperand = typeof v2 === "string" ? this._ExtractOperation(v2) : v2;
            operator.rightOperand = typeof v1 === "string" ? this._ExtractOperation(v1) : v1;
            stack.push(operator);
          }
        }
        let result = stack[stack.length - 1];
        if (typeof result === "string") {
          result = result.replace(regexSERevert, "defined($1)");
        }
        return typeof result === "string" ? this._ExtractOperation(result) : result;
      }
      static _BuildExpression(line, start) {
        const node = new ShaderCodeTestNode();
        const command = line.substring(0, start);
        let expression = line.substring(start);
        expression = expression.substring(0, (expression.indexOf("//") + 1 || expression.length + 1) - 1).trim();
        if (command === "#ifdef") {
          node.testExpression = new ShaderDefineIsDefinedOperator(expression);
        } else if (command === "#ifndef") {
          node.testExpression = new ShaderDefineIsDefinedOperator(expression, true);
        } else {
          node.testExpression = this._BuildSubExpression(expression);
        }
        return node;
      }
      static _MoveCursorWithinIf(cursor, rootNode, ifNode) {
        let line = cursor.currentLine;
        while (this._MoveCursor(cursor, ifNode)) {
          line = cursor.currentLine;
          const first5 = line.substring(0, 5).toLowerCase();
          if (first5 === "#else") {
            const elseNode = new ShaderCodeNode();
            rootNode.children.push(elseNode);
            this._MoveCursor(cursor, elseNode);
            return;
          } else if (first5 === "#elif") {
            const elifNode = this._BuildExpression(line, 5);
            rootNode.children.push(elifNode);
            ifNode = elifNode;
          }
        }
      }
      static _MoveCursor(cursor, rootNode) {
        while (cursor.canRead) {
          cursor.lineIndex++;
          const line = cursor.currentLine;
          if (line.indexOf("#") >= 0) {
            const matches = ShaderProcessor._MoveCursorRegex.exec(line);
            if (matches && matches.length) {
              const keyword = matches[0];
              switch (keyword) {
                case "#ifdef": {
                  const newRootNode = new ShaderCodeConditionNode();
                  rootNode.children.push(newRootNode);
                  const ifNode = this._BuildExpression(line, 6);
                  newRootNode.children.push(ifNode);
                  this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
                  break;
                }
                case "#else":
                case "#elif":
                  return true;
                case "#endif":
                  return false;
                case "#ifndef": {
                  const newRootNode = new ShaderCodeConditionNode();
                  rootNode.children.push(newRootNode);
                  const ifNode = this._BuildExpression(line, 7);
                  newRootNode.children.push(ifNode);
                  this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
                  break;
                }
                case "#if": {
                  const newRootNode = new ShaderCodeConditionNode();
                  const ifNode = this._BuildExpression(line, 3);
                  rootNode.children.push(newRootNode);
                  newRootNode.children.push(ifNode);
                  this._MoveCursorWithinIf(cursor, newRootNode, ifNode);
                  break;
                }
              }
              continue;
            }
          }
          const newNode = new ShaderCodeNode();
          newNode.line = line;
          rootNode.children.push(newNode);
          if (line[0] === "#" && line[1] === "d") {
            const split = line.replace(";", "").split(" ");
            newNode.additionalDefineKey = split[1];
            if (split.length === 3) {
              newNode.additionalDefineValue = split[2];
            }
          }
        }
        return false;
      }
      static _EvaluatePreProcessors(sourceCode, preprocessors, options) {
        const rootNode = new ShaderCodeNode();
        const cursor = new ShaderCodeCursor();
        cursor.lineIndex = -1;
        cursor.lines = sourceCode.split("\n");
        this._MoveCursor(cursor, rootNode);
        return rootNode.process(preprocessors, options);
      }
      static _PreparePreProcessors(options, engine) {
        var _a;
        const defines = options.defines;
        const preprocessors = {};
        for (const define of defines) {
          const keyValue = define.replace("#define", "").replace(";", "").trim();
          const split = keyValue.split(" ");
          preprocessors[split[0]] = split.length > 1 ? split[1] : "";
        }
        if (((_a = options.processor) === null || _a === void 0 ? void 0 : _a.shaderLanguage) === ShaderLanguage.GLSL) {
          preprocessors["GL_ES"] = "true";
        }
        preprocessors["__VERSION__"] = options.version;
        preprocessors[options.platformName] = "true";
        engine._getGlobalDefines(preprocessors);
        return preprocessors;
      }
      static _ProcessShaderConversion(sourceCode, options, engine) {
        let preparedSourceCode = this._ProcessPrecision(sourceCode, options);
        if (!options.processor) {
          return preparedSourceCode;
        }
        if (options.processor.shaderLanguage === ShaderLanguage.GLSL && preparedSourceCode.indexOf("#version 3") !== -1) {
          preparedSourceCode = preparedSourceCode.replace("#version 300 es", "");
          if (!options.processor.parseGLES3) {
            return preparedSourceCode;
          }
        }
        const defines = options.defines;
        const preprocessors = this._PreparePreProcessors(options, engine);
        if (options.processor.preProcessor) {
          preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
        }
        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
        if (options.processor.postProcessor) {
          preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
        }
        if (engine._features.needShaderCodeInlining) {
          preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
        }
        return preparedSourceCode;
      }
      static _ApplyPreProcessing(sourceCode, options, engine) {
        var _a, _b;
        let preparedSourceCode = sourceCode;
        const defines = options.defines;
        const preprocessors = this._PreparePreProcessors(options, engine);
        if ((_a = options.processor) === null || _a === void 0 ? void 0 : _a.preProcessor) {
          preparedSourceCode = options.processor.preProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext);
        }
        preparedSourceCode = this._EvaluatePreProcessors(preparedSourceCode, preprocessors, options);
        if ((_b = options.processor) === null || _b === void 0 ? void 0 : _b.postProcessor) {
          preparedSourceCode = options.processor.postProcessor(preparedSourceCode, defines, options.isFragment, options.processingContext, engine);
        }
        if (engine._features.needShaderCodeInlining) {
          preparedSourceCode = engine.inlineShaderCode(preparedSourceCode);
        }
        return preparedSourceCode;
      }
      static _ProcessIncludes(sourceCode, options, callback) {
        reusableMatches.length = 0;
        let match;
        while ((match = regexShaderInclude.exec(sourceCode)) !== null) {
          reusableMatches.push(match);
        }
        let returnValue = String(sourceCode);
        let parts = [sourceCode];
        let keepProcessing = false;
        for (const match2 of reusableMatches) {
          let includeFile = match2[1];
          if (includeFile.indexOf("__decl__") !== -1) {
            includeFile = includeFile.replace(regexShaderDecl, "");
            if (options.supportsUniformBuffers) {
              includeFile = includeFile.replace("Vertex", "Ubo").replace("Fragment", "Ubo");
            }
            includeFile = includeFile + "Declaration";
          }
          if (options.includesShadersStore[includeFile]) {
            let includeContent = options.includesShadersStore[includeFile];
            if (match2[2]) {
              const splits = match2[3].split(",");
              for (let index = 0; index < splits.length; index += 2) {
                const source = new RegExp(splits[index], "g");
                const dest = splits[index + 1];
                includeContent = includeContent.replace(source, dest);
              }
            }
            if (match2[4]) {
              const indexString = match2[5];
              if (indexString.indexOf("..") !== -1) {
                const indexSplits = indexString.split("..");
                const minIndex = parseInt(indexSplits[0]);
                let maxIndex = parseInt(indexSplits[1]);
                let sourceIncludeContent = includeContent.slice(0);
                includeContent = "";
                if (isNaN(maxIndex)) {
                  maxIndex = options.indexParameters[indexSplits[1]];
                }
                for (let i = minIndex; i < maxIndex; i++) {
                  if (!options.supportsUniformBuffers) {
                    sourceIncludeContent = sourceIncludeContent.replace(regexLightX, (str, p1) => {
                      return p1 + "{X}";
                    });
                  }
                  includeContent += sourceIncludeContent.replace(regexX, i.toString()) + "\n";
                }
              } else {
                if (!options.supportsUniformBuffers) {
                  includeContent = includeContent.replace(regexLightX, (str, p1) => {
                    return p1 + "{X}";
                  });
                }
                includeContent = includeContent.replace(regexX, indexString);
              }
            }
            const newParts = [];
            for (const part of parts) {
              const splitPart = part.split(match2[0]);
              for (let i = 0; i < splitPart.length - 1; i++) {
                newParts.push(splitPart[i]);
                newParts.push(includeContent);
              }
              newParts.push(splitPart[splitPart.length - 1]);
            }
            parts = newParts;
            keepProcessing = keepProcessing || includeContent.indexOf("#include<") >= 0 || includeContent.indexOf("#include <") >= 0;
          } else {
            const includeShaderUrl = options.shadersRepository + "ShadersInclude/" + includeFile + ".fx";
            ShaderProcessor._FileToolsLoadFile(includeShaderUrl, (fileContent) => {
              options.includesShadersStore[includeFile] = fileContent;
              this._ProcessIncludes(parts.join(""), options, callback);
            });
            return;
          }
        }
        reusableMatches.length = 0;
        returnValue = parts.join("");
        if (keepProcessing) {
          this._ProcessIncludes(returnValue.toString(), options, callback);
        } else {
          callback(returnValue);
        }
      }
      static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        throw _WarnImport("FileTools");
      }
    };
    ShaderProcessor._MoveCursorRegex = /(#ifdef)|(#else)|(#elif)|(#endif)|(#ifndef)|(#if)/;
  }
});

// node_modules/@babylonjs/core/Engines/shaderStore.js
var ShaderStore;
var init_shaderStore = __esm({
  "node_modules/@babylonjs/core/Engines/shaderStore.js"() {
    init_shaderLanguage();
    ShaderStore = class {
      static GetShadersRepository(shaderLanguage = ShaderLanguage.GLSL) {
        return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore.ShadersRepository : ShaderStore.ShadersRepositoryWGSL;
      }
      static GetShadersStore(shaderLanguage = ShaderLanguage.GLSL) {
        return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore.ShadersStore : ShaderStore.ShadersStoreWGSL;
      }
      static GetIncludesShadersStore(shaderLanguage = ShaderLanguage.GLSL) {
        return shaderLanguage === ShaderLanguage.GLSL ? ShaderStore.IncludesShadersStore : ShaderStore.IncludesShadersStoreWGSL;
      }
    };
    ShaderStore.ShadersRepository = "src/Shaders/";
    ShaderStore.ShadersStore = {};
    ShaderStore.IncludesShadersStore = {};
    ShaderStore.ShadersRepositoryWGSL = "src/ShadersWGSL/";
    ShaderStore.ShadersStoreWGSL = {};
    ShaderStore.IncludesShadersStoreWGSL = {};
  }
});

// node_modules/@babylonjs/core/Materials/effect.js
var Effect;
var init_effect = __esm({
  "node_modules/@babylonjs/core/Materials/effect.js"() {
    init_observable();
    init_domManagement();
    init_logger();
    init_shaderProcessor();
    init_shaderStore();
    init_shaderLanguage();
    Effect = class {
      static get ShadersRepository() {
        return ShaderStore.ShadersRepository;
      }
      static set ShadersRepository(repo) {
        ShaderStore.ShadersRepository = repo;
      }
      get onBindObservable() {
        if (!this._onBindObservable) {
          this._onBindObservable = new Observable();
        }
        return this._onBindObservable;
      }
      constructor(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers = null, engine, defines = null, fallbacks = null, onCompiled = null, onError = null, indexParameters, key = "", shaderLanguage = ShaderLanguage.GLSL) {
        var _a, _b, _c;
        this.name = null;
        this.defines = "";
        this.onCompiled = null;
        this.onError = null;
        this.onBind = null;
        this.uniqueId = 0;
        this.onCompileObservable = new Observable();
        this.onErrorObservable = new Observable();
        this._onBindObservable = null;
        this._wasPreviouslyReady = false;
        this._forceRebindOnNextCall = false;
        this._wasPreviouslyUsingInstances = null;
        this._isDisposed = false;
        this._bonesComputationForcedToCPU = false;
        this._uniformBuffersNames = {};
        this._multiTarget = false;
        this._samplers = {};
        this._isReady = false;
        this._compilationError = "";
        this._allFallbacksProcessed = false;
        this._uniforms = {};
        this._key = "";
        this._fallbacks = null;
        this._vertexSourceCodeOverride = "";
        this._fragmentSourceCodeOverride = "";
        this._transformFeedbackVaryings = null;
        this._pipelineContext = null;
        this._vertexSourceCode = "";
        this._fragmentSourceCode = "";
        this._vertexSourceCodeBeforeMigration = "";
        this._fragmentSourceCodeBeforeMigration = "";
        this._rawVertexSourceCode = "";
        this._rawFragmentSourceCode = "";
        this.name = baseName;
        this._key = key;
        let processCodeAfterIncludes = void 0;
        let processFinalCode = null;
        if (attributesNamesOrOptions.attributes) {
          const options = attributesNamesOrOptions;
          this._engine = uniformsNamesOrEngine;
          this._attributesNames = options.attributes;
          this._uniformsNames = options.uniformsNames.concat(options.samplers);
          this._samplerList = options.samplers.slice();
          this.defines = options.defines;
          this.onError = options.onError;
          this.onCompiled = options.onCompiled;
          this._fallbacks = options.fallbacks;
          this._indexParameters = options.indexParameters;
          this._transformFeedbackVaryings = options.transformFeedbackVaryings || null;
          this._multiTarget = !!options.multiTarget;
          this._shaderLanguage = (_a = options.shaderLanguage) !== null && _a !== void 0 ? _a : ShaderLanguage.GLSL;
          if (options.uniformBuffersNames) {
            this._uniformBuffersNamesList = options.uniformBuffersNames.slice();
            for (let i = 0; i < options.uniformBuffersNames.length; i++) {
              this._uniformBuffersNames[options.uniformBuffersNames[i]] = i;
            }
          }
          processFinalCode = (_b = options.processFinalCode) !== null && _b !== void 0 ? _b : null;
          processCodeAfterIncludes = (_c = options.processCodeAfterIncludes) !== null && _c !== void 0 ? _c : void 0;
        } else {
          this._engine = engine;
          this.defines = defines == null ? "" : defines;
          this._uniformsNames = uniformsNamesOrEngine.concat(samplers);
          this._samplerList = samplers ? samplers.slice() : [];
          this._attributesNames = attributesNamesOrOptions;
          this._uniformBuffersNamesList = [];
          this._shaderLanguage = shaderLanguage;
          this.onError = onError;
          this.onCompiled = onCompiled;
          this._indexParameters = indexParameters;
          this._fallbacks = fallbacks;
        }
        this._attributeLocationByName = {};
        this.uniqueId = Effect._UniqueIdSeed++;
        let vertexSource;
        let fragmentSource;
        const hostDocument = IsWindowObjectExist() ? this._engine.getHostDocument() : null;
        if (baseName.vertexSource) {
          vertexSource = "source:" + baseName.vertexSource;
        } else if (baseName.vertexElement) {
          vertexSource = hostDocument ? hostDocument.getElementById(baseName.vertexElement) : null;
          if (!vertexSource) {
            vertexSource = baseName.vertexElement;
          }
        } else {
          vertexSource = baseName.vertex || baseName;
        }
        if (baseName.fragmentSource) {
          fragmentSource = "source:" + baseName.fragmentSource;
        } else if (baseName.fragmentElement) {
          fragmentSource = hostDocument ? hostDocument.getElementById(baseName.fragmentElement) : null;
          if (!fragmentSource) {
            fragmentSource = baseName.fragmentElement;
          }
        } else {
          fragmentSource = baseName.fragment || baseName;
        }
        this._processingContext = this._engine._getShaderProcessingContext(this._shaderLanguage);
        let processorOptions = {
          defines: this.defines.split("\n"),
          indexParameters: this._indexParameters,
          isFragment: false,
          shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
          processor: this._engine._getShaderProcessor(this._shaderLanguage),
          supportsUniformBuffers: this._engine.supportsUniformBuffers,
          shadersRepository: ShaderStore.GetShadersRepository(this._shaderLanguage),
          includesShadersStore: ShaderStore.GetIncludesShadersStore(this._shaderLanguage),
          version: (this._engine.version * 100).toString(),
          platformName: this._engine.shaderPlatformName,
          processingContext: this._processingContext,
          isNDCHalfZRange: this._engine.isNDCHalfZRange,
          useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
          processCodeAfterIncludes
        };
        const shaderCodes = [void 0, void 0];
        const shadersLoaded = () => {
          if (shaderCodes[0] && shaderCodes[1]) {
            processorOptions.isFragment = true;
            const [migratedVertexCode, fragmentCode] = shaderCodes;
            ShaderProcessor.Process(fragmentCode, processorOptions, (migratedFragmentCode, codeBeforeMigration) => {
              this._fragmentSourceCodeBeforeMigration = codeBeforeMigration;
              if (processFinalCode) {
                migratedFragmentCode = processFinalCode("fragment", migratedFragmentCode);
              }
              const finalShaders = ShaderProcessor.Finalize(migratedVertexCode, migratedFragmentCode, processorOptions);
              processorOptions = null;
              this._useFinalCode(finalShaders.vertexCode, finalShaders.fragmentCode, baseName);
            }, this._engine);
          }
        };
        this._loadShader(vertexSource, "Vertex", "", (vertexCode) => {
          ShaderProcessor.Initialize(processorOptions);
          ShaderProcessor.Process(vertexCode, processorOptions, (migratedVertexCode, codeBeforeMigration) => {
            this._rawVertexSourceCode = vertexCode;
            this._vertexSourceCodeBeforeMigration = codeBeforeMigration;
            if (processFinalCode) {
              migratedVertexCode = processFinalCode("vertex", migratedVertexCode);
            }
            shaderCodes[0] = migratedVertexCode;
            shadersLoaded();
          }, this._engine);
        });
        this._loadShader(fragmentSource, "Fragment", "Pixel", (fragmentCode) => {
          this._rawFragmentSourceCode = fragmentCode;
          shaderCodes[1] = fragmentCode;
          shadersLoaded();
        });
      }
      _useFinalCode(migratedVertexCode, migratedFragmentCode, baseName) {
        if (baseName) {
          const vertex = baseName.vertexElement || baseName.vertex || baseName.spectorName || baseName;
          const fragment = baseName.fragmentElement || baseName.fragment || baseName.spectorName || baseName;
          this._vertexSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME vertex:" + vertex + "\n" + migratedVertexCode;
          this._fragmentSourceCode = (this._shaderLanguage === ShaderLanguage.WGSL ? "//" : "") + "#define SHADER_NAME fragment:" + fragment + "\n" + migratedFragmentCode;
        } else {
          this._vertexSourceCode = migratedVertexCode;
          this._fragmentSourceCode = migratedFragmentCode;
        }
        this._prepareEffect();
      }
      get key() {
        return this._key;
      }
      isReady() {
        try {
          return this._isReadyInternal();
        } catch (_a) {
          return false;
        }
      }
      _isReadyInternal() {
        if (this._isReady) {
          return true;
        }
        if (this._pipelineContext) {
          return this._pipelineContext.isReady;
        }
        return false;
      }
      getEngine() {
        return this._engine;
      }
      getPipelineContext() {
        return this._pipelineContext;
      }
      getAttributesNames() {
        return this._attributesNames;
      }
      getAttributeLocation(index) {
        return this._attributes[index];
      }
      getAttributeLocationByName(name) {
        return this._attributeLocationByName[name];
      }
      getAttributesCount() {
        return this._attributes.length;
      }
      getUniformIndex(uniformName) {
        return this._uniformsNames.indexOf(uniformName);
      }
      getUniform(uniformName) {
        return this._uniforms[uniformName];
      }
      getSamplers() {
        return this._samplerList;
      }
      getUniformNames() {
        return this._uniformsNames;
      }
      getUniformBuffersNames() {
        return this._uniformBuffersNamesList;
      }
      getIndexParameters() {
        return this._indexParameters;
      }
      getCompilationError() {
        return this._compilationError;
      }
      allFallbacksProcessed() {
        return this._allFallbacksProcessed;
      }
      executeWhenCompiled(func) {
        if (this.isReady()) {
          func(this);
          return;
        }
        this.onCompileObservable.add((effect) => {
          func(effect);
        });
        if (!this._pipelineContext || this._pipelineContext.isAsync) {
          setTimeout(() => {
            this._checkIsReady(null);
          }, 16);
        }
      }
      _checkIsReady(previousPipelineContext) {
        try {
          if (this._isReadyInternal()) {
            return;
          }
        } catch (e) {
          this._processCompilationErrors(e, previousPipelineContext);
          return;
        }
        if (this._isDisposed) {
          return;
        }
        setTimeout(() => {
          this._checkIsReady(previousPipelineContext);
        }, 16);
      }
      _loadShader(shader, key, optionalKey, callback) {
        if (typeof HTMLElement !== "undefined") {
          if (shader instanceof HTMLElement) {
            const shaderCode = GetDOMTextContent(shader);
            callback(shaderCode);
            return;
          }
        }
        if (shader.substr(0, 7) === "source:") {
          callback(shader.substr(7));
          return;
        }
        if (shader.substr(0, 7) === "base64:") {
          const shaderBinary = window.atob(shader.substr(7));
          callback(shaderBinary);
          return;
        }
        const shaderStore = ShaderStore.GetShadersStore(this._shaderLanguage);
        if (shaderStore[shader + key + "Shader"]) {
          callback(shaderStore[shader + key + "Shader"]);
          return;
        }
        if (optionalKey && shaderStore[shader + optionalKey + "Shader"]) {
          callback(shaderStore[shader + optionalKey + "Shader"]);
          return;
        }
        let shaderUrl;
        if (shader[0] === "." || shader[0] === "/" || shader.indexOf("http") > -1) {
          shaderUrl = shader;
        } else {
          shaderUrl = ShaderStore.GetShadersRepository(this._shaderLanguage) + shader;
        }
        this._engine._loadFile(shaderUrl + "." + key.toLowerCase() + ".fx", callback);
      }
      get vertexSourceCode() {
        var _a, _b;
        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._vertexSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) !== null && _b !== void 0 ? _b : this._vertexSourceCode;
      }
      get fragmentSourceCode() {
        var _a, _b;
        return this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride ? this._fragmentSourceCodeOverride : (_b = (_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getFragmentShaderCode()) !== null && _b !== void 0 ? _b : this._fragmentSourceCode;
      }
      get vertexSourceCodeBeforeMigration() {
        return this._vertexSourceCodeBeforeMigration;
      }
      get fragmentSourceCodeBeforeMigration() {
        return this._fragmentSourceCodeBeforeMigration;
      }
      get rawVertexSourceCode() {
        return this._rawVertexSourceCode;
      }
      get rawFragmentSourceCode() {
        return this._rawFragmentSourceCode;
      }
      _rebuildProgram(vertexSourceCode, fragmentSourceCode, onCompiled, onError) {
        this._isReady = false;
        this._vertexSourceCodeOverride = vertexSourceCode;
        this._fragmentSourceCodeOverride = fragmentSourceCode;
        this.onError = (effect, error) => {
          if (onError) {
            onError(error);
          }
        };
        this.onCompiled = () => {
          const scenes = this.getEngine().scenes;
          if (scenes) {
            for (let i = 0; i < scenes.length; i++) {
              scenes[i].markAllMaterialsAsDirty(63);
            }
          }
          this._pipelineContext._handlesSpectorRebuildCallback(onCompiled);
        };
        this._fallbacks = null;
        this._prepareEffect();
      }
      _prepareEffect() {
        const attributesNames = this._attributesNames;
        const defines = this.defines;
        const previousPipelineContext = this._pipelineContext;
        this._isReady = false;
        try {
          const engine = this._engine;
          this._pipelineContext = engine.createPipelineContext(this._processingContext);
          this._pipelineContext._name = this._key;
          const rebuildRebind = this._rebuildProgram.bind(this);
          if (this._vertexSourceCodeOverride && this._fragmentSourceCodeOverride) {
            engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCodeOverride, this._fragmentSourceCodeOverride, true, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, null, this._transformFeedbackVaryings, this._key);
          } else {
            engine._preparePipelineContext(this._pipelineContext, this._vertexSourceCode, this._fragmentSourceCode, false, this._rawVertexSourceCode, this._rawFragmentSourceCode, rebuildRebind, defines, this._transformFeedbackVaryings, this._key);
          }
          engine._executeWhenRenderingStateIsCompiled(this._pipelineContext, () => {
            this._attributes = [];
            this._pipelineContext._fillEffectInformation(this, this._uniformBuffersNames, this._uniformsNames, this._uniforms, this._samplerList, this._samplers, attributesNames, this._attributes);
            if (attributesNames) {
              for (let i = 0; i < attributesNames.length; i++) {
                const name = attributesNames[i];
                this._attributeLocationByName[name] = this._attributes[i];
              }
            }
            engine.bindSamplers(this);
            this._compilationError = "";
            this._isReady = true;
            if (this.onCompiled) {
              this.onCompiled(this);
            }
            this.onCompileObservable.notifyObservers(this);
            this.onCompileObservable.clear();
            if (this._fallbacks) {
              this._fallbacks.unBindMesh();
            }
            if (previousPipelineContext) {
              this.getEngine()._deletePipelineContext(previousPipelineContext);
            }
          });
          if (this._pipelineContext.isAsync) {
            this._checkIsReady(previousPipelineContext);
          }
        } catch (e) {
          this._processCompilationErrors(e, previousPipelineContext);
        }
      }
      _getShaderCodeAndErrorLine(code, error, isFragment) {
        const regexp = isFragment ? /FRAGMENT SHADER ERROR: 0:(\d+?):/ : /VERTEX SHADER ERROR: 0:(\d+?):/;
        let errorLine = null;
        if (error && code) {
          const res = error.match(regexp);
          if (res && res.length === 2) {
            const lineNumber = parseInt(res[1]);
            const lines = code.split("\n", -1);
            if (lines.length >= lineNumber) {
              errorLine = `Offending line [${lineNumber}] in ${isFragment ? "fragment" : "vertex"} code: ${lines[lineNumber - 1]}`;
            }
          }
        }
        return [code, errorLine];
      }
      _processCompilationErrors(e, previousPipelineContext = null) {
        var _a, _b, _c;
        this._compilationError = e.message;
        const attributesNames = this._attributesNames;
        const fallbacks = this._fallbacks;
        Logger.Error("Unable to compile effect:");
        Logger.Error("Uniforms: " + this._uniformsNames.map(function(uniform) {
          return " " + uniform;
        }));
        Logger.Error("Attributes: " + attributesNames.map(function(attribute) {
          return " " + attribute;
        }));
        Logger.Error("Defines:\n" + this.defines);
        if (Effect.LogShaderCodeOnCompilationError) {
          let lineErrorVertex = null, lineErrorFragment = null, code = null;
          if ((_a = this._pipelineContext) === null || _a === void 0 ? void 0 : _a._getVertexShaderCode()) {
            [code, lineErrorVertex] = this._getShaderCodeAndErrorLine(this._pipelineContext._getVertexShaderCode(), this._compilationError, false);
            if (code) {
              Logger.Error("Vertex code:");
              Logger.Error(code);
            }
          }
          if ((_b = this._pipelineContext) === null || _b === void 0 ? void 0 : _b._getFragmentShaderCode()) {
            [code, lineErrorFragment] = this._getShaderCodeAndErrorLine((_c = this._pipelineContext) === null || _c === void 0 ? void 0 : _c._getFragmentShaderCode(), this._compilationError, true);
            if (code) {
              Logger.Error("Fragment code:");
              Logger.Error(code);
            }
          }
          if (lineErrorVertex) {
            Logger.Error(lineErrorVertex);
          }
          if (lineErrorFragment) {
            Logger.Error(lineErrorFragment);
          }
        }
        Logger.Error("Error: " + this._compilationError);
        const notifyErrors = () => {
          if (this.onError) {
            this.onError(this, this._compilationError);
          }
          this.onErrorObservable.notifyObservers(this);
        };
        if (previousPipelineContext) {
          this._pipelineContext = previousPipelineContext;
          this._isReady = true;
          notifyErrors();
        }
        if (fallbacks) {
          this._pipelineContext = null;
          if (fallbacks.hasMoreFallbacks) {
            this._allFallbacksProcessed = false;
            Logger.Error("Trying next fallback.");
            this.defines = fallbacks.reduce(this.defines, this);
            this._prepareEffect();
          } else {
            this._allFallbacksProcessed = true;
            notifyErrors();
            this.onErrorObservable.clear();
            if (this._fallbacks) {
              this._fallbacks.unBindMesh();
            }
          }
        } else {
          this._allFallbacksProcessed = true;
          if (!previousPipelineContext) {
            notifyErrors();
          }
        }
      }
      get isSupported() {
        return this._compilationError === "";
      }
      _bindTexture(channel, texture) {
        this._engine._bindTexture(this._samplers[channel], texture, channel);
      }
      setTexture(channel, texture) {
        this._engine.setTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
      }
      setDepthStencilTexture(channel, texture) {
        this._engine.setDepthStencilTexture(this._samplers[channel], this._uniforms[channel], texture, channel);
      }
      setTextureArray(channel, textures) {
        const exName = channel + "Ex";
        if (this._samplerList.indexOf(exName + "0") === -1) {
          const initialPos = this._samplerList.indexOf(channel);
          for (let index = 1; index < textures.length; index++) {
            const currentExName = exName + (index - 1).toString();
            this._samplerList.splice(initialPos + index, 0, currentExName);
          }
          let channelIndex = 0;
          for (const key of this._samplerList) {
            this._samplers[key] = channelIndex;
            channelIndex += 1;
          }
        }
        this._engine.setTextureArray(this._samplers[channel], this._uniforms[channel], textures, channel);
      }
      setTextureFromPostProcess(channel, postProcess) {
        this._engine.setTextureFromPostProcess(this._samplers[channel], postProcess, channel);
      }
      setTextureFromPostProcessOutput(channel, postProcess) {
        this._engine.setTextureFromPostProcessOutput(this._samplers[channel], postProcess, channel);
      }
      bindUniformBuffer(buffer, name) {
        const bufferName = this._uniformBuffersNames[name];
        if (bufferName === void 0 || Effect._BaseCache[bufferName] === buffer && this._engine._features.useUBOBindingCache) {
          return;
        }
        Effect._BaseCache[bufferName] = buffer;
        this._engine.bindUniformBufferBase(buffer, bufferName, name);
      }
      bindUniformBlock(blockName, index) {
        this._engine.bindUniformBlock(this._pipelineContext, blockName, index);
      }
      setInt(uniformName, value) {
        this._pipelineContext.setInt(uniformName, value);
        return this;
      }
      setInt2(uniformName, x, y) {
        this._pipelineContext.setInt2(uniformName, x, y);
        return this;
      }
      setInt3(uniformName, x, y, z) {
        this._pipelineContext.setInt3(uniformName, x, y, z);
        return this;
      }
      setInt4(uniformName, x, y, z, w) {
        this._pipelineContext.setInt4(uniformName, x, y, z, w);
        return this;
      }
      setIntArray(uniformName, array) {
        this._pipelineContext.setIntArray(uniformName, array);
        return this;
      }
      setIntArray2(uniformName, array) {
        this._pipelineContext.setIntArray2(uniformName, array);
        return this;
      }
      setIntArray3(uniformName, array) {
        this._pipelineContext.setIntArray3(uniformName, array);
        return this;
      }
      setIntArray4(uniformName, array) {
        this._pipelineContext.setIntArray4(uniformName, array);
        return this;
      }
      setUInt(uniformName, value) {
        this._pipelineContext.setUInt(uniformName, value);
        return this;
      }
      setUInt2(uniformName, x, y) {
        this._pipelineContext.setUInt2(uniformName, x, y);
        return this;
      }
      setUInt3(uniformName, x, y, z) {
        this._pipelineContext.setUInt3(uniformName, x, y, z);
        return this;
      }
      setUInt4(uniformName, x, y, z, w) {
        this._pipelineContext.setUInt4(uniformName, x, y, z, w);
        return this;
      }
      setUIntArray(uniformName, array) {
        this._pipelineContext.setUIntArray(uniformName, array);
        return this;
      }
      setUIntArray2(uniformName, array) {
        this._pipelineContext.setUIntArray2(uniformName, array);
        return this;
      }
      setUIntArray3(uniformName, array) {
        this._pipelineContext.setUIntArray3(uniformName, array);
        return this;
      }
      setUIntArray4(uniformName, array) {
        this._pipelineContext.setUIntArray4(uniformName, array);
        return this;
      }
      setFloatArray(uniformName, array) {
        this._pipelineContext.setArray(uniformName, array);
        return this;
      }
      setFloatArray2(uniformName, array) {
        this._pipelineContext.setArray2(uniformName, array);
        return this;
      }
      setFloatArray3(uniformName, array) {
        this._pipelineContext.setArray3(uniformName, array);
        return this;
      }
      setFloatArray4(uniformName, array) {
        this._pipelineContext.setArray4(uniformName, array);
        return this;
      }
      setArray(uniformName, array) {
        this._pipelineContext.setArray(uniformName, array);
        return this;
      }
      setArray2(uniformName, array) {
        this._pipelineContext.setArray2(uniformName, array);
        return this;
      }
      setArray3(uniformName, array) {
        this._pipelineContext.setArray3(uniformName, array);
        return this;
      }
      setArray4(uniformName, array) {
        this._pipelineContext.setArray4(uniformName, array);
        return this;
      }
      setMatrices(uniformName, matrices) {
        this._pipelineContext.setMatrices(uniformName, matrices);
        return this;
      }
      setMatrix(uniformName, matrix) {
        this._pipelineContext.setMatrix(uniformName, matrix);
        return this;
      }
      setMatrix3x3(uniformName, matrix) {
        this._pipelineContext.setMatrix3x3(uniformName, matrix);
        return this;
      }
      setMatrix2x2(uniformName, matrix) {
        this._pipelineContext.setMatrix2x2(uniformName, matrix);
        return this;
      }
      setFloat(uniformName, value) {
        this._pipelineContext.setFloat(uniformName, value);
        return this;
      }
      setBool(uniformName, bool) {
        this._pipelineContext.setInt(uniformName, bool ? 1 : 0);
        return this;
      }
      setVector2(uniformName, vector2) {
        this._pipelineContext.setVector2(uniformName, vector2);
        return this;
      }
      setFloat2(uniformName, x, y) {
        this._pipelineContext.setFloat2(uniformName, x, y);
        return this;
      }
      setVector3(uniformName, vector3) {
        this._pipelineContext.setVector3(uniformName, vector3);
        return this;
      }
      setFloat3(uniformName, x, y, z) {
        this._pipelineContext.setFloat3(uniformName, x, y, z);
        return this;
      }
      setVector4(uniformName, vector4) {
        this._pipelineContext.setVector4(uniformName, vector4);
        return this;
      }
      setQuaternion(uniformName, quaternion) {
        this._pipelineContext.setQuaternion(uniformName, quaternion);
        return this;
      }
      setFloat4(uniformName, x, y, z, w) {
        this._pipelineContext.setFloat4(uniformName, x, y, z, w);
        return this;
      }
      setColor3(uniformName, color3) {
        this._pipelineContext.setColor3(uniformName, color3);
        return this;
      }
      setColor4(uniformName, color3, alpha) {
        this._pipelineContext.setColor4(uniformName, color3, alpha);
        return this;
      }
      setDirectColor4(uniformName, color4) {
        this._pipelineContext.setDirectColor4(uniformName, color4);
        return this;
      }
      dispose() {
        if (this._pipelineContext) {
          this._pipelineContext.dispose();
        }
        this._engine._releaseEffect(this);
        this._isDisposed = true;
      }
      static RegisterShader(name, pixelShader, vertexShader, shaderLanguage = ShaderLanguage.GLSL) {
        if (pixelShader) {
          ShaderStore.GetShadersStore(shaderLanguage)[`${name}PixelShader`] = pixelShader;
        }
        if (vertexShader) {
          ShaderStore.GetShadersStore(shaderLanguage)[`${name}VertexShader`] = vertexShader;
        }
      }
      static ResetCache() {
        Effect._BaseCache = {};
      }
    };
    Effect.LogShaderCodeOnCompilationError = true;
    Effect._UniqueIdSeed = 0;
    Effect._BaseCache = {};
    Effect.ShadersStore = ShaderStore.ShadersStore;
    Effect.IncludesShadersStore = ShaderStore.IncludesShadersStore;
  }
});

// node_modules/@babylonjs/core/States/depthCullingState.js
var DepthCullingState;
var init_depthCullingState = __esm({
  "node_modules/@babylonjs/core/States/depthCullingState.js"() {
    DepthCullingState = class {
      constructor(reset = true) {
        this._isDepthTestDirty = false;
        this._isDepthMaskDirty = false;
        this._isDepthFuncDirty = false;
        this._isCullFaceDirty = false;
        this._isCullDirty = false;
        this._isZOffsetDirty = false;
        this._isFrontFaceDirty = false;
        if (reset) {
          this.reset();
        }
      }
      get isDirty() {
        return this._isDepthFuncDirty || this._isDepthTestDirty || this._isDepthMaskDirty || this._isCullFaceDirty || this._isCullDirty || this._isZOffsetDirty || this._isFrontFaceDirty;
      }
      get zOffset() {
        return this._zOffset;
      }
      set zOffset(value) {
        if (this._zOffset === value) {
          return;
        }
        this._zOffset = value;
        this._isZOffsetDirty = true;
      }
      get zOffsetUnits() {
        return this._zOffsetUnits;
      }
      set zOffsetUnits(value) {
        if (this._zOffsetUnits === value) {
          return;
        }
        this._zOffsetUnits = value;
        this._isZOffsetDirty = true;
      }
      get cullFace() {
        return this._cullFace;
      }
      set cullFace(value) {
        if (this._cullFace === value) {
          return;
        }
        this._cullFace = value;
        this._isCullFaceDirty = true;
      }
      get cull() {
        return this._cull;
      }
      set cull(value) {
        if (this._cull === value) {
          return;
        }
        this._cull = value;
        this._isCullDirty = true;
      }
      get depthFunc() {
        return this._depthFunc;
      }
      set depthFunc(value) {
        if (this._depthFunc === value) {
          return;
        }
        this._depthFunc = value;
        this._isDepthFuncDirty = true;
      }
      get depthMask() {
        return this._depthMask;
      }
      set depthMask(value) {
        if (this._depthMask === value) {
          return;
        }
        this._depthMask = value;
        this._isDepthMaskDirty = true;
      }
      get depthTest() {
        return this._depthTest;
      }
      set depthTest(value) {
        if (this._depthTest === value) {
          return;
        }
        this._depthTest = value;
        this._isDepthTestDirty = true;
      }
      get frontFace() {
        return this._frontFace;
      }
      set frontFace(value) {
        if (this._frontFace === value) {
          return;
        }
        this._frontFace = value;
        this._isFrontFaceDirty = true;
      }
      reset() {
        this._depthMask = true;
        this._depthTest = true;
        this._depthFunc = null;
        this._cullFace = null;
        this._cull = null;
        this._zOffset = 0;
        this._zOffsetUnits = 0;
        this._frontFace = null;
        this._isDepthTestDirty = true;
        this._isDepthMaskDirty = true;
        this._isDepthFuncDirty = false;
        this._isCullFaceDirty = false;
        this._isCullDirty = false;
        this._isZOffsetDirty = true;
        this._isFrontFaceDirty = false;
      }
      apply(gl) {
        if (!this.isDirty) {
          return;
        }
        if (this._isCullDirty) {
          if (this.cull) {
            gl.enable(gl.CULL_FACE);
          } else {
            gl.disable(gl.CULL_FACE);
          }
          this._isCullDirty = false;
        }
        if (this._isCullFaceDirty) {
          gl.cullFace(this.cullFace);
          this._isCullFaceDirty = false;
        }
        if (this._isDepthMaskDirty) {
          gl.depthMask(this.depthMask);
          this._isDepthMaskDirty = false;
        }
        if (this._isDepthTestDirty) {
          if (this.depthTest) {
            gl.enable(gl.DEPTH_TEST);
          } else {
            gl.disable(gl.DEPTH_TEST);
          }
          this._isDepthTestDirty = false;
        }
        if (this._isDepthFuncDirty) {
          gl.depthFunc(this.depthFunc);
          this._isDepthFuncDirty = false;
        }
        if (this._isZOffsetDirty) {
          if (this.zOffset || this.zOffsetUnits) {
            gl.enable(gl.POLYGON_OFFSET_FILL);
            gl.polygonOffset(this.zOffset, this.zOffsetUnits);
          } else {
            gl.disable(gl.POLYGON_OFFSET_FILL);
          }
          this._isZOffsetDirty = false;
        }
        if (this._isFrontFaceDirty) {
          gl.frontFace(this.frontFace);
          this._isFrontFaceDirty = false;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/States/stencilState.js
var StencilState;
var init_stencilState = __esm({
  "node_modules/@babylonjs/core/States/stencilState.js"() {
    StencilState = class {
      constructor() {
        this.reset();
      }
      reset() {
        this.enabled = false;
        this.mask = 255;
        this.func = StencilState.ALWAYS;
        this.funcRef = 1;
        this.funcMask = 255;
        this.opStencilFail = StencilState.KEEP;
        this.opDepthFail = StencilState.KEEP;
        this.opStencilDepthPass = StencilState.REPLACE;
      }
      get stencilFunc() {
        return this.func;
      }
      set stencilFunc(value) {
        this.func = value;
      }
      get stencilFuncRef() {
        return this.funcRef;
      }
      set stencilFuncRef(value) {
        this.funcRef = value;
      }
      get stencilFuncMask() {
        return this.funcMask;
      }
      set stencilFuncMask(value) {
        this.funcMask = value;
      }
      get stencilOpStencilFail() {
        return this.opStencilFail;
      }
      set stencilOpStencilFail(value) {
        this.opStencilFail = value;
      }
      get stencilOpDepthFail() {
        return this.opDepthFail;
      }
      set stencilOpDepthFail(value) {
        this.opDepthFail = value;
      }
      get stencilOpStencilDepthPass() {
        return this.opStencilDepthPass;
      }
      set stencilOpStencilDepthPass(value) {
        this.opStencilDepthPass = value;
      }
      get stencilMask() {
        return this.mask;
      }
      set stencilMask(value) {
        this.mask = value;
      }
      get stencilTest() {
        return this.enabled;
      }
      set stencilTest(value) {
        this.enabled = value;
      }
    };
    StencilState.ALWAYS = 519;
    StencilState.KEEP = 7680;
    StencilState.REPLACE = 7681;
  }
});

// node_modules/@babylonjs/core/States/alphaCullingState.js
var AlphaState;
var init_alphaCullingState = __esm({
  "node_modules/@babylonjs/core/States/alphaCullingState.js"() {
    AlphaState = class {
      constructor() {
        this._blendFunctionParameters = new Array(4);
        this._blendEquationParameters = new Array(2);
        this._blendConstants = new Array(4);
        this._isBlendConstantsDirty = false;
        this._alphaBlend = false;
        this._isAlphaBlendDirty = false;
        this._isBlendFunctionParametersDirty = false;
        this._isBlendEquationParametersDirty = false;
        this.reset();
      }
      get isDirty() {
        return this._isAlphaBlendDirty || this._isBlendFunctionParametersDirty || this._isBlendEquationParametersDirty;
      }
      get alphaBlend() {
        return this._alphaBlend;
      }
      set alphaBlend(value) {
        if (this._alphaBlend === value) {
          return;
        }
        this._alphaBlend = value;
        this._isAlphaBlendDirty = true;
      }
      setAlphaBlendConstants(r, g, b, a) {
        if (this._blendConstants[0] === r && this._blendConstants[1] === g && this._blendConstants[2] === b && this._blendConstants[3] === a) {
          return;
        }
        this._blendConstants[0] = r;
        this._blendConstants[1] = g;
        this._blendConstants[2] = b;
        this._blendConstants[3] = a;
        this._isBlendConstantsDirty = true;
      }
      setAlphaBlendFunctionParameters(value0, value1, value2, value3) {
        if (this._blendFunctionParameters[0] === value0 && this._blendFunctionParameters[1] === value1 && this._blendFunctionParameters[2] === value2 && this._blendFunctionParameters[3] === value3) {
          return;
        }
        this._blendFunctionParameters[0] = value0;
        this._blendFunctionParameters[1] = value1;
        this._blendFunctionParameters[2] = value2;
        this._blendFunctionParameters[3] = value3;
        this._isBlendFunctionParametersDirty = true;
      }
      setAlphaEquationParameters(rgb, alpha) {
        if (this._blendEquationParameters[0] === rgb && this._blendEquationParameters[1] === alpha) {
          return;
        }
        this._blendEquationParameters[0] = rgb;
        this._blendEquationParameters[1] = alpha;
        this._isBlendEquationParametersDirty = true;
      }
      reset() {
        this._alphaBlend = false;
        this._blendFunctionParameters[0] = null;
        this._blendFunctionParameters[1] = null;
        this._blendFunctionParameters[2] = null;
        this._blendFunctionParameters[3] = null;
        this._blendEquationParameters[0] = null;
        this._blendEquationParameters[1] = null;
        this._blendConstants[0] = null;
        this._blendConstants[1] = null;
        this._blendConstants[2] = null;
        this._blendConstants[3] = null;
        this._isAlphaBlendDirty = true;
        this._isBlendFunctionParametersDirty = false;
        this._isBlendEquationParametersDirty = false;
        this._isBlendConstantsDirty = false;
      }
      apply(gl) {
        if (!this.isDirty) {
          return;
        }
        if (this._isAlphaBlendDirty) {
          if (this._alphaBlend) {
            gl.enable(gl.BLEND);
          } else {
            gl.disable(gl.BLEND);
          }
          this._isAlphaBlendDirty = false;
        }
        if (this._isBlendFunctionParametersDirty) {
          gl.blendFuncSeparate(this._blendFunctionParameters[0], this._blendFunctionParameters[1], this._blendFunctionParameters[2], this._blendFunctionParameters[3]);
          this._isBlendFunctionParametersDirty = false;
        }
        if (this._isBlendEquationParametersDirty) {
          gl.blendEquationSeparate(this._blendEquationParameters[0], this._blendEquationParameters[1]);
          this._isBlendEquationParametersDirty = false;
        }
        if (this._isBlendConstantsDirty) {
          gl.blendColor(this._blendConstants[0], this._blendConstants[1], this._blendConstants[2], this._blendConstants[3]);
          this._isBlendConstantsDirty = false;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/textureSampler.js
var TextureSampler;
var init_textureSampler = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/textureSampler.js"() {
    TextureSampler = class {
      get wrapU() {
        return this._cachedWrapU;
      }
      set wrapU(value) {
        this._cachedWrapU = value;
      }
      get wrapV() {
        return this._cachedWrapV;
      }
      set wrapV(value) {
        this._cachedWrapV = value;
      }
      get wrapR() {
        return this._cachedWrapR;
      }
      set wrapR(value) {
        this._cachedWrapR = value;
      }
      get anisotropicFilteringLevel() {
        return this._cachedAnisotropicFilteringLevel;
      }
      set anisotropicFilteringLevel(value) {
        this._cachedAnisotropicFilteringLevel = value;
      }
      get comparisonFunction() {
        return this._comparisonFunction;
      }
      set comparisonFunction(value) {
        this._comparisonFunction = value;
      }
      get useMipMaps() {
        return this._useMipMaps;
      }
      set useMipMaps(value) {
        this._useMipMaps = value;
      }
      constructor() {
        this.samplingMode = -1;
        this._useMipMaps = true;
        this._cachedWrapU = null;
        this._cachedWrapV = null;
        this._cachedWrapR = null;
        this._cachedAnisotropicFilteringLevel = null;
        this._comparisonFunction = 0;
      }
      setParameters(wrapU = 1, wrapV = 1, wrapR = 1, anisotropicFilteringLevel = 1, samplingMode = 2, comparisonFunction = 0) {
        this._cachedWrapU = wrapU;
        this._cachedWrapV = wrapV;
        this._cachedWrapR = wrapR;
        this._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
        this.samplingMode = samplingMode;
        this._comparisonFunction = comparisonFunction;
        return this;
      }
      compareSampler(other) {
        return this._cachedWrapU === other._cachedWrapU && this._cachedWrapV === other._cachedWrapV && this._cachedWrapR === other._cachedWrapR && this._cachedAnisotropicFilteringLevel === other._cachedAnisotropicFilteringLevel && this.samplingMode === other.samplingMode && this._comparisonFunction === other._comparisonFunction && this._useMipMaps === other._useMipMaps;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/internalTexture.js
var InternalTextureSource, InternalTexture;
var init_internalTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/internalTexture.js"() {
    init_observable();
    init_textureSampler();
    (function(InternalTextureSource2) {
      InternalTextureSource2[InternalTextureSource2["Unknown"] = 0] = "Unknown";
      InternalTextureSource2[InternalTextureSource2["Url"] = 1] = "Url";
      InternalTextureSource2[InternalTextureSource2["Temp"] = 2] = "Temp";
      InternalTextureSource2[InternalTextureSource2["Raw"] = 3] = "Raw";
      InternalTextureSource2[InternalTextureSource2["Dynamic"] = 4] = "Dynamic";
      InternalTextureSource2[InternalTextureSource2["RenderTarget"] = 5] = "RenderTarget";
      InternalTextureSource2[InternalTextureSource2["MultiRenderTarget"] = 6] = "MultiRenderTarget";
      InternalTextureSource2[InternalTextureSource2["Cube"] = 7] = "Cube";
      InternalTextureSource2[InternalTextureSource2["CubeRaw"] = 8] = "CubeRaw";
      InternalTextureSource2[InternalTextureSource2["CubePrefiltered"] = 9] = "CubePrefiltered";
      InternalTextureSource2[InternalTextureSource2["Raw3D"] = 10] = "Raw3D";
      InternalTextureSource2[InternalTextureSource2["Raw2DArray"] = 11] = "Raw2DArray";
      InternalTextureSource2[InternalTextureSource2["DepthStencil"] = 12] = "DepthStencil";
      InternalTextureSource2[InternalTextureSource2["CubeRawRGBD"] = 13] = "CubeRawRGBD";
      InternalTextureSource2[InternalTextureSource2["Depth"] = 14] = "Depth";
    })(InternalTextureSource || (InternalTextureSource = {}));
    InternalTexture = class extends TextureSampler {
      get useMipMaps() {
        return this.generateMipMaps;
      }
      set useMipMaps(value) {
        this.generateMipMaps = value;
      }
      get uniqueId() {
        return this._uniqueId;
      }
      _setUniqueId(id) {
        this._uniqueId = id;
      }
      getEngine() {
        return this._engine;
      }
      get source() {
        return this._source;
      }
      constructor(engine, source, delayAllocation = false) {
        super();
        this.isReady = false;
        this.isCube = false;
        this.is3D = false;
        this.is2DArray = false;
        this.isMultiview = false;
        this.url = "";
        this.generateMipMaps = false;
        this.samples = 0;
        this.type = -1;
        this.format = -1;
        this.onLoadedObservable = new Observable();
        this.onErrorObservable = new Observable();
        this.onRebuildCallback = null;
        this.width = 0;
        this.height = 0;
        this.depth = 0;
        this.baseWidth = 0;
        this.baseHeight = 0;
        this.baseDepth = 0;
        this.invertY = false;
        this._invertVScale = false;
        this._associatedChannel = -1;
        this._source = InternalTextureSource.Unknown;
        this._buffer = null;
        this._bufferView = null;
        this._bufferViewArray = null;
        this._bufferViewArrayArray = null;
        this._size = 0;
        this._extension = "";
        this._files = null;
        this._workingCanvas = null;
        this._workingContext = null;
        this._cachedCoordinatesMode = null;
        this._isDisabled = false;
        this._compression = null;
        this._sphericalPolynomial = null;
        this._sphericalPolynomialPromise = null;
        this._sphericalPolynomialComputed = false;
        this._lodGenerationScale = 0;
        this._lodGenerationOffset = 0;
        this._useSRGBBuffer = false;
        this._lodTextureHigh = null;
        this._lodTextureMid = null;
        this._lodTextureLow = null;
        this._isRGBD = false;
        this._linearSpecularLOD = false;
        this._irradianceTexture = null;
        this._hardwareTexture = null;
        this._maxLodLevel = null;
        this._references = 1;
        this._gammaSpace = null;
        this._engine = engine;
        this._source = source;
        this._uniqueId = InternalTexture._Counter++;
        if (!delayAllocation) {
          this._hardwareTexture = engine._createHardwareTexture();
        }
      }
      incrementReferences() {
        this._references++;
      }
      updateSize(width, height, depth = 1) {
        this._engine.updateTextureDimensions(this, width, height, depth);
        this.width = width;
        this.height = height;
        this.depth = depth;
        this.baseWidth = width;
        this.baseHeight = height;
        this.baseDepth = depth;
        this._size = width * height * depth;
      }
      _rebuild() {
        var _a;
        this.isReady = false;
        this._cachedCoordinatesMode = null;
        this._cachedWrapU = null;
        this._cachedWrapV = null;
        this._cachedWrapR = null;
        this._cachedAnisotropicFilteringLevel = null;
        if (this.onRebuildCallback) {
          const data = this.onRebuildCallback(this);
          const swapAndSetIsReady = (proxyInternalTexture) => {
            proxyInternalTexture._swapAndDie(this, false);
            this.isReady = data.isReady;
          };
          if (data.isAsync) {
            data.proxy.then(swapAndSetIsReady);
          } else {
            swapAndSetIsReady(data.proxy);
          }
          return;
        }
        let proxy;
        switch (this.source) {
          case InternalTextureSource.Temp:
            break;
          case InternalTextureSource.Url:
            proxy = this._engine.createTexture(
              (_a = this._originalUrl) !== null && _a !== void 0 ? _a : this.url,
              !this.generateMipMaps,
              this.invertY,
              null,
              this.samplingMode,
              (temp) => {
                temp._swapAndDie(this, false);
                this.isReady = true;
              },
              null,
              this._buffer,
              void 0,
              this.format,
              this._extension,
              void 0,
              void 0,
              void 0,
              this._useSRGBBuffer
            );
            return;
          case InternalTextureSource.Raw:
            proxy = this._engine.createRawTexture(this._bufferView, this.baseWidth, this.baseHeight, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type, void 0, this._useSRGBBuffer);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.Raw3D:
            proxy = this._engine.createRawTexture3D(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.Raw2DArray:
            proxy = this._engine.createRawTexture2DArray(this._bufferView, this.baseWidth, this.baseHeight, this.baseDepth, this.format, this.generateMipMaps, this.invertY, this.samplingMode, this._compression, this.type);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.Dynamic:
            proxy = this._engine.createDynamicTexture(this.baseWidth, this.baseHeight, this.generateMipMaps, this.samplingMode);
            proxy._swapAndDie(this, false);
            this._engine.updateDynamicTexture(this, this._engine.getRenderingCanvas(), this.invertY, void 0, void 0, true);
            break;
          case InternalTextureSource.Cube:
            proxy = this._engine.createCubeTexture(this.url, null, this._files, !this.generateMipMaps, () => {
              proxy._swapAndDie(this, false);
              this.isReady = true;
            }, null, this.format, this._extension, false, 0, 0, null, void 0, this._useSRGBBuffer);
            return;
          case InternalTextureSource.CubeRaw:
            proxy = this._engine.createRawCubeTexture(this._bufferViewArray, this.width, this.format, this.type, this.generateMipMaps, this.invertY, this.samplingMode, this._compression);
            proxy._swapAndDie(this, false);
            this.isReady = true;
            break;
          case InternalTextureSource.CubeRawRGBD:
            return;
          case InternalTextureSource.CubePrefiltered:
            proxy = this._engine.createPrefilteredCubeTexture(this.url, null, this._lodGenerationScale, this._lodGenerationOffset, (proxy2) => {
              if (proxy2) {
                proxy2._swapAndDie(this, false);
              }
              this.isReady = true;
            }, null, this.format, this._extension);
            proxy._sphericalPolynomial = this._sphericalPolynomial;
            return;
        }
      }
      _swapAndDie(target, swapAll = true) {
        var _a;
        (_a = this._hardwareTexture) === null || _a === void 0 ? void 0 : _a.setUsage(target._source, this.generateMipMaps, this.isCube, this.width, this.height);
        target._hardwareTexture = this._hardwareTexture;
        if (swapAll) {
          target._isRGBD = this._isRGBD;
        }
        if (this._lodTextureHigh) {
          if (target._lodTextureHigh) {
            target._lodTextureHigh.dispose();
          }
          target._lodTextureHigh = this._lodTextureHigh;
        }
        if (this._lodTextureMid) {
          if (target._lodTextureMid) {
            target._lodTextureMid.dispose();
          }
          target._lodTextureMid = this._lodTextureMid;
        }
        if (this._lodTextureLow) {
          if (target._lodTextureLow) {
            target._lodTextureLow.dispose();
          }
          target._lodTextureLow = this._lodTextureLow;
        }
        if (this._irradianceTexture) {
          if (target._irradianceTexture) {
            target._irradianceTexture.dispose();
          }
          target._irradianceTexture = this._irradianceTexture;
        }
        const cache = this._engine.getLoadedTexturesCache();
        let index = cache.indexOf(this);
        if (index !== -1) {
          cache.splice(index, 1);
        }
        index = cache.indexOf(target);
        if (index === -1) {
          cache.push(target);
        }
      }
      dispose() {
        this._references--;
        this.onLoadedObservable.clear();
        this.onErrorObservable.clear();
        if (this._references === 0) {
          this._engine._releaseTexture(this);
          this._hardwareTexture = null;
        }
      }
    };
    InternalTexture._Counter = 0;
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js
var WebGLShaderProcessor;
var init_webGLShaderProcessors = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLShaderProcessors.js"() {
    init_shaderLanguage();
    WebGLShaderProcessor = class {
      constructor() {
        this.shaderLanguage = ShaderLanguage.GLSL;
      }
      postProcessor(code, defines, isFragment, processingContext, engine) {
        if (!engine.getCaps().drawBuffersExtension) {
          const regex = /#extension.+GL_EXT_draw_buffers.+(enable|require)/g;
          code = code.replace(regex, "");
        }
        return code;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js
var varyingRegex, WebGL2ShaderProcessor;
var init_webGL2ShaderProcessors = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGL2ShaderProcessors.js"() {
    init_shaderLanguage();
    varyingRegex = /(flat\s)?\s*varying\s*.*/;
    WebGL2ShaderProcessor = class {
      constructor() {
        this.shaderLanguage = ShaderLanguage.GLSL;
      }
      attributeProcessor(attribute) {
        return attribute.replace("attribute", "in");
      }
      varyingCheck(varying, _isFragment) {
        return varyingRegex.test(varying);
      }
      varyingProcessor(varying, isFragment) {
        return varying.replace("varying", isFragment ? "in" : "out");
      }
      postProcessor(code, defines, isFragment) {
        const hasDrawBuffersExtension = code.search(/#extension.+GL_EXT_draw_buffers.+require/) !== -1;
        const regex = /#extension.+(GL_OVR_multiview2|GL_OES_standard_derivatives|GL_EXT_shader_texture_lod|GL_EXT_frag_depth|GL_EXT_draw_buffers).+(enable|require)/g;
        code = code.replace(regex, "");
        code = code.replace(/texture2D\s*\(/g, "texture(");
        if (isFragment) {
          const hasOutput = code.search(/layout *\(location *= *0\) *out/g) !== -1;
          code = code.replace(/texture2DLodEXT\s*\(/g, "textureLod(");
          code = code.replace(/textureCubeLodEXT\s*\(/g, "textureLod(");
          code = code.replace(/textureCube\s*\(/g, "texture(");
          code = code.replace(/gl_FragDepthEXT/g, "gl_FragDepth");
          code = code.replace(/gl_FragColor/g, "glFragColor");
          code = code.replace(/gl_FragData/g, "glFragData");
          code = code.replace(/void\s+?main\s*\(/g, (hasDrawBuffersExtension || hasOutput ? "" : "layout(location = 0) out vec4 glFragColor;\n") + "void main(");
        } else {
          const hasMultiviewExtension = defines.indexOf("#define MULTIVIEW") !== -1;
          if (hasMultiviewExtension) {
            return "#extension GL_OVR_multiview2 : require\nlayout (num_views = 2) in;\n" + code;
          }
        }
        return code;
      }
    };
  }
});

// node_modules/@babylonjs/core/Buffers/dataBuffer.js
var DataBuffer;
var init_dataBuffer = __esm({
  "node_modules/@babylonjs/core/Buffers/dataBuffer.js"() {
    DataBuffer = class {
      get underlyingResource() {
        return null;
      }
      constructor() {
        this.references = 0;
        this.capacity = 0;
        this.is32Bits = false;
        this.uniqueId = DataBuffer._Counter++;
      }
    };
    DataBuffer._Counter = 0;
  }
});

// node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js
var WebGLDataBuffer;
var init_webGLDataBuffer = __esm({
  "node_modules/@babylonjs/core/Meshes/WebGL/webGLDataBuffer.js"() {
    init_dataBuffer();
    WebGLDataBuffer = class extends DataBuffer {
      constructor(resource) {
        super();
        this._buffer = resource;
      }
      get underlyingResource() {
        return this._buffer;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js
var WebGLPipelineContext;
var init_webGLPipelineContext = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLPipelineContext.js"() {
    WebGLPipelineContext = class {
      constructor() {
        this._valueCache = {};
        this.vertexCompilationError = null;
        this.fragmentCompilationError = null;
        this.programLinkError = null;
        this.programValidationError = null;
        this._isDisposed = false;
      }
      get isAsync() {
        return this.isParallelCompiled;
      }
      get isReady() {
        if (this.program) {
          if (this.isParallelCompiled) {
            return this.engine._isRenderingStateCompiled(this);
          }
          return true;
        }
        return false;
      }
      _handlesSpectorRebuildCallback(onCompiled) {
        if (onCompiled && this.program) {
          onCompiled(this.program);
        }
      }
      _fillEffectInformation(effect, uniformBuffersNames, uniformsNames, uniforms, samplerList, samplers, attributesNames, attributes) {
        const engine = this.engine;
        if (engine.supportsUniformBuffers) {
          for (const name in uniformBuffersNames) {
            effect.bindUniformBlock(name, uniformBuffersNames[name]);
          }
        }
        const effectAvailableUniforms = this.engine.getUniforms(this, uniformsNames);
        effectAvailableUniforms.forEach((uniform, index2) => {
          uniforms[uniformsNames[index2]] = uniform;
        });
        this._uniforms = uniforms;
        let index;
        for (index = 0; index < samplerList.length; index++) {
          const sampler = effect.getUniform(samplerList[index]);
          if (sampler == null) {
            samplerList.splice(index, 1);
            index--;
          }
        }
        samplerList.forEach((name, index2) => {
          samplers[name] = index2;
        });
        for (const attr of engine.getAttributes(this, attributesNames)) {
          attributes.push(attr);
        }
      }
      dispose() {
        this._uniforms = {};
        this._isDisposed = true;
      }
      _cacheMatrix(uniformName, matrix) {
        const cache = this._valueCache[uniformName];
        const flag = matrix.updateFlag;
        if (cache !== void 0 && cache === flag) {
          return false;
        }
        this._valueCache[uniformName] = flag;
        return true;
      }
      _cacheFloat2(uniformName, x, y) {
        let cache = this._valueCache[uniformName];
        if (!cache || cache.length !== 2) {
          cache = [x, y];
          this._valueCache[uniformName] = cache;
          return true;
        }
        let changed = false;
        if (cache[0] !== x) {
          cache[0] = x;
          changed = true;
        }
        if (cache[1] !== y) {
          cache[1] = y;
          changed = true;
        }
        return changed;
      }
      _cacheFloat3(uniformName, x, y, z) {
        let cache = this._valueCache[uniformName];
        if (!cache || cache.length !== 3) {
          cache = [x, y, z];
          this._valueCache[uniformName] = cache;
          return true;
        }
        let changed = false;
        if (cache[0] !== x) {
          cache[0] = x;
          changed = true;
        }
        if (cache[1] !== y) {
          cache[1] = y;
          changed = true;
        }
        if (cache[2] !== z) {
          cache[2] = z;
          changed = true;
        }
        return changed;
      }
      _cacheFloat4(uniformName, x, y, z, w) {
        let cache = this._valueCache[uniformName];
        if (!cache || cache.length !== 4) {
          cache = [x, y, z, w];
          this._valueCache[uniformName] = cache;
          return true;
        }
        let changed = false;
        if (cache[0] !== x) {
          cache[0] = x;
          changed = true;
        }
        if (cache[1] !== y) {
          cache[1] = y;
          changed = true;
        }
        if (cache[2] !== z) {
          cache[2] = z;
          changed = true;
        }
        if (cache[3] !== w) {
          cache[3] = w;
          changed = true;
        }
        return changed;
      }
      setInt(uniformName, value) {
        const cache = this._valueCache[uniformName];
        if (cache !== void 0 && cache === value) {
          return;
        }
        if (this.engine.setInt(this._uniforms[uniformName], value)) {
          this._valueCache[uniformName] = value;
        }
      }
      setInt2(uniformName, x, y) {
        if (this._cacheFloat2(uniformName, x, y)) {
          if (!this.engine.setInt2(this._uniforms[uniformName], x, y)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setInt3(uniformName, x, y, z) {
        if (this._cacheFloat3(uniformName, x, y, z)) {
          if (!this.engine.setInt3(this._uniforms[uniformName], x, y, z)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setInt4(uniformName, x, y, z, w) {
        if (this._cacheFloat4(uniformName, x, y, z, w)) {
          if (!this.engine.setInt4(this._uniforms[uniformName], x, y, z, w)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setIntArray(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray(this._uniforms[uniformName], array);
      }
      setIntArray2(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray2(this._uniforms[uniformName], array);
      }
      setIntArray3(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray3(this._uniforms[uniformName], array);
      }
      setIntArray4(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setIntArray4(this._uniforms[uniformName], array);
      }
      setUInt(uniformName, value) {
        const cache = this._valueCache[uniformName];
        if (cache !== void 0 && cache === value) {
          return;
        }
        if (this.engine.setUInt(this._uniforms[uniformName], value)) {
          this._valueCache[uniformName] = value;
        }
      }
      setUInt2(uniformName, x, y) {
        if (this._cacheFloat2(uniformName, x, y)) {
          if (!this.engine.setUInt2(this._uniforms[uniformName], x, y)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setUInt3(uniformName, x, y, z) {
        if (this._cacheFloat3(uniformName, x, y, z)) {
          if (!this.engine.setUInt3(this._uniforms[uniformName], x, y, z)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setUInt4(uniformName, x, y, z, w) {
        if (this._cacheFloat4(uniformName, x, y, z, w)) {
          if (!this.engine.setUInt4(this._uniforms[uniformName], x, y, z, w)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setUIntArray(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setUIntArray(this._uniforms[uniformName], array);
      }
      setUIntArray2(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setUIntArray2(this._uniforms[uniformName], array);
      }
      setUIntArray3(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setUIntArray3(this._uniforms[uniformName], array);
      }
      setUIntArray4(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setUIntArray4(this._uniforms[uniformName], array);
      }
      setArray(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray(this._uniforms[uniformName], array);
      }
      setArray2(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray2(this._uniforms[uniformName], array);
      }
      setArray3(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray3(this._uniforms[uniformName], array);
      }
      setArray4(uniformName, array) {
        this._valueCache[uniformName] = null;
        this.engine.setArray4(this._uniforms[uniformName], array);
      }
      setMatrices(uniformName, matrices) {
        if (!matrices) {
          return;
        }
        this._valueCache[uniformName] = null;
        this.engine.setMatrices(this._uniforms[uniformName], matrices);
      }
      setMatrix(uniformName, matrix) {
        if (this._cacheMatrix(uniformName, matrix)) {
          if (!this.engine.setMatrices(this._uniforms[uniformName], matrix.toArray())) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setMatrix3x3(uniformName, matrix) {
        this._valueCache[uniformName] = null;
        this.engine.setMatrix3x3(this._uniforms[uniformName], matrix);
      }
      setMatrix2x2(uniformName, matrix) {
        this._valueCache[uniformName] = null;
        this.engine.setMatrix2x2(this._uniforms[uniformName], matrix);
      }
      setFloat(uniformName, value) {
        const cache = this._valueCache[uniformName];
        if (cache !== void 0 && cache === value) {
          return;
        }
        if (this.engine.setFloat(this._uniforms[uniformName], value)) {
          this._valueCache[uniformName] = value;
        }
      }
      setVector2(uniformName, vector2) {
        if (this._cacheFloat2(uniformName, vector2.x, vector2.y)) {
          if (!this.engine.setFloat2(this._uniforms[uniformName], vector2.x, vector2.y)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setFloat2(uniformName, x, y) {
        if (this._cacheFloat2(uniformName, x, y)) {
          if (!this.engine.setFloat2(this._uniforms[uniformName], x, y)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setVector3(uniformName, vector3) {
        if (this._cacheFloat3(uniformName, vector3.x, vector3.y, vector3.z)) {
          if (!this.engine.setFloat3(this._uniforms[uniformName], vector3.x, vector3.y, vector3.z)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setFloat3(uniformName, x, y, z) {
        if (this._cacheFloat3(uniformName, x, y, z)) {
          if (!this.engine.setFloat3(this._uniforms[uniformName], x, y, z)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setVector4(uniformName, vector4) {
        if (this._cacheFloat4(uniformName, vector4.x, vector4.y, vector4.z, vector4.w)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], vector4.x, vector4.y, vector4.z, vector4.w)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setQuaternion(uniformName, quaternion) {
        if (this._cacheFloat4(uniformName, quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], quaternion.x, quaternion.y, quaternion.z, quaternion.w)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setFloat4(uniformName, x, y, z, w) {
        if (this._cacheFloat4(uniformName, x, y, z, w)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], x, y, z, w)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setColor3(uniformName, color3) {
        if (this._cacheFloat3(uniformName, color3.r, color3.g, color3.b)) {
          if (!this.engine.setFloat3(this._uniforms[uniformName], color3.r, color3.g, color3.b)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setColor4(uniformName, color3, alpha) {
        if (this._cacheFloat4(uniformName, color3.r, color3.g, color3.b, alpha)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], color3.r, color3.g, color3.b, alpha)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      setDirectColor4(uniformName, color4) {
        if (this._cacheFloat4(uniformName, color4.r, color4.g, color4.b, color4.a)) {
          if (!this.engine.setFloat4(this._uniforms[uniformName], color4.r, color4.g, color4.b, color4.a)) {
            this._valueCache[uniformName] = null;
          }
        }
      }
      _getVertexShaderCode() {
        return this.vertexShader ? this.engine._getShaderSource(this.vertexShader) : null;
      }
      _getFragmentShaderCode() {
        return this.fragmentShader ? this.engine._getShaderSource(this.fragmentShader) : null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js
var WebGLHardwareTexture;
var init_webGLHardwareTexture = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLHardwareTexture.js"() {
    WebGLHardwareTexture = class {
      get underlyingResource() {
        return this._webGLTexture;
      }
      constructor(existingTexture = null, context) {
        this._MSAARenderBuffers = null;
        this._context = context;
        if (!existingTexture) {
          existingTexture = context.createTexture();
          if (!existingTexture) {
            throw new Error("Unable to create webGL texture");
          }
        }
        this.set(existingTexture);
      }
      setUsage() {
      }
      set(hardwareTexture) {
        this._webGLTexture = hardwareTexture;
      }
      reset() {
        this._webGLTexture = null;
        this._MSAARenderBuffers = null;
      }
      addMSAARenderBuffer(buffer) {
        if (!this._MSAARenderBuffers) {
          this._MSAARenderBuffers = [];
        }
        this._MSAARenderBuffers.push(buffer);
      }
      releaseMSAARenderBuffers() {
        if (this._MSAARenderBuffers) {
          for (const buffer of this._MSAARenderBuffers) {
            this._context.deleteRenderbuffer(buffer);
          }
          this._MSAARenderBuffers = null;
        }
      }
      getMSAARenderBuffer(index = 0) {
        var _a, _b;
        return (_b = (_a = this._MSAARenderBuffers) === null || _a === void 0 ? void 0 : _a[index]) !== null && _b !== void 0 ? _b : null;
      }
      release() {
        this.releaseMSAARenderBuffers();
        if (this._webGLTexture) {
          this._context.deleteTexture(this._webGLTexture);
        }
        this.reset();
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/drawWrapper.js
var DrawWrapper;
var init_drawWrapper = __esm({
  "node_modules/@babylonjs/core/Materials/drawWrapper.js"() {
    DrawWrapper = class {
      static IsWrapper(effect) {
        return effect.getPipelineContext === void 0;
      }
      static GetEffect(effect) {
        return effect.getPipelineContext === void 0 ? effect.effect : effect;
      }
      constructor(engine, createMaterialContext = true) {
        this.effect = null;
        this.defines = null;
        this.drawContext = engine.createDrawContext();
        if (createMaterialContext) {
          this.materialContext = engine.createMaterialContext();
        }
      }
      setEffect(effect, defines, resetContext = true) {
        var _a;
        this.effect = effect;
        if (defines !== void 0) {
          this.defines = defines;
        }
        if (resetContext) {
          (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.reset();
        }
      }
      dispose() {
        var _a;
        (_a = this.drawContext) === null || _a === void 0 ? void 0 : _a.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/States/stencilStateComposer.js
var StencilStateComposer;
var init_stencilStateComposer = __esm({
  "node_modules/@babylonjs/core/States/stencilStateComposer.js"() {
    StencilStateComposer = class {
      get isDirty() {
        return this._isStencilTestDirty || this._isStencilMaskDirty || this._isStencilFuncDirty || this._isStencilOpDirty;
      }
      get func() {
        return this._func;
      }
      set func(value) {
        if (this._func === value) {
          return;
        }
        this._func = value;
        this._isStencilFuncDirty = true;
      }
      get funcRef() {
        return this._funcRef;
      }
      set funcRef(value) {
        if (this._funcRef === value) {
          return;
        }
        this._funcRef = value;
        this._isStencilFuncDirty = true;
      }
      get funcMask() {
        return this._funcMask;
      }
      set funcMask(value) {
        if (this._funcMask === value) {
          return;
        }
        this._funcMask = value;
        this._isStencilFuncDirty = true;
      }
      get opStencilFail() {
        return this._opStencilFail;
      }
      set opStencilFail(value) {
        if (this._opStencilFail === value) {
          return;
        }
        this._opStencilFail = value;
        this._isStencilOpDirty = true;
      }
      get opDepthFail() {
        return this._opDepthFail;
      }
      set opDepthFail(value) {
        if (this._opDepthFail === value) {
          return;
        }
        this._opDepthFail = value;
        this._isStencilOpDirty = true;
      }
      get opStencilDepthPass() {
        return this._opStencilDepthPass;
      }
      set opStencilDepthPass(value) {
        if (this._opStencilDepthPass === value) {
          return;
        }
        this._opStencilDepthPass = value;
        this._isStencilOpDirty = true;
      }
      get mask() {
        return this._mask;
      }
      set mask(value) {
        if (this._mask === value) {
          return;
        }
        this._mask = value;
        this._isStencilMaskDirty = true;
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(value) {
        if (this._enabled === value) {
          return;
        }
        this._enabled = value;
        this._isStencilTestDirty = true;
      }
      constructor(reset = true) {
        this._isStencilTestDirty = false;
        this._isStencilMaskDirty = false;
        this._isStencilFuncDirty = false;
        this._isStencilOpDirty = false;
        this.useStencilGlobalOnly = false;
        if (reset) {
          this.reset();
        }
      }
      reset() {
        var _a;
        this.stencilMaterial = void 0;
        (_a = this.stencilGlobal) === null || _a === void 0 ? void 0 : _a.reset();
        this._isStencilTestDirty = true;
        this._isStencilMaskDirty = true;
        this._isStencilFuncDirty = true;
        this._isStencilOpDirty = true;
      }
      apply(gl) {
        var _a;
        if (!gl) {
          return;
        }
        const stencilMaterialEnabled = !this.useStencilGlobalOnly && !!((_a = this.stencilMaterial) === null || _a === void 0 ? void 0 : _a.enabled);
        this.enabled = stencilMaterialEnabled ? this.stencilMaterial.enabled : this.stencilGlobal.enabled;
        this.func = stencilMaterialEnabled ? this.stencilMaterial.func : this.stencilGlobal.func;
        this.funcRef = stencilMaterialEnabled ? this.stencilMaterial.funcRef : this.stencilGlobal.funcRef;
        this.funcMask = stencilMaterialEnabled ? this.stencilMaterial.funcMask : this.stencilGlobal.funcMask;
        this.opStencilFail = stencilMaterialEnabled ? this.stencilMaterial.opStencilFail : this.stencilGlobal.opStencilFail;
        this.opDepthFail = stencilMaterialEnabled ? this.stencilMaterial.opDepthFail : this.stencilGlobal.opDepthFail;
        this.opStencilDepthPass = stencilMaterialEnabled ? this.stencilMaterial.opStencilDepthPass : this.stencilGlobal.opStencilDepthPass;
        this.mask = stencilMaterialEnabled ? this.stencilMaterial.mask : this.stencilGlobal.mask;
        if (!this.isDirty) {
          return;
        }
        if (this._isStencilTestDirty) {
          if (this.enabled) {
            gl.enable(gl.STENCIL_TEST);
          } else {
            gl.disable(gl.STENCIL_TEST);
          }
          this._isStencilTestDirty = false;
        }
        if (this._isStencilMaskDirty) {
          gl.stencilMask(this.mask);
          this._isStencilMaskDirty = false;
        }
        if (this._isStencilFuncDirty) {
          gl.stencilFunc(this.func, this.funcRef, this.funcMask);
          this._isStencilFuncDirty = false;
        }
        if (this._isStencilOpDirty) {
          gl.stencilOp(this.opStencilFail, this.opDepthFail, this.opStencilDepthPass);
          this._isStencilOpDirty = false;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/thinEngine.js
var BufferPointer, ThinEngine;
var init_thinEngine = __esm({
  "node_modules/@babylonjs/core/Engines/thinEngine.js"() {
    init_engineStore();
    init_effect();
    init_devTools();
    init_observable();
    init_depthCullingState();
    init_stencilState();
    init_alphaCullingState();
    init_internalTexture();
    init_logger();
    init_domManagement();
    init_webGLShaderProcessors();
    init_webGL2ShaderProcessors();
    init_webGLDataBuffer();
    init_webGLPipelineContext();
    init_performanceConfigurator();
    init_webGLHardwareTexture();
    init_drawWrapper();
    init_stencilStateComposer();
    init_shaderLanguage();
    init_precisionDate();
    BufferPointer = class {
    };
    ThinEngine = class {
      static get NpmPackage() {
        return "babylonjs@6.21.0";
      }
      static get Version() {
        return "6.21.0";
      }
      get description() {
        let description = this.name + this.webGLVersion;
        if (this._caps.parallelShaderCompile) {
          description += " - Parallel shader compilation";
        }
        return description;
      }
      get name() {
        return this._name;
      }
      set name(value) {
        this._name = value;
      }
      get version() {
        return this._webGLVersion;
      }
      get isDisposed() {
        return this._isDisposed;
      }
      static get ShadersRepository() {
        return Effect.ShadersRepository;
      }
      static set ShadersRepository(value) {
        Effect.ShadersRepository = value;
      }
      _getShaderProcessor(shaderLanguage) {
        return this._shaderProcessor;
      }
      get useReverseDepthBuffer() {
        return this._useReverseDepthBuffer;
      }
      set useReverseDepthBuffer(useReverse) {
        if (useReverse === this._useReverseDepthBuffer) {
          return;
        }
        this._useReverseDepthBuffer = useReverse;
        if (useReverse) {
          this._depthCullingState.depthFunc = 518;
        } else {
          this._depthCullingState.depthFunc = 515;
        }
      }
      get frameId() {
        return this._frameId;
      }
      get supportsUniformBuffers() {
        return this.webGLVersion > 1 && !this.disableUniformBuffers;
      }
      getCreationOptions() {
        return this._creationOptions;
      }
      get _shouldUseHighPrecisionShader() {
        return !!(this._caps.highPrecisionShaderSupported && this._highPrecisionShadersAllowed);
      }
      get needPOTTextures() {
        return this._webGLVersion < 2 || this.forcePOTTextures;
      }
      get activeRenderLoops() {
        return this._activeRenderLoops;
      }
      get doNotHandleContextLost() {
        return this._doNotHandleContextLost;
      }
      set doNotHandleContextLost(value) {
        this._doNotHandleContextLost = value;
      }
      get _supportsHardwareTextureRescaling() {
        return false;
      }
      set framebufferDimensionsObject(dimensions) {
        this._framebufferDimensionsObject = dimensions;
      }
      get currentViewport() {
        return this._cachedViewport;
      }
      get emptyTexture() {
        if (!this._emptyTexture) {
          this._emptyTexture = this.createRawTexture(new Uint8Array(4), 1, 1, 5, false, false, 1);
        }
        return this._emptyTexture;
      }
      get emptyTexture3D() {
        if (!this._emptyTexture3D) {
          this._emptyTexture3D = this.createRawTexture3D(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
        }
        return this._emptyTexture3D;
      }
      get emptyTexture2DArray() {
        if (!this._emptyTexture2DArray) {
          this._emptyTexture2DArray = this.createRawTexture2DArray(new Uint8Array(4), 1, 1, 1, 5, false, false, 1);
        }
        return this._emptyTexture2DArray;
      }
      get emptyCubeTexture() {
        if (!this._emptyCubeTexture) {
          const faceData = new Uint8Array(4);
          const cubeData = [faceData, faceData, faceData, faceData, faceData, faceData];
          this._emptyCubeTexture = this.createRawCubeTexture(cubeData, 1, 5, 0, false, false, 1);
        }
        return this._emptyCubeTexture;
      }
      get isWebGPU() {
        return this._isWebGPU;
      }
      get shaderPlatformName() {
        return this._shaderPlatformName;
      }
      get snapshotRendering() {
        return false;
      }
      set snapshotRendering(activate) {
      }
      get snapshotRenderingMode() {
        return this._snapshotRenderingMode;
      }
      set snapshotRenderingMode(mode) {
        this._snapshotRenderingMode = mode;
      }
      snapshotRenderingReset() {
        this.snapshotRendering = false;
      }
      static _CreateCanvas(width, height) {
        if (typeof document === "undefined") {
          return new OffscreenCanvas(width, height);
        }
        const canvas = document.createElement("canvas");
        canvas.width = width;
        canvas.height = height;
        return canvas;
      }
      createCanvas(width, height) {
        return ThinEngine._CreateCanvas(width, height);
      }
      createCanvasImage() {
        return document.createElement("img");
      }
      constructor(canvasOrContext, antialias, options, adaptToDeviceRatio) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        this._name = "WebGL";
        this._isDisposed = false;
        this.forcePOTTextures = false;
        this.isFullscreen = false;
        this.cullBackFaces = null;
        this.renderEvenInBackground = true;
        this.preventCacheWipeBetweenFrames = false;
        this.validateShaderPrograms = false;
        this._useReverseDepthBuffer = false;
        this.isNDCHalfZRange = false;
        this.hasOriginBottomLeft = true;
        this.disableUniformBuffers = false;
        this.onDisposeObservable = new Observable();
        this._frameId = 0;
        this._uniformBuffers = new Array();
        this._storageBuffers = new Array();
        this._webGLVersion = 1;
        this._windowIsBackground = false;
        this._highPrecisionShadersAllowed = true;
        this._badOS = false;
        this._badDesktopOS = false;
        this._renderingQueueLaunched = false;
        this._activeRenderLoops = new Array();
        this.onContextLostObservable = new Observable();
        this.onContextRestoredObservable = new Observable();
        this._contextWasLost = false;
        this._doNotHandleContextLost = false;
        this.disableVertexArrayObjects = false;
        this._colorWrite = true;
        this._colorWriteChanged = true;
        this._depthCullingState = new DepthCullingState();
        this._stencilStateComposer = new StencilStateComposer();
        this._stencilState = new StencilState();
        this._alphaState = new AlphaState();
        this._alphaMode = 1;
        this._alphaEquation = 0;
        this._internalTexturesCache = new Array();
        this._renderTargetWrapperCache = new Array();
        this._activeChannel = 0;
        this._currentTextureChannel = -1;
        this._boundTexturesCache = {};
        this._compiledEffects = {};
        this._vertexAttribArraysEnabled = [];
        this._uintIndicesCurrentlySet = false;
        this._currentBoundBuffer = new Array();
        this._currentFramebuffer = null;
        this._dummyFramebuffer = null;
        this._currentBufferPointers = new Array();
        this._currentInstanceLocations = new Array();
        this._currentInstanceBuffers = new Array();
        this._vaoRecordInProgress = false;
        this._mustWipeVertexAttributes = false;
        this._nextFreeTextureSlots = new Array();
        this._maxSimultaneousTextures = 0;
        this._maxMSAASamplesOverride = null;
        this._activeRequests = new Array();
        this.adaptToDeviceRatio = false;
        this._lastDevicePixelRatio = 1;
        this._transformTextureUrl = null;
        this.hostInformation = {
          isMobile: false
        };
        this.premultipliedAlpha = true;
        this.onBeforeTextureInitObservable = new Observable();
        this._isWebGPU = false;
        this._snapshotRenderingMode = 0;
        this._viewportCached = { x: 0, y: 0, z: 0, w: 0 };
        this._unpackFlipYCached = null;
        this.enableUnpackFlipYCached = true;
        this._boundUniforms = {};
        this.startTime = PrecisionDate.Now;
        let canvas = null;
        options = options || {};
        this._creationOptions = options;
        this.adaptToDeviceRatio = adaptToDeviceRatio !== null && adaptToDeviceRatio !== void 0 ? adaptToDeviceRatio : false;
        this._stencilStateComposer.stencilGlobal = this._stencilState;
        PerformanceConfigurator.SetMatrixPrecision(!!options.useHighPrecisionMatrix);
        options.antialias = antialias !== null && antialias !== void 0 ? antialias : options.antialias;
        options.deterministicLockstep = (_a = options.deterministicLockstep) !== null && _a !== void 0 ? _a : false;
        options.lockstepMaxSteps = (_b = options.lockstepMaxSteps) !== null && _b !== void 0 ? _b : 4;
        options.timeStep = (_c = options.timeStep) !== null && _c !== void 0 ? _c : 1 / 60;
        options.audioEngine = (_d = options.audioEngine) !== null && _d !== void 0 ? _d : true;
        options.stencil = (_e = options.stencil) !== null && _e !== void 0 ? _e : true;
        this._audioContext = (_g = (_f = options.audioEngineOptions) === null || _f === void 0 ? void 0 : _f.audioContext) !== null && _g !== void 0 ? _g : null;
        this._audioDestination = (_j = (_h = options.audioEngineOptions) === null || _h === void 0 ? void 0 : _h.audioDestination) !== null && _j !== void 0 ? _j : null;
        this.premultipliedAlpha = (_k = options.premultipliedAlpha) !== null && _k !== void 0 ? _k : true;
        this.useExactSrgbConversions = (_l = options.useExactSrgbConversions) !== null && _l !== void 0 ? _l : false;
        this._doNotHandleContextLost = !!options.doNotHandleContextLost;
        this._isStencilEnable = options.stencil ? true : false;
        adaptToDeviceRatio = adaptToDeviceRatio || options.adaptToDeviceRatio || false;
        const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
        const limitDeviceRatio = options.limitDeviceRatio || devicePixelRatio;
        this._hardwareScalingLevel = adaptToDeviceRatio ? 1 / Math.min(limitDeviceRatio, devicePixelRatio) : 1;
        this._lastDevicePixelRatio = devicePixelRatio;
        if (!canvasOrContext) {
          return;
        }
        if (canvasOrContext.getContext) {
          canvas = canvasOrContext;
          this._renderingCanvas = canvas;
          if (options.preserveDrawingBuffer === void 0) {
            options.preserveDrawingBuffer = false;
          }
          if (options.xrCompatible === void 0) {
            options.xrCompatible = true;
          }
          if (navigator && navigator.userAgent) {
            this._setupMobileChecks();
            const ua = navigator.userAgent;
            for (const exception of ThinEngine.ExceptionList) {
              const key = exception.key;
              const targets = exception.targets;
              const check = new RegExp(key);
              if (check.test(ua)) {
                if (exception.capture && exception.captureConstraint) {
                  const capture = exception.capture;
                  const constraint = exception.captureConstraint;
                  const regex = new RegExp(capture);
                  const matches = regex.exec(ua);
                  if (matches && matches.length > 0) {
                    const capturedValue = parseInt(matches[matches.length - 1]);
                    if (capturedValue >= constraint) {
                      continue;
                    }
                  }
                }
                for (const target of targets) {
                  switch (target) {
                    case "uniformBuffer":
                      this.disableUniformBuffers = true;
                      break;
                    case "vao":
                      this.disableVertexArrayObjects = true;
                      break;
                    case "antialias":
                      options.antialias = false;
                      break;
                    case "maxMSAASamples":
                      this._maxMSAASamplesOverride = 1;
                      break;
                  }
                }
              }
            }
          }
          if (!this._doNotHandleContextLost) {
            this._onContextLost = (evt) => {
              evt.preventDefault();
              this._contextWasLost = true;
              Logger.Warn("WebGL context lost.");
              this.onContextLostObservable.notifyObservers(this);
            };
            this._onContextRestored = () => {
              this._restoreEngineAfterContextLost(this._initGLContext.bind(this));
            };
            canvas.addEventListener("webglcontextlost", this._onContextLost, false);
            canvas.addEventListener("webglcontextrestored", this._onContextRestored, false);
            options.powerPreference = options.powerPreference || "high-performance";
          }
          this._badDesktopOS = /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
          if (this._badDesktopOS) {
            options.xrCompatible = false;
          }
          if (!options.disableWebGL2Support) {
            try {
              this._gl = canvas.getContext("webgl2", options) || canvas.getContext("experimental-webgl2", options);
              if (this._gl) {
                this._webGLVersion = 2;
                this._shaderPlatformName = "WEBGL2";
                if (!this._gl.deleteQuery) {
                  this._webGLVersion = 1;
                  this._shaderPlatformName = "WEBGL1";
                }
              }
            } catch (e) {
            }
          }
          if (!this._gl) {
            if (!canvas) {
              throw new Error("The provided canvas is null or undefined.");
            }
            try {
              this._gl = canvas.getContext("webgl", options) || canvas.getContext("experimental-webgl", options);
            } catch (e) {
              throw new Error("WebGL not supported");
            }
          }
          if (!this._gl) {
            throw new Error("WebGL not supported");
          }
        } else {
          this._gl = canvasOrContext;
          this._renderingCanvas = this._gl.canvas;
          if (this._gl.renderbufferStorageMultisample) {
            this._webGLVersion = 2;
            this._shaderPlatformName = "WEBGL2";
          } else {
            this._shaderPlatformName = "WEBGL1";
          }
          const attributes = this._gl.getContextAttributes();
          if (attributes) {
            options.stencil = attributes.stencil;
          }
        }
        this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
        if (options.useHighPrecisionFloats !== void 0) {
          this._highPrecisionShadersAllowed = options.useHighPrecisionFloats;
        }
        this.resize();
        this._initGLContext();
        this._initFeatures();
        for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
          this._currentBufferPointers[i] = new BufferPointer();
        }
        this._shaderProcessor = this.webGLVersion > 1 ? new WebGL2ShaderProcessor() : new WebGLShaderProcessor();
        this._badOS = /iPad/i.test(navigator.userAgent) || /iPhone/i.test(navigator.userAgent);
        const versionToLog = `Babylon.js v${ThinEngine.Version}`;
        console.log(versionToLog + ` - ${this.description}`);
        if (this._renderingCanvas && this._renderingCanvas.setAttribute) {
          this._renderingCanvas.setAttribute("data-engine", versionToLog);
        }
      }
      _setupMobileChecks() {
        if (!(navigator && navigator.userAgent)) {
          return;
        }
        this._checkForMobile = () => {
          const currentUA = navigator.userAgent;
          this.hostInformation.isMobile = currentUA.indexOf("Mobile") !== -1 || currentUA.indexOf("Mac") !== -1 && IsDocumentAvailable() && "ontouchend" in document;
        };
        this._checkForMobile();
        if (IsWindowObjectExist()) {
          window.addEventListener("resize", this._checkForMobile);
        }
      }
      _restoreEngineAfterContextLost(initEngine) {
        setTimeout(async () => {
          var _a;
          this._dummyFramebuffer = null;
          const depthTest = this._depthCullingState.depthTest;
          const depthFunc = this._depthCullingState.depthFunc;
          const depthMask = this._depthCullingState.depthMask;
          const stencilTest = this._stencilState.stencilTest;
          await initEngine();
          this.wipeCaches(true);
          this._rebuildEffects();
          (_a = this._rebuildComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
          this._rebuildBuffers();
          this._rebuildInternalTextures();
          this._rebuildRenderTargetWrappers();
          this.wipeCaches(true);
          this._depthCullingState.depthTest = depthTest;
          this._depthCullingState.depthFunc = depthFunc;
          this._depthCullingState.depthMask = depthMask;
          this._stencilState.stencilTest = stencilTest;
          Logger.Warn(this.name + " context successfully restored.");
          this.onContextRestoredObservable.notifyObservers(this);
          this._contextWasLost = false;
        }, 0);
      }
      _sharedInit(canvas) {
        this._renderingCanvas = canvas;
      }
      _getShaderProcessingContext(shaderLanguage) {
        return null;
      }
      _rebuildInternalTextures() {
        const currentState = this._internalTexturesCache.slice();
        for (const internalTexture of currentState) {
          internalTexture._rebuild();
        }
      }
      _rebuildRenderTargetWrappers() {
        const currentState = this._renderTargetWrapperCache.slice();
        for (const renderTargetWrapper of currentState) {
          renderTargetWrapper._rebuild();
        }
      }
      _rebuildEffects() {
        for (const key in this._compiledEffects) {
          const effect = this._compiledEffects[key];
          effect._pipelineContext = null;
          effect._wasPreviouslyReady = false;
          effect._prepareEffect();
        }
        Effect.ResetCache();
      }
      areAllEffectsReady() {
        for (const key in this._compiledEffects) {
          const effect = this._compiledEffects[key];
          if (!effect.isReady()) {
            return false;
          }
        }
        return true;
      }
      _rebuildBuffers() {
        for (const uniformBuffer of this._uniformBuffers) {
          uniformBuffer._rebuild();
        }
        for (const storageBuffer of this._storageBuffers) {
          storageBuffer._rebuild();
        }
      }
      _initGLContext() {
        var _a;
        this._caps = {
          maxTexturesImageUnits: this._gl.getParameter(this._gl.MAX_TEXTURE_IMAGE_UNITS),
          maxCombinedTexturesImageUnits: this._gl.getParameter(this._gl.MAX_COMBINED_TEXTURE_IMAGE_UNITS),
          maxVertexTextureImageUnits: this._gl.getParameter(this._gl.MAX_VERTEX_TEXTURE_IMAGE_UNITS),
          maxTextureSize: this._gl.getParameter(this._gl.MAX_TEXTURE_SIZE),
          maxSamples: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_SAMPLES) : 1,
          maxCubemapTextureSize: this._gl.getParameter(this._gl.MAX_CUBE_MAP_TEXTURE_SIZE),
          maxRenderTextureSize: this._gl.getParameter(this._gl.MAX_RENDERBUFFER_SIZE),
          maxVertexAttribs: this._gl.getParameter(this._gl.MAX_VERTEX_ATTRIBS),
          maxVaryingVectors: this._gl.getParameter(this._gl.MAX_VARYING_VECTORS),
          maxFragmentUniformVectors: this._gl.getParameter(this._gl.MAX_FRAGMENT_UNIFORM_VECTORS),
          maxVertexUniformVectors: this._gl.getParameter(this._gl.MAX_VERTEX_UNIFORM_VECTORS),
          parallelShaderCompile: this._gl.getExtension("KHR_parallel_shader_compile") || void 0,
          standardDerivatives: this._webGLVersion > 1 || this._gl.getExtension("OES_standard_derivatives") !== null,
          maxAnisotropy: 1,
          astc: this._gl.getExtension("WEBGL_compressed_texture_astc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_astc"),
          bptc: this._gl.getExtension("EXT_texture_compression_bptc") || this._gl.getExtension("WEBKIT_EXT_texture_compression_bptc"),
          s3tc: this._gl.getExtension("WEBGL_compressed_texture_s3tc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc"),
          s3tc_srgb: this._gl.getExtension("WEBGL_compressed_texture_s3tc_srgb") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_s3tc_srgb"),
          pvrtc: this._gl.getExtension("WEBGL_compressed_texture_pvrtc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_pvrtc"),
          etc1: this._gl.getExtension("WEBGL_compressed_texture_etc1") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc1"),
          etc2: this._gl.getExtension("WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBKIT_WEBGL_compressed_texture_etc") || this._gl.getExtension("WEBGL_compressed_texture_es3_0"),
          textureAnisotropicFilterExtension: this._gl.getExtension("EXT_texture_filter_anisotropic") || this._gl.getExtension("WEBKIT_EXT_texture_filter_anisotropic") || this._gl.getExtension("MOZ_EXT_texture_filter_anisotropic"),
          uintIndices: this._webGLVersion > 1 || this._gl.getExtension("OES_element_index_uint") !== null,
          fragmentDepthSupported: this._webGLVersion > 1 || this._gl.getExtension("EXT_frag_depth") !== null,
          highPrecisionShaderSupported: false,
          timerQuery: this._gl.getExtension("EXT_disjoint_timer_query_webgl2") || this._gl.getExtension("EXT_disjoint_timer_query"),
          supportOcclusionQuery: this._webGLVersion > 1,
          canUseTimestampForTimerQuery: false,
          drawBuffersExtension: false,
          maxMSAASamples: 1,
          colorBufferFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_float")),
          colorBufferHalfFloat: !!(this._webGLVersion > 1 && this._gl.getExtension("EXT_color_buffer_half_float")),
          textureFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_float") ? true : false,
          textureHalfFloat: this._webGLVersion > 1 || this._gl.getExtension("OES_texture_half_float") ? true : false,
          textureHalfFloatRender: false,
          textureFloatLinearFiltering: false,
          textureFloatRender: false,
          textureHalfFloatLinearFiltering: false,
          vertexArrayObject: false,
          instancedArrays: false,
          textureLOD: this._webGLVersion > 1 || this._gl.getExtension("EXT_shader_texture_lod") ? true : false,
          texelFetch: this._webGLVersion !== 1,
          blendMinMax: false,
          multiview: this._gl.getExtension("OVR_multiview2"),
          oculusMultiview: this._gl.getExtension("OCULUS_multiview"),
          depthTextureExtension: false,
          canUseGLInstanceID: this._webGLVersion > 1,
          canUseGLVertexID: this._webGLVersion > 1,
          supportComputeShaders: false,
          supportSRGBBuffers: false,
          supportTransformFeedbacks: this._webGLVersion > 1,
          textureMaxLevel: this._webGLVersion > 1,
          texture2DArrayMaxLayerCount: this._webGLVersion > 1 ? this._gl.getParameter(this._gl.MAX_ARRAY_TEXTURE_LAYERS) : 128,
          disableMorphTargetTexture: false
        };
        this._glVersion = this._gl.getParameter(this._gl.VERSION);
        const rendererInfo = this._gl.getExtension("WEBGL_debug_renderer_info");
        if (rendererInfo != null) {
          this._glRenderer = this._gl.getParameter(rendererInfo.UNMASKED_RENDERER_WEBGL);
          this._glVendor = this._gl.getParameter(rendererInfo.UNMASKED_VENDOR_WEBGL);
        }
        if (!this._glVendor) {
          this._glVendor = this._gl.getParameter(this._gl.VENDOR) || "Unknown vendor";
        }
        if (!this._glRenderer) {
          this._glRenderer = this._gl.getParameter(this._gl.RENDERER) || "Unknown renderer";
        }
        if (this._gl.HALF_FLOAT_OES !== 36193) {
          this._gl.HALF_FLOAT_OES = 36193;
        }
        if (this._gl.RGBA16F !== 34842) {
          this._gl.RGBA16F = 34842;
        }
        if (this._gl.RGBA32F !== 34836) {
          this._gl.RGBA32F = 34836;
        }
        if (this._gl.DEPTH24_STENCIL8 !== 35056) {
          this._gl.DEPTH24_STENCIL8 = 35056;
        }
        if (this._caps.timerQuery) {
          if (this._webGLVersion === 1) {
            this._gl.getQuery = this._caps.timerQuery.getQueryEXT.bind(this._caps.timerQuery);
          }
          this._caps.canUseTimestampForTimerQuery = ((_a = this._gl.getQuery(this._caps.timerQuery.TIMESTAMP_EXT, this._caps.timerQuery.QUERY_COUNTER_BITS_EXT)) !== null && _a !== void 0 ? _a : 0) > 0;
        }
        this._caps.maxAnisotropy = this._caps.textureAnisotropicFilterExtension ? this._gl.getParameter(this._caps.textureAnisotropicFilterExtension.MAX_TEXTURE_MAX_ANISOTROPY_EXT) : 0;
        this._caps.textureFloatLinearFiltering = this._caps.textureFloat && this._gl.getExtension("OES_texture_float_linear") ? true : false;
        this._caps.textureFloatRender = this._caps.textureFloat && this._canRenderToFloatFramebuffer() ? true : false;
        this._caps.textureHalfFloatLinearFiltering = this._webGLVersion > 1 || this._caps.textureHalfFloat && this._gl.getExtension("OES_texture_half_float_linear") ? true : false;
        if (this._caps.astc) {
          this._gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = this._caps.astc.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
        }
        if (this._caps.bptc) {
          this._gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT = this._caps.bptc.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
        }
        if (this._caps.s3tc_srgb) {
          this._gl.COMPRESSED_SRGB_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_S3TC_DXT1_EXT;
          this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
          this._gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = this._caps.s3tc_srgb.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
        }
        if (this._caps.etc2) {
          this._gl.COMPRESSED_SRGB8_ETC2 = this._caps.etc2.COMPRESSED_SRGB8_ETC2;
          this._gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = this._caps.etc2.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
        }
        if (this._webGLVersion > 1) {
          if (this._gl.HALF_FLOAT_OES !== 5131) {
            this._gl.HALF_FLOAT_OES = 5131;
          }
        }
        this._caps.textureHalfFloatRender = this._caps.textureHalfFloat && this._canRenderToHalfFloatFramebuffer();
        if (this._webGLVersion > 1) {
          this._caps.drawBuffersExtension = true;
          this._caps.maxMSAASamples = this._maxMSAASamplesOverride !== null ? this._maxMSAASamplesOverride : this._gl.getParameter(this._gl.MAX_SAMPLES);
        } else {
          const drawBuffersExtension = this._gl.getExtension("WEBGL_draw_buffers");
          if (drawBuffersExtension !== null) {
            this._caps.drawBuffersExtension = true;
            this._gl.drawBuffers = drawBuffersExtension.drawBuffersWEBGL.bind(drawBuffersExtension);
            this._gl.DRAW_FRAMEBUFFER = this._gl.FRAMEBUFFER;
            for (let i = 0; i < 16; i++) {
              this._gl["COLOR_ATTACHMENT" + i + "_WEBGL"] = drawBuffersExtension["COLOR_ATTACHMENT" + i + "_WEBGL"];
            }
          }
        }
        if (this._webGLVersion > 1) {
          this._caps.depthTextureExtension = true;
        } else {
          const depthTextureExtension = this._gl.getExtension("WEBGL_depth_texture");
          if (depthTextureExtension != null) {
            this._caps.depthTextureExtension = true;
            this._gl.UNSIGNED_INT_24_8 = depthTextureExtension.UNSIGNED_INT_24_8_WEBGL;
          }
        }
        if (this.disableVertexArrayObjects) {
          this._caps.vertexArrayObject = false;
        } else if (this._webGLVersion > 1) {
          this._caps.vertexArrayObject = true;
        } else {
          const vertexArrayObjectExtension = this._gl.getExtension("OES_vertex_array_object");
          if (vertexArrayObjectExtension != null) {
            this._caps.vertexArrayObject = true;
            this._gl.createVertexArray = vertexArrayObjectExtension.createVertexArrayOES.bind(vertexArrayObjectExtension);
            this._gl.bindVertexArray = vertexArrayObjectExtension.bindVertexArrayOES.bind(vertexArrayObjectExtension);
            this._gl.deleteVertexArray = vertexArrayObjectExtension.deleteVertexArrayOES.bind(vertexArrayObjectExtension);
          }
        }
        if (this._webGLVersion > 1) {
          this._caps.instancedArrays = true;
        } else {
          const instanceExtension = this._gl.getExtension("ANGLE_instanced_arrays");
          if (instanceExtension != null) {
            this._caps.instancedArrays = true;
            this._gl.drawArraysInstanced = instanceExtension.drawArraysInstancedANGLE.bind(instanceExtension);
            this._gl.drawElementsInstanced = instanceExtension.drawElementsInstancedANGLE.bind(instanceExtension);
            this._gl.vertexAttribDivisor = instanceExtension.vertexAttribDivisorANGLE.bind(instanceExtension);
          } else {
            this._caps.instancedArrays = false;
          }
        }
        if (this._gl.getShaderPrecisionFormat) {
          const vertexhighp = this._gl.getShaderPrecisionFormat(this._gl.VERTEX_SHADER, this._gl.HIGH_FLOAT);
          const fragmenthighp = this._gl.getShaderPrecisionFormat(this._gl.FRAGMENT_SHADER, this._gl.HIGH_FLOAT);
          if (vertexhighp && fragmenthighp) {
            this._caps.highPrecisionShaderSupported = vertexhighp.precision !== 0 && fragmenthighp.precision !== 0;
          }
        }
        if (this._webGLVersion > 1) {
          this._caps.blendMinMax = true;
        } else {
          const blendMinMaxExtension = this._gl.getExtension("EXT_blend_minmax");
          if (blendMinMaxExtension != null) {
            this._caps.blendMinMax = true;
            this._gl.MAX = blendMinMaxExtension.MAX_EXT;
            this._gl.MIN = blendMinMaxExtension.MIN_EXT;
          }
        }
        if (!this._caps.supportSRGBBuffers) {
          if (this._webGLVersion > 1) {
            this._caps.supportSRGBBuffers = true;
            this._glSRGBExtensionValues = {
              SRGB: WebGL2RenderingContext.SRGB,
              SRGB8: WebGL2RenderingContext.SRGB8,
              SRGB8_ALPHA8: WebGL2RenderingContext.SRGB8_ALPHA8
            };
          } else {
            const sRGBExtension = this._gl.getExtension("EXT_sRGB");
            if (sRGBExtension != null) {
              this._caps.supportSRGBBuffers = true;
              this._glSRGBExtensionValues = {
                SRGB: sRGBExtension.SRGB_EXT,
                SRGB8: sRGBExtension.SRGB_ALPHA_EXT,
                SRGB8_ALPHA8: sRGBExtension.SRGB_ALPHA_EXT
              };
            }
          }
          this._caps.supportSRGBBuffers = this._caps.supportSRGBBuffers && !!(this._creationOptions && this._creationOptions.forceSRGBBufferSupportState);
        }
        this._depthCullingState.depthTest = true;
        this._depthCullingState.depthFunc = this._gl.LEQUAL;
        this._depthCullingState.depthMask = true;
        this._maxSimultaneousTextures = this._caps.maxCombinedTexturesImageUnits;
        for (let slot = 0; slot < this._maxSimultaneousTextures; slot++) {
          this._nextFreeTextureSlots.push(slot);
        }
        if (this._glRenderer === "Mali-G72") {
          this._caps.disableMorphTargetTexture = true;
        }
      }
      _initFeatures() {
        this._features = {
          forceBitmapOverHTMLImageElement: false,
          supportRenderAndCopyToLodForFloatTextures: this._webGLVersion !== 1,
          supportDepthStencilTexture: this._webGLVersion !== 1,
          supportShadowSamplers: this._webGLVersion !== 1,
          uniformBufferHardCheckMatrix: false,
          allowTexturePrefiltering: this._webGLVersion !== 1,
          trackUbosInFrame: false,
          checkUbosContentBeforeUpload: false,
          supportCSM: this._webGLVersion !== 1,
          basisNeedsPOT: this._webGLVersion === 1,
          support3DTextures: this._webGLVersion !== 1,
          needTypeSuffixInShaderConstants: this._webGLVersion !== 1,
          supportMSAA: this._webGLVersion !== 1,
          supportSSAO2: this._webGLVersion !== 1,
          supportExtendedTextureFormats: this._webGLVersion !== 1,
          supportSwitchCaseInShader: this._webGLVersion !== 1,
          supportSyncTextureRead: true,
          needsInvertingBitmap: true,
          useUBOBindingCache: true,
          needShaderCodeInlining: false,
          needToAlwaysBindUniformBuffers: false,
          supportRenderPasses: false,
          supportSpriteInstancing: true,
          _collectUbosUpdatedInFrame: false
        };
      }
      get webGLVersion() {
        return this._webGLVersion;
      }
      getClassName() {
        return "ThinEngine";
      }
      get isStencilEnable() {
        return this._isStencilEnable;
      }
      _prepareWorkingCanvas() {
        if (this._workingCanvas) {
          return;
        }
        this._workingCanvas = this.createCanvas(1, 1);
        const context = this._workingCanvas.getContext("2d");
        if (context) {
          this._workingContext = context;
        }
      }
      resetTextureCache() {
        for (const key in this._boundTexturesCache) {
          if (!Object.prototype.hasOwnProperty.call(this._boundTexturesCache, key)) {
            continue;
          }
          this._boundTexturesCache[key] = null;
        }
        this._currentTextureChannel = -1;
      }
      getInfo() {
        return this.getGlInfo();
      }
      getGlInfo() {
        return {
          vendor: this._glVendor,
          renderer: this._glRenderer,
          version: this._glVersion
        };
      }
      setHardwareScalingLevel(level) {
        this._hardwareScalingLevel = level;
        this.resize();
      }
      getHardwareScalingLevel() {
        return this._hardwareScalingLevel;
      }
      getLoadedTexturesCache() {
        return this._internalTexturesCache;
      }
      getCaps() {
        return this._caps;
      }
      stopRenderLoop(renderFunction) {
        if (!renderFunction) {
          this._activeRenderLoops.length = 0;
          this._cancelFrame();
          return;
        }
        const index = this._activeRenderLoops.indexOf(renderFunction);
        if (index >= 0) {
          this._activeRenderLoops.splice(index, 1);
          if (this._activeRenderLoops.length == 0) {
            this._cancelFrame();
          }
        }
      }
      _cancelFrame() {
        if (this._renderingQueueLaunched && this._frameHandler) {
          this._renderingQueueLaunched = false;
          if (!IsWindowObjectExist()) {
            if (typeof cancelAnimationFrame === "function") {
              return cancelAnimationFrame(this._frameHandler);
            }
          } else {
            const { cancelAnimationFrame: cancelAnimationFrame2 } = this.getHostWindow() || window;
            if (typeof cancelAnimationFrame2 === "function") {
              return cancelAnimationFrame2(this._frameHandler);
            }
          }
          return clearTimeout(this._frameHandler);
        }
      }
      _renderLoop() {
        if (!this._contextWasLost) {
          let shouldRender = true;
          if (this._isDisposed || !this.renderEvenInBackground && this._windowIsBackground) {
            shouldRender = false;
          }
          if (shouldRender) {
            this.beginFrame();
            for (let index = 0; index < this._activeRenderLoops.length; index++) {
              const renderFunction = this._activeRenderLoops[index];
              renderFunction();
            }
            this.endFrame();
          }
        }
        if (this._activeRenderLoops.length > 0) {
          this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
        } else {
          this._renderingQueueLaunched = false;
        }
      }
      getRenderingCanvas() {
        return this._renderingCanvas;
      }
      getAudioContext() {
        return this._audioContext;
      }
      getAudioDestination() {
        return this._audioDestination;
      }
      getHostWindow() {
        if (!IsWindowObjectExist()) {
          return null;
        }
        if (this._renderingCanvas && this._renderingCanvas.ownerDocument && this._renderingCanvas.ownerDocument.defaultView) {
          return this._renderingCanvas.ownerDocument.defaultView;
        }
        return window;
      }
      getRenderWidth(useScreen = false) {
        if (!useScreen && this._currentRenderTarget) {
          return this._currentRenderTarget.width;
        }
        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferWidth : this._gl.drawingBufferWidth;
      }
      getRenderHeight(useScreen = false) {
        if (!useScreen && this._currentRenderTarget) {
          return this._currentRenderTarget.height;
        }
        return this._framebufferDimensionsObject ? this._framebufferDimensionsObject.framebufferHeight : this._gl.drawingBufferHeight;
      }
      _queueNewFrame(bindedRenderFunction, requester) {
        return ThinEngine.QueueNewFrame(bindedRenderFunction, requester);
      }
      runRenderLoop(renderFunction) {
        if (this._activeRenderLoops.indexOf(renderFunction) !== -1) {
          return;
        }
        this._activeRenderLoops.push(renderFunction);
        if (!this._renderingQueueLaunched) {
          this._renderingQueueLaunched = true;
          this._boundRenderFunction = this._renderLoop.bind(this);
          this._frameHandler = this._queueNewFrame(this._boundRenderFunction, this.getHostWindow());
        }
      }
      clear(color, backBuffer, depth, stencil = false) {
        var _a, _b;
        const useStencilGlobalOnly = this.stencilStateComposer.useStencilGlobalOnly;
        this.stencilStateComposer.useStencilGlobalOnly = true;
        this.applyStates();
        this.stencilStateComposer.useStencilGlobalOnly = useStencilGlobalOnly;
        let mode = 0;
        if (backBuffer && color) {
          let setBackBufferColor = true;
          if (this._currentRenderTarget) {
            const textureFormat = (_a = this._currentRenderTarget.texture) === null || _a === void 0 ? void 0 : _a.format;
            if (textureFormat === 8 || textureFormat === 9 || textureFormat === 10 || textureFormat === 11) {
              const textureType = (_b = this._currentRenderTarget.texture) === null || _b === void 0 ? void 0 : _b.type;
              if (textureType === 7 || textureType === 5) {
                ThinEngine._TempClearColorUint32[0] = color.r * 255;
                ThinEngine._TempClearColorUint32[1] = color.g * 255;
                ThinEngine._TempClearColorUint32[2] = color.b * 255;
                ThinEngine._TempClearColorUint32[3] = color.a * 255;
                this._gl.clearBufferuiv(this._gl.COLOR, 0, ThinEngine._TempClearColorUint32);
                setBackBufferColor = false;
              } else {
                ThinEngine._TempClearColorInt32[0] = color.r * 255;
                ThinEngine._TempClearColorInt32[1] = color.g * 255;
                ThinEngine._TempClearColorInt32[2] = color.b * 255;
                ThinEngine._TempClearColorInt32[3] = color.a * 255;
                this._gl.clearBufferiv(this._gl.COLOR, 0, ThinEngine._TempClearColorInt32);
                setBackBufferColor = false;
              }
            }
          }
          if (setBackBufferColor) {
            this._gl.clearColor(color.r, color.g, color.b, color.a !== void 0 ? color.a : 1);
            mode |= this._gl.COLOR_BUFFER_BIT;
          }
        }
        if (depth) {
          if (this.useReverseDepthBuffer) {
            this._depthCullingState.depthFunc = this._gl.GEQUAL;
            this._gl.clearDepth(0);
          } else {
            this._gl.clearDepth(1);
          }
          mode |= this._gl.DEPTH_BUFFER_BIT;
        }
        if (stencil) {
          this._gl.clearStencil(0);
          mode |= this._gl.STENCIL_BUFFER_BIT;
        }
        this._gl.clear(mode);
      }
      _viewport(x, y, width, height) {
        if (x !== this._viewportCached.x || y !== this._viewportCached.y || width !== this._viewportCached.z || height !== this._viewportCached.w) {
          this._viewportCached.x = x;
          this._viewportCached.y = y;
          this._viewportCached.z = width;
          this._viewportCached.w = height;
          this._gl.viewport(x, y, width, height);
        }
      }
      setViewport(viewport, requiredWidth, requiredHeight) {
        const width = requiredWidth || this.getRenderWidth();
        const height = requiredHeight || this.getRenderHeight();
        const x = viewport.x || 0;
        const y = viewport.y || 0;
        this._cachedViewport = viewport;
        this._viewport(x * width, y * height, width * viewport.width, height * viewport.height);
      }
      beginFrame() {
      }
      endFrame() {
        if (this._badOS) {
          this.flushFramebuffer();
        }
        this._frameId++;
      }
      resize(forceSetSize = false) {
        let width;
        let height;
        if (this.adaptToDeviceRatio) {
          const devicePixelRatio = IsWindowObjectExist() ? window.devicePixelRatio || 1 : 1;
          const changeRatio = this._lastDevicePixelRatio / devicePixelRatio;
          this._lastDevicePixelRatio = devicePixelRatio;
          this._hardwareScalingLevel *= changeRatio;
        }
        if (IsWindowObjectExist() && IsDocumentAvailable()) {
          if (this._renderingCanvas) {
            const boundingRect = this._renderingCanvas.getBoundingClientRect ? this._renderingCanvas.getBoundingClientRect() : {
              width: this._renderingCanvas.width * this._hardwareScalingLevel,
              height: this._renderingCanvas.height * this._hardwareScalingLevel
            };
            width = this._renderingCanvas.clientWidth || boundingRect.width || this._renderingCanvas.width || 100;
            height = this._renderingCanvas.clientHeight || boundingRect.height || this._renderingCanvas.height || 100;
          } else {
            width = window.innerWidth;
            height = window.innerHeight;
          }
        } else {
          width = this._renderingCanvas ? this._renderingCanvas.width : 100;
          height = this._renderingCanvas ? this._renderingCanvas.height : 100;
        }
        this.setSize(width / this._hardwareScalingLevel, height / this._hardwareScalingLevel, forceSetSize);
      }
      setSize(width, height, forceSetSize = false) {
        if (!this._renderingCanvas) {
          return false;
        }
        width = width | 0;
        height = height | 0;
        if (!forceSetSize && this._renderingCanvas.width === width && this._renderingCanvas.height === height) {
          return false;
        }
        this._renderingCanvas.width = width;
        this._renderingCanvas.height = height;
        return true;
      }
      bindFramebuffer(rtWrapper, faceIndex = 0, requiredWidth, requiredHeight, forceFullscreenViewport, lodLevel = 0, layer = 0) {
        var _a, _b, _c, _d, _e;
        const webglRTWrapper = rtWrapper;
        if (this._currentRenderTarget) {
          this.unBindFramebuffer(this._currentRenderTarget);
        }
        this._currentRenderTarget = rtWrapper;
        this._bindUnboundFramebuffer(webglRTWrapper._MSAAFramebuffer ? webglRTWrapper._MSAAFramebuffer : webglRTWrapper._framebuffer);
        const gl = this._gl;
        if (!rtWrapper.isMulti) {
          if (rtWrapper.is2DArray) {
            gl.framebufferTextureLayer(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, (_a = rtWrapper.texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource, lodLevel, layer);
          } else if (rtWrapper.isCube) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_b = rtWrapper.texture._hardwareTexture) === null || _b === void 0 ? void 0 : _b.underlyingResource, lodLevel);
          }
        }
        const depthStencilTexture = rtWrapper._depthStencilTexture;
        if (depthStencilTexture) {
          const attachment = rtWrapper._depthStencilTextureWithStencil ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
          if (rtWrapper.is2DArray) {
            gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, (_c = depthStencilTexture._hardwareTexture) === null || _c === void 0 ? void 0 : _c.underlyingResource, lodLevel, layer);
          } else if (rtWrapper.isCube) {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, (_d = depthStencilTexture._hardwareTexture) === null || _d === void 0 ? void 0 : _d.underlyingResource, lodLevel);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, (_e = depthStencilTexture._hardwareTexture) === null || _e === void 0 ? void 0 : _e.underlyingResource, lodLevel);
          }
        }
        if (this._cachedViewport && !forceFullscreenViewport) {
          this.setViewport(this._cachedViewport, requiredWidth, requiredHeight);
        } else {
          if (!requiredWidth) {
            requiredWidth = rtWrapper.width;
            if (lodLevel) {
              requiredWidth = requiredWidth / Math.pow(2, lodLevel);
            }
          }
          if (!requiredHeight) {
            requiredHeight = rtWrapper.height;
            if (lodLevel) {
              requiredHeight = requiredHeight / Math.pow(2, lodLevel);
            }
          }
          this._viewport(0, 0, requiredWidth, requiredHeight);
        }
        this.wipeCaches();
      }
      setState(culling, zOffset = 0, force, reverseSide = false, cullBackFaces, stencil, zOffsetUnits = 0) {
        var _a, _b;
        if (this._depthCullingState.cull !== culling || force) {
          this._depthCullingState.cull = culling;
        }
        const cullFace = ((_b = (_a = this.cullBackFaces) !== null && _a !== void 0 ? _a : cullBackFaces) !== null && _b !== void 0 ? _b : true) ? this._gl.BACK : this._gl.FRONT;
        if (this._depthCullingState.cullFace !== cullFace || force) {
          this._depthCullingState.cullFace = cullFace;
        }
        this.setZOffset(zOffset);
        this.setZOffsetUnits(zOffsetUnits);
        const frontFace = reverseSide ? this._gl.CW : this._gl.CCW;
        if (this._depthCullingState.frontFace !== frontFace || force) {
          this._depthCullingState.frontFace = frontFace;
        }
        this._stencilStateComposer.stencilMaterial = stencil;
      }
      getDepthBuffer() {
        return this._depthCullingState.depthTest;
      }
      setDepthBuffer(enable) {
        this._depthCullingState.depthTest = enable;
      }
      setZOffset(value) {
        this._depthCullingState.zOffset = this.useReverseDepthBuffer ? -value : value;
      }
      getZOffset() {
        const zOffset = this._depthCullingState.zOffset;
        return this.useReverseDepthBuffer ? -zOffset : zOffset;
      }
      setZOffsetUnits(value) {
        this._depthCullingState.zOffsetUnits = this.useReverseDepthBuffer ? -value : value;
      }
      getZOffsetUnits() {
        const zOffsetUnits = this._depthCullingState.zOffsetUnits;
        return this.useReverseDepthBuffer ? -zOffsetUnits : zOffsetUnits;
      }
      _bindUnboundFramebuffer(framebuffer) {
        if (this._currentFramebuffer !== framebuffer) {
          this._gl.bindFramebuffer(this._gl.FRAMEBUFFER, framebuffer);
          this._currentFramebuffer = framebuffer;
        }
      }
      _currentFrameBufferIsDefaultFrameBuffer() {
        return this._currentFramebuffer === null;
      }
      generateMipmaps(texture) {
        this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
        this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      }
      unBindFramebuffer(texture, disableGenerateMipMaps = false, onBeforeUnbind) {
        var _a;
        const webglRTWrapper = texture;
        this._currentRenderTarget = null;
        const gl = this._gl;
        if (webglRTWrapper._MSAAFramebuffer) {
          if (texture.isMulti) {
            this.unBindMultiColorAttachmentFramebuffer(texture, disableGenerateMipMaps, onBeforeUnbind);
            return;
          }
          gl.bindFramebuffer(gl.READ_FRAMEBUFFER, webglRTWrapper._MSAAFramebuffer);
          gl.bindFramebuffer(gl.DRAW_FRAMEBUFFER, webglRTWrapper._framebuffer);
          gl.blitFramebuffer(0, 0, texture.width, texture.height, 0, 0, texture.width, texture.height, gl.COLOR_BUFFER_BIT, gl.NEAREST);
        }
        if (((_a = texture.texture) === null || _a === void 0 ? void 0 : _a.generateMipMaps) && !disableGenerateMipMaps && !texture.isCube) {
          this.generateMipmaps(texture.texture);
        }
        if (onBeforeUnbind) {
          if (webglRTWrapper._MSAAFramebuffer) {
            this._bindUnboundFramebuffer(webglRTWrapper._framebuffer);
          }
          onBeforeUnbind();
        }
        this._bindUnboundFramebuffer(null);
      }
      flushFramebuffer() {
        this._gl.flush();
      }
      restoreDefaultFramebuffer() {
        if (this._currentRenderTarget) {
          this.unBindFramebuffer(this._currentRenderTarget);
        } else {
          this._bindUnboundFramebuffer(null);
        }
        if (this._cachedViewport) {
          this.setViewport(this._cachedViewport);
        }
        this.wipeCaches();
      }
      _resetVertexBufferBinding() {
        this.bindArrayBuffer(null);
        this._cachedVertexBuffers = null;
      }
      createVertexBuffer(data) {
        return this._createVertexBuffer(data, this._gl.STATIC_DRAW);
      }
      _createVertexBuffer(data, usage) {
        const vbo = this._gl.createBuffer();
        if (!vbo) {
          throw new Error("Unable to create vertex buffer");
        }
        const dataBuffer = new WebGLDataBuffer(vbo);
        this.bindArrayBuffer(dataBuffer);
        if (data instanceof Array) {
          this._gl.bufferData(this._gl.ARRAY_BUFFER, new Float32Array(data), usage);
        } else {
          this._gl.bufferData(this._gl.ARRAY_BUFFER, data, usage);
        }
        this._resetVertexBufferBinding();
        dataBuffer.references = 1;
        return dataBuffer;
      }
      createDynamicVertexBuffer(data) {
        return this._createVertexBuffer(data, this._gl.DYNAMIC_DRAW);
      }
      _resetIndexBufferBinding() {
        this.bindIndexBuffer(null);
        this._cachedIndexBuffer = null;
      }
      createIndexBuffer(indices, updatable) {
        const vbo = this._gl.createBuffer();
        const dataBuffer = new WebGLDataBuffer(vbo);
        if (!vbo) {
          throw new Error("Unable to create index buffer");
        }
        this.bindIndexBuffer(dataBuffer);
        const data = this._normalizeIndexData(indices);
        this._gl.bufferData(this._gl.ELEMENT_ARRAY_BUFFER, data, updatable ? this._gl.DYNAMIC_DRAW : this._gl.STATIC_DRAW);
        this._resetIndexBufferBinding();
        dataBuffer.references = 1;
        dataBuffer.is32Bits = data.BYTES_PER_ELEMENT === 4;
        return dataBuffer;
      }
      _normalizeIndexData(indices) {
        const bytesPerElement = indices.BYTES_PER_ELEMENT;
        if (bytesPerElement === 2) {
          return indices;
        }
        if (this._caps.uintIndices) {
          if (indices instanceof Uint32Array) {
            return indices;
          } else {
            for (let index = 0; index < indices.length; index++) {
              if (indices[index] >= 65535) {
                return new Uint32Array(indices);
              }
            }
            return new Uint16Array(indices);
          }
        }
        return new Uint16Array(indices);
      }
      bindArrayBuffer(buffer) {
        if (!this._vaoRecordInProgress) {
          this._unbindVertexArrayObject();
        }
        this._bindBuffer(buffer, this._gl.ARRAY_BUFFER);
      }
      bindUniformBlock(pipelineContext, blockName, index) {
        const program = pipelineContext.program;
        const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
        this._gl.uniformBlockBinding(program, uniformLocation, index);
      }
      bindIndexBuffer(buffer) {
        if (!this._vaoRecordInProgress) {
          this._unbindVertexArrayObject();
        }
        this._bindBuffer(buffer, this._gl.ELEMENT_ARRAY_BUFFER);
      }
      _bindBuffer(buffer, target) {
        if (this._vaoRecordInProgress || this._currentBoundBuffer[target] !== buffer) {
          this._gl.bindBuffer(target, buffer ? buffer.underlyingResource : null);
          this._currentBoundBuffer[target] = buffer;
        }
      }
      updateArrayBuffer(data) {
        this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
      }
      _vertexAttribPointer(buffer, indx, size, type, normalized, stride, offset) {
        const pointer = this._currentBufferPointers[indx];
        if (!pointer) {
          return;
        }
        let changed = false;
        if (!pointer.active) {
          changed = true;
          pointer.active = true;
          pointer.index = indx;
          pointer.size = size;
          pointer.type = type;
          pointer.normalized = normalized;
          pointer.stride = stride;
          pointer.offset = offset;
          pointer.buffer = buffer;
        } else {
          if (pointer.buffer !== buffer) {
            pointer.buffer = buffer;
            changed = true;
          }
          if (pointer.size !== size) {
            pointer.size = size;
            changed = true;
          }
          if (pointer.type !== type) {
            pointer.type = type;
            changed = true;
          }
          if (pointer.normalized !== normalized) {
            pointer.normalized = normalized;
            changed = true;
          }
          if (pointer.stride !== stride) {
            pointer.stride = stride;
            changed = true;
          }
          if (pointer.offset !== offset) {
            pointer.offset = offset;
            changed = true;
          }
        }
        if (changed || this._vaoRecordInProgress) {
          this.bindArrayBuffer(buffer);
          if (type === this._gl.UNSIGNED_INT || type === this._gl.INT) {
            this._gl.vertexAttribIPointer(indx, size, type, stride, offset);
          } else {
            this._gl.vertexAttribPointer(indx, size, type, normalized, stride, offset);
          }
        }
      }
      _bindIndexBufferWithCache(indexBuffer) {
        if (indexBuffer == null) {
          return;
        }
        if (this._cachedIndexBuffer !== indexBuffer) {
          this._cachedIndexBuffer = indexBuffer;
          this.bindIndexBuffer(indexBuffer);
          this._uintIndicesCurrentlySet = indexBuffer.is32Bits;
        }
      }
      _bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers) {
        const attributes = effect.getAttributesNames();
        if (!this._vaoRecordInProgress) {
          this._unbindVertexArrayObject();
        }
        this.unbindAllAttributes();
        for (let index = 0; index < attributes.length; index++) {
          const order = effect.getAttributeLocation(index);
          if (order >= 0) {
            const ai = attributes[index];
            let vertexBuffer = null;
            if (overrideVertexBuffers) {
              vertexBuffer = overrideVertexBuffers[ai];
            }
            if (!vertexBuffer) {
              vertexBuffer = vertexBuffers[ai];
            }
            if (!vertexBuffer) {
              continue;
            }
            this._gl.enableVertexAttribArray(order);
            if (!this._vaoRecordInProgress) {
              this._vertexAttribArraysEnabled[order] = true;
            }
            const buffer = vertexBuffer.getBuffer();
            if (buffer) {
              this._vertexAttribPointer(buffer, order, vertexBuffer.getSize(), vertexBuffer.type, vertexBuffer.normalized, vertexBuffer.byteStride, vertexBuffer.byteOffset);
              if (vertexBuffer.getIsInstanced()) {
                this._gl.vertexAttribDivisor(order, vertexBuffer.getInstanceDivisor());
                if (!this._vaoRecordInProgress) {
                  this._currentInstanceLocations.push(order);
                  this._currentInstanceBuffers.push(buffer);
                }
              }
            }
          }
        }
      }
      recordVertexArrayObject(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
        const vao = this._gl.createVertexArray();
        if (!vao) {
          throw new Error("Unable to create VAO");
        }
        this._vaoRecordInProgress = true;
        this._gl.bindVertexArray(vao);
        this._mustWipeVertexAttributes = true;
        this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
        this.bindIndexBuffer(indexBuffer);
        this._vaoRecordInProgress = false;
        this._gl.bindVertexArray(null);
        return vao;
      }
      bindVertexArrayObject(vertexArrayObject, indexBuffer) {
        if (this._cachedVertexArrayObject !== vertexArrayObject) {
          this._cachedVertexArrayObject = vertexArrayObject;
          this._gl.bindVertexArray(vertexArrayObject);
          this._cachedVertexBuffers = null;
          this._cachedIndexBuffer = null;
          this._uintIndicesCurrentlySet = indexBuffer != null && indexBuffer.is32Bits;
          this._mustWipeVertexAttributes = true;
        }
      }
      bindBuffersDirectly(vertexBuffer, indexBuffer, vertexDeclaration, vertexStrideSize, effect) {
        if (this._cachedVertexBuffers !== vertexBuffer || this._cachedEffectForVertexBuffers !== effect) {
          this._cachedVertexBuffers = vertexBuffer;
          this._cachedEffectForVertexBuffers = effect;
          const attributesCount = effect.getAttributesCount();
          this._unbindVertexArrayObject();
          this.unbindAllAttributes();
          let offset = 0;
          for (let index = 0; index < attributesCount; index++) {
            if (index < vertexDeclaration.length) {
              const order = effect.getAttributeLocation(index);
              if (order >= 0) {
                this._gl.enableVertexAttribArray(order);
                this._vertexAttribArraysEnabled[order] = true;
                this._vertexAttribPointer(vertexBuffer, order, vertexDeclaration[index], this._gl.FLOAT, false, vertexStrideSize, offset);
              }
              offset += vertexDeclaration[index] * 4;
            }
          }
        }
        this._bindIndexBufferWithCache(indexBuffer);
      }
      _unbindVertexArrayObject() {
        if (!this._cachedVertexArrayObject) {
          return;
        }
        this._cachedVertexArrayObject = null;
        this._gl.bindVertexArray(null);
      }
      bindBuffers(vertexBuffers, indexBuffer, effect, overrideVertexBuffers) {
        if (this._cachedVertexBuffers !== vertexBuffers || this._cachedEffectForVertexBuffers !== effect) {
          this._cachedVertexBuffers = vertexBuffers;
          this._cachedEffectForVertexBuffers = effect;
          this._bindVertexBuffersAttributes(vertexBuffers, effect, overrideVertexBuffers);
        }
        this._bindIndexBufferWithCache(indexBuffer);
      }
      unbindInstanceAttributes() {
        let boundBuffer;
        for (let i = 0, ul = this._currentInstanceLocations.length; i < ul; i++) {
          const instancesBuffer = this._currentInstanceBuffers[i];
          if (boundBuffer != instancesBuffer && instancesBuffer.references) {
            boundBuffer = instancesBuffer;
            this.bindArrayBuffer(instancesBuffer);
          }
          const offsetLocation = this._currentInstanceLocations[i];
          this._gl.vertexAttribDivisor(offsetLocation, 0);
        }
        this._currentInstanceBuffers.length = 0;
        this._currentInstanceLocations.length = 0;
      }
      releaseVertexArrayObject(vao) {
        this._gl.deleteVertexArray(vao);
      }
      _releaseBuffer(buffer) {
        buffer.references--;
        if (buffer.references === 0) {
          this._deleteBuffer(buffer);
          return true;
        }
        return false;
      }
      _deleteBuffer(buffer) {
        this._gl.deleteBuffer(buffer.underlyingResource);
      }
      updateAndBindInstancesBuffer(instancesBuffer, data, offsetLocations) {
        this.bindArrayBuffer(instancesBuffer);
        if (data) {
          this._gl.bufferSubData(this._gl.ARRAY_BUFFER, 0, data);
        }
        if (offsetLocations[0].index !== void 0) {
          this.bindInstancesBuffer(instancesBuffer, offsetLocations, true);
        } else {
          for (let index = 0; index < 4; index++) {
            const offsetLocation = offsetLocations[index];
            if (!this._vertexAttribArraysEnabled[offsetLocation]) {
              this._gl.enableVertexAttribArray(offsetLocation);
              this._vertexAttribArraysEnabled[offsetLocation] = true;
            }
            this._vertexAttribPointer(instancesBuffer, offsetLocation, 4, this._gl.FLOAT, false, 64, index * 16);
            this._gl.vertexAttribDivisor(offsetLocation, 1);
            this._currentInstanceLocations.push(offsetLocation);
            this._currentInstanceBuffers.push(instancesBuffer);
          }
        }
      }
      bindInstancesBuffer(instancesBuffer, attributesInfo, computeStride = true) {
        this.bindArrayBuffer(instancesBuffer);
        let stride = 0;
        if (computeStride) {
          for (let i = 0; i < attributesInfo.length; i++) {
            const ai = attributesInfo[i];
            stride += ai.attributeSize * 4;
          }
        }
        for (let i = 0; i < attributesInfo.length; i++) {
          const ai = attributesInfo[i];
          if (ai.index === void 0) {
            ai.index = this._currentEffect.getAttributeLocationByName(ai.attributeName);
          }
          if (ai.index < 0) {
            continue;
          }
          if (!this._vertexAttribArraysEnabled[ai.index]) {
            this._gl.enableVertexAttribArray(ai.index);
            this._vertexAttribArraysEnabled[ai.index] = true;
          }
          this._vertexAttribPointer(instancesBuffer, ai.index, ai.attributeSize, ai.attributeType || this._gl.FLOAT, ai.normalized || false, stride, ai.offset);
          this._gl.vertexAttribDivisor(ai.index, ai.divisor === void 0 ? 1 : ai.divisor);
          this._currentInstanceLocations.push(ai.index);
          this._currentInstanceBuffers.push(instancesBuffer);
        }
      }
      disableInstanceAttributeByName(name) {
        if (!this._currentEffect) {
          return;
        }
        const attributeLocation = this._currentEffect.getAttributeLocationByName(name);
        this.disableInstanceAttribute(attributeLocation);
      }
      disableInstanceAttribute(attributeLocation) {
        let shouldClean = false;
        let index;
        while ((index = this._currentInstanceLocations.indexOf(attributeLocation)) !== -1) {
          this._currentInstanceLocations.splice(index, 1);
          this._currentInstanceBuffers.splice(index, 1);
          shouldClean = true;
          index = this._currentInstanceLocations.indexOf(attributeLocation);
        }
        if (shouldClean) {
          this._gl.vertexAttribDivisor(attributeLocation, 0);
          this.disableAttributeByIndex(attributeLocation);
        }
      }
      disableAttributeByIndex(attributeLocation) {
        this._gl.disableVertexAttribArray(attributeLocation);
        this._vertexAttribArraysEnabled[attributeLocation] = false;
        this._currentBufferPointers[attributeLocation].active = false;
      }
      draw(useTriangles, indexStart, indexCount, instancesCount) {
        this.drawElementsType(useTriangles ? 0 : 1, indexStart, indexCount, instancesCount);
      }
      drawPointClouds(verticesStart, verticesCount, instancesCount) {
        this.drawArraysType(2, verticesStart, verticesCount, instancesCount);
      }
      drawUnIndexed(useTriangles, verticesStart, verticesCount, instancesCount) {
        this.drawArraysType(useTriangles ? 0 : 1, verticesStart, verticesCount, instancesCount);
      }
      drawElementsType(fillMode, indexStart, indexCount, instancesCount) {
        this.applyStates();
        this._reportDrawCall();
        const drawMode = this._drawMode(fillMode);
        const indexFormat = this._uintIndicesCurrentlySet ? this._gl.UNSIGNED_INT : this._gl.UNSIGNED_SHORT;
        const mult = this._uintIndicesCurrentlySet ? 4 : 2;
        if (instancesCount) {
          this._gl.drawElementsInstanced(drawMode, indexCount, indexFormat, indexStart * mult, instancesCount);
        } else {
          this._gl.drawElements(drawMode, indexCount, indexFormat, indexStart * mult);
        }
      }
      drawArraysType(fillMode, verticesStart, verticesCount, instancesCount) {
        this.applyStates();
        this._reportDrawCall();
        const drawMode = this._drawMode(fillMode);
        if (instancesCount) {
          this._gl.drawArraysInstanced(drawMode, verticesStart, verticesCount, instancesCount);
        } else {
          this._gl.drawArrays(drawMode, verticesStart, verticesCount);
        }
      }
      _drawMode(fillMode) {
        switch (fillMode) {
          case 0:
            return this._gl.TRIANGLES;
          case 2:
            return this._gl.POINTS;
          case 1:
            return this._gl.LINES;
          case 3:
            return this._gl.POINTS;
          case 4:
            return this._gl.LINES;
          case 5:
            return this._gl.LINE_LOOP;
          case 6:
            return this._gl.LINE_STRIP;
          case 7:
            return this._gl.TRIANGLE_STRIP;
          case 8:
            return this._gl.TRIANGLE_FAN;
          default:
            return this._gl.TRIANGLES;
        }
      }
      _reportDrawCall() {
      }
      _releaseEffect(effect) {
        if (this._compiledEffects[effect._key]) {
          delete this._compiledEffects[effect._key];
        }
        const pipelineContext = effect.getPipelineContext();
        if (pipelineContext) {
          this._deletePipelineContext(pipelineContext);
        }
      }
      _deletePipelineContext(pipelineContext) {
        const webGLPipelineContext = pipelineContext;
        if (webGLPipelineContext && webGLPipelineContext.program) {
          webGLPipelineContext.program.__SPECTOR_rebuildProgram = null;
          this._gl.deleteProgram(webGLPipelineContext.program);
        }
      }
      _getGlobalDefines(defines) {
        if (defines) {
          if (this.isNDCHalfZRange) {
            defines["IS_NDC_HALF_ZRANGE"] = "";
          } else {
            delete defines["IS_NDC_HALF_ZRANGE"];
          }
          if (this.useReverseDepthBuffer) {
            defines["USE_REVERSE_DEPTHBUFFER"] = "";
          } else {
            delete defines["USE_REVERSE_DEPTHBUFFER"];
          }
          if (this.useExactSrgbConversions) {
            defines["USE_EXACT_SRGB_CONVERSIONS"] = "";
          } else {
            delete defines["USE_EXACT_SRGB_CONVERSIONS"];
          }
          return;
        } else {
          let s = "";
          if (this.isNDCHalfZRange) {
            s += "#define IS_NDC_HALF_ZRANGE";
          }
          if (this.useReverseDepthBuffer) {
            if (s) {
              s += "\n";
            }
            s += "#define USE_REVERSE_DEPTHBUFFER";
          }
          if (this.useExactSrgbConversions) {
            if (s) {
              s += "\n";
            }
            s += "#define USE_EXACT_SRGB_CONVERSIONS";
          }
          return s;
        }
      }
      createEffect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, defines, fallbacks, onCompiled, onError, indexParameters, shaderLanguage = ShaderLanguage.GLSL) {
        var _a;
        const vertex = baseName.vertexElement || baseName.vertex || baseName.vertexToken || baseName.vertexSource || baseName;
        const fragment = baseName.fragmentElement || baseName.fragment || baseName.fragmentToken || baseName.fragmentSource || baseName;
        const globalDefines = this._getGlobalDefines();
        let fullDefines = (_a = defines !== null && defines !== void 0 ? defines : attributesNamesOrOptions.defines) !== null && _a !== void 0 ? _a : "";
        if (globalDefines) {
          fullDefines += globalDefines;
        }
        const name = vertex + "+" + fragment + "@" + fullDefines;
        if (this._compiledEffects[name]) {
          const compiledEffect = this._compiledEffects[name];
          if (onCompiled && compiledEffect.isReady()) {
            onCompiled(compiledEffect);
          }
          return compiledEffect;
        }
        const effect = new Effect(baseName, attributesNamesOrOptions, uniformsNamesOrEngine, samplers, this, defines, fallbacks, onCompiled, onError, indexParameters, name, shaderLanguage);
        this._compiledEffects[name] = effect;
        return effect;
      }
      static _ConcatenateShader(source, defines, shaderVersion = "") {
        return shaderVersion + (defines ? defines + "\n" : "") + source;
      }
      _compileShader(source, type, defines, shaderVersion) {
        return this._compileRawShader(ThinEngine._ConcatenateShader(source, defines, shaderVersion), type);
      }
      _compileRawShader(source, type) {
        const gl = this._gl;
        const shader = gl.createShader(type === "vertex" ? gl.VERTEX_SHADER : gl.FRAGMENT_SHADER);
        if (!shader) {
          let error = gl.NO_ERROR;
          let tempError = gl.NO_ERROR;
          while ((tempError = gl.getError()) !== gl.NO_ERROR) {
            error = tempError;
          }
          throw new Error(`Something went wrong while creating a gl ${type} shader object. gl error=${error}, gl isContextLost=${gl.isContextLost()}, _contextWasLost=${this._contextWasLost}`);
        }
        gl.shaderSource(shader, source);
        gl.compileShader(shader);
        return shader;
      }
      _getShaderSource(shader) {
        return this._gl.getShaderSource(shader);
      }
      createRawShaderProgram(pipelineContext, vertexCode, fragmentCode, context, transformFeedbackVaryings = null) {
        context = context || this._gl;
        const vertexShader = this._compileRawShader(vertexCode, "vertex");
        const fragmentShader = this._compileRawShader(fragmentCode, "fragment");
        return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
      }
      createShaderProgram(pipelineContext, vertexCode, fragmentCode, defines, context, transformFeedbackVaryings = null) {
        context = context || this._gl;
        const shaderVersion = this._webGLVersion > 1 ? "#version 300 es\n#define WEBGL2 \n" : "";
        const vertexShader = this._compileShader(vertexCode, "vertex", defines, shaderVersion);
        const fragmentShader = this._compileShader(fragmentCode, "fragment", defines, shaderVersion);
        return this._createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings);
      }
      inlineShaderCode(code) {
        return code;
      }
      createPipelineContext(shaderProcessingContext) {
        const pipelineContext = new WebGLPipelineContext();
        pipelineContext.engine = this;
        if (this._caps.parallelShaderCompile) {
          pipelineContext.isParallelCompiled = true;
        }
        return pipelineContext;
      }
      createMaterialContext() {
        return void 0;
      }
      createDrawContext() {
        return void 0;
      }
      _createShaderProgram(pipelineContext, vertexShader, fragmentShader, context, transformFeedbackVaryings = null) {
        const shaderProgram = context.createProgram();
        pipelineContext.program = shaderProgram;
        if (!shaderProgram) {
          throw new Error("Unable to create program");
        }
        context.attachShader(shaderProgram, vertexShader);
        context.attachShader(shaderProgram, fragmentShader);
        context.linkProgram(shaderProgram);
        pipelineContext.context = context;
        pipelineContext.vertexShader = vertexShader;
        pipelineContext.fragmentShader = fragmentShader;
        if (!pipelineContext.isParallelCompiled) {
          this._finalizePipelineContext(pipelineContext);
        }
        return shaderProgram;
      }
      _finalizePipelineContext(pipelineContext) {
        const context = pipelineContext.context;
        const vertexShader = pipelineContext.vertexShader;
        const fragmentShader = pipelineContext.fragmentShader;
        const program = pipelineContext.program;
        const linked = context.getProgramParameter(program, context.LINK_STATUS);
        if (!linked) {
          if (!this._gl.getShaderParameter(vertexShader, this._gl.COMPILE_STATUS)) {
            const log = this._gl.getShaderInfoLog(vertexShader);
            if (log) {
              pipelineContext.vertexCompilationError = log;
              throw new Error("VERTEX SHADER " + log);
            }
          }
          if (!this._gl.getShaderParameter(fragmentShader, this._gl.COMPILE_STATUS)) {
            const log = this._gl.getShaderInfoLog(fragmentShader);
            if (log) {
              pipelineContext.fragmentCompilationError = log;
              throw new Error("FRAGMENT SHADER " + log);
            }
          }
          const error = context.getProgramInfoLog(program);
          if (error) {
            pipelineContext.programLinkError = error;
            throw new Error(error);
          }
        }
        if (this.validateShaderPrograms) {
          context.validateProgram(program);
          const validated = context.getProgramParameter(program, context.VALIDATE_STATUS);
          if (!validated) {
            const error = context.getProgramInfoLog(program);
            if (error) {
              pipelineContext.programValidationError = error;
              throw new Error(error);
            }
          }
        }
        context.deleteShader(vertexShader);
        context.deleteShader(fragmentShader);
        pipelineContext.vertexShader = void 0;
        pipelineContext.fragmentShader = void 0;
        if (pipelineContext.onCompiled) {
          pipelineContext.onCompiled();
          pipelineContext.onCompiled = void 0;
        }
      }
      _preparePipelineContext(pipelineContext, vertexSourceCode, fragmentSourceCode, createAsRaw, rawVertexSourceCode, rawFragmentSourceCode, rebuildRebind, defines, transformFeedbackVaryings, key) {
        const webGLRenderingState = pipelineContext;
        if (createAsRaw) {
          webGLRenderingState.program = this.createRawShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, void 0, transformFeedbackVaryings);
        } else {
          webGLRenderingState.program = this.createShaderProgram(webGLRenderingState, vertexSourceCode, fragmentSourceCode, defines, void 0, transformFeedbackVaryings);
        }
        webGLRenderingState.program.__SPECTOR_rebuildProgram = rebuildRebind;
      }
      _isRenderingStateCompiled(pipelineContext) {
        const webGLPipelineContext = pipelineContext;
        if (this._isDisposed || webGLPipelineContext._isDisposed) {
          return false;
        }
        if (this._gl.getProgramParameter(webGLPipelineContext.program, this._caps.parallelShaderCompile.COMPLETION_STATUS_KHR)) {
          this._finalizePipelineContext(webGLPipelineContext);
          return true;
        }
        return false;
      }
      _executeWhenRenderingStateIsCompiled(pipelineContext, action) {
        const webGLPipelineContext = pipelineContext;
        if (!webGLPipelineContext.isParallelCompiled) {
          action();
          return;
        }
        const oldHandler = webGLPipelineContext.onCompiled;
        if (oldHandler) {
          webGLPipelineContext.onCompiled = () => {
            oldHandler();
            action();
          };
        } else {
          webGLPipelineContext.onCompiled = action;
        }
      }
      getUniforms(pipelineContext, uniformsNames) {
        const results = new Array();
        const webGLPipelineContext = pipelineContext;
        for (let index = 0; index < uniformsNames.length; index++) {
          results.push(this._gl.getUniformLocation(webGLPipelineContext.program, uniformsNames[index]));
        }
        return results;
      }
      getAttributes(pipelineContext, attributesNames) {
        const results = [];
        const webGLPipelineContext = pipelineContext;
        for (let index = 0; index < attributesNames.length; index++) {
          try {
            results.push(this._gl.getAttribLocation(webGLPipelineContext.program, attributesNames[index]));
          } catch (e) {
            results.push(-1);
          }
        }
        return results;
      }
      enableEffect(effect) {
        effect = effect !== null && DrawWrapper.IsWrapper(effect) ? effect.effect : effect;
        if (!effect || effect === this._currentEffect) {
          return;
        }
        this._stencilStateComposer.stencilMaterial = void 0;
        effect = effect;
        this.bindSamplers(effect);
        this._currentEffect = effect;
        if (effect.onBind) {
          effect.onBind(effect);
        }
        if (effect._onBindObservable) {
          effect._onBindObservable.notifyObservers(effect);
        }
      }
      setInt(uniform, value) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1i(uniform, value);
        return true;
      }
      setInt2(uniform, x, y) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform2i(uniform, x, y);
        return true;
      }
      setInt3(uniform, x, y, z) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform3i(uniform, x, y, z);
        return true;
      }
      setInt4(uniform, x, y, z, w) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform4i(uniform, x, y, z, w);
        return true;
      }
      setIntArray(uniform, array) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1iv(uniform, array);
        return true;
      }
      setIntArray2(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
          return false;
        }
        this._gl.uniform2iv(uniform, array);
        return true;
      }
      setIntArray3(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
          return false;
        }
        this._gl.uniform3iv(uniform, array);
        return true;
      }
      setIntArray4(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
          return false;
        }
        this._gl.uniform4iv(uniform, array);
        return true;
      }
      setUInt(uniform, value) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1ui(uniform, value);
        return true;
      }
      setUInt2(uniform, x, y) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform2ui(uniform, x, y);
        return true;
      }
      setUInt3(uniform, x, y, z) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform3ui(uniform, x, y, z);
        return true;
      }
      setUInt4(uniform, x, y, z, w) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform4ui(uniform, x, y, z, w);
        return true;
      }
      setUIntArray(uniform, array) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1uiv(uniform, array);
        return true;
      }
      setUIntArray2(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
          return false;
        }
        this._gl.uniform2uiv(uniform, array);
        return true;
      }
      setUIntArray3(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
          return false;
        }
        this._gl.uniform3uiv(uniform, array);
        return true;
      }
      setUIntArray4(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
          return false;
        }
        this._gl.uniform4uiv(uniform, array);
        return true;
      }
      setArray(uniform, array) {
        if (!uniform) {
          return false;
        }
        if (array.length < 1) {
          return false;
        }
        this._gl.uniform1fv(uniform, array);
        return true;
      }
      setArray2(uniform, array) {
        if (!uniform || array.length % 2 !== 0) {
          return false;
        }
        this._gl.uniform2fv(uniform, array);
        return true;
      }
      setArray3(uniform, array) {
        if (!uniform || array.length % 3 !== 0) {
          return false;
        }
        this._gl.uniform3fv(uniform, array);
        return true;
      }
      setArray4(uniform, array) {
        if (!uniform || array.length % 4 !== 0) {
          return false;
        }
        this._gl.uniform4fv(uniform, array);
        return true;
      }
      setMatrices(uniform, matrices) {
        if (!uniform) {
          return false;
        }
        this._gl.uniformMatrix4fv(uniform, false, matrices);
        return true;
      }
      setMatrix3x3(uniform, matrix) {
        if (!uniform) {
          return false;
        }
        this._gl.uniformMatrix3fv(uniform, false, matrix);
        return true;
      }
      setMatrix2x2(uniform, matrix) {
        if (!uniform) {
          return false;
        }
        this._gl.uniformMatrix2fv(uniform, false, matrix);
        return true;
      }
      setFloat(uniform, value) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform1f(uniform, value);
        return true;
      }
      setFloat2(uniform, x, y) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform2f(uniform, x, y);
        return true;
      }
      setFloat3(uniform, x, y, z) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform3f(uniform, x, y, z);
        return true;
      }
      setFloat4(uniform, x, y, z, w) {
        if (!uniform) {
          return false;
        }
        this._gl.uniform4f(uniform, x, y, z, w);
        return true;
      }
      applyStates() {
        this._depthCullingState.apply(this._gl);
        this._stencilStateComposer.apply(this._gl);
        this._alphaState.apply(this._gl);
        if (this._colorWriteChanged) {
          this._colorWriteChanged = false;
          const enable = this._colorWrite;
          this._gl.colorMask(enable, enable, enable, enable);
        }
      }
      setColorWrite(enable) {
        if (enable !== this._colorWrite) {
          this._colorWriteChanged = true;
          this._colorWrite = enable;
        }
      }
      getColorWrite() {
        return this._colorWrite;
      }
      get depthCullingState() {
        return this._depthCullingState;
      }
      get alphaState() {
        return this._alphaState;
      }
      get stencilState() {
        return this._stencilState;
      }
      get stencilStateComposer() {
        return this._stencilStateComposer;
      }
      clearInternalTexturesCache() {
        this._internalTexturesCache.length = 0;
      }
      wipeCaches(bruteForce) {
        if (this.preventCacheWipeBetweenFrames && !bruteForce) {
          return;
        }
        this._currentEffect = null;
        this._viewportCached.x = 0;
        this._viewportCached.y = 0;
        this._viewportCached.z = 0;
        this._viewportCached.w = 0;
        this._unbindVertexArrayObject();
        if (bruteForce) {
          this._currentProgram = null;
          this.resetTextureCache();
          this._stencilStateComposer.reset();
          this._depthCullingState.reset();
          this._depthCullingState.depthFunc = this._gl.LEQUAL;
          this._alphaState.reset();
          this._alphaMode = 1;
          this._alphaEquation = 0;
          this._colorWrite = true;
          this._colorWriteChanged = true;
          this._unpackFlipYCached = null;
          this._gl.pixelStorei(this._gl.UNPACK_COLORSPACE_CONVERSION_WEBGL, this._gl.NONE);
          this._gl.pixelStorei(this._gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, 0);
          this._mustWipeVertexAttributes = true;
          this.unbindAllAttributes();
        }
        this._resetVertexBufferBinding();
        this._cachedIndexBuffer = null;
        this._cachedEffectForVertexBuffers = null;
        this.bindIndexBuffer(null);
      }
      _getSamplingParameters(samplingMode, generateMipMaps) {
        const gl = this._gl;
        let magFilter = gl.NEAREST;
        let minFilter = gl.NEAREST;
        switch (samplingMode) {
          case 11:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_NEAREST;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 3:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_LINEAR;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 8:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_LINEAR;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 4:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_NEAREST;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 5:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_NEAREST;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 6:
            magFilter = gl.NEAREST;
            if (generateMipMaps) {
              minFilter = gl.LINEAR_MIPMAP_LINEAR;
            } else {
              minFilter = gl.LINEAR;
            }
            break;
          case 7:
            magFilter = gl.NEAREST;
            minFilter = gl.LINEAR;
            break;
          case 1:
            magFilter = gl.NEAREST;
            minFilter = gl.NEAREST;
            break;
          case 9:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_NEAREST;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 10:
            magFilter = gl.LINEAR;
            if (generateMipMaps) {
              minFilter = gl.NEAREST_MIPMAP_LINEAR;
            } else {
              minFilter = gl.NEAREST;
            }
            break;
          case 2:
            magFilter = gl.LINEAR;
            minFilter = gl.LINEAR;
            break;
          case 12:
            magFilter = gl.LINEAR;
            minFilter = gl.NEAREST;
            break;
        }
        return {
          min: minFilter,
          mag: magFilter
        };
      }
      _createTexture() {
        const texture = this._gl.createTexture();
        if (!texture) {
          throw new Error("Unable to create texture");
        }
        return texture;
      }
      _createHardwareTexture() {
        return new WebGLHardwareTexture(this._createTexture(), this._gl);
      }
      _createInternalTexture(size, options, delayGPUTextureCreation = true, source = InternalTextureSource.Unknown) {
        var _a;
        let generateMipMaps = false;
        let type = 0;
        let samplingMode = 3;
        let format = 5;
        let useSRGBBuffer = false;
        let samples = 1;
        let label;
        if (options !== void 0 && typeof options === "object") {
          generateMipMaps = !!options.generateMipMaps;
          type = options.type === void 0 ? 0 : options.type;
          samplingMode = options.samplingMode === void 0 ? 3 : options.samplingMode;
          format = options.format === void 0 ? 5 : options.format;
          useSRGBBuffer = options.useSRGBBuffer === void 0 ? false : options.useSRGBBuffer;
          samples = (_a = options.samples) !== null && _a !== void 0 ? _a : 1;
          label = options.label;
        } else {
          generateMipMaps = !!options;
        }
        useSRGBBuffer && (useSRGBBuffer = this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU));
        if (type === 1 && !this._caps.textureFloatLinearFiltering) {
          samplingMode = 1;
        } else if (type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
          samplingMode = 1;
        }
        if (type === 1 && !this._caps.textureFloat) {
          type = 0;
          Logger.Warn("Float textures are not supported. Type forced to TEXTURETYPE_UNSIGNED_BYTE");
        }
        const gl = this._gl;
        const texture = new InternalTexture(this, source);
        const width = size.width || size;
        const height = size.height || size;
        const layers = size.layers || 0;
        const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
        const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
        const sizedFormat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
        const internalFormat = this._getInternalFormat(format);
        const textureType = this._getWebGLTextureType(type);
        this._bindTextureDirectly(target, texture);
        if (layers !== 0) {
          texture.is2DArray = true;
          gl.texImage3D(target, 0, sizedFormat, width, height, layers, 0, internalFormat, textureType, null);
        } else {
          gl.texImage2D(target, 0, sizedFormat, width, height, 0, internalFormat, textureType, null);
        }
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, filters.min);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (generateMipMaps) {
          this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        texture._useSRGBBuffer = useSRGBBuffer;
        texture.baseWidth = width;
        texture.baseHeight = height;
        texture.width = width;
        texture.height = height;
        texture.depth = layers;
        texture.isReady = true;
        texture.samples = samples;
        texture.generateMipMaps = generateMipMaps;
        texture.samplingMode = samplingMode;
        texture.type = type;
        texture.format = format;
        texture.label = label;
        this._internalTexturesCache.push(texture);
        return texture;
      }
      _getUseSRGBBuffer(useSRGBBuffer, noMipmap) {
        return useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || noMipmap);
      }
      _createTextureBase(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, prepareTexture, prepareTextureProcessFunction, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, useSRGBBuffer) {
        url = url || "";
        const fromData = url.substr(0, 5) === "data:";
        const fromBlob = url.substr(0, 5) === "blob:";
        const isBase64 = fromData && url.indexOf(";base64,") !== -1;
        const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Url);
        if (texture !== fallback) {
          texture.label = url.substring(0, 60);
        }
        const originalUrl = url;
        if (this._transformTextureUrl && !isBase64 && !fallback && !buffer) {
          url = this._transformTextureUrl(url);
        }
        if (originalUrl !== url) {
          texture._originalUrl = originalUrl;
        }
        const lastDot = url.lastIndexOf(".");
        let extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
        let loader = null;
        const queryStringIndex = extension.indexOf("?");
        if (queryStringIndex > -1) {
          extension = extension.split("?")[0];
        }
        for (const availableLoader of ThinEngine._TextureLoaders) {
          if (availableLoader.canLoad(extension, mimeType)) {
            loader = availableLoader;
            break;
          }
        }
        if (scene) {
          scene.addPendingData(texture);
        }
        texture.url = url;
        texture.generateMipMaps = !noMipmap;
        texture.samplingMode = samplingMode;
        texture.invertY = invertY;
        texture._useSRGBBuffer = this._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
        if (!this._doNotHandleContextLost) {
          texture._buffer = buffer;
        }
        let onLoadObserver = null;
        if (onLoad && !fallback) {
          onLoadObserver = texture.onLoadedObservable.add(onLoad);
        }
        if (!fallback) {
          this._internalTexturesCache.push(texture);
        }
        const onInternalError = (message, exception) => {
          if (scene) {
            scene.removePendingData(texture);
          }
          if (url === originalUrl) {
            if (onLoadObserver) {
              texture.onLoadedObservable.remove(onLoadObserver);
            }
            if (EngineStore.UseFallbackTexture) {
              this._createTextureBase(EngineStore.FallbackTexture, noMipmap, texture.invertY, scene, samplingMode, null, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture);
            }
            message = (message || "Unknown error") + (EngineStore.UseFallbackTexture ? " - Fallback texture was used" : "");
            texture.onErrorObservable.notifyObservers({ message, exception });
            if (onError) {
              onError(message, exception);
            }
          } else {
            Logger.Warn(`Failed to load ${url}, falling back to ${originalUrl}`);
            this._createTextureBase(originalUrl, noMipmap, texture.invertY, scene, samplingMode, onLoad, onError, prepareTexture, prepareTextureProcessFunction, buffer, texture, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
          }
        };
        if (loader) {
          const callback = (data) => {
            loader.loadData(data, texture, (width, height, loadMipmap, isCompressed, done, loadFailed) => {
              if (loadFailed) {
                onInternalError("TextureLoader failed to load data");
              } else {
                prepareTexture(texture, extension, scene, { width, height }, texture.invertY, !loadMipmap, isCompressed, () => {
                  done();
                  return false;
                }, samplingMode);
              }
            }, loaderOptions);
          };
          if (!buffer) {
            this._loadFile(url, (data) => callback(new Uint8Array(data)), void 0, scene ? scene.offlineProvider : void 0, true, (request, exception) => {
              onInternalError("Unable to load " + (request ? request.responseURL : url, exception));
            });
          } else {
            if (buffer instanceof ArrayBuffer) {
              callback(new Uint8Array(buffer));
            } else if (ArrayBuffer.isView(buffer)) {
              callback(buffer);
            } else {
              if (onError) {
                onError("Unable to load: only ArrayBuffer or ArrayBufferView is supported", null);
              }
            }
          }
        } else {
          const onload = (img) => {
            if (fromBlob && !this._doNotHandleContextLost) {
              texture._buffer = img;
            }
            prepareTexture(texture, extension, scene, img, texture.invertY, noMipmap, false, prepareTextureProcessFunction, samplingMode);
          };
          if (!fromData || isBase64) {
            if (buffer && (typeof buffer.decoding === "string" || buffer.close)) {
              onload(buffer);
            } else {
              ThinEngine._FileToolsLoadImage(url, onload, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
            }
          } else if (typeof buffer === "string" || buffer instanceof ArrayBuffer || ArrayBuffer.isView(buffer) || buffer instanceof Blob) {
            ThinEngine._FileToolsLoadImage(buffer, onload, onInternalError, scene ? scene.offlineProvider : null, mimeType, texture.invertY && this._features.needsInvertingBitmap ? { imageOrientation: "flipY" } : void 0);
          } else if (buffer) {
            onload(buffer);
          }
        }
        return texture;
      }
      createTexture(url, noMipmap, invertY, scene, samplingMode = 3, onLoad = null, onError = null, buffer = null, fallback = null, format = null, forcedExtension = null, mimeType, loaderOptions, creationFlags, useSRGBBuffer) {
        return this._createTextureBase(url, noMipmap, invertY, scene, samplingMode, onLoad, onError, this._prepareWebGLTexture.bind(this), (potWidth, potHeight, img, extension, texture, continuationCallback) => {
          const gl = this._gl;
          const isPot = img.width === potWidth && img.height === potHeight;
          const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;
          let texelFormat = format ? this._getInternalFormat(format) : extension === ".jpg" && !texture._useSRGBBuffer ? gl.RGB : gl.RGBA;
          if (texture._useSRGBBuffer && this.webGLVersion === 1) {
            texelFormat = internalFormat;
          }
          if (isPot) {
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
            return false;
          }
          const maxTextureSize = this._caps.maxTextureSize;
          if (img.width > maxTextureSize || img.height > maxTextureSize || !this._supportsHardwareTextureRescaling) {
            this._prepareWorkingCanvas();
            if (!this._workingCanvas || !this._workingContext) {
              return false;
            }
            this._workingCanvas.width = potWidth;
            this._workingCanvas.height = potHeight;
            this._workingContext.drawImage(img, 0, 0, img.width, img.height, 0, 0, potWidth, potHeight);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);
            texture.width = potWidth;
            texture.height = potHeight;
            return false;
          } else {
            const source = new InternalTexture(this, InternalTextureSource.Temp);
            this._bindTextureDirectly(gl.TEXTURE_2D, source, true);
            gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, img);
            this._rescaleTexture(source, texture, scene, internalFormat, () => {
              this._releaseTexture(source);
              this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
              continuationCallback();
            });
          }
          return true;
        }, buffer, fallback, format, forcedExtension, mimeType, loaderOptions, useSRGBBuffer);
      }
      static _FileToolsLoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
        throw _WarnImport("FileTools");
      }
      _rescaleTexture(source, destination, scene, internalFormat, onComplete) {
      }
      createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
        throw _WarnImport("Engine.RawTexture");
      }
      createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
        throw _WarnImport("Engine.RawTexture");
      }
      createRawTexture3D(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
        throw _WarnImport("Engine.RawTexture");
      }
      createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
        throw _WarnImport("Engine.RawTexture");
      }
      _unpackFlipY(value) {
        if (this._unpackFlipYCached !== value) {
          this._gl.pixelStorei(this._gl.UNPACK_FLIP_Y_WEBGL, value ? 1 : 0);
          if (this.enableUnpackFlipYCached) {
            this._unpackFlipYCached = value;
          }
        }
      }
      _getUnpackAlignement() {
        return this._gl.getParameter(this._gl.UNPACK_ALIGNMENT);
      }
      _getTextureTarget(texture) {
        if (texture.isCube) {
          return this._gl.TEXTURE_CUBE_MAP;
        } else if (texture.is3D) {
          return this._gl.TEXTURE_3D;
        } else if (texture.is2DArray || texture.isMultiview) {
          return this._gl.TEXTURE_2D_ARRAY;
        }
        return this._gl.TEXTURE_2D;
      }
      updateTextureSamplingMode(samplingMode, texture, generateMipMaps = false) {
        const target = this._getTextureTarget(texture);
        const filters = this._getSamplingParameters(samplingMode, texture.useMipMaps || generateMipMaps);
        this._setTextureParameterInteger(target, this._gl.TEXTURE_MAG_FILTER, filters.mag, texture);
        this._setTextureParameterInteger(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
        if (generateMipMaps) {
          texture.generateMipMaps = true;
          this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(target, null);
        texture.samplingMode = samplingMode;
      }
      updateTextureDimensions(texture, width, height, depth = 1) {
      }
      updateTextureWrappingMode(texture, wrapU, wrapV = null, wrapR = null) {
        const target = this._getTextureTarget(texture);
        if (wrapU !== null) {
          this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(wrapU), texture);
          texture._cachedWrapU = wrapU;
        }
        if (wrapV !== null) {
          this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(wrapV), texture);
          texture._cachedWrapV = wrapV;
        }
        if ((texture.is2DArray || texture.is3D) && wrapR !== null) {
          this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(wrapR), texture);
          texture._cachedWrapR = wrapR;
        }
        this._bindTextureDirectly(target, null);
      }
      _setupDepthStencilTexture(internalTexture, size, generateStencil, bilinearFiltering, comparisonFunction, samples = 1) {
        const width = size.width || size;
        const height = size.height || size;
        const layers = size.layers || 0;
        internalTexture.baseWidth = width;
        internalTexture.baseHeight = height;
        internalTexture.width = width;
        internalTexture.height = height;
        internalTexture.is2DArray = layers > 0;
        internalTexture.depth = layers;
        internalTexture.isReady = true;
        internalTexture.samples = samples;
        internalTexture.generateMipMaps = false;
        internalTexture.samplingMode = bilinearFiltering ? 2 : 1;
        internalTexture.type = 0;
        internalTexture._comparisonFunction = comparisonFunction;
        const gl = this._gl;
        const target = this._getTextureTarget(internalTexture);
        const samplingParameters = this._getSamplingParameters(internalTexture.samplingMode, false);
        gl.texParameteri(target, gl.TEXTURE_MAG_FILTER, samplingParameters.mag);
        gl.texParameteri(target, gl.TEXTURE_MIN_FILTER, samplingParameters.min);
        gl.texParameteri(target, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
        gl.texParameteri(target, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
        if (this.webGLVersion > 1) {
          if (comparisonFunction === 0) {
            gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, 515);
            gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.NONE);
          } else {
            gl.texParameteri(target, gl.TEXTURE_COMPARE_FUNC, comparisonFunction);
            gl.texParameteri(target, gl.TEXTURE_COMPARE_MODE, gl.COMPARE_REF_TO_TEXTURE);
          }
        }
      }
      _uploadCompressedDataToTextureDirectly(texture, internalFormat, width, height, data, faceIndex = 0, lod = 0) {
        const gl = this._gl;
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        if (texture._useSRGBBuffer) {
          switch (internalFormat) {
            case 37492:
            case 36196:
              if (this._caps.etc2) {
                internalFormat = gl.COMPRESSED_SRGB8_ETC2;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            case 37496:
              if (this._caps.etc2) {
                internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ETC2_EAC;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            case 36492:
              internalFormat = gl.COMPRESSED_SRGB_ALPHA_BPTC_UNORM_EXT;
              break;
            case 37808:
              internalFormat = gl.COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR;
              break;
            case 33776:
              if (this._caps.s3tc_srgb) {
                internalFormat = gl.COMPRESSED_SRGB_S3TC_DXT1_EXT;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            case 33777:
              if (this._caps.s3tc_srgb) {
                internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            case 33779:
              if (this._caps.s3tc_srgb) {
                internalFormat = gl.COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT;
              } else {
                texture._useSRGBBuffer = false;
              }
              break;
            default:
              texture._useSRGBBuffer = false;
              break;
          }
        }
        this._gl.compressedTexImage2D(target, lod, internalFormat, width, height, 0, data);
      }
      _uploadDataToTextureDirectly(texture, imageData, faceIndex = 0, lod = 0, babylonInternalFormat, useTextureWidthAndHeight = false) {
        const gl = this._gl;
        const textureType = this._getWebGLTextureType(texture.type);
        const format = this._getInternalFormat(texture.format);
        const internalFormat = babylonInternalFormat === void 0 ? this._getRGBABufferInternalSizedFormat(texture.type, texture.format, texture._useSRGBBuffer) : this._getInternalFormat(babylonInternalFormat, texture._useSRGBBuffer);
        this._unpackFlipY(texture.invertY);
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
        }
        const lodMaxWidth = Math.round(Math.log(texture.width) * Math.LOG2E);
        const lodMaxHeight = Math.round(Math.log(texture.height) * Math.LOG2E);
        const width = useTextureWidthAndHeight ? texture.width : Math.pow(2, Math.max(lodMaxWidth - lod, 0));
        const height = useTextureWidthAndHeight ? texture.height : Math.pow(2, Math.max(lodMaxHeight - lod, 0));
        gl.texImage2D(target, lod, internalFormat, width, height, 0, format, textureType, imageData);
      }
      updateTextureData(texture, imageData, xOffset, yOffset, width, height, faceIndex = 0, lod = 0, generateMipMaps = false) {
        const gl = this._gl;
        const textureType = this._getWebGLTextureType(texture.type);
        const format = this._getInternalFormat(texture.format);
        this._unpackFlipY(texture.invertY);
        let targetForBinding = gl.TEXTURE_2D;
        let target = gl.TEXTURE_2D;
        if (texture.isCube) {
          target = gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex;
          targetForBinding = gl.TEXTURE_CUBE_MAP;
        }
        this._bindTextureDirectly(targetForBinding, texture, true);
        gl.texSubImage2D(target, lod, xOffset, yOffset, width, height, format, textureType, imageData);
        if (generateMipMaps) {
          this._gl.generateMipmap(target);
        }
        this._bindTextureDirectly(targetForBinding, null);
      }
      _uploadArrayBufferViewToTexture(texture, imageData, faceIndex = 0, lod = 0) {
        const gl = this._gl;
        const bindTarget = texture.isCube ? gl.TEXTURE_CUBE_MAP : gl.TEXTURE_2D;
        this._bindTextureDirectly(bindTarget, texture, true);
        this._uploadDataToTextureDirectly(texture, imageData, faceIndex, lod);
        this._bindTextureDirectly(bindTarget, null, true);
      }
      _prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode) {
        const gl = this._gl;
        if (!gl) {
          return;
        }
        const filters = this._getSamplingParameters(samplingMode, !noMipmap);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, filters.mag);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, filters.min);
        if (!noMipmap && !isCompressed) {
          gl.generateMipmap(gl.TEXTURE_2D);
        }
        this._bindTextureDirectly(gl.TEXTURE_2D, null);
        if (scene) {
          scene.removePendingData(texture);
        }
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
      }
      _prepareWebGLTexture(texture, extension, scene, img, invertY, noMipmap, isCompressed, processFunction, samplingMode = 3) {
        const maxTextureSize = this.getCaps().maxTextureSize;
        const potWidth = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine.GetExponentOfTwo(img.width, maxTextureSize) : img.width);
        const potHeight = Math.min(maxTextureSize, this.needPOTTextures ? ThinEngine.GetExponentOfTwo(img.height, maxTextureSize) : img.height);
        const gl = this._gl;
        if (!gl) {
          return;
        }
        if (!texture._hardwareTexture) {
          if (scene) {
            scene.removePendingData(texture);
          }
          return;
        }
        this._bindTextureDirectly(gl.TEXTURE_2D, texture, true);
        this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
        texture.baseWidth = img.width;
        texture.baseHeight = img.height;
        texture.width = potWidth;
        texture.height = potHeight;
        texture.isReady = true;
        if (processFunction(potWidth, potHeight, img, extension, texture, () => {
          this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
        })) {
          return;
        }
        this._prepareWebGLTextureContinuation(texture, scene, noMipmap, isCompressed, samplingMode);
      }
      _setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height, samples = 1) {
        const gl = this._gl;
        if (generateStencilBuffer && generateDepthBuffer) {
          return this._createRenderBuffer(width, height, samples, gl.DEPTH_STENCIL, gl.DEPTH24_STENCIL8, gl.DEPTH_STENCIL_ATTACHMENT);
        }
        if (generateDepthBuffer) {
          let depthFormat = gl.DEPTH_COMPONENT16;
          if (this._webGLVersion > 1) {
            depthFormat = gl.DEPTH_COMPONENT32F;
          }
          return this._createRenderBuffer(width, height, samples, depthFormat, depthFormat, gl.DEPTH_ATTACHMENT);
        }
        if (generateStencilBuffer) {
          return this._createRenderBuffer(width, height, samples, gl.STENCIL_INDEX8, gl.STENCIL_INDEX8, gl.STENCIL_ATTACHMENT);
        }
        return null;
      }
      _createRenderBuffer(width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
        const gl = this._gl;
        const renderBuffer = gl.createRenderbuffer();
        return this._updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer);
      }
      _updateRenderBuffer(renderBuffer, width, height, samples, internalFormat, msInternalFormat, attachment, unbindBuffer = true) {
        const gl = this._gl;
        gl.bindRenderbuffer(gl.RENDERBUFFER, renderBuffer);
        if (samples > 1 && gl.renderbufferStorageMultisample) {
          gl.renderbufferStorageMultisample(gl.RENDERBUFFER, samples, msInternalFormat, width, height);
        } else {
          gl.renderbufferStorage(gl.RENDERBUFFER, internalFormat, width, height);
        }
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, renderBuffer);
        if (unbindBuffer) {
          gl.bindRenderbuffer(gl.RENDERBUFFER, null);
        }
        return renderBuffer;
      }
      _releaseTexture(texture) {
        var _a;
        this._deleteTexture((_a = texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource);
        this.unbindAllTextures();
        const index = this._internalTexturesCache.indexOf(texture);
        if (index !== -1) {
          this._internalTexturesCache.splice(index, 1);
        }
        if (texture._lodTextureHigh) {
          texture._lodTextureHigh.dispose();
        }
        if (texture._lodTextureMid) {
          texture._lodTextureMid.dispose();
        }
        if (texture._lodTextureLow) {
          texture._lodTextureLow.dispose();
        }
        if (texture._irradianceTexture) {
          texture._irradianceTexture.dispose();
        }
      }
      _releaseRenderTargetWrapper(rtWrapper) {
        const index = this._renderTargetWrapperCache.indexOf(rtWrapper);
        if (index !== -1) {
          this._renderTargetWrapperCache.splice(index, 1);
        }
      }
      _deleteTexture(texture) {
        if (texture) {
          this._gl.deleteTexture(texture);
        }
      }
      _setProgram(program) {
        if (this._currentProgram !== program) {
          this._gl.useProgram(program);
          this._currentProgram = program;
        }
      }
      bindSamplers(effect) {
        const webGLPipelineContext = effect.getPipelineContext();
        this._setProgram(webGLPipelineContext.program);
        const samplers = effect.getSamplers();
        for (let index = 0; index < samplers.length; index++) {
          const uniform = effect.getUniform(samplers[index]);
          if (uniform) {
            this._boundUniforms[index] = uniform;
          }
        }
        this._currentEffect = null;
      }
      _activateCurrentTexture() {
        if (this._currentTextureChannel !== this._activeChannel) {
          this._gl.activeTexture(this._gl.TEXTURE0 + this._activeChannel);
          this._currentTextureChannel = this._activeChannel;
        }
      }
      _bindTextureDirectly(target, texture, forTextureDataUpdate = false, force = false) {
        var _a, _b;
        let wasPreviouslyBound = false;
        const isTextureForRendering = texture && texture._associatedChannel > -1;
        if (forTextureDataUpdate && isTextureForRendering) {
          this._activeChannel = texture._associatedChannel;
        }
        const currentTextureBound = this._boundTexturesCache[this._activeChannel];
        if (currentTextureBound !== texture || force) {
          this._activateCurrentTexture();
          if (texture && texture.isMultiview) {
            console.error(target, texture);
            throw "_bindTextureDirectly called with a multiview texture!";
          } else {
            this._gl.bindTexture(target, (_b = (_a = texture === null || texture === void 0 ? void 0 : texture._hardwareTexture) === null || _a === void 0 ? void 0 : _a.underlyingResource) !== null && _b !== void 0 ? _b : null);
          }
          this._boundTexturesCache[this._activeChannel] = texture;
          if (texture) {
            texture._associatedChannel = this._activeChannel;
          }
        } else if (forTextureDataUpdate) {
          wasPreviouslyBound = true;
          this._activateCurrentTexture();
        }
        if (isTextureForRendering && !forTextureDataUpdate) {
          this._bindSamplerUniformToChannel(texture._associatedChannel, this._activeChannel);
        }
        return wasPreviouslyBound;
      }
      _bindTexture(channel, texture, name) {
        if (channel === void 0) {
          return;
        }
        if (texture) {
          texture._associatedChannel = channel;
        }
        this._activeChannel = channel;
        const target = texture ? this._getTextureTarget(texture) : this._gl.TEXTURE_2D;
        this._bindTextureDirectly(target, texture);
      }
      unbindAllTextures() {
        for (let channel = 0; channel < this._maxSimultaneousTextures; channel++) {
          this._activeChannel = channel;
          this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
          this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
          if (this.webGLVersion > 1) {
            this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
            this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
          }
        }
      }
      setTexture(channel, uniform, texture, name) {
        if (channel === void 0) {
          return;
        }
        if (uniform) {
          this._boundUniforms[channel] = uniform;
        }
        this._setTexture(channel, texture);
      }
      _bindSamplerUniformToChannel(sourceSlot, destination) {
        const uniform = this._boundUniforms[sourceSlot];
        if (!uniform || uniform._currentState === destination) {
          return;
        }
        this._gl.uniform1i(uniform, destination);
        uniform._currentState = destination;
      }
      _getTextureWrapMode(mode) {
        switch (mode) {
          case 1:
            return this._gl.REPEAT;
          case 0:
            return this._gl.CLAMP_TO_EDGE;
          case 2:
            return this._gl.MIRRORED_REPEAT;
        }
        return this._gl.REPEAT;
      }
      _setTexture(channel, texture, isPartOfTextureArray = false, depthStencilTexture = false, name = "") {
        if (!texture) {
          if (this._boundTexturesCache[channel] != null) {
            this._activeChannel = channel;
            this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
            this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
            if (this.webGLVersion > 1) {
              this._bindTextureDirectly(this._gl.TEXTURE_3D, null);
              this._bindTextureDirectly(this._gl.TEXTURE_2D_ARRAY, null);
            }
          }
          return false;
        }
        if (texture.video) {
          this._activeChannel = channel;
          const videoInternalTexture = texture.getInternalTexture();
          if (videoInternalTexture) {
            videoInternalTexture._associatedChannel = channel;
          }
          texture.update();
        } else if (texture.delayLoadState === 4) {
          texture.delayLoad();
          return false;
        }
        let internalTexture;
        if (depthStencilTexture) {
          internalTexture = texture.depthStencilTexture;
        } else if (texture.isReady()) {
          internalTexture = texture.getInternalTexture();
        } else if (texture.isCube) {
          internalTexture = this.emptyCubeTexture;
        } else if (texture.is3D) {
          internalTexture = this.emptyTexture3D;
        } else if (texture.is2DArray) {
          internalTexture = this.emptyTexture2DArray;
        } else {
          internalTexture = this.emptyTexture;
        }
        if (!isPartOfTextureArray && internalTexture) {
          internalTexture._associatedChannel = channel;
        }
        let needToBind = true;
        if (this._boundTexturesCache[channel] === internalTexture) {
          if (!isPartOfTextureArray) {
            this._bindSamplerUniformToChannel(internalTexture._associatedChannel, channel);
          }
          needToBind = false;
        }
        this._activeChannel = channel;
        const target = this._getTextureTarget(internalTexture);
        if (needToBind) {
          this._bindTextureDirectly(target, internalTexture, isPartOfTextureArray);
        }
        if (internalTexture && !internalTexture.isMultiview) {
          if (internalTexture.isCube && internalTexture._cachedCoordinatesMode !== texture.coordinatesMode) {
            internalTexture._cachedCoordinatesMode = texture.coordinatesMode;
            const textureWrapMode = texture.coordinatesMode !== 3 && texture.coordinatesMode !== 5 ? 1 : 0;
            texture.wrapU = textureWrapMode;
            texture.wrapV = textureWrapMode;
          }
          if (internalTexture._cachedWrapU !== texture.wrapU) {
            internalTexture._cachedWrapU = texture.wrapU;
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_S, this._getTextureWrapMode(texture.wrapU), internalTexture);
          }
          if (internalTexture._cachedWrapV !== texture.wrapV) {
            internalTexture._cachedWrapV = texture.wrapV;
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_T, this._getTextureWrapMode(texture.wrapV), internalTexture);
          }
          if (internalTexture.is3D && internalTexture._cachedWrapR !== texture.wrapR) {
            internalTexture._cachedWrapR = texture.wrapR;
            this._setTextureParameterInteger(target, this._gl.TEXTURE_WRAP_R, this._getTextureWrapMode(texture.wrapR), internalTexture);
          }
          this._setAnisotropicLevel(target, internalTexture, texture.anisotropicFilteringLevel);
        }
        return true;
      }
      setTextureArray(channel, uniform, textures, name) {
        if (channel === void 0 || !uniform) {
          return;
        }
        if (!this._textureUnits || this._textureUnits.length !== textures.length) {
          this._textureUnits = new Int32Array(textures.length);
        }
        for (let i = 0; i < textures.length; i++) {
          const texture = textures[i].getInternalTexture();
          if (texture) {
            this._textureUnits[i] = channel + i;
            texture._associatedChannel = channel + i;
          } else {
            this._textureUnits[i] = -1;
          }
        }
        this._gl.uniform1iv(uniform, this._textureUnits);
        for (let index = 0; index < textures.length; index++) {
          this._setTexture(this._textureUnits[index], textures[index], true);
        }
      }
      _setAnisotropicLevel(target, internalTexture, anisotropicFilteringLevel) {
        const anisotropicFilterExtension = this._caps.textureAnisotropicFilterExtension;
        if (internalTexture.samplingMode !== 11 && internalTexture.samplingMode !== 3 && internalTexture.samplingMode !== 2) {
          anisotropicFilteringLevel = 1;
        }
        if (anisotropicFilterExtension && internalTexture._cachedAnisotropicFilteringLevel !== anisotropicFilteringLevel) {
          this._setTextureParameterFloat(target, anisotropicFilterExtension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min(anisotropicFilteringLevel, this._caps.maxAnisotropy), internalTexture);
          internalTexture._cachedAnisotropicFilteringLevel = anisotropicFilteringLevel;
        }
      }
      _setTextureParameterFloat(target, parameter, value, texture) {
        this._bindTextureDirectly(target, texture, true, true);
        this._gl.texParameterf(target, parameter, value);
      }
      _setTextureParameterInteger(target, parameter, value, texture) {
        if (texture) {
          this._bindTextureDirectly(target, texture, true, true);
        }
        this._gl.texParameteri(target, parameter, value);
      }
      unbindAllAttributes() {
        if (this._mustWipeVertexAttributes) {
          this._mustWipeVertexAttributes = false;
          for (let i = 0; i < this._caps.maxVertexAttribs; i++) {
            this.disableAttributeByIndex(i);
          }
          return;
        }
        for (let i = 0, ul = this._vertexAttribArraysEnabled.length; i < ul; i++) {
          if (i >= this._caps.maxVertexAttribs || !this._vertexAttribArraysEnabled[i]) {
            continue;
          }
          this.disableAttributeByIndex(i);
        }
      }
      releaseEffects() {
        for (const name in this._compiledEffects) {
          const webGLPipelineContext = this._compiledEffects[name].getPipelineContext();
          this._deletePipelineContext(webGLPipelineContext);
        }
        this._compiledEffects = {};
      }
      dispose() {
        var _a;
        this._isDisposed = true;
        this.stopRenderLoop();
        if (this.onBeforeTextureInitObservable) {
          this.onBeforeTextureInitObservable.clear();
        }
        if (this._emptyTexture) {
          this._releaseTexture(this._emptyTexture);
          this._emptyTexture = null;
        }
        if (this._emptyCubeTexture) {
          this._releaseTexture(this._emptyCubeTexture);
          this._emptyCubeTexture = null;
        }
        if (this._dummyFramebuffer) {
          this._gl.deleteFramebuffer(this._dummyFramebuffer);
        }
        this.releaseEffects();
        (_a = this.releaseComputeEffects) === null || _a === void 0 ? void 0 : _a.call(this);
        this.unbindAllAttributes();
        this._boundUniforms = {};
        if (IsWindowObjectExist()) {
          if (this._renderingCanvas) {
            if (!this._doNotHandleContextLost) {
              this._renderingCanvas.removeEventListener("webglcontextlost", this._onContextLost);
              this._renderingCanvas.removeEventListener("webglcontextrestored", this._onContextRestored);
            }
            window.removeEventListener("resize", this._checkForMobile);
          }
        }
        this._workingCanvas = null;
        this._workingContext = null;
        this._currentBufferPointers.length = 0;
        this._renderingCanvas = null;
        this._currentProgram = null;
        this._boundRenderFunction = null;
        Effect.ResetCache();
        for (const request of this._activeRequests) {
          request.abort();
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
      }
      attachContextLostEvent(callback) {
        if (this._renderingCanvas) {
          this._renderingCanvas.addEventListener("webglcontextlost", callback, false);
        }
      }
      attachContextRestoredEvent(callback) {
        if (this._renderingCanvas) {
          this._renderingCanvas.addEventListener("webglcontextrestored", callback, false);
        }
      }
      getError() {
        return this._gl.getError();
      }
      _canRenderToFloatFramebuffer() {
        if (this._webGLVersion > 1) {
          return this._caps.colorBufferFloat;
        }
        return this._canRenderToFramebuffer(1);
      }
      _canRenderToHalfFloatFramebuffer() {
        if (this._webGLVersion > 1) {
          return this._caps.colorBufferFloat;
        }
        return this._canRenderToFramebuffer(2);
      }
      _canRenderToFramebuffer(type) {
        const gl = this._gl;
        while (gl.getError() !== gl.NO_ERROR) {
        }
        let successful = true;
        const texture = gl.createTexture();
        gl.bindTexture(gl.TEXTURE_2D, texture);
        gl.texImage2D(gl.TEXTURE_2D, 0, this._getRGBABufferInternalSizedFormat(type), 1, 1, 0, gl.RGBA, this._getWebGLTextureType(type), null);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.NEAREST);
        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.NEAREST);
        const fb = gl.createFramebuffer();
        gl.bindFramebuffer(gl.FRAMEBUFFER, fb);
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture, 0);
        const status = gl.checkFramebufferStatus(gl.FRAMEBUFFER);
        successful = successful && status === gl.FRAMEBUFFER_COMPLETE;
        successful = successful && gl.getError() === gl.NO_ERROR;
        if (successful) {
          gl.clear(gl.COLOR_BUFFER_BIT);
          successful = successful && gl.getError() === gl.NO_ERROR;
        }
        if (successful) {
          gl.bindFramebuffer(gl.FRAMEBUFFER, null);
          const readFormat = gl.RGBA;
          const readType = gl.UNSIGNED_BYTE;
          const buffer = new Uint8Array(4);
          gl.readPixels(0, 0, 1, 1, readFormat, readType, buffer);
          successful = successful && gl.getError() === gl.NO_ERROR;
        }
        gl.deleteTexture(texture);
        gl.deleteFramebuffer(fb);
        gl.bindFramebuffer(gl.FRAMEBUFFER, null);
        while (!successful && gl.getError() !== gl.NO_ERROR) {
        }
        return successful;
      }
      _getWebGLTextureType(type) {
        if (this._webGLVersion === 1) {
          switch (type) {
            case 1:
              return this._gl.FLOAT;
            case 2:
              return this._gl.HALF_FLOAT_OES;
            case 0:
              return this._gl.UNSIGNED_BYTE;
            case 8:
              return this._gl.UNSIGNED_SHORT_4_4_4_4;
            case 9:
              return this._gl.UNSIGNED_SHORT_5_5_5_1;
            case 10:
              return this._gl.UNSIGNED_SHORT_5_6_5;
          }
          return this._gl.UNSIGNED_BYTE;
        }
        switch (type) {
          case 3:
            return this._gl.BYTE;
          case 0:
            return this._gl.UNSIGNED_BYTE;
          case 4:
            return this._gl.SHORT;
          case 5:
            return this._gl.UNSIGNED_SHORT;
          case 6:
            return this._gl.INT;
          case 7:
            return this._gl.UNSIGNED_INT;
          case 1:
            return this._gl.FLOAT;
          case 2:
            return this._gl.HALF_FLOAT;
          case 8:
            return this._gl.UNSIGNED_SHORT_4_4_4_4;
          case 9:
            return this._gl.UNSIGNED_SHORT_5_5_5_1;
          case 10:
            return this._gl.UNSIGNED_SHORT_5_6_5;
          case 11:
            return this._gl.UNSIGNED_INT_2_10_10_10_REV;
          case 12:
            return this._gl.UNSIGNED_INT_24_8;
          case 13:
            return this._gl.UNSIGNED_INT_10F_11F_11F_REV;
          case 14:
            return this._gl.UNSIGNED_INT_5_9_9_9_REV;
          case 15:
            return this._gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
        }
        return this._gl.UNSIGNED_BYTE;
      }
      _getInternalFormat(format, useSRGBBuffer = false) {
        let internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
        switch (format) {
          case 0:
            internalFormat = this._gl.ALPHA;
            break;
          case 1:
            internalFormat = this._gl.LUMINANCE;
            break;
          case 2:
            internalFormat = this._gl.LUMINANCE_ALPHA;
            break;
          case 6:
            internalFormat = this._gl.RED;
            break;
          case 7:
            internalFormat = this._gl.RG;
            break;
          case 4:
            internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
            break;
          case 5:
            internalFormat = useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA;
            break;
        }
        if (this._webGLVersion > 1) {
          switch (format) {
            case 8:
              internalFormat = this._gl.RED_INTEGER;
              break;
            case 9:
              internalFormat = this._gl.RG_INTEGER;
              break;
            case 10:
              internalFormat = this._gl.RGB_INTEGER;
              break;
            case 11:
              internalFormat = this._gl.RGBA_INTEGER;
              break;
          }
        }
        return internalFormat;
      }
      _getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer = false) {
        if (this._webGLVersion === 1) {
          if (format !== void 0) {
            switch (format) {
              case 0:
                return this._gl.ALPHA;
              case 1:
                return this._gl.LUMINANCE;
              case 2:
                return this._gl.LUMINANCE_ALPHA;
              case 4:
                return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB : this._gl.RGB;
            }
          }
          return this._gl.RGBA;
        }
        switch (type) {
          case 3:
            switch (format) {
              case 6:
                return this._gl.R8_SNORM;
              case 7:
                return this._gl.RG8_SNORM;
              case 4:
                return this._gl.RGB8_SNORM;
              case 8:
                return this._gl.R8I;
              case 9:
                return this._gl.RG8I;
              case 10:
                return this._gl.RGB8I;
              case 11:
                return this._gl.RGBA8I;
              default:
                return this._gl.RGBA8_SNORM;
            }
          case 0:
            switch (format) {
              case 6:
                return this._gl.R8;
              case 7:
                return this._gl.RG8;
              case 4:
                return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8 : this._gl.RGB8;
              case 5:
                return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
              case 8:
                return this._gl.R8UI;
              case 9:
                return this._gl.RG8UI;
              case 10:
                return this._gl.RGB8UI;
              case 11:
                return this._gl.RGBA8UI;
              case 0:
                return this._gl.ALPHA;
              case 1:
                return this._gl.LUMINANCE;
              case 2:
                return this._gl.LUMINANCE_ALPHA;
              default:
                return this._gl.RGBA8;
            }
          case 4:
            switch (format) {
              case 8:
                return this._gl.R16I;
              case 9:
                return this._gl.RG16I;
              case 10:
                return this._gl.RGB16I;
              case 11:
                return this._gl.RGBA16I;
              default:
                return this._gl.RGBA16I;
            }
          case 5:
            switch (format) {
              case 8:
                return this._gl.R16UI;
              case 9:
                return this._gl.RG16UI;
              case 10:
                return this._gl.RGB16UI;
              case 11:
                return this._gl.RGBA16UI;
              default:
                return this._gl.RGBA16UI;
            }
          case 6:
            switch (format) {
              case 8:
                return this._gl.R32I;
              case 9:
                return this._gl.RG32I;
              case 10:
                return this._gl.RGB32I;
              case 11:
                return this._gl.RGBA32I;
              default:
                return this._gl.RGBA32I;
            }
          case 7:
            switch (format) {
              case 8:
                return this._gl.R32UI;
              case 9:
                return this._gl.RG32UI;
              case 10:
                return this._gl.RGB32UI;
              case 11:
                return this._gl.RGBA32UI;
              default:
                return this._gl.RGBA32UI;
            }
          case 1:
            switch (format) {
              case 6:
                return this._gl.R32F;
              case 7:
                return this._gl.RG32F;
              case 4:
                return this._gl.RGB32F;
              case 5:
                return this._gl.RGBA32F;
              default:
                return this._gl.RGBA32F;
            }
          case 2:
            switch (format) {
              case 6:
                return this._gl.R16F;
              case 7:
                return this._gl.RG16F;
              case 4:
                return this._gl.RGB16F;
              case 5:
                return this._gl.RGBA16F;
              default:
                return this._gl.RGBA16F;
            }
          case 10:
            return this._gl.RGB565;
          case 13:
            return this._gl.R11F_G11F_B10F;
          case 14:
            return this._gl.RGB9_E5;
          case 8:
            return this._gl.RGBA4;
          case 9:
            return this._gl.RGB5_A1;
          case 11:
            switch (format) {
              case 5:
                return this._gl.RGB10_A2;
              case 11:
                return this._gl.RGB10_A2UI;
              default:
                return this._gl.RGB10_A2;
            }
        }
        return useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : this._gl.RGBA8;
      }
      _getRGBAMultiSampleBufferFormat(type, format = 5) {
        switch (type) {
          case 1:
            switch (format) {
              case 6:
                return this._gl.R32F;
              default:
                return this._gl.RGBA32F;
            }
          case 2:
            switch (format) {
              case 6:
                return this._gl.R16F;
              default:
                return this._gl.RGBA16F;
            }
        }
        return this._gl.RGBA8;
      }
      _loadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        const request = ThinEngine._FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
        this._activeRequests.push(request);
        request.onCompleteObservable.add((request2) => {
          this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
        });
        return request;
      }
      static _FileToolsLoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        throw _WarnImport("FileTools");
      }
      readPixels(x, y, width, height, hasAlpha = true, flushRenderer = true) {
        const numChannels = hasAlpha ? 4 : 3;
        const format = hasAlpha ? this._gl.RGBA : this._gl.RGB;
        const data = new Uint8Array(height * width * numChannels);
        if (flushRenderer) {
          this.flushFramebuffer();
        }
        this._gl.readPixels(x, y, width, height, format, this._gl.UNSIGNED_BYTE, data);
        return Promise.resolve(data);
      }
      static get IsSupportedAsync() {
        return Promise.resolve(this.isSupported());
      }
      static get IsSupported() {
        return this.isSupported();
      }
      static isSupported() {
        if (this._HasMajorPerformanceCaveat !== null) {
          return !this._HasMajorPerformanceCaveat;
        }
        if (this._IsSupported === null) {
          try {
            const tempcanvas = this._CreateCanvas(1, 1);
            const gl = tempcanvas.getContext("webgl") || tempcanvas.getContext("experimental-webgl");
            this._IsSupported = gl != null && !!window.WebGLRenderingContext;
          } catch (e) {
            this._IsSupported = false;
          }
        }
        return this._IsSupported;
      }
      static get HasMajorPerformanceCaveat() {
        if (this._HasMajorPerformanceCaveat === null) {
          try {
            const tempcanvas = this._CreateCanvas(1, 1);
            const gl = tempcanvas.getContext("webgl", { failIfMajorPerformanceCaveat: true }) || tempcanvas.getContext("experimental-webgl", { failIfMajorPerformanceCaveat: true });
            this._HasMajorPerformanceCaveat = !gl;
          } catch (e) {
            this._HasMajorPerformanceCaveat = false;
          }
        }
        return this._HasMajorPerformanceCaveat;
      }
      static CeilingPOT(x) {
        x--;
        x |= x >> 1;
        x |= x >> 2;
        x |= x >> 4;
        x |= x >> 8;
        x |= x >> 16;
        x++;
        return x;
      }
      static FloorPOT(x) {
        x = x | x >> 1;
        x = x | x >> 2;
        x = x | x >> 4;
        x = x | x >> 8;
        x = x | x >> 16;
        return x - (x >> 1);
      }
      static NearestPOT(x) {
        const c = ThinEngine.CeilingPOT(x);
        const f = ThinEngine.FloorPOT(x);
        return c - x > x - f ? f : c;
      }
      static GetExponentOfTwo(value, max, mode = 2) {
        let pot;
        switch (mode) {
          case 1:
            pot = ThinEngine.FloorPOT(value);
            break;
          case 2:
            pot = ThinEngine.NearestPOT(value);
            break;
          case 3:
          default:
            pot = ThinEngine.CeilingPOT(value);
            break;
        }
        return Math.min(pot, max);
      }
      static QueueNewFrame(func, requester) {
        if (!IsWindowObjectExist()) {
          if (typeof requestAnimationFrame === "function") {
            return requestAnimationFrame(func);
          }
        } else {
          const { requestAnimationFrame: requestAnimationFrame2 } = requester || window;
          if (typeof requestAnimationFrame2 === "function") {
            return requestAnimationFrame2(func);
          }
        }
        return setTimeout(func, 16);
      }
      getHostDocument() {
        if (this._renderingCanvas && this._renderingCanvas.ownerDocument) {
          return this._renderingCanvas.ownerDocument;
        }
        return IsDocumentAvailable() ? document : null;
      }
    };
    ThinEngine._TempClearColorUint32 = new Uint32Array(4);
    ThinEngine._TempClearColorInt32 = new Int32Array(4);
    ThinEngine.ExceptionList = [
      { key: "Chrome/63.0", capture: "63\\.0\\.3239\\.(\\d+)", captureConstraint: 108, targets: ["uniformBuffer"] },
      { key: "Firefox/58", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
      { key: "Firefox/59", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
      { key: "Chrome/72.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
      { key: "Chrome/73.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
      { key: "Chrome/74.+?Mobile", capture: null, captureConstraint: null, targets: ["vao"] },
      { key: "Mac OS.+Chrome/71", capture: null, captureConstraint: null, targets: ["vao"] },
      { key: "Mac OS.+Chrome/72", capture: null, captureConstraint: null, targets: ["vao"] },
      { key: "Mac OS.+Chrome", capture: null, captureConstraint: null, targets: ["uniformBuffer"] },
      { key: ".*AppleWebKit.*(15.4).*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] },
      { key: ".*(15.4).*AppleWebKit.*Safari", capture: null, captureConstraint: null, targets: ["antialias", "maxMSAASamples"] }
    ];
    ThinEngine._TextureLoaders = [];
    ThinEngine.CollisionsEpsilon = 1e-3;
    ThinEngine._IsSupported = null;
    ThinEngine._HasMajorPerformanceCaveat = null;
  }
});

// node_modules/@babylonjs/core/Misc/timingTools.js
var TimingTools;
var init_timingTools = __esm({
  "node_modules/@babylonjs/core/Misc/timingTools.js"() {
    init_domManagement();
    TimingTools = class {
      static SetImmediate(action) {
        if (IsWindowObjectExist() && window.setImmediate) {
          window.setImmediate(action);
        } else {
          setTimeout(action, 1);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/fileTools.js
function DecodeBase64UrlToBinary(uri) {
  return DecodeBase64ToBinary(uri.split(",")[1]);
}
var Base64DataUrlRegEx, LoadFileError, RequestFileError, ReadFileError, FileToolsOptions, _CleanUrl, SetCorsBehavior, LoadImage, ReadFile, LoadFile, RequestFile, IsFileURL, IsBase64DataUrl, TestBase64DataUrl, DecodeBase64UrlToString, initSideEffects, FileTools, _injectLTSFileTools;
var init_fileTools = __esm({
  "node_modules/@babylonjs/core/Misc/fileTools.js"() {
    init_webRequest();
    init_domManagement();
    init_observable();
    init_filesInputStore();
    init_retryStrategy();
    init_error();
    init_stringTools();
    init_shaderProcessor();
    init_thinEngine();
    init_engineStore();
    init_logger();
    init_timingTools();
    Base64DataUrlRegEx = new RegExp(/^data:([^,]+\/[^,]+)?;base64,/i);
    LoadFileError = class extends RuntimeError {
      constructor(message, object) {
        super(message, ErrorCodes.LoadFileError);
        this.name = "LoadFileError";
        BaseError._setPrototypeOf(this, LoadFileError.prototype);
        if (object instanceof WebRequest) {
          this.request = object;
        } else {
          this.file = object;
        }
      }
    };
    RequestFileError = class extends RuntimeError {
      constructor(message, request) {
        super(message, ErrorCodes.RequestFileError);
        this.request = request;
        this.name = "RequestFileError";
        BaseError._setPrototypeOf(this, RequestFileError.prototype);
      }
    };
    ReadFileError = class extends RuntimeError {
      constructor(message, file) {
        super(message, ErrorCodes.ReadFileError);
        this.file = file;
        this.name = "ReadFileError";
        BaseError._setPrototypeOf(this, ReadFileError.prototype);
      }
    };
    FileToolsOptions = {
      DefaultRetryStrategy: RetryStrategy.ExponentialBackoff(),
      BaseUrl: "",
      CorsBehavior: "anonymous",
      PreprocessUrl: (url) => {
        return url;
      }
    };
    _CleanUrl = (url) => {
      url = url.replace(/#/gm, "%23");
      return url;
    };
    SetCorsBehavior = (url, element) => {
      if (url && url.indexOf("data:") === 0) {
        return;
      }
      if (FileToolsOptions.CorsBehavior) {
        if (typeof FileToolsOptions.CorsBehavior === "string" || FileToolsOptions.CorsBehavior instanceof String) {
          element.crossOrigin = FileToolsOptions.CorsBehavior;
        } else {
          const result = FileToolsOptions.CorsBehavior(url);
          if (result) {
            element.crossOrigin = result;
          }
        }
      }
    };
    LoadImage = (input, onLoad, onError, offlineProvider, mimeType = "", imageBitmapOptions) => {
      var _a;
      let url;
      let usingObjectURL = false;
      if (input instanceof ArrayBuffer || ArrayBuffer.isView(input)) {
        if (typeof Blob !== "undefined" && typeof URL !== "undefined") {
          url = URL.createObjectURL(new Blob([input], { type: mimeType }));
          usingObjectURL = true;
        } else {
          url = `data:${mimeType};base64,` + EncodeArrayBufferToBase64(input);
        }
      } else if (input instanceof Blob) {
        url = URL.createObjectURL(input);
        usingObjectURL = true;
      } else {
        url = _CleanUrl(input);
        url = FileToolsOptions.PreprocessUrl(input);
      }
      const engine = EngineStore.LastCreatedEngine;
      const onErrorHandler = (exception) => {
        if (onError) {
          const inputText = url || input.toString();
          onError(`Error while trying to load image: ${inputText.indexOf("http") === 0 || inputText.length <= 128 ? inputText : inputText.slice(0, 128) + "..."}`, exception);
        }
      };
      if (typeof Image === "undefined" || ((_a = engine === null || engine === void 0 ? void 0 : engine._features.forceBitmapOverHTMLImageElement) !== null && _a !== void 0 ? _a : false)) {
        LoadFile(url, (data) => {
          engine.createImageBitmap(new Blob([data], { type: mimeType }), Object.assign({ premultiplyAlpha: "none" }, imageBitmapOptions)).then((imgBmp) => {
            onLoad(imgBmp);
            if (usingObjectURL) {
              URL.revokeObjectURL(url);
            }
          }).catch((reason) => {
            if (onError) {
              onError("Error while trying to load image: " + input, reason);
            }
          });
        }, void 0, offlineProvider || void 0, true, (request, exception) => {
          onErrorHandler(exception);
        });
        return null;
      }
      const img = new Image();
      SetCorsBehavior(url, img);
      const handlersList = [];
      const loadHandlersList = () => {
        handlersList.forEach((handler) => {
          handler.target.addEventListener(handler.name, handler.handler);
        });
      };
      const unloadHandlersList = () => {
        handlersList.forEach((handler) => {
          handler.target.removeEventListener(handler.name, handler.handler);
        });
        handlersList.length = 0;
      };
      const loadHandler = () => {
        unloadHandlersList();
        onLoad(img);
        if (usingObjectURL && img.src) {
          URL.revokeObjectURL(img.src);
        }
      };
      const errorHandler = (err) => {
        unloadHandlersList();
        onErrorHandler(err);
        if (usingObjectURL && img.src) {
          URL.revokeObjectURL(img.src);
        }
      };
      const cspHandler = (err) => {
        if (err.blockedURI !== img.src) {
          return;
        }
        unloadHandlersList();
        const cspException = new Error(`CSP violation of policy ${err.effectiveDirective} ${err.blockedURI}. Current policy is ${err.originalPolicy}`);
        EngineStore.UseFallbackTexture = false;
        onErrorHandler(cspException);
        if (usingObjectURL && img.src) {
          URL.revokeObjectURL(img.src);
        }
        img.src = "";
      };
      handlersList.push({ target: img, name: "load", handler: loadHandler });
      handlersList.push({ target: img, name: "error", handler: errorHandler });
      handlersList.push({ target: document, name: "securitypolicyviolation", handler: cspHandler });
      loadHandlersList();
      const fromBlob = url.substring(0, 5) === "blob:";
      const fromData = url.substring(0, 5) === "data:";
      const noOfflineSupport = () => {
        if (fromBlob || fromData) {
          img.src = url;
        } else {
          LoadFile(url, (data, _, contentType) => {
            const type = !mimeType && contentType ? contentType : mimeType;
            const blob = new Blob([data], { type });
            const url2 = URL.createObjectURL(blob);
            usingObjectURL = true;
            img.src = url2;
          }, void 0, offlineProvider || void 0, true, (request, exception) => {
            onErrorHandler(exception);
          });
        }
      };
      const loadFromOfflineSupport = () => {
        if (offlineProvider) {
          offlineProvider.loadImage(url, img);
        }
      };
      if (!fromBlob && !fromData && offlineProvider && offlineProvider.enableTexturesOffline) {
        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
      } else {
        if (url.indexOf("file:") !== -1) {
          const textureName = decodeURIComponent(url.substring(5).toLowerCase());
          if (FilesInputStore.FilesToLoad[textureName] && typeof URL !== "undefined") {
            try {
              let blobURL;
              try {
                blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
              } catch (ex) {
                blobURL = URL.createObjectURL(FilesInputStore.FilesToLoad[textureName]);
              }
              img.src = blobURL;
              usingObjectURL = true;
            } catch (e) {
              img.src = "";
            }
            return img;
          }
        }
        noOfflineSupport();
      }
      return img;
    };
    ReadFile = (file, onSuccess, onProgress, useArrayBuffer, onError) => {
      const reader = new FileReader();
      const fileRequest = {
        onCompleteObservable: new Observable(),
        abort: () => reader.abort()
      };
      reader.onloadend = () => fileRequest.onCompleteObservable.notifyObservers(fileRequest);
      if (onError) {
        reader.onerror = () => {
          onError(new ReadFileError(`Unable to read ${file.name}`, file));
        };
      }
      reader.onload = (e) => {
        onSuccess(e.target["result"]);
      };
      if (onProgress) {
        reader.onprogress = onProgress;
      }
      if (!useArrayBuffer) {
        reader.readAsText(file);
      } else {
        reader.readAsArrayBuffer(file);
      }
      return fileRequest;
    };
    LoadFile = (fileOrUrl, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
      if (fileOrUrl.name) {
        return ReadFile(fileOrUrl, onSuccess, onProgress, useArrayBuffer, onError ? (error) => {
          onError(void 0, error);
        } : void 0);
      }
      const url = fileOrUrl;
      if (url.indexOf("file:") !== -1) {
        let fileName = decodeURIComponent(url.substring(5).toLowerCase());
        if (fileName.indexOf("./") === 0) {
          fileName = fileName.substring(2);
        }
        const file = FilesInputStore.FilesToLoad[fileName];
        if (file) {
          return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError ? (error) => onError(void 0, new LoadFileError(error.message, error.file)) : void 0);
        }
      }
      const { match, type } = TestBase64DataUrl(url);
      if (match) {
        const fileRequest = {
          onCompleteObservable: new Observable(),
          abort: () => () => {
          }
        };
        try {
          const data = useArrayBuffer ? DecodeBase64UrlToBinary(url) : DecodeBase64UrlToString(url);
          onSuccess(data, void 0, type);
        } catch (error) {
          if (onError) {
            onError(void 0, error);
          } else {
            Logger.Error(error.message || "Failed to parse the Data URL");
          }
        }
        TimingTools.SetImmediate(() => {
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
        });
        return fileRequest;
      }
      return RequestFile(url, (data, request) => {
        onSuccess(data, request === null || request === void 0 ? void 0 : request.responseURL, request === null || request === void 0 ? void 0 : request.getResponseHeader("content-type"));
      }, onProgress, offlineProvider, useArrayBuffer, onError ? (error) => {
        onError(error.request, new LoadFileError(error.message, error.request));
      } : void 0, onOpened);
    };
    RequestFile = (url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError, onOpened) => {
      url = _CleanUrl(url);
      url = FileToolsOptions.PreprocessUrl(url);
      const loadUrl = FileToolsOptions.BaseUrl + url;
      let aborted = false;
      const fileRequest = {
        onCompleteObservable: new Observable(),
        abort: () => aborted = true
      };
      const requestFile = () => {
        let request = new WebRequest();
        let retryHandle = null;
        let onReadyStateChange;
        const unbindEvents = () => {
          if (!request) {
            return;
          }
          if (onProgress) {
            request.removeEventListener("progress", onProgress);
          }
          if (onReadyStateChange) {
            request.removeEventListener("readystatechange", onReadyStateChange);
          }
          request.removeEventListener("loadend", onLoadEnd);
        };
        let onLoadEnd = () => {
          unbindEvents();
          fileRequest.onCompleteObservable.notifyObservers(fileRequest);
          fileRequest.onCompleteObservable.clear();
          onProgress = void 0;
          onReadyStateChange = null;
          onLoadEnd = null;
          onError = void 0;
          onOpened = void 0;
          onSuccess = void 0;
        };
        fileRequest.abort = () => {
          aborted = true;
          if (onLoadEnd) {
            onLoadEnd();
          }
          if (request && request.readyState !== (XMLHttpRequest.DONE || 4)) {
            request.abort();
          }
          if (retryHandle !== null) {
            clearTimeout(retryHandle);
            retryHandle = null;
          }
          request = null;
        };
        const handleError = (error) => {
          const message = error.message || "Unknown error";
          if (onError && request) {
            onError(new RequestFileError(message, request));
          } else {
            Logger.Error(message);
          }
        };
        const retryLoop = (retryIndex) => {
          if (!request) {
            return;
          }
          request.open("GET", loadUrl);
          if (onOpened) {
            try {
              onOpened(request);
            } catch (e) {
              handleError(e);
              return;
            }
          }
          if (useArrayBuffer) {
            request.responseType = "arraybuffer";
          }
          if (onProgress) {
            request.addEventListener("progress", onProgress);
          }
          if (onLoadEnd) {
            request.addEventListener("loadend", onLoadEnd);
          }
          onReadyStateChange = () => {
            if (aborted || !request) {
              return;
            }
            if (request.readyState === (XMLHttpRequest.DONE || 4)) {
              if (onReadyStateChange) {
                request.removeEventListener("readystatechange", onReadyStateChange);
              }
              if (request.status >= 200 && request.status < 300 || request.status === 0 && (!IsWindowObjectExist() || IsFileURL())) {
                try {
                  if (onSuccess) {
                    onSuccess(useArrayBuffer ? request.response : request.responseText, request);
                  }
                } catch (e) {
                  handleError(e);
                }
                return;
              }
              const retryStrategy = FileToolsOptions.DefaultRetryStrategy;
              if (retryStrategy) {
                const waitTime = retryStrategy(loadUrl, request, retryIndex);
                if (waitTime !== -1) {
                  unbindEvents();
                  request = new WebRequest();
                  retryHandle = setTimeout(() => retryLoop(retryIndex + 1), waitTime);
                  return;
                }
              }
              const error = new RequestFileError("Error status: " + request.status + " " + request.statusText + " - Unable to load " + loadUrl, request);
              if (onError) {
                onError(error);
              }
            }
          };
          request.addEventListener("readystatechange", onReadyStateChange);
          request.send();
        };
        retryLoop(0);
      };
      if (offlineProvider && offlineProvider.enableSceneOffline) {
        const noOfflineSupport = (request) => {
          if (request && request.status > 400) {
            if (onError) {
              onError(request);
            }
          } else {
            requestFile();
          }
        };
        const loadFromOfflineSupport = () => {
          if (offlineProvider) {
            offlineProvider.loadFile(FileToolsOptions.BaseUrl + url, (data) => {
              if (!aborted && onSuccess) {
                onSuccess(data);
              }
              fileRequest.onCompleteObservable.notifyObservers(fileRequest);
            }, onProgress ? (event) => {
              if (!aborted && onProgress) {
                onProgress(event);
              }
            } : void 0, noOfflineSupport, useArrayBuffer);
          }
        };
        offlineProvider.open(loadFromOfflineSupport, noOfflineSupport);
      } else {
        requestFile();
      }
      return fileRequest;
    };
    IsFileURL = () => {
      return typeof location !== "undefined" && location.protocol === "file:";
    };
    IsBase64DataUrl = (uri) => {
      return Base64DataUrlRegEx.test(uri);
    };
    TestBase64DataUrl = (uri) => {
      const results = Base64DataUrlRegEx.exec(uri);
      if (results === null || results.length === 0) {
        return { match: false, type: "" };
      } else {
        const type = results[0].replace("data:", "").replace("base64,", "");
        return { match: true, type };
      }
    };
    DecodeBase64UrlToString = (uri) => {
      return DecodeBase64ToString(uri.split(",")[1]);
    };
    initSideEffects = () => {
      ThinEngine._FileToolsLoadImage = LoadImage;
      ThinEngine._FileToolsLoadFile = LoadFile;
      ShaderProcessor._FileToolsLoadFile = LoadFile;
    };
    initSideEffects();
    _injectLTSFileTools = (DecodeBase64UrlToBinary2, DecodeBase64UrlToString2, FileToolsOptions2, IsBase64DataUrl2, IsFileURL2, LoadFile2, LoadImage2, ReadFile2, RequestFile2, SetCorsBehavior2) => {
      FileTools = {
        DecodeBase64UrlToBinary: DecodeBase64UrlToBinary2,
        DecodeBase64UrlToString: DecodeBase64UrlToString2,
        DefaultRetryStrategy: FileToolsOptions2.DefaultRetryStrategy,
        BaseUrl: FileToolsOptions2.BaseUrl,
        CorsBehavior: FileToolsOptions2.CorsBehavior,
        PreprocessUrl: FileToolsOptions2.PreprocessUrl,
        IsBase64DataUrl: IsBase64DataUrl2,
        IsFileURL: IsFileURL2,
        LoadFile: LoadFile2,
        LoadImage: LoadImage2,
        ReadFile: ReadFile2,
        RequestFile: RequestFile2,
        SetCorsBehavior: SetCorsBehavior2
      };
      Object.defineProperty(FileTools, "DefaultRetryStrategy", {
        get: function() {
          return FileToolsOptions2.DefaultRetryStrategy;
        },
        set: function(value) {
          FileToolsOptions2.DefaultRetryStrategy = value;
        }
      });
      Object.defineProperty(FileTools, "BaseUrl", {
        get: function() {
          return FileToolsOptions2.BaseUrl;
        },
        set: function(value) {
          FileToolsOptions2.BaseUrl = value;
        }
      });
      Object.defineProperty(FileTools, "PreprocessUrl", {
        get: function() {
          return FileToolsOptions2.PreprocessUrl;
        },
        set: function(value) {
          FileToolsOptions2.PreprocessUrl = value;
        }
      });
      Object.defineProperty(FileTools, "CorsBehavior", {
        get: function() {
          return FileToolsOptions2.CorsBehavior;
        },
        set: function(value) {
          FileToolsOptions2.CorsBehavior = value;
        }
      });
    };
    _injectLTSFileTools(DecodeBase64UrlToBinary, DecodeBase64UrlToString, FileToolsOptions, IsBase64DataUrl, IsFileURL, LoadFile, LoadImage, ReadFile, RequestFile, SetCorsBehavior);
  }
});

// node_modules/@babylonjs/core/Misc/instantiationTools.js
var InstantiationTools;
var init_instantiationTools = __esm({
  "node_modules/@babylonjs/core/Misc/instantiationTools.js"() {
    init_logger();
    init_typeStore();
    InstantiationTools = class {
      static Instantiate(className2) {
        if (this.RegisteredExternalClasses && this.RegisteredExternalClasses[className2]) {
          return this.RegisteredExternalClasses[className2];
        }
        const internalClass = GetClass(className2);
        if (internalClass) {
          return internalClass;
        }
        Logger.Warn(className2 + " not found, you may have missed an import.");
        const arr = className2.split(".");
        let fn = window || this;
        for (let i = 0, len = arr.length; i < len; i++) {
          fn = fn[arr[i]];
        }
        if (typeof fn !== "function") {
          return null;
        }
        return fn;
      }
    };
    InstantiationTools.RegisteredExternalClasses = {};
  }
});

// node_modules/@babylonjs/core/Misc/guid.js
function RandomGUID() {
  return "xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx".replace(/[xy]/g, (c) => {
    const r = Math.random() * 16 | 0, v = c === "x" ? r : r & 3 | 8;
    return v.toString(16);
  });
}
var GUID;
var init_guid = __esm({
  "node_modules/@babylonjs/core/Misc/guid.js"() {
    GUID = {
      RandomId: RandomGUID
    };
  }
});

// node_modules/@babylonjs/core/Misc/tools.js
function className(name, module) {
  return (target) => {
    target["__bjsclassName__"] = name;
    target["__bjsmoduleName__"] = module != null ? module : null;
  };
}
var Tools, AsyncLoop;
var init_tools = __esm({
  "node_modules/@babylonjs/core/Misc/tools.js"() {
    init_observable();
    init_domManagement();
    init_logger();
    init_deepCopier();
    init_precisionDate();
    init_devTools();
    init_webRequest();
    init_engineStore();
    init_fileTools();
    init_timingTools();
    init_instantiationTools();
    init_guid();
    Tools = class {
      static get BaseUrl() {
        return FileToolsOptions.BaseUrl;
      }
      static set BaseUrl(value) {
        FileToolsOptions.BaseUrl = value;
      }
      static get DefaultRetryStrategy() {
        return FileToolsOptions.DefaultRetryStrategy;
      }
      static set DefaultRetryStrategy(strategy) {
        FileToolsOptions.DefaultRetryStrategy = strategy;
      }
      static get CorsBehavior() {
        return FileToolsOptions.CorsBehavior;
      }
      static set CorsBehavior(value) {
        FileToolsOptions.CorsBehavior = value;
      }
      static get UseFallbackTexture() {
        return EngineStore.UseFallbackTexture;
      }
      static set UseFallbackTexture(value) {
        EngineStore.UseFallbackTexture = value;
      }
      static get RegisteredExternalClasses() {
        return InstantiationTools.RegisteredExternalClasses;
      }
      static set RegisteredExternalClasses(classes) {
        InstantiationTools.RegisteredExternalClasses = classes;
      }
      static get fallbackTexture() {
        return EngineStore.FallbackTexture;
      }
      static set fallbackTexture(value) {
        EngineStore.FallbackTexture = value;
      }
      static FetchToRef(u, v, width, height, pixels, color) {
        const wrappedU = Math.abs(u) * width % width | 0;
        const wrappedV = Math.abs(v) * height % height | 0;
        const position = (wrappedU + wrappedV * width) * 4;
        color.r = pixels[position] / 255;
        color.g = pixels[position + 1] / 255;
        color.b = pixels[position + 2] / 255;
        color.a = pixels[position + 3] / 255;
      }
      static Mix(a, b, alpha) {
        return a * (1 - alpha) + b * alpha;
      }
      static Instantiate(className2) {
        return InstantiationTools.Instantiate(className2);
      }
      static SetImmediate(action) {
        TimingTools.SetImmediate(action);
      }
      static IsExponentOfTwo(value) {
        let count = 1;
        do {
          count *= 2;
        } while (count < value);
        return count === value;
      }
      static FloatRound(value) {
        if (Math.fround) {
          return Math.fround(value);
        }
        return Tools._TmpFloatArray[0] = value, Tools._TmpFloatArray[0];
      }
      static GetFilename(path) {
        const index = path.lastIndexOf("/");
        if (index < 0) {
          return path;
        }
        return path.substring(index + 1);
      }
      static GetFolderPath(uri, returnUnchangedIfNoSlash = false) {
        const index = uri.lastIndexOf("/");
        if (index < 0) {
          if (returnUnchangedIfNoSlash) {
            return uri;
          }
          return "";
        }
        return uri.substring(0, index + 1);
      }
      static ToDegrees(angle) {
        return angle * 180 / Math.PI;
      }
      static ToRadians(angle) {
        return angle * Math.PI / 180;
      }
      static SmoothAngleChange(previousAngle, newAngle, smoothFactor = 0.9) {
        const previousAngleRad = this.ToRadians(previousAngle);
        const newAngleRad = this.ToRadians(newAngle);
        return this.ToDegrees(Math.atan2((1 - smoothFactor) * Math.sin(newAngleRad) + smoothFactor * Math.sin(previousAngleRad), (1 - smoothFactor) * Math.cos(newAngleRad) + smoothFactor * Math.cos(previousAngleRad)));
      }
      static MakeArray(obj, allowsNullUndefined) {
        if (allowsNullUndefined !== true && (obj === void 0 || obj == null)) {
          return null;
        }
        return Array.isArray(obj) ? obj : [obj];
      }
      static GetPointerPrefix(engine) {
        let eventPrefix = "pointer";
        if (IsWindowObjectExist() && !window.PointerEvent) {
          eventPrefix = "mouse";
        }
        if (engine._badDesktopOS && !engine._badOS && !(document && "ontouchend" in document)) {
          eventPrefix = "mouse";
        }
        return eventPrefix;
      }
      static SetCorsBehavior(url, element) {
        SetCorsBehavior(url, element);
      }
      static SetReferrerPolicyBehavior(referrerPolicy, element) {
        element.referrerPolicy = referrerPolicy;
      }
      static CleanUrl(url) {
        url = url.replace(/#/gm, "%23");
        return url;
      }
      static get PreprocessUrl() {
        return FileToolsOptions.PreprocessUrl;
      }
      static set PreprocessUrl(processor) {
        FileToolsOptions.PreprocessUrl = processor;
      }
      static LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions) {
        return LoadImage(input, onLoad, onError, offlineProvider, mimeType, imageBitmapOptions);
      }
      static LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError) {
        return LoadFile(url, onSuccess, onProgress, offlineProvider, useArrayBuffer, onError);
      }
      static LoadFileAsync(url, useArrayBuffer = true) {
        return new Promise((resolve, reject) => {
          LoadFile(url, (data) => {
            resolve(data);
          }, void 0, void 0, useArrayBuffer, (request, exception) => {
            reject(exception);
          });
        });
      }
      static LoadScript(scriptUrl, onSuccess, onError, scriptId) {
        if (typeof importScripts === "function") {
          try {
            importScripts(scriptUrl);
            onSuccess();
          } catch (e) {
            onError === null || onError === void 0 ? void 0 : onError(`Unable to load script '${scriptUrl}' in worker`, e);
          }
          return;
        } else if (!IsWindowObjectExist()) {
          onError === null || onError === void 0 ? void 0 : onError(`Cannot load script '${scriptUrl}' outside of a window or a worker`);
          return;
        }
        const head = document.getElementsByTagName("head")[0];
        const script = document.createElement("script");
        script.setAttribute("type", "text/javascript");
        script.setAttribute("src", scriptUrl);
        if (scriptId) {
          script.id = scriptId;
        }
        script.onload = () => {
          if (onSuccess) {
            onSuccess();
          }
        };
        script.onerror = (e) => {
          if (onError) {
            onError(`Unable to load script '${scriptUrl}'`, e);
          }
        };
        head.appendChild(script);
      }
      static LoadScriptAsync(scriptUrl) {
        return new Promise((resolve, reject) => {
          this.LoadScript(scriptUrl, () => {
            resolve();
          }, (message, exception) => {
            reject(exception || new Error(message));
          });
        });
      }
      static ReadFileAsDataURL(fileToLoad, callback, progressCallback) {
        const reader = new FileReader();
        const request = {
          onCompleteObservable: new Observable(),
          abort: () => reader.abort()
        };
        reader.onloadend = () => {
          request.onCompleteObservable.notifyObservers(request);
        };
        reader.onload = (e) => {
          callback(e.target["result"]);
        };
        reader.onprogress = progressCallback;
        reader.readAsDataURL(fileToLoad);
        return request;
      }
      static ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
        return ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
      }
      static FileAsURL(content) {
        const fileBlob = new Blob([content]);
        const url = window.URL;
        const link = url.createObjectURL(fileBlob);
        return link;
      }
      static Format(value, decimals = 2) {
        return value.toFixed(decimals);
      }
      static DeepCopy(source, destination, doNotCopyList, mustCopyList) {
        DeepCopier.DeepCopy(source, destination, doNotCopyList, mustCopyList);
      }
      static IsEmpty(obj) {
        for (const i in obj) {
          if (Object.prototype.hasOwnProperty.call(obj, i)) {
            return false;
          }
        }
        return true;
      }
      static RegisterTopRootEvents(windowElement, events) {
        for (let index = 0; index < events.length; index++) {
          const event = events[index];
          windowElement.addEventListener(event.name, event.handler, false);
          try {
            if (window.parent) {
              window.parent.addEventListener(event.name, event.handler, false);
            }
          } catch (e) {
          }
        }
      }
      static UnregisterTopRootEvents(windowElement, events) {
        for (let index = 0; index < events.length; index++) {
          const event = events[index];
          windowElement.removeEventListener(event.name, event.handler);
          try {
            if (windowElement.parent) {
              windowElement.parent.removeEventListener(event.name, event.handler);
            }
          } catch (e) {
          }
        }
      }
      static async DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
        throw _WarnImport("DumpTools");
      }
      static DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
        throw _WarnImport("DumpTools");
      }
      static DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
        throw _WarnImport("DumpTools");
      }
      static _IsOffScreenCanvas(canvas) {
        return canvas.convertToBlob !== void 0;
      }
      static ToBlob(canvas, successCallback, mimeType = "image/png", quality) {
        if (!Tools._IsOffScreenCanvas(canvas) && !canvas.toBlob) {
          canvas.toBlob = function(callback, type, quality2) {
            setTimeout(() => {
              const binStr = atob(this.toDataURL(type, quality2).split(",")[1]), len = binStr.length, arr = new Uint8Array(len);
              for (let i = 0; i < len; i++) {
                arr[i] = binStr.charCodeAt(i);
              }
              callback(new Blob([arr]));
            });
          };
        }
        if (Tools._IsOffScreenCanvas(canvas)) {
          canvas.convertToBlob({
            type: mimeType,
            quality
          }).then((blob) => successCallback(blob));
        } else {
          canvas.toBlob(function(blob) {
            successCallback(blob);
          }, mimeType, quality);
        }
      }
      static DownloadBlob(blob, fileName) {
        if ("download" in document.createElement("a")) {
          if (!fileName) {
            const date = new Date();
            const stringDate = (date.getFullYear() + "-" + (date.getMonth() + 1)).slice(2) + "-" + date.getDate() + "_" + date.getHours() + "-" + ("0" + date.getMinutes()).slice(-2);
            fileName = "screenshot_" + stringDate + ".png";
          }
          Tools.Download(blob, fileName);
        } else {
          if (blob && typeof URL !== "undefined") {
            const url = URL.createObjectURL(blob);
            const newWindow = window.open("");
            if (!newWindow) {
              return;
            }
            const img = newWindow.document.createElement("img");
            img.onload = function() {
              URL.revokeObjectURL(url);
            };
            img.src = url;
            newWindow.document.body.appendChild(img);
          }
        }
      }
      static EncodeScreenshotCanvasData(canvas, successCallback, mimeType = "image/png", fileName, quality) {
        if (typeof fileName === "string" || !successCallback) {
          this.ToBlob(canvas, function(blob) {
            if (blob) {
              Tools.DownloadBlob(blob, fileName);
            }
            if (successCallback) {
              successCallback("");
            }
          }, mimeType, quality);
        } else if (successCallback) {
          if (Tools._IsOffScreenCanvas(canvas)) {
            canvas.convertToBlob({
              type: mimeType,
              quality
            }).then((blob) => {
              const reader = new FileReader();
              reader.readAsDataURL(blob);
              reader.onloadend = () => {
                const base64data = reader.result;
                successCallback(base64data);
              };
            });
            return;
          }
          const base64Image = canvas.toDataURL(mimeType, quality);
          successCallback(base64Image);
        }
      }
      static Download(blob, fileName) {
        if (typeof URL === "undefined") {
          return;
        }
        const url = window.URL.createObjectURL(blob);
        const a = document.createElement("a");
        document.body.appendChild(a);
        a.style.display = "none";
        a.href = url;
        a.download = fileName;
        a.addEventListener("click", () => {
          if (a.parentElement) {
            a.parentElement.removeChild(a);
          }
        });
        a.click();
        window.URL.revokeObjectURL(url);
      }
      static BackCompatCameraNoPreventDefault(args) {
        if (typeof args[0] === "boolean") {
          return args[0];
        } else if (typeof args[1] === "boolean") {
          return args[1];
        }
        return false;
      }
      static CreateScreenshot(engine, camera, size, successCallback, mimeType = "image/png", forceDownload = false, quality) {
        throw _WarnImport("ScreenshotTools");
      }
      static CreateScreenshotAsync(engine, camera, size, mimeType = "image/png", quality) {
        throw _WarnImport("ScreenshotTools");
      }
      static CreateScreenshotUsingRenderTarget(engine, camera, size, successCallback, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {
        throw _WarnImport("ScreenshotTools");
      }
      static CreateScreenshotUsingRenderTargetAsync(engine, camera, size, mimeType = "image/png", samples = 1, antialiasing = false, fileName, renderSprites = false, enableStencilBuffer = false, useLayerMask = true, quality) {
        throw _WarnImport("ScreenshotTools");
      }
      static RandomId() {
        return RandomGUID();
      }
      static IsBase64(uri) {
        return IsBase64DataUrl(uri);
      }
      static DecodeBase64(uri) {
        return DecodeBase64UrlToBinary(uri);
      }
      static get errorsCount() {
        return Logger.errorsCount;
      }
      static Log(message) {
        Logger.Log(message);
      }
      static Warn(message) {
        Logger.Warn(message);
      }
      static Error(message) {
        Logger.Error(message);
      }
      static get LogCache() {
        return Logger.LogCache;
      }
      static ClearLogCache() {
        Logger.ClearLogCache();
      }
      static set LogLevels(level) {
        Logger.LogLevels = level;
      }
      static set PerformanceLogLevel(level) {
        if ((level & Tools.PerformanceUserMarkLogLevel) === Tools.PerformanceUserMarkLogLevel) {
          Tools.StartPerformanceCounter = Tools._StartUserMark;
          Tools.EndPerformanceCounter = Tools._EndUserMark;
          return;
        }
        if ((level & Tools.PerformanceConsoleLogLevel) === Tools.PerformanceConsoleLogLevel) {
          Tools.StartPerformanceCounter = Tools._StartPerformanceConsole;
          Tools.EndPerformanceCounter = Tools._EndPerformanceConsole;
          return;
        }
        Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
        Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
      }
      static _StartPerformanceCounterDisabled(counterName, condition) {
      }
      static _EndPerformanceCounterDisabled(counterName, condition) {
      }
      static _StartUserMark(counterName, condition = true) {
        if (!Tools._Performance) {
          if (!IsWindowObjectExist()) {
            return;
          }
          Tools._Performance = window.performance;
        }
        if (!condition || !Tools._Performance.mark) {
          return;
        }
        Tools._Performance.mark(counterName + "-Begin");
      }
      static _EndUserMark(counterName, condition = true) {
        if (!condition || !Tools._Performance.mark) {
          return;
        }
        Tools._Performance.mark(counterName + "-End");
        Tools._Performance.measure(counterName, counterName + "-Begin", counterName + "-End");
      }
      static _StartPerformanceConsole(counterName, condition = true) {
        if (!condition) {
          return;
        }
        Tools._StartUserMark(counterName, condition);
        if (console.time) {
          console.time(counterName);
        }
      }
      static _EndPerformanceConsole(counterName, condition = true) {
        if (!condition) {
          return;
        }
        Tools._EndUserMark(counterName, condition);
        console.timeEnd(counterName);
      }
      static get Now() {
        return PrecisionDate.Now;
      }
      static GetClassName(object, isType = false) {
        let name = null;
        if (!isType && object.getClassName) {
          name = object.getClassName();
        } else {
          if (object instanceof Object) {
            const classObj = isType ? object : Object.getPrototypeOf(object);
            name = classObj.constructor["__bjsclassName__"];
          }
          if (!name) {
            name = typeof object;
          }
        }
        return name;
      }
      static First(array, predicate) {
        for (const el of array) {
          if (predicate(el)) {
            return el;
          }
        }
        return null;
      }
      static getFullClassName(object, isType = false) {
        let className2 = null;
        let moduleName = null;
        if (!isType && object.getClassName) {
          className2 = object.getClassName();
        } else {
          if (object instanceof Object) {
            const classObj = isType ? object : Object.getPrototypeOf(object);
            className2 = classObj.constructor["__bjsclassName__"];
            moduleName = classObj.constructor["__bjsmoduleName__"];
          }
          if (!className2) {
            className2 = typeof object;
          }
        }
        if (!className2) {
          return null;
        }
        return (moduleName != null ? moduleName + "." : "") + className2;
      }
      static DelayAsync(delay) {
        return new Promise((resolve) => {
          setTimeout(() => {
            resolve();
          }, delay);
        });
      }
      static IsSafari() {
        if (!IsNavigatorAvailable()) {
          return false;
        }
        return /^((?!chrome|android).)*safari/i.test(navigator.userAgent);
      }
    };
    Tools.UseCustomRequestHeaders = false;
    Tools.CustomRequestHeaders = WebRequest.CustomRequestHeaders;
    Tools._TmpFloatArray = new Float32Array(1);
    Tools.GetDOMTextContent = GetDOMTextContent;
    Tools.GetAbsoluteUrl = typeof document === "object" ? (url) => {
      const a = document.createElement("a");
      a.href = url;
      return a.href;
    } : typeof URL === "function" && typeof location === "object" ? (url) => new URL(url, location.origin).href : () => {
      throw new Error("Unable to get absolute URL. Override BABYLON.Tools.GetAbsoluteUrl to a custom implementation for the current context.");
    };
    Tools.NoneLogLevel = Logger.NoneLogLevel;
    Tools.MessageLogLevel = Logger.MessageLogLevel;
    Tools.WarningLogLevel = Logger.WarningLogLevel;
    Tools.ErrorLogLevel = Logger.ErrorLogLevel;
    Tools.AllLogLevel = Logger.AllLogLevel;
    Tools.IsWindowObjectExist = IsWindowObjectExist;
    Tools.PerformanceNoneLogLevel = 0;
    Tools.PerformanceUserMarkLogLevel = 1;
    Tools.PerformanceConsoleLogLevel = 2;
    Tools.StartPerformanceCounter = Tools._StartPerformanceCounterDisabled;
    Tools.EndPerformanceCounter = Tools._EndPerformanceCounterDisabled;
    AsyncLoop = class {
      constructor(iterations, func, successCallback, offset = 0) {
        this.iterations = iterations;
        this.index = offset - 1;
        this._done = false;
        this._fn = func;
        this._successCallback = successCallback;
      }
      executeNext() {
        if (!this._done) {
          if (this.index + 1 < this.iterations) {
            ++this.index;
            this._fn(this);
          } else {
            this.breakLoop();
          }
        }
      }
      breakLoop() {
        this._done = true;
        this._successCallback();
      }
      static Run(iterations, fn, successCallback, offset = 0) {
        const loop = new AsyncLoop(iterations, fn, successCallback, offset);
        loop.executeNext();
        return loop;
      }
      static SyncAsyncForLoop(iterations, syncedIterations, fn, callback, breakFunction, timeout = 0) {
        return AsyncLoop.Run(Math.ceil(iterations / syncedIterations), (loop) => {
          if (breakFunction && breakFunction()) {
            loop.breakLoop();
          } else {
            setTimeout(() => {
              for (let i = 0; i < syncedIterations; ++i) {
                const iteration = loop.index * syncedIterations + i;
                if (iteration >= iterations) {
                  break;
                }
                fn(iteration);
                if (breakFunction && breakFunction()) {
                  loop.breakLoop();
                  break;
                }
              }
              loop.executeNext();
            }, timeout);
          }
        }, callback);
      }
    };
    EngineStore.FallbackTexture = "data:image/jpg;base64,/9j/4AAQSkZJRgABAQEAYABgAAD/4QBmRXhpZgAATU0AKgAAAAgABAEaAAUAAAABAAAAPgEbAAUAAAABAAAARgEoAAMAAAABAAIAAAExAAIAAAAQAAAATgAAAAAAAABgAAAAAQAAAGAAAAABcGFpbnQubmV0IDQuMC41AP/bAEMABAIDAwMCBAMDAwQEBAQFCQYFBQUFCwgIBgkNCw0NDQsMDA4QFBEODxMPDAwSGBITFRYXFxcOERkbGRYaFBYXFv/bAEMBBAQEBQUFCgYGChYPDA8WFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFhYWFv/AABEIAQABAAMBIgACEQEDEQH/xAAfAAABBQEBAQEBAQAAAAAAAAAAAQIDBAUGBwgJCgv/xAC1EAACAQMDAgQDBQUEBAAAAX0BAgMABBEFEiExQQYTUWEHInEUMoGRoQgjQrHBFVLR8CQzYnKCCQoWFxgZGiUmJygpKjQ1Njc4OTpDREVGR0hJSlNUVVZXWFlaY2RlZmdoaWpzdHV2d3h5eoOEhYaHiImKkpOUlZaXmJmaoqOkpaanqKmqsrO0tba3uLm6wsPExcbHyMnK0tPU1dbX2Nna4eLj5OXm5+jp6vHy8/T19vf4+fr/xAAfAQADAQEBAQEBAQEBAAAAAAAAAQIDBAUGBwgJCgv/xAC1EQACAQIEBAMEBwUEBAABAncAAQIDEQQFITEGEkFRB2FxEyIygQgUQpGhscEJIzNS8BVictEKFiQ04SXxFxgZGiYnKCkqNTY3ODk6Q0RFRkdISUpTVFVWV1hZWmNkZWZnaGlqc3R1dnd4eXqCg4SFhoeIiYqSk5SVlpeYmZqio6Slpqeoqaqys7S1tre4ubrCw8TFxsfIycrS09TV1tfY2dri4+Tl5ufo6ery8/T19vf4+fr/2gAMAwEAAhEDEQA/APH6KKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76CiiigD5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BQooooA+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/voKKKKAPl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FCiiigD6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++gooooA+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gUKKKKAPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76Pl+iiivuj+BT6gooor4U/vo+X6KKK+6P4FPqCiiivhT++j5fooor7o/gU+oKKKK+FP76P//Z";
  }
});

// node_modules/@babylonjs/core/Misc/smartArray.js
var SmartArray, SmartArrayNoDuplicate;
var init_smartArray = __esm({
  "node_modules/@babylonjs/core/Misc/smartArray.js"() {
    SmartArray = class {
      constructor(capacity) {
        this.length = 0;
        this.data = new Array(capacity);
        this._id = SmartArray._GlobalId++;
      }
      push(value) {
        this.data[this.length++] = value;
        if (this.length > this.data.length) {
          this.data.length *= 2;
        }
      }
      forEach(func) {
        for (let index = 0; index < this.length; index++) {
          func(this.data[index]);
        }
      }
      sort(compareFn) {
        this.data.sort(compareFn);
      }
      reset() {
        this.length = 0;
      }
      dispose() {
        this.reset();
        if (this.data) {
          this.data.length = 0;
        }
      }
      concat(array) {
        if (array.length === 0) {
          return;
        }
        if (this.length + array.length > this.data.length) {
          this.data.length = (this.length + array.length) * 2;
        }
        for (let index = 0; index < array.length; index++) {
          this.data[this.length++] = (array.data || array)[index];
        }
      }
      indexOf(value) {
        const position = this.data.indexOf(value);
        if (position >= this.length) {
          return -1;
        }
        return position;
      }
      contains(value) {
        return this.indexOf(value) !== -1;
      }
    };
    SmartArray._GlobalId = 0;
    SmartArrayNoDuplicate = class extends SmartArray {
      constructor() {
        super(...arguments);
        this._duplicateId = 0;
      }
      push(value) {
        super.push(value);
        if (!value.__smartArrayFlags) {
          value.__smartArrayFlags = {};
        }
        value.__smartArrayFlags[this._id] = this._duplicateId;
      }
      pushNoDuplicate(value) {
        if (value.__smartArrayFlags && value.__smartArrayFlags[this._id] === this._duplicateId) {
          return false;
        }
        this.push(value);
        return true;
      }
      reset() {
        super.reset();
        this._duplicateId++;
      }
      concatWithNoDuplicate(array) {
        if (array.length === 0) {
          return;
        }
        if (this.length + array.length > this.data.length) {
          this.data.length = (this.length + array.length) * 2;
        }
        for (let index = 0; index < array.length; index++) {
          const item = (array.data || array)[index];
          this.pushNoDuplicate(item);
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/stringDictionary.js
var StringDictionary;
var init_stringDictionary = __esm({
  "node_modules/@babylonjs/core/Misc/stringDictionary.js"() {
    StringDictionary = class {
      constructor() {
        this._count = 0;
        this._data = {};
      }
      copyFrom(source) {
        this.clear();
        source.forEach((t, v) => this.add(t, v));
      }
      get(key) {
        const val = this._data[key];
        if (val !== void 0) {
          return val;
        }
        return void 0;
      }
      getOrAddWithFactory(key, factory) {
        let val = this.get(key);
        if (val !== void 0) {
          return val;
        }
        val = factory(key);
        if (val) {
          this.add(key, val);
        }
        return val;
      }
      getOrAdd(key, val) {
        const curVal = this.get(key);
        if (curVal !== void 0) {
          return curVal;
        }
        this.add(key, val);
        return val;
      }
      contains(key) {
        return this._data[key] !== void 0;
      }
      add(key, value) {
        if (this._data[key] !== void 0) {
          return false;
        }
        this._data[key] = value;
        ++this._count;
        return true;
      }
      set(key, value) {
        if (this._data[key] === void 0) {
          return false;
        }
        this._data[key] = value;
        return true;
      }
      getAndRemove(key) {
        const val = this.get(key);
        if (val !== void 0) {
          delete this._data[key];
          --this._count;
          return val;
        }
        return null;
      }
      remove(key) {
        if (this.contains(key)) {
          delete this._data[key];
          --this._count;
          return true;
        }
        return false;
      }
      clear() {
        this._data = {};
        this._count = 0;
      }
      get count() {
        return this._count;
      }
      forEach(callback) {
        for (const cur in this._data) {
          const val = this._data[cur];
          callback(cur, val);
        }
      }
      first(callback) {
        for (const cur in this._data) {
          const val = this._data[cur];
          const res = callback(cur, val);
          if (res) {
            return res;
          }
        }
        return null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js
var AndOrNotEvaluator;
var init_andOrNotEvaluator = __esm({
  "node_modules/@babylonjs/core/Misc/andOrNotEvaluator.js"() {
    AndOrNotEvaluator = class {
      static Eval(query, evaluateCallback) {
        if (!query.match(/\([^()]*\)/g)) {
          query = AndOrNotEvaluator._HandleParenthesisContent(query, evaluateCallback);
        } else {
          query = query.replace(/\([^()]*\)/g, (r) => {
            r = r.slice(1, r.length - 1);
            return AndOrNotEvaluator._HandleParenthesisContent(r, evaluateCallback);
          });
        }
        if (query === "true") {
          return true;
        }
        if (query === "false") {
          return false;
        }
        return AndOrNotEvaluator.Eval(query, evaluateCallback);
      }
      static _HandleParenthesisContent(parenthesisContent, evaluateCallback) {
        evaluateCallback = evaluateCallback || ((r) => {
          return r === "true" ? true : false;
        });
        let result;
        const or = parenthesisContent.split("||");
        for (const i in or) {
          if (Object.prototype.hasOwnProperty.call(or, i)) {
            let ori = AndOrNotEvaluator._SimplifyNegation(or[i].trim());
            const and = ori.split("&&");
            if (and.length > 1) {
              for (let j = 0; j < and.length; ++j) {
                const andj = AndOrNotEvaluator._SimplifyNegation(and[j].trim());
                if (andj !== "true" && andj !== "false") {
                  if (andj[0] === "!") {
                    result = !evaluateCallback(andj.substring(1));
                  } else {
                    result = evaluateCallback(andj);
                  }
                } else {
                  result = andj === "true" ? true : false;
                }
                if (!result) {
                  ori = "false";
                  break;
                }
              }
            }
            if (result || ori === "true") {
              result = true;
              break;
            }
            if (ori !== "true" && ori !== "false") {
              if (ori[0] === "!") {
                result = !evaluateCallback(ori.substring(1));
              } else {
                result = evaluateCallback(ori);
              }
            } else {
              result = ori === "true" ? true : false;
            }
          }
        }
        return result ? "true" : "false";
      }
      static _SimplifyNegation(booleanString) {
        booleanString = booleanString.replace(/^[\s!]+/, (r) => {
          r = r.replace(/[\s]/g, () => "");
          return r.length % 2 ? "!" : "";
        });
        booleanString = booleanString.trim();
        if (booleanString === "!true") {
          booleanString = "false";
        } else if (booleanString === "!false") {
          booleanString = "true";
        }
        return booleanString;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/tags.js
var Tags;
var init_tags = __esm({
  "node_modules/@babylonjs/core/Misc/tags.js"() {
    init_andOrNotEvaluator();
    Tags = class {
      static EnableFor(obj) {
        obj._tags = obj._tags || {};
        obj.hasTags = () => {
          return Tags.HasTags(obj);
        };
        obj.addTags = (tagsString) => {
          return Tags.AddTagsTo(obj, tagsString);
        };
        obj.removeTags = (tagsString) => {
          return Tags.RemoveTagsFrom(obj, tagsString);
        };
        obj.matchesTagsQuery = (tagsQuery) => {
          return Tags.MatchesQuery(obj, tagsQuery);
        };
      }
      static DisableFor(obj) {
        delete obj._tags;
        delete obj.hasTags;
        delete obj.addTags;
        delete obj.removeTags;
        delete obj.matchesTagsQuery;
      }
      static HasTags(obj) {
        if (!obj._tags) {
          return false;
        }
        const tags = obj._tags;
        for (const i in tags) {
          if (Object.prototype.hasOwnProperty.call(tags, i)) {
            return true;
          }
        }
        return false;
      }
      static GetTags(obj, asString = true) {
        if (!obj._tags) {
          return null;
        }
        if (asString) {
          const tagsArray = [];
          for (const tag in obj._tags) {
            if (Object.prototype.hasOwnProperty.call(obj._tags, tag) && obj._tags[tag] === true) {
              tagsArray.push(tag);
            }
          }
          return tagsArray.join(" ");
        } else {
          return obj._tags;
        }
      }
      static AddTagsTo(obj, tagsString) {
        if (!tagsString) {
          return;
        }
        if (typeof tagsString !== "string") {
          return;
        }
        const tags = tagsString.split(" ");
        tags.forEach(function(tag) {
          Tags._AddTagTo(obj, tag);
        });
      }
      static _AddTagTo(obj, tag) {
        tag = tag.trim();
        if (tag === "" || tag === "true" || tag === "false") {
          return;
        }
        if (tag.match(/[\s]/) || tag.match(/^([!]|([|]|[&]){2})/)) {
          return;
        }
        Tags.EnableFor(obj);
        obj._tags[tag] = true;
      }
      static RemoveTagsFrom(obj, tagsString) {
        if (!Tags.HasTags(obj)) {
          return;
        }
        const tags = tagsString.split(" ");
        for (const t in tags) {
          Tags._RemoveTagFrom(obj, tags[t]);
        }
      }
      static _RemoveTagFrom(obj, tag) {
        delete obj._tags[tag];
      }
      static MatchesQuery(obj, tagsQuery) {
        if (tagsQuery === void 0) {
          return true;
        }
        if (tagsQuery === "") {
          return Tags.HasTags(obj);
        }
        return AndOrNotEvaluator.Eval(tagsQuery, (r) => Tags.HasTags(obj) && obj._tags[r]);
      }
    };
  }
});

// node_modules/@babylonjs/core/abstractScene.js
var AbstractScene;
var init_abstractScene = __esm({
  "node_modules/@babylonjs/core/abstractScene.js"() {
    AbstractScene = class {
      constructor() {
        this.rootNodes = new Array();
        this.cameras = new Array();
        this.lights = new Array();
        this.meshes = new Array();
        this.skeletons = new Array();
        this.particleSystems = new Array();
        this.animations = [];
        this.animationGroups = new Array();
        this.multiMaterials = new Array();
        this.materials = new Array();
        this.morphTargetManagers = new Array();
        this.geometries = new Array();
        this.transformNodes = new Array();
        this.actionManagers = new Array();
        this.textures = new Array();
        this._environmentTexture = null;
        this.postProcesses = new Array();
      }
      static AddParser(name, parser) {
        this._BabylonFileParsers[name] = parser;
      }
      static GetParser(name) {
        if (this._BabylonFileParsers[name]) {
          return this._BabylonFileParsers[name];
        }
        return null;
      }
      static AddIndividualParser(name, parser) {
        this._IndividualBabylonFileParsers[name] = parser;
      }
      static GetIndividualParser(name) {
        if (this._IndividualBabylonFileParsers[name]) {
          return this._IndividualBabylonFileParsers[name];
        }
        return null;
      }
      static Parse(jsonData, scene, container, rootUrl) {
        for (const parserName in this._BabylonFileParsers) {
          if (Object.prototype.hasOwnProperty.call(this._BabylonFileParsers, parserName)) {
            this._BabylonFileParsers[parserName](jsonData, scene, container, rootUrl);
          }
        }
      }
      get environmentTexture() {
        return this._environmentTexture;
      }
      set environmentTexture(value) {
        this._environmentTexture = value;
      }
      getNodes() {
        let nodes = new Array();
        nodes = nodes.concat(this.meshes);
        nodes = nodes.concat(this.lights);
        nodes = nodes.concat(this.cameras);
        nodes = nodes.concat(this.transformNodes);
        this.skeletons.forEach((skeleton) => nodes = nodes.concat(skeleton.bones));
        return nodes;
      }
    };
    AbstractScene._BabylonFileParsers = {};
    AbstractScene._IndividualBabylonFileParsers = {};
  }
});

// node_modules/@babylonjs/core/tslib.es6.js
function __decorate(decorators, target, key, desc) {
  var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
  if (typeof Reflect === "object" && typeof Reflect.decorate === "function")
    r = Reflect.decorate(decorators, target, key, desc);
  else
    for (var i = decorators.length - 1; i >= 0; i--)
      if (d = decorators[i])
        r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
  return c > 3 && r && Object.defineProperty(target, key, r), r;
}
var init_tslib_es6 = __esm({
  "node_modules/@babylonjs/core/tslib.es6.js"() {
  }
});

// node_modules/@babylonjs/core/Maths/math.color.js
function colorChannelToLinearSpace(color) {
  return Math.pow(color, ToLinearSpace);
}
function colorChannelToLinearSpaceExact(color) {
  if (color <= 0.04045) {
    return 0.0773993808 * color;
  }
  return Math.pow(0.947867299 * (color + 0.055), 2.4);
}
function colorChannelToGammaSpace(color) {
  return Math.pow(color, ToGammaSpace);
}
function colorChannelToGammaSpaceExact(color) {
  if (color <= 31308e-7) {
    return 12.92 * color;
  }
  return 1.055 * Math.pow(color, 0.41666) - 0.055;
}
var Color3, Color4, TmpColors;
var init_math_color = __esm({
  "node_modules/@babylonjs/core/Maths/math.color.js"() {
    init_math_scalar();
    init_math_constants();
    init_arrayTools();
    init_typeStore();
    Color3 = class {
      constructor(r = 0, g = 0, b = 0) {
        this.r = r;
        this.g = g;
        this.b = b;
      }
      toString() {
        return "{R: " + this.r + " G:" + this.g + " B:" + this.b + "}";
      }
      getClassName() {
        return "Color3";
      }
      getHashCode() {
        let hash = this.r * 255 | 0;
        hash = hash * 397 ^ (this.g * 255 | 0);
        hash = hash * 397 ^ (this.b * 255 | 0);
        return hash;
      }
      toArray(array, index = 0) {
        array[index] = this.r;
        array[index + 1] = this.g;
        array[index + 2] = this.b;
        return this;
      }
      fromArray(array, offset = 0) {
        Color3.FromArrayToRef(array, offset, this);
        return this;
      }
      toColor4(alpha = 1) {
        return new Color4(this.r, this.g, this.b, alpha);
      }
      asArray() {
        return [this.r, this.g, this.b];
      }
      toLuminance() {
        return this.r * 0.3 + this.g * 0.59 + this.b * 0.11;
      }
      multiply(otherColor) {
        return new Color3(this.r * otherColor.r, this.g * otherColor.g, this.b * otherColor.b);
      }
      multiplyToRef(otherColor, result) {
        result.r = this.r * otherColor.r;
        result.g = this.g * otherColor.g;
        result.b = this.b * otherColor.b;
        return this;
      }
      equals(otherColor) {
        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b;
      }
      equalsFloats(r, g, b) {
        return this.r === r && this.g === g && this.b === b;
      }
      scale(scale) {
        return new Color3(this.r * scale, this.g * scale, this.b * scale);
      }
      scaleInPlace(scale) {
        this.r *= scale;
        this.g *= scale;
        this.b *= scale;
        return this;
      }
      scaleToRef(scale, result) {
        result.r = this.r * scale;
        result.g = this.g * scale;
        result.b = this.b * scale;
        return this;
      }
      scaleAndAddToRef(scale, result) {
        result.r += this.r * scale;
        result.g += this.g * scale;
        result.b += this.b * scale;
        return this;
      }
      clampToRef(min = 0, max = 1, result) {
        result.r = Scalar.Clamp(this.r, min, max);
        result.g = Scalar.Clamp(this.g, min, max);
        result.b = Scalar.Clamp(this.b, min, max);
        return this;
      }
      add(otherColor) {
        return new Color3(this.r + otherColor.r, this.g + otherColor.g, this.b + otherColor.b);
      }
      addToRef(otherColor, result) {
        result.r = this.r + otherColor.r;
        result.g = this.g + otherColor.g;
        result.b = this.b + otherColor.b;
        return this;
      }
      subtract(otherColor) {
        return new Color3(this.r - otherColor.r, this.g - otherColor.g, this.b - otherColor.b);
      }
      subtractToRef(otherColor, result) {
        result.r = this.r - otherColor.r;
        result.g = this.g - otherColor.g;
        result.b = this.b - otherColor.b;
        return this;
      }
      clone() {
        return new Color3(this.r, this.g, this.b);
      }
      copyFrom(source) {
        this.r = source.r;
        this.g = source.g;
        this.b = source.b;
        return this;
      }
      copyFromFloats(r, g, b) {
        this.r = r;
        this.g = g;
        this.b = b;
        return this;
      }
      set(r, g, b) {
        return this.copyFromFloats(r, g, b);
      }
      toHexString() {
        const intR = Math.round(this.r * 255);
        const intG = Math.round(this.g * 255);
        const intB = Math.round(this.b * 255);
        return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
      }
      toHSV() {
        const result = new Color3();
        this.toHSVToRef(result);
        return result;
      }
      toHSVToRef(result) {
        const r = this.r;
        const g = this.g;
        const b = this.b;
        const max = Math.max(r, g, b);
        const min = Math.min(r, g, b);
        let h = 0;
        let s = 0;
        const v = max;
        const dm = max - min;
        if (max !== 0) {
          s = dm / max;
        }
        if (max != min) {
          if (max == r) {
            h = (g - b) / dm;
            if (g < b) {
              h += 6;
            }
          } else if (max == g) {
            h = (b - r) / dm + 2;
          } else if (max == b) {
            h = (r - g) / dm + 4;
          }
          h *= 60;
        }
        result.r = h;
        result.g = s;
        result.b = v;
      }
      toLinearSpace(exact = false) {
        const convertedColor = new Color3();
        this.toLinearSpaceToRef(convertedColor, exact);
        return convertedColor;
      }
      toLinearSpaceToRef(convertedColor, exact = false) {
        if (exact) {
          convertedColor.r = colorChannelToLinearSpaceExact(this.r);
          convertedColor.g = colorChannelToLinearSpaceExact(this.g);
          convertedColor.b = colorChannelToLinearSpaceExact(this.b);
        } else {
          convertedColor.r = colorChannelToLinearSpace(this.r);
          convertedColor.g = colorChannelToLinearSpace(this.g);
          convertedColor.b = colorChannelToLinearSpace(this.b);
        }
        return this;
      }
      toGammaSpace(exact = false) {
        const convertedColor = new Color3();
        this.toGammaSpaceToRef(convertedColor, exact);
        return convertedColor;
      }
      toGammaSpaceToRef(convertedColor, exact = false) {
        if (exact) {
          convertedColor.r = colorChannelToGammaSpaceExact(this.r);
          convertedColor.g = colorChannelToGammaSpaceExact(this.g);
          convertedColor.b = colorChannelToGammaSpaceExact(this.b);
        } else {
          convertedColor.r = colorChannelToGammaSpace(this.r);
          convertedColor.g = colorChannelToGammaSpace(this.g);
          convertedColor.b = colorChannelToGammaSpace(this.b);
        }
        return this;
      }
      static HSVtoRGBToRef(hue, saturation, value, result) {
        const chroma = value * saturation;
        const h = hue / 60;
        const x = chroma * (1 - Math.abs(h % 2 - 1));
        let r = 0;
        let g = 0;
        let b = 0;
        if (h >= 0 && h <= 1) {
          r = chroma;
          g = x;
        } else if (h >= 1 && h <= 2) {
          r = x;
          g = chroma;
        } else if (h >= 2 && h <= 3) {
          g = chroma;
          b = x;
        } else if (h >= 3 && h <= 4) {
          g = x;
          b = chroma;
        } else if (h >= 4 && h <= 5) {
          r = x;
          b = chroma;
        } else if (h >= 5 && h <= 6) {
          r = chroma;
          b = x;
        }
        const m = value - chroma;
        result.set(r + m, g + m, b + m);
      }
      static FromHSV(hue, saturation, value) {
        const result = new Color3(0, 0, 0);
        Color3.HSVtoRGBToRef(hue, saturation, value, result);
        return result;
      }
      static FromHexString(hex) {
        if (hex.substring(0, 1) !== "#" || hex.length !== 7) {
          return new Color3(0, 0, 0);
        }
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        return Color3.FromInts(r, g, b);
      }
      static FromArray(array, offset = 0) {
        return new Color3(array[offset], array[offset + 1], array[offset + 2]);
      }
      static FromArrayToRef(array, offset = 0, result) {
        result.r = array[offset];
        result.g = array[offset + 1];
        result.b = array[offset + 2];
      }
      static FromInts(r, g, b) {
        return new Color3(r / 255, g / 255, b / 255);
      }
      static Lerp(start, end, amount) {
        const result = new Color3(0, 0, 0);
        Color3.LerpToRef(start, end, amount, result);
        return result;
      }
      static LerpToRef(left, right, amount, result) {
        result.r = left.r + (right.r - left.r) * amount;
        result.g = left.g + (right.g - left.g) * amount;
        result.b = left.b + (right.b - left.b) * amount;
      }
      static Hermite(value1, tangent1, value2, tangent2, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const part1 = 2 * cubed - 3 * squared + 1;
        const part2 = -2 * cubed + 3 * squared;
        const part3 = cubed - 2 * squared + amount;
        const part4 = cubed - squared;
        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
        return new Color3(r, g, b);
      }
      static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
        const result = Color3.Black();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      }
      static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
        const t2 = time * time;
        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
      }
      static Red() {
        return new Color3(1, 0, 0);
      }
      static Green() {
        return new Color3(0, 1, 0);
      }
      static Blue() {
        return new Color3(0, 0, 1);
      }
      static Black() {
        return new Color3(0, 0, 0);
      }
      static get BlackReadOnly() {
        return Color3._BlackReadOnly;
      }
      static White() {
        return new Color3(1, 1, 1);
      }
      static Purple() {
        return new Color3(0.5, 0, 0.5);
      }
      static Magenta() {
        return new Color3(1, 0, 1);
      }
      static Yellow() {
        return new Color3(1, 1, 0);
      }
      static Gray() {
        return new Color3(0.5, 0.5, 0.5);
      }
      static Teal() {
        return new Color3(0, 1, 1);
      }
      static Random() {
        return new Color3(Math.random(), Math.random(), Math.random());
      }
    };
    Color3._BlackReadOnly = Color3.Black();
    Color4 = class {
      constructor(r = 0, g = 0, b = 0, a = 1) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
      }
      addInPlace(right) {
        this.r += right.r;
        this.g += right.g;
        this.b += right.b;
        this.a += right.a;
        return this;
      }
      asArray() {
        return [this.r, this.g, this.b, this.a];
      }
      toArray(array, index = 0) {
        array[index] = this.r;
        array[index + 1] = this.g;
        array[index + 2] = this.b;
        array[index + 3] = this.a;
        return this;
      }
      fromArray(array, offset = 0) {
        Color4.FromArrayToRef(array, offset, this);
        return this;
      }
      equals(otherColor) {
        return otherColor && this.r === otherColor.r && this.g === otherColor.g && this.b === otherColor.b && this.a === otherColor.a;
      }
      add(right) {
        return new Color4(this.r + right.r, this.g + right.g, this.b + right.b, this.a + right.a);
      }
      subtract(right) {
        return new Color4(this.r - right.r, this.g - right.g, this.b - right.b, this.a - right.a);
      }
      subtractToRef(right, result) {
        result.r = this.r - right.r;
        result.g = this.g - right.g;
        result.b = this.b - right.b;
        result.a = this.a - right.a;
        return this;
      }
      scale(scale) {
        return new Color4(this.r * scale, this.g * scale, this.b * scale, this.a * scale);
      }
      scaleInPlace(scale) {
        this.r *= scale;
        this.g *= scale;
        this.b *= scale;
        this.a *= scale;
        return this;
      }
      scaleToRef(scale, result) {
        result.r = this.r * scale;
        result.g = this.g * scale;
        result.b = this.b * scale;
        result.a = this.a * scale;
        return this;
      }
      scaleAndAddToRef(scale, result) {
        result.r += this.r * scale;
        result.g += this.g * scale;
        result.b += this.b * scale;
        result.a += this.a * scale;
        return this;
      }
      clampToRef(min = 0, max = 1, result) {
        result.r = Scalar.Clamp(this.r, min, max);
        result.g = Scalar.Clamp(this.g, min, max);
        result.b = Scalar.Clamp(this.b, min, max);
        result.a = Scalar.Clamp(this.a, min, max);
        return this;
      }
      multiply(color) {
        return new Color4(this.r * color.r, this.g * color.g, this.b * color.b, this.a * color.a);
      }
      multiplyToRef(color, result) {
        result.r = this.r * color.r;
        result.g = this.g * color.g;
        result.b = this.b * color.b;
        result.a = this.a * color.a;
        return result;
      }
      toString() {
        return "{R: " + this.r + " G:" + this.g + " B:" + this.b + " A:" + this.a + "}";
      }
      getClassName() {
        return "Color4";
      }
      getHashCode() {
        let hash = this.r * 255 | 0;
        hash = hash * 397 ^ (this.g * 255 | 0);
        hash = hash * 397 ^ (this.b * 255 | 0);
        hash = hash * 397 ^ (this.a * 255 | 0);
        return hash;
      }
      clone() {
        return new Color4(this.r, this.g, this.b, this.a);
      }
      copyFrom(source) {
        this.r = source.r;
        this.g = source.g;
        this.b = source.b;
        this.a = source.a;
        return this;
      }
      copyFromFloats(r, g, b, a) {
        this.r = r;
        this.g = g;
        this.b = b;
        this.a = a;
        return this;
      }
      set(r, g, b, a) {
        return this.copyFromFloats(r, g, b, a);
      }
      toHexString(returnAsColor3 = false) {
        const intR = Math.round(this.r * 255);
        const intG = Math.round(this.g * 255);
        const intB = Math.round(this.b * 255);
        if (returnAsColor3) {
          return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB);
        }
        const intA = Math.round(this.a * 255);
        return "#" + Scalar.ToHex(intR) + Scalar.ToHex(intG) + Scalar.ToHex(intB) + Scalar.ToHex(intA);
      }
      toLinearSpace(exact = false) {
        const convertedColor = new Color4();
        this.toLinearSpaceToRef(convertedColor, exact);
        return convertedColor;
      }
      toLinearSpaceToRef(convertedColor, exact = false) {
        if (exact) {
          convertedColor.r = colorChannelToLinearSpaceExact(this.r);
          convertedColor.g = colorChannelToLinearSpaceExact(this.g);
          convertedColor.b = colorChannelToLinearSpaceExact(this.b);
        } else {
          convertedColor.r = colorChannelToLinearSpace(this.r);
          convertedColor.g = colorChannelToLinearSpace(this.g);
          convertedColor.b = colorChannelToLinearSpace(this.b);
        }
        convertedColor.a = this.a;
        return this;
      }
      toGammaSpace(exact = false) {
        const convertedColor = new Color4();
        this.toGammaSpaceToRef(convertedColor, exact);
        return convertedColor;
      }
      toGammaSpaceToRef(convertedColor, exact = false) {
        if (exact) {
          convertedColor.r = colorChannelToGammaSpaceExact(this.r);
          convertedColor.g = colorChannelToGammaSpaceExact(this.g);
          convertedColor.b = colorChannelToGammaSpaceExact(this.b);
        } else {
          convertedColor.r = colorChannelToGammaSpace(this.r);
          convertedColor.g = colorChannelToGammaSpace(this.g);
          convertedColor.b = colorChannelToGammaSpace(this.b);
        }
        convertedColor.a = this.a;
        return this;
      }
      static FromHexString(hex) {
        if (hex.substring(0, 1) !== "#" || hex.length !== 9 && hex.length !== 7) {
          return new Color4(0, 0, 0, 0);
        }
        const r = parseInt(hex.substring(1, 3), 16);
        const g = parseInt(hex.substring(3, 5), 16);
        const b = parseInt(hex.substring(5, 7), 16);
        const a = hex.length === 9 ? parseInt(hex.substring(7, 9), 16) : 255;
        return Color4.FromInts(r, g, b, a);
      }
      static Lerp(left, right, amount) {
        const result = new Color4(0, 0, 0, 0);
        Color4.LerpToRef(left, right, amount, result);
        return result;
      }
      static LerpToRef(left, right, amount, result) {
        result.r = left.r + (right.r - left.r) * amount;
        result.g = left.g + (right.g - left.g) * amount;
        result.b = left.b + (right.b - left.b) * amount;
        result.a = left.a + (right.a - left.a) * amount;
      }
      static Hermite(value1, tangent1, value2, tangent2, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const part1 = 2 * cubed - 3 * squared + 1;
        const part2 = -2 * cubed + 3 * squared;
        const part3 = cubed - 2 * squared + amount;
        const part4 = cubed - squared;
        const r = value1.r * part1 + value2.r * part2 + tangent1.r * part3 + tangent2.r * part4;
        const g = value1.g * part1 + value2.g * part2 + tangent1.g * part3 + tangent2.g * part4;
        const b = value1.b * part1 + value2.b * part2 + tangent1.b * part3 + tangent2.b * part4;
        const a = value1.a * part1 + value2.a * part2 + tangent1.a * part3 + tangent2.a * part4;
        return new Color4(r, g, b, a);
      }
      static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
        const result = new Color4();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      }
      static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
        const t2 = time * time;
        result.r = (t2 - time) * 6 * value1.r + (3 * t2 - 4 * time + 1) * tangent1.r + (-t2 + time) * 6 * value2.r + (3 * t2 - 2 * time) * tangent2.r;
        result.g = (t2 - time) * 6 * value1.g + (3 * t2 - 4 * time + 1) * tangent1.g + (-t2 + time) * 6 * value2.g + (3 * t2 - 2 * time) * tangent2.g;
        result.b = (t2 - time) * 6 * value1.b + (3 * t2 - 4 * time + 1) * tangent1.b + (-t2 + time) * 6 * value2.b + (3 * t2 - 2 * time) * tangent2.b;
        result.a = (t2 - time) * 6 * value1.a + (3 * t2 - 4 * time + 1) * tangent1.a + (-t2 + time) * 6 * value2.a + (3 * t2 - 2 * time) * tangent2.a;
      }
      static FromColor3(color3, alpha = 1) {
        return new Color4(color3.r, color3.g, color3.b, alpha);
      }
      static FromArray(array, offset = 0) {
        return new Color4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
      }
      static FromArrayToRef(array, offset = 0, result) {
        result.r = array[offset];
        result.g = array[offset + 1];
        result.b = array[offset + 2];
        result.a = array[offset + 3];
      }
      static FromInts(r, g, b, a) {
        return new Color4(r / 255, g / 255, b / 255, a / 255);
      }
      static CheckColors4(colors, count) {
        if (colors.length === count * 3) {
          const colors4 = [];
          for (let index = 0; index < colors.length; index += 3) {
            const newIndex = index / 3 * 4;
            colors4[newIndex] = colors[index];
            colors4[newIndex + 1] = colors[index + 1];
            colors4[newIndex + 2] = colors[index + 2];
            colors4[newIndex + 3] = 1;
          }
          return colors4;
        }
        return colors;
      }
    };
    TmpColors = class {
    };
    TmpColors.Color3 = ArrayTools.BuildArray(3, Color3.Black);
    TmpColors.Color4 = ArrayTools.BuildArray(3, () => new Color4(0, 0, 0, 0));
    RegisterClass("BABYLON.Color3", Color3);
    RegisterClass("BABYLON.Color4", Color4);
  }
});

// node_modules/@babylonjs/core/Misc/decorators.js
function getDirectStore(target) {
  const classKey = target.getClassName();
  if (!__decoratorInitialStore[classKey]) {
    __decoratorInitialStore[classKey] = {};
  }
  return __decoratorInitialStore[classKey];
}
function getMergedStore(target) {
  const classKey = target.getClassName();
  if (__mergedStore[classKey]) {
    return __mergedStore[classKey];
  }
  __mergedStore[classKey] = {};
  const store = __mergedStore[classKey];
  let currentTarget = target;
  let currentKey = classKey;
  while (currentKey) {
    const initialStore = __decoratorInitialStore[currentKey];
    for (const property in initialStore) {
      store[property] = initialStore[property];
    }
    let parent;
    let done = false;
    do {
      parent = Object.getPrototypeOf(currentTarget);
      if (!parent.getClassName) {
        done = true;
        break;
      }
      if (parent.getClassName() !== currentKey) {
        break;
      }
      currentTarget = parent;
    } while (parent);
    if (done) {
      break;
    }
    currentKey = parent.getClassName();
    currentTarget = parent;
  }
  return store;
}
function generateSerializableMember(type, sourceName) {
  return (target, propertyKey) => {
    const classStore = getDirectStore(target);
    if (!classStore[propertyKey]) {
      classStore[propertyKey] = { type, sourceName };
    }
  };
}
function generateExpandMember(setCallback, targetKey = null) {
  return (target, propertyKey) => {
    const key = targetKey || "_" + propertyKey;
    Object.defineProperty(target, propertyKey, {
      get: function() {
        return this[key];
      },
      set: function(value) {
        if (typeof this.equals === "function") {
          if (this.equals(value)) {
            return;
          }
        }
        if (this[key] === value) {
          return;
        }
        this[key] = value;
        target[setCallback].apply(this);
      },
      enumerable: true,
      configurable: true
    });
  };
}
function expandToProperty(callback, targetKey = null) {
  return generateExpandMember(callback, targetKey);
}
function serialize(sourceName) {
  return generateSerializableMember(0, sourceName);
}
function serializeAsTexture(sourceName) {
  return generateSerializableMember(1, sourceName);
}
function serializeAsColor3(sourceName) {
  return generateSerializableMember(2, sourceName);
}
function serializeAsFresnelParameters(sourceName) {
  return generateSerializableMember(3, sourceName);
}
function serializeAsVector2(sourceName) {
  return generateSerializableMember(4, sourceName);
}
function serializeAsVector3(sourceName) {
  return generateSerializableMember(5, sourceName);
}
function serializeAsMeshReference(sourceName) {
  return generateSerializableMember(6, sourceName);
}
function serializeAsColorCurves(sourceName) {
  return generateSerializableMember(7, sourceName);
}
function serializeAsColor4(sourceName) {
  return generateSerializableMember(8, sourceName);
}
function serializeAsImageProcessingConfiguration(sourceName) {
  return generateSerializableMember(9, sourceName);
}
function serializeAsQuaternion(sourceName) {
  return generateSerializableMember(10, sourceName);
}
function serializeAsMatrix(sourceName) {
  return generateSerializableMember(12, sourceName);
}
function serializeAsCameraReference(sourceName) {
  return generateSerializableMember(11, sourceName);
}
function nativeOverride(target, propertyKey, descriptor, predicate) {
  const jsFunc = descriptor.value;
  descriptor.value = (...params) => {
    let func = jsFunc;
    if (typeof _native !== "undefined" && _native[propertyKey]) {
      const nativeFunc = _native[propertyKey];
      if (predicate) {
        func = (...params2) => predicate(...params2) ? nativeFunc(...params2) : jsFunc(...params2);
      } else {
        func = nativeFunc;
      }
    }
    target[propertyKey] = func;
    return func(...params);
  };
}
var __decoratorInitialStore, __mergedStore, _copySource, SerializationHelper;
var init_decorators = __esm({
  "node_modules/@babylonjs/core/Misc/decorators.js"() {
    init_tags();
    init_math_vector();
    init_devTools();
    init_math_color();
    __decoratorInitialStore = {};
    __mergedStore = {};
    _copySource = function(creationFunction, source, instanciate, options = {}) {
      const destination = creationFunction();
      if (Tags && Tags.HasTags(source)) {
        Tags.AddTagsTo(destination, Tags.GetTags(source, true));
      }
      const classStore = getMergedStore(destination);
      const textureMap = {};
      for (const property in classStore) {
        const propertyDescriptor = classStore[property];
        const sourceProperty = source[property];
        const propertyType = propertyDescriptor.type;
        if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
          switch (propertyType) {
            case 0:
            case 6:
            case 11:
              destination[property] = sourceProperty;
              break;
            case 1:
              if (options.cloneTexturesOnlyOnce && textureMap[sourceProperty.uniqueId]) {
                destination[property] = textureMap[sourceProperty.uniqueId];
              } else {
                destination[property] = instanciate || sourceProperty.isRenderTarget ? sourceProperty : sourceProperty.clone();
                textureMap[sourceProperty.uniqueId] = destination[property];
              }
              break;
            case 2:
            case 3:
            case 4:
            case 5:
            case 7:
            case 10:
            case 12:
              destination[property] = instanciate ? sourceProperty : sourceProperty.clone();
              break;
          }
        }
      }
      return destination;
    };
    SerializationHelper = class {
      static AppendSerializedAnimations(source, destination) {
        if (source.animations) {
          destination.animations = [];
          for (let animationIndex = 0; animationIndex < source.animations.length; animationIndex++) {
            const animation = source.animations[animationIndex];
            destination.animations.push(animation.serialize());
          }
        }
      }
      static Serialize(entity, serializationObject) {
        if (!serializationObject) {
          serializationObject = {};
        }
        if (Tags) {
          serializationObject.tags = Tags.GetTags(entity);
        }
        const serializedProperties = getMergedStore(entity);
        for (const property in serializedProperties) {
          const propertyDescriptor = serializedProperties[property];
          const targetPropertyName = propertyDescriptor.sourceName || property;
          const propertyType = propertyDescriptor.type;
          const sourceProperty = entity[property];
          if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
            switch (propertyType) {
              case 0:
                serializationObject[targetPropertyName] = sourceProperty;
                break;
              case 1:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 2:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 3:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 4:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 5:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 6:
                serializationObject[targetPropertyName] = sourceProperty.id;
                break;
              case 7:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 8:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 9:
                serializationObject[targetPropertyName] = sourceProperty.serialize();
                break;
              case 10:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
              case 11:
                serializationObject[targetPropertyName] = sourceProperty.id;
                break;
              case 12:
                serializationObject[targetPropertyName] = sourceProperty.asArray();
                break;
            }
          }
        }
        return serializationObject;
      }
      static ParseProperties(source, destination, scene, rootUrl) {
        if (!rootUrl) {
          rootUrl = "";
        }
        const classStore = getMergedStore(destination);
        for (const property in classStore) {
          const propertyDescriptor = classStore[property];
          const sourceProperty = source[propertyDescriptor.sourceName || property];
          const propertyType = propertyDescriptor.type;
          if (sourceProperty !== void 0 && sourceProperty !== null && (property !== "uniqueId" || SerializationHelper.AllowLoadingUniqueId)) {
            const dest = destination;
            switch (propertyType) {
              case 0:
                dest[property] = sourceProperty;
                break;
              case 1:
                if (scene) {
                  dest[property] = SerializationHelper._TextureParser(sourceProperty, scene, rootUrl);
                }
                break;
              case 2:
                dest[property] = Color3.FromArray(sourceProperty);
                break;
              case 3:
                dest[property] = SerializationHelper._FresnelParametersParser(sourceProperty);
                break;
              case 4:
                dest[property] = Vector2.FromArray(sourceProperty);
                break;
              case 5:
                dest[property] = Vector3.FromArray(sourceProperty);
                break;
              case 6:
                if (scene) {
                  dest[property] = scene.getLastMeshById(sourceProperty);
                }
                break;
              case 7:
                dest[property] = SerializationHelper._ColorCurvesParser(sourceProperty);
                break;
              case 8:
                dest[property] = Color4.FromArray(sourceProperty);
                break;
              case 9:
                dest[property] = SerializationHelper._ImageProcessingConfigurationParser(sourceProperty);
                break;
              case 10:
                dest[property] = Quaternion.FromArray(sourceProperty);
                break;
              case 11:
                if (scene) {
                  dest[property] = scene.getCameraById(sourceProperty);
                }
                break;
              case 12:
                dest[property] = Matrix.FromArray(sourceProperty);
                break;
            }
          }
        }
      }
      static Parse(creationFunction, source, scene, rootUrl = null) {
        const destination = creationFunction();
        if (Tags) {
          Tags.AddTagsTo(destination, source.tags);
        }
        SerializationHelper.ParseProperties(source, destination, scene, rootUrl);
        return destination;
      }
      static Clone(creationFunction, source, options = {}) {
        return _copySource(creationFunction, source, false, options);
      }
      static Instanciate(creationFunction, source) {
        return _copySource(creationFunction, source, true);
      }
    };
    SerializationHelper.AllowLoadingUniqueId = false;
    SerializationHelper._ImageProcessingConfigurationParser = (sourceProperty) => {
      throw _WarnImport("ImageProcessingConfiguration");
    };
    SerializationHelper._FresnelParametersParser = (sourceProperty) => {
      throw _WarnImport("FresnelParameters");
    };
    SerializationHelper._ColorCurvesParser = (sourceProperty) => {
      throw _WarnImport("ColorCurves");
    };
    SerializationHelper._TextureParser = (sourceProperty, scene, rootUrl) => {
      throw _WarnImport("Texture");
    };
    nativeOverride.filter = function(predicate) {
      return (target, propertyKey, descriptor) => nativeOverride(target, propertyKey, descriptor, predicate);
    };
  }
});

// node_modules/@babylonjs/core/Materials/materialDefines.js
var MaterialDefines;
var init_materialDefines = __esm({
  "node_modules/@babylonjs/core/Materials/materialDefines.js"() {
    MaterialDefines = class {
      constructor(externalProperties) {
        this._keys = [];
        this._isDirty = true;
        this._areLightsDirty = true;
        this._areLightsDisposed = false;
        this._areAttributesDirty = true;
        this._areTexturesDirty = true;
        this._areFresnelDirty = true;
        this._areMiscDirty = true;
        this._arePrePassDirty = true;
        this._areImageProcessingDirty = true;
        this._normals = false;
        this._uvs = false;
        this._needNormals = false;
        this._needUVs = false;
        this._externalProperties = externalProperties;
        if (externalProperties) {
          for (const prop in externalProperties) {
            if (Object.prototype.hasOwnProperty.call(externalProperties, prop)) {
              this._setDefaultValue(prop);
            }
          }
        }
      }
      get isDirty() {
        return this._isDirty;
      }
      markAsProcessed() {
        this._isDirty = false;
        this._areAttributesDirty = false;
        this._areTexturesDirty = false;
        this._areFresnelDirty = false;
        this._areLightsDirty = false;
        this._areLightsDisposed = false;
        this._areMiscDirty = false;
        this._arePrePassDirty = false;
        this._areImageProcessingDirty = false;
      }
      markAsUnprocessed() {
        this._isDirty = true;
      }
      markAllAsDirty() {
        this._areTexturesDirty = true;
        this._areAttributesDirty = true;
        this._areLightsDirty = true;
        this._areFresnelDirty = true;
        this._areMiscDirty = true;
        this._arePrePassDirty = false;
        this._areImageProcessingDirty = true;
        this._isDirty = true;
      }
      markAsImageProcessingDirty() {
        this._areImageProcessingDirty = true;
        this._isDirty = true;
      }
      markAsLightDirty(disposed = false) {
        this._areLightsDirty = true;
        this._areLightsDisposed = this._areLightsDisposed || disposed;
        this._isDirty = true;
      }
      markAsAttributesDirty() {
        this._areAttributesDirty = true;
        this._isDirty = true;
      }
      markAsTexturesDirty() {
        this._areTexturesDirty = true;
        this._isDirty = true;
      }
      markAsFresnelDirty() {
        this._areFresnelDirty = true;
        this._isDirty = true;
      }
      markAsMiscDirty() {
        this._areMiscDirty = true;
        this._isDirty = true;
      }
      markAsPrePassDirty() {
        this._arePrePassDirty = true;
        this._isDirty = true;
      }
      rebuild() {
        this._keys.length = 0;
        for (const key of Object.keys(this)) {
          if (key[0] === "_") {
            continue;
          }
          this._keys.push(key);
        }
        if (this._externalProperties) {
          for (const name in this._externalProperties) {
            if (this._keys.indexOf(name) === -1) {
              this._keys.push(name);
            }
          }
        }
      }
      isEqual(other) {
        if (this._keys.length !== other._keys.length) {
          return false;
        }
        for (let index = 0; index < this._keys.length; index++) {
          const prop = this._keys[index];
          if (this[prop] !== other[prop]) {
            return false;
          }
        }
        return true;
      }
      cloneTo(other) {
        if (this._keys.length !== other._keys.length) {
          other._keys = this._keys.slice(0);
        }
        for (let index = 0; index < this._keys.length; index++) {
          const prop = this._keys[index];
          other[prop] = this[prop];
        }
      }
      reset() {
        this._keys.forEach((prop) => this._setDefaultValue(prop));
      }
      _setDefaultValue(prop) {
        var _a, _b, _c, _d, _e;
        const type = (_c = (_b = (_a = this._externalProperties) === null || _a === void 0 ? void 0 : _a[prop]) === null || _b === void 0 ? void 0 : _b.type) !== null && _c !== void 0 ? _c : typeof this[prop];
        const defValue = (_e = (_d = this._externalProperties) === null || _d === void 0 ? void 0 : _d[prop]) === null || _e === void 0 ? void 0 : _e.default;
        switch (type) {
          case "number":
            this[prop] = defValue !== null && defValue !== void 0 ? defValue : 0;
            break;
          case "string":
            this[prop] = defValue !== null && defValue !== void 0 ? defValue : "";
            break;
          default:
            this[prop] = defValue !== null && defValue !== void 0 ? defValue : false;
            break;
        }
      }
      toString() {
        let result = "";
        for (let index = 0; index < this._keys.length; index++) {
          const prop = this._keys[index];
          const value = this[prop];
          const type = typeof value;
          switch (type) {
            case "number":
            case "string":
              result += "#define " + prop + " " + value + "\n";
              break;
            default:
              if (value) {
                result += "#define " + prop + "\n";
              }
              break;
          }
        }
        return result;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/colorCurves.js
var ColorCurves;
var init_colorCurves = __esm({
  "node_modules/@babylonjs/core/Materials/colorCurves.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    ColorCurves = class {
      constructor() {
        this._dirty = true;
        this._tempColor = new Color4(0, 0, 0, 0);
        this._globalCurve = new Color4(0, 0, 0, 0);
        this._highlightsCurve = new Color4(0, 0, 0, 0);
        this._midtonesCurve = new Color4(0, 0, 0, 0);
        this._shadowsCurve = new Color4(0, 0, 0, 0);
        this._positiveCurve = new Color4(0, 0, 0, 0);
        this._negativeCurve = new Color4(0, 0, 0, 0);
        this._globalHue = 30;
        this._globalDensity = 0;
        this._globalSaturation = 0;
        this._globalExposure = 0;
        this._highlightsHue = 30;
        this._highlightsDensity = 0;
        this._highlightsSaturation = 0;
        this._highlightsExposure = 0;
        this._midtonesHue = 30;
        this._midtonesDensity = 0;
        this._midtonesSaturation = 0;
        this._midtonesExposure = 0;
        this._shadowsHue = 30;
        this._shadowsDensity = 0;
        this._shadowsSaturation = 0;
        this._shadowsExposure = 0;
      }
      get globalHue() {
        return this._globalHue;
      }
      set globalHue(value) {
        this._globalHue = value;
        this._dirty = true;
      }
      get globalDensity() {
        return this._globalDensity;
      }
      set globalDensity(value) {
        this._globalDensity = value;
        this._dirty = true;
      }
      get globalSaturation() {
        return this._globalSaturation;
      }
      set globalSaturation(value) {
        this._globalSaturation = value;
        this._dirty = true;
      }
      get globalExposure() {
        return this._globalExposure;
      }
      set globalExposure(value) {
        this._globalExposure = value;
        this._dirty = true;
      }
      get highlightsHue() {
        return this._highlightsHue;
      }
      set highlightsHue(value) {
        this._highlightsHue = value;
        this._dirty = true;
      }
      get highlightsDensity() {
        return this._highlightsDensity;
      }
      set highlightsDensity(value) {
        this._highlightsDensity = value;
        this._dirty = true;
      }
      get highlightsSaturation() {
        return this._highlightsSaturation;
      }
      set highlightsSaturation(value) {
        this._highlightsSaturation = value;
        this._dirty = true;
      }
      get highlightsExposure() {
        return this._highlightsExposure;
      }
      set highlightsExposure(value) {
        this._highlightsExposure = value;
        this._dirty = true;
      }
      get midtonesHue() {
        return this._midtonesHue;
      }
      set midtonesHue(value) {
        this._midtonesHue = value;
        this._dirty = true;
      }
      get midtonesDensity() {
        return this._midtonesDensity;
      }
      set midtonesDensity(value) {
        this._midtonesDensity = value;
        this._dirty = true;
      }
      get midtonesSaturation() {
        return this._midtonesSaturation;
      }
      set midtonesSaturation(value) {
        this._midtonesSaturation = value;
        this._dirty = true;
      }
      get midtonesExposure() {
        return this._midtonesExposure;
      }
      set midtonesExposure(value) {
        this._midtonesExposure = value;
        this._dirty = true;
      }
      get shadowsHue() {
        return this._shadowsHue;
      }
      set shadowsHue(value) {
        this._shadowsHue = value;
        this._dirty = true;
      }
      get shadowsDensity() {
        return this._shadowsDensity;
      }
      set shadowsDensity(value) {
        this._shadowsDensity = value;
        this._dirty = true;
      }
      get shadowsSaturation() {
        return this._shadowsSaturation;
      }
      set shadowsSaturation(value) {
        this._shadowsSaturation = value;
        this._dirty = true;
      }
      get shadowsExposure() {
        return this._shadowsExposure;
      }
      set shadowsExposure(value) {
        this._shadowsExposure = value;
        this._dirty = true;
      }
      getClassName() {
        return "ColorCurves";
      }
      static Bind(colorCurves, effect, positiveUniform = "vCameraColorCurvePositive", neutralUniform = "vCameraColorCurveNeutral", negativeUniform = "vCameraColorCurveNegative") {
        if (colorCurves._dirty) {
          colorCurves._dirty = false;
          colorCurves._getColorGradingDataToRef(colorCurves._globalHue, colorCurves._globalDensity, colorCurves._globalSaturation, colorCurves._globalExposure, colorCurves._globalCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._highlightsHue, colorCurves._highlightsDensity, colorCurves._highlightsSaturation, colorCurves._highlightsExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._highlightsCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._midtonesHue, colorCurves._midtonesDensity, colorCurves._midtonesSaturation, colorCurves._midtonesExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._midtonesCurve);
          colorCurves._getColorGradingDataToRef(colorCurves._shadowsHue, colorCurves._shadowsDensity, colorCurves._shadowsSaturation, colorCurves._shadowsExposure, colorCurves._tempColor);
          colorCurves._tempColor.multiplyToRef(colorCurves._globalCurve, colorCurves._shadowsCurve);
          colorCurves._highlightsCurve.subtractToRef(colorCurves._midtonesCurve, colorCurves._positiveCurve);
          colorCurves._midtonesCurve.subtractToRef(colorCurves._shadowsCurve, colorCurves._negativeCurve);
        }
        if (effect) {
          effect.setFloat4(positiveUniform, colorCurves._positiveCurve.r, colorCurves._positiveCurve.g, colorCurves._positiveCurve.b, colorCurves._positiveCurve.a);
          effect.setFloat4(neutralUniform, colorCurves._midtonesCurve.r, colorCurves._midtonesCurve.g, colorCurves._midtonesCurve.b, colorCurves._midtonesCurve.a);
          effect.setFloat4(negativeUniform, colorCurves._negativeCurve.r, colorCurves._negativeCurve.g, colorCurves._negativeCurve.b, colorCurves._negativeCurve.a);
        }
      }
      static PrepareUniforms(uniformsList) {
        uniformsList.push("vCameraColorCurveNeutral", "vCameraColorCurvePositive", "vCameraColorCurveNegative");
      }
      _getColorGradingDataToRef(hue, density, saturation, exposure, result) {
        if (hue == null) {
          return;
        }
        hue = ColorCurves._Clamp(hue, 0, 360);
        density = ColorCurves._Clamp(density, -100, 100);
        saturation = ColorCurves._Clamp(saturation, -100, 100);
        exposure = ColorCurves._Clamp(exposure, -100, 100);
        density = ColorCurves._ApplyColorGradingSliderNonlinear(density);
        density *= 0.5;
        exposure = ColorCurves._ApplyColorGradingSliderNonlinear(exposure);
        if (density < 0) {
          density *= -1;
          hue = (hue + 180) % 360;
        }
        ColorCurves._FromHSBToRef(hue, density, 50 + 0.25 * exposure, result);
        result.scaleToRef(2, result);
        result.a = 1 + 0.01 * saturation;
      }
      static _ApplyColorGradingSliderNonlinear(value) {
        value /= 100;
        let x = Math.abs(value);
        x = Math.pow(x, 2);
        if (value < 0) {
          x *= -1;
        }
        x *= 100;
        return x;
      }
      static _FromHSBToRef(hue, saturation, brightness, result) {
        let h = ColorCurves._Clamp(hue, 0, 360);
        const s = ColorCurves._Clamp(saturation / 100, 0, 1);
        const v = ColorCurves._Clamp(brightness / 100, 0, 1);
        if (s === 0) {
          result.r = v;
          result.g = v;
          result.b = v;
        } else {
          h /= 60;
          const i = Math.floor(h);
          const f = h - i;
          const p = v * (1 - s);
          const q = v * (1 - s * f);
          const t = v * (1 - s * (1 - f));
          switch (i) {
            case 0:
              result.r = v;
              result.g = t;
              result.b = p;
              break;
            case 1:
              result.r = q;
              result.g = v;
              result.b = p;
              break;
            case 2:
              result.r = p;
              result.g = v;
              result.b = t;
              break;
            case 3:
              result.r = p;
              result.g = q;
              result.b = v;
              break;
            case 4:
              result.r = t;
              result.g = p;
              result.b = v;
              break;
            default:
              result.r = v;
              result.g = p;
              result.b = q;
              break;
          }
        }
        result.a = 1;
      }
      static _Clamp(value, min, max) {
        return Math.min(Math.max(value, min), max);
      }
      clone() {
        return SerializationHelper.Clone(() => new ColorCurves(), this);
      }
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      static Parse(source) {
        return SerializationHelper.Parse(() => new ColorCurves(), source, null, null);
      }
    };
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalHue", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalDensity", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalSaturation", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_globalExposure", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsHue", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsDensity", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsSaturation", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_highlightsExposure", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesHue", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesDensity", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesSaturation", void 0);
    __decorate([
      serialize()
    ], ColorCurves.prototype, "_midtonesExposure", void 0);
    SerializationHelper._ColorCurvesParser = ColorCurves.Parse;
  }
});

// node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js
var ImageProcessingConfigurationDefines, ImageProcessingConfiguration;
var init_imageProcessingConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/imageProcessingConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_tools();
    init_math_color();
    init_materialDefines();
    init_colorCurves();
    ImageProcessingConfigurationDefines = class extends MaterialDefines {
      constructor() {
        super();
        this.IMAGEPROCESSING = false;
        this.VIGNETTE = false;
        this.VIGNETTEBLENDMODEMULTIPLY = false;
        this.VIGNETTEBLENDMODEOPAQUE = false;
        this.TONEMAPPING = false;
        this.TONEMAPPING_ACES = false;
        this.CONTRAST = false;
        this.COLORCURVES = false;
        this.COLORGRADING = false;
        this.COLORGRADING3D = false;
        this.SAMPLER3DGREENDEPTH = false;
        this.SAMPLER3DBGRMAP = false;
        this.DITHER = false;
        this.IMAGEPROCESSINGPOSTPROCESS = false;
        this.EXPOSURE = false;
        this.SKIPFINALCOLORCLAMP = false;
        this.rebuild();
      }
    };
    ImageProcessingConfiguration = class {
      constructor() {
        this.colorCurves = new ColorCurves();
        this._colorCurvesEnabled = false;
        this._colorGradingEnabled = false;
        this._colorGradingWithGreenDepth = true;
        this._colorGradingBGR = true;
        this._exposure = 1;
        this._toneMappingEnabled = false;
        this._toneMappingType = ImageProcessingConfiguration.TONEMAPPING_STANDARD;
        this._contrast = 1;
        this.vignetteStretch = 0;
        this.vignetteCenterX = 0;
        this.vignetteCenterY = 0;
        this.vignetteWeight = 1.5;
        this.vignetteColor = new Color4(0, 0, 0, 0);
        this.vignetteCameraFov = 0.5;
        this._vignetteBlendMode = ImageProcessingConfiguration.VIGNETTEMODE_MULTIPLY;
        this._vignetteEnabled = false;
        this._ditheringEnabled = false;
        this._ditheringIntensity = 1 / 255;
        this._skipFinalColorClamp = false;
        this._applyByPostProcess = false;
        this._isEnabled = true;
        this.onUpdateParameters = new Observable();
      }
      get colorCurvesEnabled() {
        return this._colorCurvesEnabled;
      }
      set colorCurvesEnabled(value) {
        if (this._colorCurvesEnabled === value) {
          return;
        }
        this._colorCurvesEnabled = value;
        this._updateParameters();
      }
      get colorGradingTexture() {
        return this._colorGradingTexture;
      }
      set colorGradingTexture(value) {
        if (this._colorGradingTexture === value) {
          return;
        }
        this._colorGradingTexture = value;
        this._updateParameters();
      }
      get colorGradingEnabled() {
        return this._colorGradingEnabled;
      }
      set colorGradingEnabled(value) {
        if (this._colorGradingEnabled === value) {
          return;
        }
        this._colorGradingEnabled = value;
        this._updateParameters();
      }
      get colorGradingWithGreenDepth() {
        return this._colorGradingWithGreenDepth;
      }
      set colorGradingWithGreenDepth(value) {
        if (this._colorGradingWithGreenDepth === value) {
          return;
        }
        this._colorGradingWithGreenDepth = value;
        this._updateParameters();
      }
      get colorGradingBGR() {
        return this._colorGradingBGR;
      }
      set colorGradingBGR(value) {
        if (this._colorGradingBGR === value) {
          return;
        }
        this._colorGradingBGR = value;
        this._updateParameters();
      }
      get exposure() {
        return this._exposure;
      }
      set exposure(value) {
        if (this._exposure === value) {
          return;
        }
        this._exposure = value;
        this._updateParameters();
      }
      get toneMappingEnabled() {
        return this._toneMappingEnabled;
      }
      set toneMappingEnabled(value) {
        if (this._toneMappingEnabled === value) {
          return;
        }
        this._toneMappingEnabled = value;
        this._updateParameters();
      }
      get toneMappingType() {
        return this._toneMappingType;
      }
      set toneMappingType(value) {
        if (this._toneMappingType === value) {
          return;
        }
        this._toneMappingType = value;
        this._updateParameters();
      }
      get contrast() {
        return this._contrast;
      }
      set contrast(value) {
        if (this._contrast === value) {
          return;
        }
        this._contrast = value;
        this._updateParameters();
      }
      get vignetteCentreY() {
        return this.vignetteCenterY;
      }
      set vignetteCentreY(value) {
        this.vignetteCenterY = value;
      }
      get vignetteCentreX() {
        return this.vignetteCenterX;
      }
      set vignetteCentreX(value) {
        this.vignetteCenterX = value;
      }
      get vignetteBlendMode() {
        return this._vignetteBlendMode;
      }
      set vignetteBlendMode(value) {
        if (this._vignetteBlendMode === value) {
          return;
        }
        this._vignetteBlendMode = value;
        this._updateParameters();
      }
      get vignetteEnabled() {
        return this._vignetteEnabled;
      }
      set vignetteEnabled(value) {
        if (this._vignetteEnabled === value) {
          return;
        }
        this._vignetteEnabled = value;
        this._updateParameters();
      }
      get ditheringEnabled() {
        return this._ditheringEnabled;
      }
      set ditheringEnabled(value) {
        if (this._ditheringEnabled === value) {
          return;
        }
        this._ditheringEnabled = value;
        this._updateParameters();
      }
      get ditheringIntensity() {
        return this._ditheringIntensity;
      }
      set ditheringIntensity(value) {
        if (this._ditheringIntensity === value) {
          return;
        }
        this._ditheringIntensity = value;
        this._updateParameters();
      }
      get skipFinalColorClamp() {
        return this._skipFinalColorClamp;
      }
      set skipFinalColorClamp(value) {
        if (this._skipFinalColorClamp === value) {
          return;
        }
        this._skipFinalColorClamp = value;
        this._updateParameters();
      }
      get applyByPostProcess() {
        return this._applyByPostProcess;
      }
      set applyByPostProcess(value) {
        if (this._applyByPostProcess === value) {
          return;
        }
        this._applyByPostProcess = value;
        this._updateParameters();
      }
      get isEnabled() {
        return this._isEnabled;
      }
      set isEnabled(value) {
        if (this._isEnabled === value) {
          return;
        }
        this._isEnabled = value;
        this._updateParameters();
      }
      _updateParameters() {
        this.onUpdateParameters.notifyObservers(this);
      }
      getClassName() {
        return "ImageProcessingConfiguration";
      }
      static PrepareUniforms(uniforms, defines) {
        if (defines.EXPOSURE) {
          uniforms.push("exposureLinear");
        }
        if (defines.CONTRAST) {
          uniforms.push("contrast");
        }
        if (defines.COLORGRADING) {
          uniforms.push("colorTransformSettings");
        }
        if (defines.VIGNETTE || defines.DITHER) {
          uniforms.push("vInverseScreenSize");
        }
        if (defines.VIGNETTE) {
          uniforms.push("vignetteSettings1");
          uniforms.push("vignetteSettings2");
        }
        if (defines.COLORCURVES) {
          ColorCurves.PrepareUniforms(uniforms);
        }
        if (defines.DITHER) {
          uniforms.push("ditherIntensity");
        }
      }
      static PrepareSamplers(samplersList, defines) {
        if (defines.COLORGRADING) {
          samplersList.push("txColorTransform");
        }
      }
      prepareDefines(defines, forPostProcess = false) {
        if (forPostProcess !== this.applyByPostProcess || !this._isEnabled) {
          defines.VIGNETTE = false;
          defines.TONEMAPPING = false;
          defines.TONEMAPPING_ACES = false;
          defines.CONTRAST = false;
          defines.EXPOSURE = false;
          defines.COLORCURVES = false;
          defines.COLORGRADING = false;
          defines.COLORGRADING3D = false;
          defines.DITHER = false;
          defines.IMAGEPROCESSING = false;
          defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
          defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess && this._isEnabled;
          return;
        }
        defines.VIGNETTE = this.vignetteEnabled;
        defines.VIGNETTEBLENDMODEMULTIPLY = this.vignetteBlendMode === ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY;
        defines.VIGNETTEBLENDMODEOPAQUE = !defines.VIGNETTEBLENDMODEMULTIPLY;
        defines.TONEMAPPING = this.toneMappingEnabled;
        switch (this._toneMappingType) {
          case ImageProcessingConfiguration.TONEMAPPING_ACES:
            defines.TONEMAPPING_ACES = true;
            break;
          default:
            defines.TONEMAPPING_ACES = false;
            break;
        }
        defines.CONTRAST = this.contrast !== 1;
        defines.EXPOSURE = this.exposure !== 1;
        defines.COLORCURVES = this.colorCurvesEnabled && !!this.colorCurves;
        defines.COLORGRADING = this.colorGradingEnabled && !!this.colorGradingTexture;
        if (defines.COLORGRADING) {
          defines.COLORGRADING3D = this.colorGradingTexture.is3D;
        } else {
          defines.COLORGRADING3D = false;
        }
        defines.SAMPLER3DGREENDEPTH = this.colorGradingWithGreenDepth;
        defines.SAMPLER3DBGRMAP = this.colorGradingBGR;
        defines.DITHER = this._ditheringEnabled;
        defines.IMAGEPROCESSINGPOSTPROCESS = this.applyByPostProcess;
        defines.SKIPFINALCOLORCLAMP = this.skipFinalColorClamp;
        defines.IMAGEPROCESSING = defines.VIGNETTE || defines.TONEMAPPING || defines.CONTRAST || defines.EXPOSURE || defines.COLORCURVES || defines.COLORGRADING || defines.DITHER;
      }
      isReady() {
        return !this.colorGradingEnabled || !this.colorGradingTexture || this.colorGradingTexture.isReady();
      }
      bind(effect, overrideAspectRatio) {
        if (this._colorCurvesEnabled && this.colorCurves) {
          ColorCurves.Bind(this.colorCurves, effect);
        }
        if (this._vignetteEnabled || this._ditheringEnabled) {
          const inverseWidth = 1 / effect.getEngine().getRenderWidth();
          const inverseHeight = 1 / effect.getEngine().getRenderHeight();
          effect.setFloat2("vInverseScreenSize", inverseWidth, inverseHeight);
          if (this._ditheringEnabled) {
            effect.setFloat("ditherIntensity", 0.5 * this._ditheringIntensity);
          }
          if (this._vignetteEnabled) {
            const aspectRatio = overrideAspectRatio != null ? overrideAspectRatio : inverseHeight / inverseWidth;
            let vignetteScaleY = Math.tan(this.vignetteCameraFov * 0.5);
            let vignetteScaleX = vignetteScaleY * aspectRatio;
            const vignetteScaleGeometricMean = Math.sqrt(vignetteScaleX * vignetteScaleY);
            vignetteScaleX = Tools.Mix(vignetteScaleX, vignetteScaleGeometricMean, this.vignetteStretch);
            vignetteScaleY = Tools.Mix(vignetteScaleY, vignetteScaleGeometricMean, this.vignetteStretch);
            effect.setFloat4("vignetteSettings1", vignetteScaleX, vignetteScaleY, -vignetteScaleX * this.vignetteCenterX, -vignetteScaleY * this.vignetteCenterY);
            const vignettePower = -2 * this.vignetteWeight;
            effect.setFloat4("vignetteSettings2", this.vignetteColor.r, this.vignetteColor.g, this.vignetteColor.b, vignettePower);
          }
        }
        effect.setFloat("exposureLinear", this.exposure);
        effect.setFloat("contrast", this.contrast);
        if (this.colorGradingTexture) {
          effect.setTexture("txColorTransform", this.colorGradingTexture);
          const textureSize = this.colorGradingTexture.getSize().height;
          effect.setFloat4(
            "colorTransformSettings",
            (textureSize - 1) / textureSize,
            0.5 / textureSize,
            textureSize,
            this.colorGradingTexture.level
          );
        }
      }
      clone() {
        return SerializationHelper.Clone(() => new ImageProcessingConfiguration(), this);
      }
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      static Parse(source) {
        const parsed = SerializationHelper.Parse(() => new ImageProcessingConfiguration(), source, null, null);
        if (source.vignetteCentreX !== void 0) {
          parsed.vignetteCenterX = source.vignetteCentreX;
        }
        if (source.vignetteCentreY !== void 0) {
          parsed.vignetteCenterY = source.vignetteCentreY;
        }
        return parsed;
      }
      static get VIGNETTEMODE_MULTIPLY() {
        return this._VIGNETTEMODE_MULTIPLY;
      }
      static get VIGNETTEMODE_OPAQUE() {
        return this._VIGNETTEMODE_OPAQUE;
      }
    };
    ImageProcessingConfiguration.TONEMAPPING_STANDARD = 0;
    ImageProcessingConfiguration.TONEMAPPING_ACES = 1;
    ImageProcessingConfiguration._VIGNETTEMODE_MULTIPLY = 0;
    ImageProcessingConfiguration._VIGNETTEMODE_OPAQUE = 1;
    __decorate([
      serializeAsColorCurves()
    ], ImageProcessingConfiguration.prototype, "colorCurves", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorCurvesEnabled", void 0);
    __decorate([
      serializeAsTexture("colorGradingTexture")
    ], ImageProcessingConfiguration.prototype, "_colorGradingTexture", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorGradingEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorGradingWithGreenDepth", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_colorGradingBGR", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_exposure", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_toneMappingEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_toneMappingType", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_contrast", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteStretch", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteCenterX", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteCenterY", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteWeight", void 0);
    __decorate([
      serializeAsColor4()
    ], ImageProcessingConfiguration.prototype, "vignetteColor", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "vignetteCameraFov", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_vignetteBlendMode", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_vignetteEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_ditheringEnabled", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_ditheringIntensity", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_skipFinalColorClamp", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_applyByPostProcess", void 0);
    __decorate([
      serialize()
    ], ImageProcessingConfiguration.prototype, "_isEnabled", void 0);
    SerializationHelper._ImageProcessingConfigurationParser = ImageProcessingConfiguration.Parse;
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js
var init_engine_uniformBuffer = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.uniformBuffer.js"() {
    init_thinEngine();
    init_webGLDataBuffer();
    ThinEngine.prototype.createUniformBuffer = function(elements) {
      const ubo = this._gl.createBuffer();
      if (!ubo) {
        throw new Error("Unable to create uniform buffer");
      }
      const result = new WebGLDataBuffer(ubo);
      this.bindUniformBuffer(result);
      if (elements instanceof Float32Array) {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.STATIC_DRAW);
      } else {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.STATIC_DRAW);
      }
      this.bindUniformBuffer(null);
      result.references = 1;
      return result;
    };
    ThinEngine.prototype.createDynamicUniformBuffer = function(elements) {
      const ubo = this._gl.createBuffer();
      if (!ubo) {
        throw new Error("Unable to create dynamic uniform buffer");
      }
      const result = new WebGLDataBuffer(ubo);
      this.bindUniformBuffer(result);
      if (elements instanceof Float32Array) {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, elements, this._gl.DYNAMIC_DRAW);
      } else {
        this._gl.bufferData(this._gl.UNIFORM_BUFFER, new Float32Array(elements), this._gl.DYNAMIC_DRAW);
      }
      this.bindUniformBuffer(null);
      result.references = 1;
      return result;
    };
    ThinEngine.prototype.updateUniformBuffer = function(uniformBuffer, elements, offset, count) {
      this.bindUniformBuffer(uniformBuffer);
      if (offset === void 0) {
        offset = 0;
      }
      if (count === void 0) {
        if (elements instanceof Float32Array) {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, elements);
        } else {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, offset, new Float32Array(elements));
        }
      } else {
        if (elements instanceof Float32Array) {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, elements.subarray(offset, offset + count));
        } else {
          this._gl.bufferSubData(this._gl.UNIFORM_BUFFER, 0, new Float32Array(elements).subarray(offset, offset + count));
        }
      }
      this.bindUniformBuffer(null);
    };
    ThinEngine.prototype.bindUniformBuffer = function(buffer) {
      this._gl.bindBuffer(this._gl.UNIFORM_BUFFER, buffer ? buffer.underlyingResource : null);
    };
    ThinEngine.prototype.bindUniformBufferBase = function(buffer, location2, name) {
      this._gl.bindBufferBase(this._gl.UNIFORM_BUFFER, location2, buffer ? buffer.underlyingResource : null);
    };
    ThinEngine.prototype.bindUniformBlock = function(pipelineContext, blockName, index) {
      const program = pipelineContext.program;
      const uniformLocation = this._gl.getUniformBlockIndex(program, blockName);
      if (uniformLocation !== 4294967295) {
        this._gl.uniformBlockBinding(program, uniformLocation, index);
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/uniformBuffer.js
var UniformBuffer;
var init_uniformBuffer = __esm({
  "node_modules/@babylonjs/core/Materials/uniformBuffer.js"() {
    init_logger();
    init_tools();
    init_engine_uniformBuffer();
    UniformBuffer = class {
      constructor(engine, data, dynamic, name, forceNoUniformBuffer = false) {
        this._valueCache = {};
        this._engine = engine;
        this._noUBO = !engine.supportsUniformBuffers || forceNoUniformBuffer;
        this._dynamic = dynamic;
        this._name = name !== null && name !== void 0 ? name : "no-name";
        this._data = data || [];
        this._uniformLocations = {};
        this._uniformSizes = {};
        this._uniformArraySizes = {};
        this._uniformLocationPointer = 0;
        this._needSync = false;
        if (this._engine._features.trackUbosInFrame) {
          this._buffers = [];
          this._bufferIndex = -1;
          this._createBufferOnWrite = false;
          this._currentFrameId = 0;
        }
        if (this._noUBO) {
          this.updateMatrix3x3 = this._updateMatrix3x3ForEffect;
          this.updateMatrix2x2 = this._updateMatrix2x2ForEffect;
          this.updateFloat = this._updateFloatForEffect;
          this.updateFloat2 = this._updateFloat2ForEffect;
          this.updateFloat3 = this._updateFloat3ForEffect;
          this.updateFloat4 = this._updateFloat4ForEffect;
          this.updateFloatArray = this._updateFloatArrayForEffect;
          this.updateArray = this._updateArrayForEffect;
          this.updateIntArray = this._updateIntArrayForEffect;
          this.updateUIntArray = this._updateUIntArrayForEffect;
          this.updateMatrix = this._updateMatrixForEffect;
          this.updateMatrices = this._updateMatricesForEffect;
          this.updateVector3 = this._updateVector3ForEffect;
          this.updateVector4 = this._updateVector4ForEffect;
          this.updateColor3 = this._updateColor3ForEffect;
          this.updateColor4 = this._updateColor4ForEffect;
          this.updateDirectColor4 = this._updateDirectColor4ForEffect;
          this.updateInt = this._updateIntForEffect;
          this.updateInt2 = this._updateInt2ForEffect;
          this.updateInt3 = this._updateInt3ForEffect;
          this.updateInt4 = this._updateInt4ForEffect;
          this.updateUInt = this._updateUIntForEffect;
          this.updateUInt2 = this._updateUInt2ForEffect;
          this.updateUInt3 = this._updateUInt3ForEffect;
          this.updateUInt4 = this._updateUInt4ForEffect;
        } else {
          this._engine._uniformBuffers.push(this);
          this.updateMatrix3x3 = this._updateMatrix3x3ForUniform;
          this.updateMatrix2x2 = this._updateMatrix2x2ForUniform;
          this.updateFloat = this._updateFloatForUniform;
          this.updateFloat2 = this._updateFloat2ForUniform;
          this.updateFloat3 = this._updateFloat3ForUniform;
          this.updateFloat4 = this._updateFloat4ForUniform;
          this.updateFloatArray = this._updateFloatArrayForUniform;
          this.updateArray = this._updateArrayForUniform;
          this.updateIntArray = this._updateIntArrayForUniform;
          this.updateUIntArray = this._updateUIntArrayForUniform;
          this.updateMatrix = this._updateMatrixForUniform;
          this.updateMatrices = this._updateMatricesForUniform;
          this.updateVector3 = this._updateVector3ForUniform;
          this.updateVector4 = this._updateVector4ForUniform;
          this.updateColor3 = this._updateColor3ForUniform;
          this.updateColor4 = this._updateColor4ForUniform;
          this.updateDirectColor4 = this._updateDirectColor4ForUniform;
          this.updateInt = this._updateIntForUniform;
          this.updateInt2 = this._updateInt2ForUniform;
          this.updateInt3 = this._updateInt3ForUniform;
          this.updateInt4 = this._updateInt4ForUniform;
          this.updateUInt = this._updateUIntForUniform;
          this.updateUInt2 = this._updateUInt2ForUniform;
          this.updateUInt3 = this._updateUInt3ForUniform;
          this.updateUInt4 = this._updateUInt4ForUniform;
        }
      }
      get useUbo() {
        return !this._noUBO;
      }
      get isSync() {
        return !this._needSync;
      }
      isDynamic() {
        return this._dynamic !== void 0;
      }
      getData() {
        return this._bufferData;
      }
      getBuffer() {
        return this._buffer;
      }
      _fillAlignment(size) {
        let alignment;
        if (size <= 2) {
          alignment = size;
        } else {
          alignment = 4;
        }
        if (this._uniformLocationPointer % alignment !== 0) {
          const oldPointer = this._uniformLocationPointer;
          this._uniformLocationPointer += alignment - this._uniformLocationPointer % alignment;
          const diff = this._uniformLocationPointer - oldPointer;
          for (let i = 0; i < diff; i++) {
            this._data.push(0);
          }
        }
      }
      addUniform(name, size, arraySize = 0) {
        if (this._noUBO) {
          return;
        }
        if (this._uniformLocations[name] !== void 0) {
          return;
        }
        let data;
        if (arraySize > 0) {
          if (size instanceof Array) {
            throw "addUniform should not be use with Array in UBO: " + name;
          }
          this._fillAlignment(4);
          this._uniformArraySizes[name] = { strideSize: size, arraySize };
          if (size == 16) {
            size = size * arraySize;
          } else {
            const perElementPadding = 4 - size;
            const totalPadding = perElementPadding * arraySize;
            size = size * arraySize + totalPadding;
          }
          data = [];
          for (let i = 0; i < size; i++) {
            data.push(0);
          }
        } else {
          if (size instanceof Array) {
            data = size;
            size = data.length;
          } else {
            size = size;
            data = [];
            for (let i = 0; i < size; i++) {
              data.push(0);
            }
          }
          this._fillAlignment(size);
        }
        this._uniformSizes[name] = size;
        this._uniformLocations[name] = this._uniformLocationPointer;
        this._uniformLocationPointer += size;
        for (let i = 0; i < size; i++) {
          this._data.push(data[i]);
        }
        this._needSync = true;
      }
      addMatrix(name, mat) {
        this.addUniform(name, Array.prototype.slice.call(mat.toArray()));
      }
      addFloat2(name, x, y) {
        const temp = [x, y];
        this.addUniform(name, temp);
      }
      addFloat3(name, x, y, z) {
        const temp = [x, y, z];
        this.addUniform(name, temp);
      }
      addColor3(name, color) {
        const temp = [color.r, color.g, color.b];
        this.addUniform(name, temp);
      }
      addColor4(name, color, alpha) {
        const temp = [color.r, color.g, color.b, alpha];
        this.addUniform(name, temp);
      }
      addVector3(name, vector) {
        const temp = [vector.x, vector.y, vector.z];
        this.addUniform(name, temp);
      }
      addMatrix3x3(name) {
        this.addUniform(name, 12);
      }
      addMatrix2x2(name) {
        this.addUniform(name, 8);
      }
      create() {
        if (this._noUBO) {
          return;
        }
        if (this._buffer) {
          return;
        }
        this._fillAlignment(4);
        this._bufferData = new Float32Array(this._data);
        this._rebuild();
        this._needSync = true;
      }
      _rebuild() {
        if (this._noUBO || !this._bufferData) {
          return;
        }
        if (this._dynamic) {
          this._buffer = this._engine.createDynamicUniformBuffer(this._bufferData);
        } else {
          this._buffer = this._engine.createUniformBuffer(this._bufferData);
        }
        if (this._engine._features.trackUbosInFrame) {
          this._buffers.push([this._buffer, this._engine._features.checkUbosContentBeforeUpload ? this._bufferData.slice() : void 0]);
          this._bufferIndex = this._buffers.length - 1;
          this._createBufferOnWrite = false;
        }
      }
      get _numBuffers() {
        return this._buffers.length;
      }
      get _indexBuffer() {
        return this._bufferIndex;
      }
      get name() {
        return this._name;
      }
      get currentEffect() {
        return this._currentEffect;
      }
      _buffersEqual(buf1, buf2) {
        for (let i = 0; i < buf1.length; ++i) {
          if (buf1[i] !== buf2[i]) {
            return false;
          }
        }
        return true;
      }
      _copyBuffer(src, dst) {
        for (let i = 0; i < src.length; ++i) {
          dst[i] = src[i];
        }
      }
      update() {
        if (this._noUBO) {
          return;
        }
        this.bindUniformBuffer();
        if (!this._buffer) {
          this.create();
          return;
        }
        if (!this._dynamic && !this._needSync) {
          this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
          return;
        }
        if (this._buffers && this._buffers.length > 1 && this._buffers[this._bufferIndex][1]) {
          if (this._buffersEqual(this._bufferData, this._buffers[this._bufferIndex][1])) {
            this._needSync = false;
            this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
            return;
          } else {
            this._copyBuffer(this._bufferData, this._buffers[this._bufferIndex][1]);
          }
        }
        this._engine.updateUniformBuffer(this._buffer, this._bufferData);
        if (this._engine._features._collectUbosUpdatedInFrame) {
          if (!UniformBuffer._UpdatedUbosInFrame[this._name]) {
            UniformBuffer._UpdatedUbosInFrame[this._name] = 0;
          }
          UniformBuffer._UpdatedUbosInFrame[this._name]++;
        }
        this._needSync = false;
        this._createBufferOnWrite = this._engine._features.trackUbosInFrame;
      }
      _createNewBuffer() {
        if (this._bufferIndex + 1 < this._buffers.length) {
          this._bufferIndex++;
          this._buffer = this._buffers[this._bufferIndex][0];
          this._createBufferOnWrite = false;
          this._needSync = true;
        } else {
          this._rebuild();
        }
      }
      _checkNewFrame() {
        if (this._engine._features.trackUbosInFrame && this._currentFrameId !== this._engine.frameId) {
          this._currentFrameId = this._engine.frameId;
          this._createBufferOnWrite = false;
          if (this._buffers && this._buffers.length > 0) {
            this._needSync = this._bufferIndex !== 0;
            this._bufferIndex = 0;
            this._buffer = this._buffers[this._bufferIndex][0];
          } else {
            this._bufferIndex = -1;
          }
        }
      }
      updateUniform(uniformName, data, size) {
        this._checkNewFrame();
        let location2 = this._uniformLocations[uniformName];
        if (location2 === void 0) {
          if (this._buffer) {
            Logger.Error("Cannot add an uniform after UBO has been created.");
            return;
          }
          this.addUniform(uniformName, size);
          location2 = this._uniformLocations[uniformName];
        }
        if (!this._buffer) {
          this.create();
        }
        if (!this._dynamic) {
          let changed = false;
          for (let i = 0; i < size; i++) {
            if (size === 16 && !this._engine._features.uniformBufferHardCheckMatrix || this._bufferData[location2 + i] !== Tools.FloatRound(data[i])) {
              changed = true;
              if (this._createBufferOnWrite) {
                this._createNewBuffer();
              }
              this._bufferData[location2 + i] = data[i];
            }
          }
          this._needSync = this._needSync || changed;
        } else {
          for (let i = 0; i < size; i++) {
            this._bufferData[location2 + i] = data[i];
          }
        }
      }
      updateUniformArray(uniformName, data, size) {
        this._checkNewFrame();
        const location2 = this._uniformLocations[uniformName];
        if (location2 === void 0) {
          Logger.Error("Cannot add an uniform Array dynamically. Please, add it using addUniform and make sure that uniform buffers are supported by the current engine.");
          return;
        }
        if (!this._buffer) {
          this.create();
        }
        const arraySizes = this._uniformArraySizes[uniformName];
        if (!this._dynamic) {
          let changed = false;
          let countToFour = 0;
          let baseStride = 0;
          for (let i = 0; i < size; i++) {
            if (this._bufferData[location2 + baseStride * 4 + countToFour] !== Tools.FloatRound(data[i])) {
              changed = true;
              if (this._createBufferOnWrite) {
                this._createNewBuffer();
              }
              this._bufferData[location2 + baseStride * 4 + countToFour] = data[i];
            }
            countToFour++;
            if (countToFour === arraySizes.strideSize) {
              for (; countToFour < 4; countToFour++) {
                this._bufferData[location2 + baseStride * 4 + countToFour] = 0;
              }
              countToFour = 0;
              baseStride++;
            }
          }
          this._needSync = this._needSync || changed;
        } else {
          for (let i = 0; i < size; i++) {
            this._bufferData[location2 + i] = data[i];
          }
        }
      }
      _cacheMatrix(name, matrix) {
        this._checkNewFrame();
        const cache = this._valueCache[name];
        const flag = matrix.updateFlag;
        if (cache !== void 0 && cache === flag) {
          return false;
        }
        this._valueCache[name] = flag;
        return true;
      }
      _updateMatrix3x3ForUniform(name, matrix) {
        for (let i = 0; i < 3; i++) {
          UniformBuffer._TempBuffer[i * 4] = matrix[i * 3];
          UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 3 + 1];
          UniformBuffer._TempBuffer[i * 4 + 2] = matrix[i * 3 + 2];
          UniformBuffer._TempBuffer[i * 4 + 3] = 0;
        }
        this.updateUniform(name, UniformBuffer._TempBuffer, 12);
      }
      _updateMatrix3x3ForEffect(name, matrix) {
        this._currentEffect.setMatrix3x3(name, matrix);
      }
      _updateMatrix2x2ForEffect(name, matrix) {
        this._currentEffect.setMatrix2x2(name, matrix);
      }
      _updateMatrix2x2ForUniform(name, matrix) {
        for (let i = 0; i < 2; i++) {
          UniformBuffer._TempBuffer[i * 4] = matrix[i * 2];
          UniformBuffer._TempBuffer[i * 4 + 1] = matrix[i * 2 + 1];
          UniformBuffer._TempBuffer[i * 4 + 2] = 0;
          UniformBuffer._TempBuffer[i * 4 + 3] = 0;
        }
        this.updateUniform(name, UniformBuffer._TempBuffer, 8);
      }
      _updateFloatForEffect(name, x) {
        this._currentEffect.setFloat(name, x);
      }
      _updateFloatForUniform(name, x) {
        UniformBuffer._TempBuffer[0] = x;
        this.updateUniform(name, UniformBuffer._TempBuffer, 1);
      }
      _updateFloat2ForEffect(name, x, y, suffix = "") {
        this._currentEffect.setFloat2(name + suffix, x, y);
      }
      _updateFloat2ForUniform(name, x, y) {
        UniformBuffer._TempBuffer[0] = x;
        UniformBuffer._TempBuffer[1] = y;
        this.updateUniform(name, UniformBuffer._TempBuffer, 2);
      }
      _updateFloat3ForEffect(name, x, y, z, suffix = "") {
        this._currentEffect.setFloat3(name + suffix, x, y, z);
      }
      _updateFloat3ForUniform(name, x, y, z) {
        UniformBuffer._TempBuffer[0] = x;
        UniformBuffer._TempBuffer[1] = y;
        UniformBuffer._TempBuffer[2] = z;
        this.updateUniform(name, UniformBuffer._TempBuffer, 3);
      }
      _updateFloat4ForEffect(name, x, y, z, w, suffix = "") {
        this._currentEffect.setFloat4(name + suffix, x, y, z, w);
      }
      _updateFloat4ForUniform(name, x, y, z, w) {
        UniformBuffer._TempBuffer[0] = x;
        UniformBuffer._TempBuffer[1] = y;
        UniformBuffer._TempBuffer[2] = z;
        UniformBuffer._TempBuffer[3] = w;
        this.updateUniform(name, UniformBuffer._TempBuffer, 4);
      }
      _updateFloatArrayForEffect(name, array) {
        this._currentEffect.setFloatArray(name, array);
      }
      _updateFloatArrayForUniform(name, array) {
        this.updateUniformArray(name, array, array.length);
      }
      _updateArrayForEffect(name, array) {
        this._currentEffect.setArray(name, array);
      }
      _updateArrayForUniform(name, array) {
        this.updateUniformArray(name, array, array.length);
      }
      _updateIntArrayForEffect(name, array) {
        this._currentEffect.setIntArray(name, array);
      }
      _updateIntArrayForUniform(name, array) {
        UniformBuffer._TempBufferInt32View.set(array);
        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);
      }
      _updateUIntArrayForEffect(name, array) {
        this._currentEffect.setUIntArray(name, array);
      }
      _updateUIntArrayForUniform(name, array) {
        UniformBuffer._TempBufferUInt32View.set(array);
        this.updateUniformArray(name, UniformBuffer._TempBuffer, array.length);
      }
      _updateMatrixForEffect(name, mat) {
        this._currentEffect.setMatrix(name, mat);
      }
      _updateMatrixForUniform(name, mat) {
        if (this._cacheMatrix(name, mat)) {
          this.updateUniform(name, mat.toArray(), 16);
        }
      }
      _updateMatricesForEffect(name, mat) {
        this._currentEffect.setMatrices(name, mat);
      }
      _updateMatricesForUniform(name, mat) {
        this.updateUniform(name, mat, mat.length);
      }
      _updateVector3ForEffect(name, vector) {
        this._currentEffect.setVector3(name, vector);
      }
      _updateVector3ForUniform(name, vector) {
        UniformBuffer._TempBuffer[0] = vector.x;
        UniformBuffer._TempBuffer[1] = vector.y;
        UniformBuffer._TempBuffer[2] = vector.z;
        this.updateUniform(name, UniformBuffer._TempBuffer, 3);
      }
      _updateVector4ForEffect(name, vector) {
        this._currentEffect.setVector4(name, vector);
      }
      _updateVector4ForUniform(name, vector) {
        UniformBuffer._TempBuffer[0] = vector.x;
        UniformBuffer._TempBuffer[1] = vector.y;
        UniformBuffer._TempBuffer[2] = vector.z;
        UniformBuffer._TempBuffer[3] = vector.w;
        this.updateUniform(name, UniformBuffer._TempBuffer, 4);
      }
      _updateColor3ForEffect(name, color, suffix = "") {
        this._currentEffect.setColor3(name + suffix, color);
      }
      _updateColor3ForUniform(name, color) {
        UniformBuffer._TempBuffer[0] = color.r;
        UniformBuffer._TempBuffer[1] = color.g;
        UniformBuffer._TempBuffer[2] = color.b;
        this.updateUniform(name, UniformBuffer._TempBuffer, 3);
      }
      _updateColor4ForEffect(name, color, alpha, suffix = "") {
        this._currentEffect.setColor4(name + suffix, color, alpha);
      }
      _updateDirectColor4ForEffect(name, color, suffix = "") {
        this._currentEffect.setDirectColor4(name + suffix, color);
      }
      _updateColor4ForUniform(name, color, alpha) {
        UniformBuffer._TempBuffer[0] = color.r;
        UniformBuffer._TempBuffer[1] = color.g;
        UniformBuffer._TempBuffer[2] = color.b;
        UniformBuffer._TempBuffer[3] = alpha;
        this.updateUniform(name, UniformBuffer._TempBuffer, 4);
      }
      _updateDirectColor4ForUniform(name, color) {
        UniformBuffer._TempBuffer[0] = color.r;
        UniformBuffer._TempBuffer[1] = color.g;
        UniformBuffer._TempBuffer[2] = color.b;
        UniformBuffer._TempBuffer[3] = color.a;
        this.updateUniform(name, UniformBuffer._TempBuffer, 4);
      }
      _updateIntForEffect(name, x, suffix = "") {
        this._currentEffect.setInt(name + suffix, x);
      }
      _updateIntForUniform(name, x) {
        UniformBuffer._TempBufferInt32View[0] = x;
        this.updateUniform(name, UniformBuffer._TempBuffer, 1);
      }
      _updateInt2ForEffect(name, x, y, suffix = "") {
        this._currentEffect.setInt2(name + suffix, x, y);
      }
      _updateInt2ForUniform(name, x, y) {
        UniformBuffer._TempBufferInt32View[0] = x;
        UniformBuffer._TempBufferInt32View[1] = y;
        this.updateUniform(name, UniformBuffer._TempBuffer, 2);
      }
      _updateInt3ForEffect(name, x, y, z, suffix = "") {
        this._currentEffect.setInt3(name + suffix, x, y, z);
      }
      _updateInt3ForUniform(name, x, y, z) {
        UniformBuffer._TempBufferInt32View[0] = x;
        UniformBuffer._TempBufferInt32View[1] = y;
        UniformBuffer._TempBufferInt32View[2] = z;
        this.updateUniform(name, UniformBuffer._TempBuffer, 3);
      }
      _updateInt4ForEffect(name, x, y, z, w, suffix = "") {
        this._currentEffect.setInt4(name + suffix, x, y, z, w);
      }
      _updateInt4ForUniform(name, x, y, z, w) {
        UniformBuffer._TempBufferInt32View[0] = x;
        UniformBuffer._TempBufferInt32View[1] = y;
        UniformBuffer._TempBufferInt32View[2] = z;
        UniformBuffer._TempBufferInt32View[3] = w;
        this.updateUniform(name, UniformBuffer._TempBuffer, 4);
      }
      _updateUIntForEffect(name, x, suffix = "") {
        this._currentEffect.setUInt(name + suffix, x);
      }
      _updateUIntForUniform(name, x) {
        UniformBuffer._TempBufferUInt32View[0] = x;
        this.updateUniform(name, UniformBuffer._TempBuffer, 1);
      }
      _updateUInt2ForEffect(name, x, y, suffix = "") {
        this._currentEffect.setUInt2(name + suffix, x, y);
      }
      _updateUInt2ForUniform(name, x, y) {
        UniformBuffer._TempBufferUInt32View[0] = x;
        UniformBuffer._TempBufferUInt32View[1] = y;
        this.updateUniform(name, UniformBuffer._TempBuffer, 2);
      }
      _updateUInt3ForEffect(name, x, y, z, suffix = "") {
        this._currentEffect.setUInt3(name + suffix, x, y, z);
      }
      _updateUInt3ForUniform(name, x, y, z) {
        UniformBuffer._TempBufferUInt32View[0] = x;
        UniformBuffer._TempBufferUInt32View[1] = y;
        UniformBuffer._TempBufferUInt32View[2] = z;
        this.updateUniform(name, UniformBuffer._TempBuffer, 3);
      }
      _updateUInt4ForEffect(name, x, y, z, w, suffix = "") {
        this._currentEffect.setUInt4(name + suffix, x, y, z, w);
      }
      _updateUInt4ForUniform(name, x, y, z, w) {
        UniformBuffer._TempBufferUInt32View[0] = x;
        UniformBuffer._TempBufferUInt32View[1] = y;
        UniformBuffer._TempBufferUInt32View[2] = z;
        UniformBuffer._TempBufferUInt32View[3] = w;
        this.updateUniform(name, UniformBuffer._TempBuffer, 4);
      }
      setTexture(name, texture) {
        this._currentEffect.setTexture(name, texture);
      }
      bindTexture(name, texture) {
        this._currentEffect._bindTexture(name, texture);
      }
      updateUniformDirectly(uniformName, data) {
        this.updateUniform(uniformName, data, data.length);
        this.update();
      }
      bindToEffect(effect, name) {
        this._currentEffect = effect;
        this._currentEffectName = name;
      }
      bindUniformBuffer() {
        if (!this._noUBO && this._buffer && this._currentEffect) {
          this._currentEffect.bindUniformBuffer(this._buffer, this._currentEffectName);
        }
      }
      unbindEffect() {
        this._currentEffect = void 0;
        this._currentEffectName = void 0;
      }
      setDataBuffer(dataBuffer) {
        if (!this._buffers) {
          return this._buffer === dataBuffer;
        }
        for (let b = 0; b < this._buffers.length; ++b) {
          const buffer = this._buffers[b];
          if (buffer[0] === dataBuffer) {
            this._bufferIndex = b;
            this._buffer = dataBuffer;
            this._createBufferOnWrite = false;
            this._currentEffect = void 0;
            return true;
          }
        }
        return false;
      }
      dispose() {
        if (this._noUBO) {
          return;
        }
        const uniformBuffers = this._engine._uniformBuffers;
        const index = uniformBuffers.indexOf(this);
        if (index !== -1) {
          uniformBuffers[index] = uniformBuffers[uniformBuffers.length - 1];
          uniformBuffers.pop();
        }
        if (this._engine._features.trackUbosInFrame && this._buffers) {
          for (let i = 0; i < this._buffers.length; ++i) {
            const buffer = this._buffers[i][0];
            this._engine._releaseBuffer(buffer);
          }
        } else if (this._buffer && this._engine._releaseBuffer(this._buffer)) {
          this._buffer = null;
        }
      }
    };
    UniformBuffer._UpdatedUbosInFrame = {};
    UniformBuffer._MAX_UNIFORM_SIZE = 256;
    UniformBuffer._TempBuffer = new Float32Array(UniformBuffer._MAX_UNIFORM_SIZE);
    UniformBuffer._TempBufferInt32View = new Int32Array(UniformBuffer._TempBuffer.buffer);
    UniformBuffer._TempBufferUInt32View = new Uint32Array(UniformBuffer._TempBuffer.buffer);
  }
});

// node_modules/@babylonjs/core/Buffers/buffer.js
var Buffer, VertexBuffer;
var init_buffer = __esm({
  "node_modules/@babylonjs/core/Buffers/buffer.js"() {
    init_dataBuffer();
    Buffer = class {
      constructor(engine, data, updatable, stride = 0, postponeInternalCreation = false, instanced = false, useBytes = false, divisor) {
        this._isAlreadyOwned = false;
        if (engine.getScene) {
          this._engine = engine.getScene().getEngine();
        } else {
          this._engine = engine;
        }
        this._updatable = updatable;
        this._instanced = instanced;
        this._divisor = divisor || 1;
        if (data instanceof DataBuffer) {
          this._data = null;
          this._buffer = data;
        } else {
          this._data = data;
          this._buffer = null;
        }
        this.byteStride = useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT;
        if (!postponeInternalCreation) {
          this.create();
        }
      }
      createVertexBuffer(kind, offset, size, stride, instanced, useBytes = false, divisor) {
        const byteOffset = useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT;
        const byteStride = stride ? useBytes ? stride : stride * Float32Array.BYTES_PER_ELEMENT : this.byteStride;
        return new VertexBuffer(this._engine, this, kind, this._updatable, true, byteStride, instanced === void 0 ? this._instanced : instanced, byteOffset, size, void 0, void 0, true, this._divisor || divisor);
      }
      isUpdatable() {
        return this._updatable;
      }
      getData() {
        return this._data;
      }
      getBuffer() {
        return this._buffer;
      }
      getStrideSize() {
        return this.byteStride / Float32Array.BYTES_PER_ELEMENT;
      }
      create(data = null) {
        if (!data && this._buffer) {
          return;
        }
        data = data || this._data;
        if (!data) {
          return;
        }
        if (!this._buffer) {
          if (this._updatable) {
            this._buffer = this._engine.createDynamicVertexBuffer(data);
            this._data = data;
          } else {
            this._buffer = this._engine.createVertexBuffer(data);
          }
        } else if (this._updatable) {
          this._engine.updateDynamicVertexBuffer(this._buffer, data);
          this._data = data;
        }
      }
      _rebuild() {
        this._buffer = null;
        this.create(this._data);
      }
      update(data) {
        this.create(data);
      }
      updateDirectly(data, offset, vertexCount, useBytes = false) {
        if (!this._buffer) {
          return;
        }
        if (this._updatable) {
          this._engine.updateDynamicVertexBuffer(this._buffer, data, useBytes ? offset : offset * Float32Array.BYTES_PER_ELEMENT, vertexCount ? vertexCount * this.byteStride : void 0);
          if (offset === 0 && vertexCount === void 0) {
            this._data = data;
          } else {
            this._data = null;
          }
        }
      }
      _increaseReferences() {
        if (!this._buffer) {
          return;
        }
        if (!this._isAlreadyOwned) {
          this._isAlreadyOwned = true;
          return;
        }
        this._buffer.references++;
      }
      dispose() {
        if (!this._buffer) {
          return;
        }
        if (this._engine._releaseBuffer(this._buffer)) {
          this._buffer = null;
          this._data = null;
        }
      }
    };
    VertexBuffer = class {
      get instanceDivisor() {
        return this._instanceDivisor;
      }
      set instanceDivisor(value) {
        const isInstanced = value != 0;
        this._instanceDivisor = value;
        if (isInstanced !== this._instanced) {
          this._instanced = isInstanced;
          this._computeHashCode();
        }
      }
      constructor(engine, data, kind, updatable, postponeInternalCreation, stride, instanced, offset, size, type, normalized = false, useBytes = false, divisor = 1, takeBufferOwnership = false) {
        if (data instanceof Buffer) {
          this._buffer = data;
          this._ownsBuffer = takeBufferOwnership;
        } else {
          this._buffer = new Buffer(engine, data, updatable, stride, postponeInternalCreation, instanced, useBytes);
          this._ownsBuffer = true;
        }
        this.uniqueId = VertexBuffer._Counter++;
        this._kind = kind;
        if (type == void 0) {
          const vertexData = this.getData();
          this.type = VertexBuffer.FLOAT;
          if (vertexData instanceof Int8Array) {
            this.type = VertexBuffer.BYTE;
          } else if (vertexData instanceof Uint8Array) {
            this.type = VertexBuffer.UNSIGNED_BYTE;
          } else if (vertexData instanceof Int16Array) {
            this.type = VertexBuffer.SHORT;
          } else if (vertexData instanceof Uint16Array) {
            this.type = VertexBuffer.UNSIGNED_SHORT;
          } else if (vertexData instanceof Int32Array) {
            this.type = VertexBuffer.INT;
          } else if (vertexData instanceof Uint32Array) {
            this.type = VertexBuffer.UNSIGNED_INT;
          }
        } else {
          this.type = type;
        }
        const typeByteLength = VertexBuffer.GetTypeByteLength(this.type);
        if (useBytes) {
          this._size = size || (stride ? stride / typeByteLength : VertexBuffer.DeduceStride(kind));
          this.byteStride = stride || this._buffer.byteStride || this._size * typeByteLength;
          this.byteOffset = offset || 0;
        } else {
          this._size = size || stride || VertexBuffer.DeduceStride(kind);
          this.byteStride = stride ? stride * typeByteLength : this._buffer.byteStride || this._size * typeByteLength;
          this.byteOffset = (offset || 0) * typeByteLength;
        }
        this.normalized = normalized;
        this._instanced = instanced !== void 0 ? instanced : false;
        this._instanceDivisor = instanced ? divisor : 0;
        this._computeHashCode();
      }
      _computeHashCode() {
        this.hashCode = (this.type - 5120 << 0) + ((this.normalized ? 1 : 0) << 3) + (this._size << 4) + ((this._instanced ? 1 : 0) << 6) + (this.byteStride << 12);
      }
      _rebuild() {
        if (!this._buffer) {
          return;
        }
        this._buffer._rebuild();
      }
      getKind() {
        return this._kind;
      }
      isUpdatable() {
        return this._buffer.isUpdatable();
      }
      getData() {
        return this._buffer.getData();
      }
      getFloatData(totalVertices, forceCopy) {
        const data = this.getData();
        if (!data) {
          return null;
        }
        const tightlyPackedByteStride = this.getSize() * VertexBuffer.GetTypeByteLength(this.type);
        const count = totalVertices * this.getSize();
        if (this.type !== VertexBuffer.FLOAT || this.byteStride !== tightlyPackedByteStride) {
          const copy = new Float32Array(count);
          this.forEach(count, (value, index) => copy[index] = value);
          return copy;
        }
        if (!(data instanceof Array || data instanceof Float32Array) || this.byteOffset !== 0 || data.length !== count) {
          if (data instanceof Array) {
            const offset = this.byteOffset / 4;
            return data.slice(offset, offset + count);
          } else if (data instanceof ArrayBuffer) {
            return new Float32Array(data, this.byteOffset, count);
          } else {
            let offset = data.byteOffset + this.byteOffset;
            if (forceCopy) {
              const result = new Float32Array(count);
              const source = new Float32Array(data.buffer, offset, count);
              result.set(source);
              return result;
            }
            const remainder = offset % 4;
            if (remainder) {
              offset = Math.max(0, offset - remainder);
            }
            return new Float32Array(data.buffer, offset, count);
          }
        }
        if (forceCopy) {
          return data.slice();
        }
        return data;
      }
      getBuffer() {
        return this._buffer.getBuffer();
      }
      getStrideSize() {
        return this.byteStride / VertexBuffer.GetTypeByteLength(this.type);
      }
      getOffset() {
        return this.byteOffset / VertexBuffer.GetTypeByteLength(this.type);
      }
      getSize(sizeInBytes = false) {
        return sizeInBytes ? this._size * VertexBuffer.GetTypeByteLength(this.type) : this._size;
      }
      getIsInstanced() {
        return this._instanced;
      }
      getInstanceDivisor() {
        return this._instanceDivisor;
      }
      create(data) {
        this._buffer.create(data);
      }
      update(data) {
        this._buffer.update(data);
      }
      updateDirectly(data, offset, useBytes = false) {
        this._buffer.updateDirectly(data, offset, void 0, useBytes);
      }
      dispose() {
        if (this._ownsBuffer) {
          this._buffer.dispose();
        }
      }
      forEach(count, callback) {
        VertexBuffer.ForEach(this._buffer.getData(), this.byteOffset, this.byteStride, this._size, this.type, count, this.normalized, callback);
      }
      static DeduceStride(kind) {
        switch (kind) {
          case VertexBuffer.UVKind:
          case VertexBuffer.UV2Kind:
          case VertexBuffer.UV3Kind:
          case VertexBuffer.UV4Kind:
          case VertexBuffer.UV5Kind:
          case VertexBuffer.UV6Kind:
            return 2;
          case VertexBuffer.NormalKind:
          case VertexBuffer.PositionKind:
            return 3;
          case VertexBuffer.ColorKind:
          case VertexBuffer.MatricesIndicesKind:
          case VertexBuffer.MatricesIndicesExtraKind:
          case VertexBuffer.MatricesWeightsKind:
          case VertexBuffer.MatricesWeightsExtraKind:
          case VertexBuffer.TangentKind:
            return 4;
          default:
            throw new Error("Invalid kind '" + kind + "'");
        }
      }
      static GetTypeByteLength(type) {
        switch (type) {
          case VertexBuffer.BYTE:
          case VertexBuffer.UNSIGNED_BYTE:
            return 1;
          case VertexBuffer.SHORT:
          case VertexBuffer.UNSIGNED_SHORT:
            return 2;
          case VertexBuffer.INT:
          case VertexBuffer.UNSIGNED_INT:
          case VertexBuffer.FLOAT:
            return 4;
          default:
            throw new Error(`Invalid type '${type}'`);
        }
      }
      static ForEach(data, byteOffset, byteStride, componentCount, componentType, count, normalized, callback) {
        if (data instanceof Array) {
          let offset = byteOffset / 4;
          const stride = byteStride / 4;
          for (let index = 0; index < count; index += componentCount) {
            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
              callback(data[offset + componentIndex], index + componentIndex);
            }
            offset += stride;
          }
        } else {
          const dataView = data instanceof ArrayBuffer ? new DataView(data) : new DataView(data.buffer, data.byteOffset, data.byteLength);
          const componentByteLength = VertexBuffer.GetTypeByteLength(componentType);
          for (let index = 0; index < count; index += componentCount) {
            let componentByteOffset = byteOffset;
            for (let componentIndex = 0; componentIndex < componentCount; componentIndex++) {
              const value = VertexBuffer._GetFloatValue(dataView, componentType, componentByteOffset, normalized);
              callback(value, index + componentIndex);
              componentByteOffset += componentByteLength;
            }
            byteOffset += byteStride;
          }
        }
      }
      static _GetFloatValue(dataView, type, byteOffset, normalized) {
        switch (type) {
          case VertexBuffer.BYTE: {
            let value = dataView.getInt8(byteOffset);
            if (normalized) {
              value = Math.max(value / 127, -1);
            }
            return value;
          }
          case VertexBuffer.UNSIGNED_BYTE: {
            let value = dataView.getUint8(byteOffset);
            if (normalized) {
              value = value / 255;
            }
            return value;
          }
          case VertexBuffer.SHORT: {
            let value = dataView.getInt16(byteOffset, true);
            if (normalized) {
              value = Math.max(value / 32767, -1);
            }
            return value;
          }
          case VertexBuffer.UNSIGNED_SHORT: {
            let value = dataView.getUint16(byteOffset, true);
            if (normalized) {
              value = value / 65535;
            }
            return value;
          }
          case VertexBuffer.INT: {
            return dataView.getInt32(byteOffset, true);
          }
          case VertexBuffer.UNSIGNED_INT: {
            return dataView.getUint32(byteOffset, true);
          }
          case VertexBuffer.FLOAT: {
            return dataView.getFloat32(byteOffset, true);
          }
          default: {
            throw new Error(`Invalid component type ${type}`);
          }
        }
      }
    };
    VertexBuffer._Counter = 0;
    VertexBuffer.BYTE = 5120;
    VertexBuffer.UNSIGNED_BYTE = 5121;
    VertexBuffer.SHORT = 5122;
    VertexBuffer.UNSIGNED_SHORT = 5123;
    VertexBuffer.INT = 5124;
    VertexBuffer.UNSIGNED_INT = 5125;
    VertexBuffer.FLOAT = 5126;
    VertexBuffer.PositionKind = "position";
    VertexBuffer.NormalKind = "normal";
    VertexBuffer.TangentKind = "tangent";
    VertexBuffer.UVKind = "uv";
    VertexBuffer.UV2Kind = "uv2";
    VertexBuffer.UV3Kind = "uv3";
    VertexBuffer.UV4Kind = "uv4";
    VertexBuffer.UV5Kind = "uv5";
    VertexBuffer.UV6Kind = "uv6";
    VertexBuffer.ColorKind = "color";
    VertexBuffer.ColorInstanceKind = "instanceColor";
    VertexBuffer.MatricesIndicesKind = "matricesIndices";
    VertexBuffer.MatricesWeightsKind = "matricesWeights";
    VertexBuffer.MatricesIndicesExtraKind = "matricesIndicesExtra";
    VertexBuffer.MatricesWeightsExtraKind = "matricesWeightsExtra";
  }
});

// node_modules/@babylonjs/core/Collisions/pickingInfo.js
var PickingInfo;
var init_pickingInfo = __esm({
  "node_modules/@babylonjs/core/Collisions/pickingInfo.js"() {
    init_math_vector();
    init_buffer();
    PickingInfo = class {
      constructor() {
        this.hit = false;
        this.distance = 0;
        this.pickedPoint = null;
        this.pickedMesh = null;
        this.bu = 0;
        this.bv = 0;
        this.faceId = -1;
        this.subMeshFaceId = -1;
        this.subMeshId = 0;
        this.pickedSprite = null;
        this.thinInstanceIndex = -1;
        this.ray = null;
        this.originMesh = null;
        this.aimTransform = null;
        this.gripTransform = null;
      }
      getNormal(useWorldCoordinates = false, useVerticesNormals = true) {
        if (!this.pickedMesh || useVerticesNormals && !this.pickedMesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          return null;
        }
        let indices = this.pickedMesh.getIndices();
        if ((indices === null || indices === void 0 ? void 0 : indices.length) === 0) {
          indices = null;
        }
        let result;
        const tmp0 = TmpVectors.Vector3[0];
        const tmp1 = TmpVectors.Vector3[1];
        const tmp2 = TmpVectors.Vector3[2];
        if (useVerticesNormals) {
          const normals = this.pickedMesh.getVerticesData(VertexBuffer.NormalKind);
          let normal0 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(normals[this.faceId * 3 * 3], normals[this.faceId * 3 * 3 + 1], normals[this.faceId * 3 * 3 + 2]);
          let normal1 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(normals[(this.faceId * 3 + 1) * 3], normals[(this.faceId * 3 + 1) * 3 + 1], normals[(this.faceId * 3 + 1) * 3 + 2]);
          let normal2 = indices ? Vector3.FromArrayToRef(normals, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(normals[(this.faceId * 3 + 2) * 3], normals[(this.faceId * 3 + 2) * 3 + 1], normals[(this.faceId * 3 + 2) * 3 + 2]);
          normal0 = normal0.scale(this.bu);
          normal1 = normal1.scale(this.bv);
          normal2 = normal2.scale(1 - this.bu - this.bv);
          result = new Vector3(normal0.x + normal1.x + normal2.x, normal0.y + normal1.y + normal2.y, normal0.z + normal1.z + normal2.z);
        } else {
          const positions = this.pickedMesh.getVerticesData(VertexBuffer.PositionKind);
          const vertex1 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3] * 3, tmp0) : tmp0.copyFromFloats(positions[this.faceId * 3 * 3], positions[this.faceId * 3 * 3 + 1], positions[this.faceId * 3 * 3 + 2]);
          const vertex2 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 1] * 3, tmp1) : tmp1.copyFromFloats(positions[(this.faceId * 3 + 1) * 3], positions[(this.faceId * 3 + 1) * 3 + 1], positions[(this.faceId * 3 + 1) * 3 + 2]);
          const vertex3 = indices ? Vector3.FromArrayToRef(positions, indices[this.faceId * 3 + 2] * 3, tmp2) : tmp2.copyFromFloats(positions[(this.faceId * 3 + 2) * 3], positions[(this.faceId * 3 + 2) * 3 + 1], positions[(this.faceId * 3 + 2) * 3 + 2]);
          const p1p2 = vertex1.subtract(vertex2);
          const p3p2 = vertex3.subtract(vertex2);
          result = Vector3.Cross(p1p2, p3p2);
        }
        const transformNormalToWorld = (pickedMesh, n) => {
          let wm = pickedMesh.getWorldMatrix();
          if (pickedMesh.nonUniformScaling) {
            TmpVectors.Matrix[0].copyFrom(wm);
            wm = TmpVectors.Matrix[0];
            wm.setTranslationFromFloats(0, 0, 0);
            wm.invert();
            wm.transposeToRef(TmpVectors.Matrix[1]);
            wm = TmpVectors.Matrix[1];
          }
          Vector3.TransformNormalToRef(n, wm, n);
        };
        if (useWorldCoordinates) {
          transformNormalToWorld(this.pickedMesh, result);
        }
        if (this.ray) {
          const normalForDirectionChecking = TmpVectors.Vector3[0].copyFrom(result);
          if (!useWorldCoordinates) {
            transformNormalToWorld(this.pickedMesh, normalForDirectionChecking);
          }
          if (Vector3.Dot(normalForDirectionChecking, this.ray.direction) > 0) {
            result.negateInPlace();
          }
        }
        result.normalize();
        return result;
      }
      getTextureCoordinates(uvSet = VertexBuffer.UVKind) {
        if (!this.pickedMesh || !this.pickedMesh.isVerticesDataPresent(uvSet)) {
          return null;
        }
        const indices = this.pickedMesh.getIndices();
        if (!indices) {
          return null;
        }
        const uvs = this.pickedMesh.getVerticesData(uvSet);
        if (!uvs) {
          return null;
        }
        let uv0 = Vector2.FromArray(uvs, indices[this.faceId * 3] * 2);
        let uv1 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 1] * 2);
        let uv2 = Vector2.FromArray(uvs, indices[this.faceId * 3 + 2] * 2);
        uv0 = uv0.scale(this.bu);
        uv1 = uv1.scale(this.bv);
        uv2 = uv2.scale(1 - this.bu - this.bv);
        return new Vector2(uv0.x + uv1.x + uv2.x, uv0.y + uv1.y + uv2.y);
      }
    };
  }
});

// node_modules/@babylonjs/core/Actions/actionEvent.js
var ActionEvent;
var init_actionEvent = __esm({
  "node_modules/@babylonjs/core/Actions/actionEvent.js"() {
    ActionEvent = class {
      constructor(source, pointerX, pointerY, meshUnderPointer, sourceEvent, additionalData) {
        this.source = source;
        this.pointerX = pointerX;
        this.pointerY = pointerY;
        this.meshUnderPointer = meshUnderPointer;
        this.sourceEvent = sourceEvent;
        this.additionalData = additionalData;
      }
      static CreateNew(source, evt, additionalData) {
        const scene = source.getScene();
        return new ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer || source, evt, additionalData);
      }
      static CreateNewFromSprite(source, scene, evt, additionalData) {
        return new ActionEvent(source, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt, additionalData);
      }
      static CreateNewFromScene(scene, evt) {
        return new ActionEvent(null, scene.pointerX, scene.pointerY, scene.meshUnderPointer, evt);
      }
      static CreateNewFromPrimitive(prim, pointerPos, evt, additionalData) {
        return new ActionEvent(prim, pointerPos.x, pointerPos.y, null, evt, additionalData);
      }
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/postProcessManager.js
var PostProcessManager;
var init_postProcessManager = __esm({
  "node_modules/@babylonjs/core/PostProcesses/postProcessManager.js"() {
    init_buffer();
    PostProcessManager = class {
      constructor(scene) {
        this._vertexBuffers = {};
        this._scene = scene;
      }
      _prepareBuffers() {
        if (this._vertexBuffers[VertexBuffer.PositionKind]) {
          return;
        }
        const vertices = [];
        vertices.push(1, 1);
        vertices.push(-1, 1);
        vertices.push(-1, -1);
        vertices.push(1, -1);
        this._vertexBuffers[VertexBuffer.PositionKind] = new VertexBuffer(this._scene.getEngine(), vertices, VertexBuffer.PositionKind, false, false, 2);
        this._buildIndexBuffer();
      }
      _buildIndexBuffer() {
        const indices = [];
        indices.push(0);
        indices.push(1);
        indices.push(2);
        indices.push(0);
        indices.push(2);
        indices.push(3);
        this._indexBuffer = this._scene.getEngine().createIndexBuffer(indices);
      }
      _rebuild() {
        const vb = this._vertexBuffers[VertexBuffer.PositionKind];
        if (!vb) {
          return;
        }
        vb._rebuild();
        this._buildIndexBuffer();
      }
      _prepareFrame(sourceTexture = null, postProcesses = null) {
        const camera = this._scene.activeCamera;
        if (!camera) {
          return false;
        }
        postProcesses = postProcesses || camera._postProcesses.filter((pp) => {
          return pp != null;
        });
        if (!postProcesses || postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
          return false;
        }
        postProcesses[0].activate(camera, sourceTexture, postProcesses !== null && postProcesses !== void 0);
        return true;
      }
      directRender(postProcesses, targetTexture = null, forceFullscreenViewport = false, faceIndex = 0, lodLevel = 0, doNotBindFrambuffer = false) {
        var _a;
        const engine = this._scene.getEngine();
        for (let index = 0; index < postProcesses.length; index++) {
          if (index < postProcesses.length - 1) {
            postProcesses[index + 1].activate(this._scene.activeCamera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
          } else {
            if (targetTexture) {
              engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport, lodLevel);
            } else if (!doNotBindFrambuffer) {
              engine.restoreDefaultFramebuffer();
            }
            (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);
          }
          const pp = postProcesses[index];
          const effect = pp.apply();
          if (effect) {
            pp.onBeforeRenderObservable.notifyObservers(effect);
            this._prepareBuffers();
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
            engine.drawElementsType(0, 0, 6);
            pp.onAfterRenderObservable.notifyObservers(effect);
          }
        }
        engine.setDepthBuffer(true);
        engine.setDepthWrite(true);
      }
      _finalizeFrame(doNotPresent, targetTexture, faceIndex, postProcesses, forceFullscreenViewport = false) {
        var _a;
        const camera = this._scene.activeCamera;
        if (!camera) {
          return;
        }
        postProcesses = postProcesses || camera._postProcesses.filter((pp) => {
          return pp != null;
        });
        if (postProcesses.length === 0 || !this._scene.postProcessesEnabled) {
          return;
        }
        const engine = this._scene.getEngine();
        for (let index = 0, len = postProcesses.length; index < len; index++) {
          const pp = postProcesses[index];
          if (index < len - 1) {
            pp._outputTexture = postProcesses[index + 1].activate(camera, targetTexture === null || targetTexture === void 0 ? void 0 : targetTexture.texture);
          } else {
            if (targetTexture) {
              engine.bindFramebuffer(targetTexture, faceIndex, void 0, void 0, forceFullscreenViewport);
              pp._outputTexture = targetTexture;
            } else {
              engine.restoreDefaultFramebuffer();
              pp._outputTexture = null;
            }
            (_a = engine._debugInsertMarker) === null || _a === void 0 ? void 0 : _a.call(engine, `post process ${postProcesses[index].name} output`);
          }
          if (doNotPresent) {
            break;
          }
          const effect = pp.apply();
          if (effect) {
            pp.onBeforeRenderObservable.notifyObservers(effect);
            this._prepareBuffers();
            engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
            engine.drawElementsType(0, 0, 6);
            pp.onAfterRenderObservable.notifyObservers(effect);
          }
        }
        engine.setDepthBuffer(true);
        engine.setDepthWrite(true);
        engine.setAlphaMode(0);
      }
      dispose() {
        const buffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (buffer) {
          buffer.dispose();
          this._vertexBuffers[VertexBuffer.PositionKind] = null;
        }
        if (this._indexBuffer) {
          this._scene.getEngine()._releaseBuffer(this._indexBuffer);
          this._indexBuffer = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Rendering/renderingGroup.js
var RenderingGroup;
var init_renderingGroup = __esm({
  "node_modules/@babylonjs/core/Rendering/renderingGroup.js"() {
    init_smartArray();
    init_math_vector();
    RenderingGroup = class {
      set opaqueSortCompareFn(value) {
        if (value) {
          this._opaqueSortCompareFn = value;
        } else {
          this._opaqueSortCompareFn = RenderingGroup.PainterSortCompare;
        }
        this._renderOpaque = this._renderOpaqueSorted;
      }
      set alphaTestSortCompareFn(value) {
        if (value) {
          this._alphaTestSortCompareFn = value;
        } else {
          this._alphaTestSortCompareFn = RenderingGroup.PainterSortCompare;
        }
        this._renderAlphaTest = this._renderAlphaTestSorted;
      }
      set transparentSortCompareFn(value) {
        if (value) {
          this._transparentSortCompareFn = value;
        } else {
          this._transparentSortCompareFn = RenderingGroup.defaultTransparentSortCompare;
        }
        this._renderTransparent = this._renderTransparentSorted;
      }
      constructor(index, scene, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
        this.index = index;
        this._opaqueSubMeshes = new SmartArray(256);
        this._transparentSubMeshes = new SmartArray(256);
        this._alphaTestSubMeshes = new SmartArray(256);
        this._depthOnlySubMeshes = new SmartArray(256);
        this._particleSystems = new SmartArray(256);
        this._spriteManagers = new SmartArray(256);
        this._empty = true;
        this._edgesRenderers = new SmartArrayNoDuplicate(16);
        this._scene = scene;
        this.opaqueSortCompareFn = opaqueSortCompareFn;
        this.alphaTestSortCompareFn = alphaTestSortCompareFn;
        this.transparentSortCompareFn = transparentSortCompareFn;
      }
      render(customRenderFunction, renderSprites, renderParticles, activeMeshes) {
        if (customRenderFunction) {
          customRenderFunction(this._opaqueSubMeshes, this._alphaTestSubMeshes, this._transparentSubMeshes, this._depthOnlySubMeshes);
          return;
        }
        const engine = this._scene.getEngine();
        if (this._depthOnlySubMeshes.length !== 0) {
          engine.setColorWrite(false);
          this._renderAlphaTest(this._depthOnlySubMeshes);
          engine.setColorWrite(true);
        }
        if (this._opaqueSubMeshes.length !== 0) {
          this._renderOpaque(this._opaqueSubMeshes);
        }
        if (this._alphaTestSubMeshes.length !== 0) {
          this._renderAlphaTest(this._alphaTestSubMeshes);
        }
        const stencilState = engine.getStencilBuffer();
        engine.setStencilBuffer(false);
        if (renderSprites) {
          this._renderSprites();
        }
        if (renderParticles) {
          this._renderParticles(activeMeshes);
        }
        if (this.onBeforeTransparentRendering) {
          this.onBeforeTransparentRendering();
        }
        if (this._transparentSubMeshes.length !== 0 || this._scene.useOrderIndependentTransparency) {
          engine.setStencilBuffer(stencilState);
          if (this._scene.useOrderIndependentTransparency) {
            const excludedMeshes = this._scene.depthPeelingRenderer.render(this._transparentSubMeshes);
            if (excludedMeshes.length) {
              this._renderTransparent(excludedMeshes);
            }
          } else {
            this._renderTransparent(this._transparentSubMeshes);
          }
          engine.setAlphaMode(0);
        }
        engine.setStencilBuffer(false);
        if (this._edgesRenderers.length) {
          for (let edgesRendererIndex = 0; edgesRendererIndex < this._edgesRenderers.length; edgesRendererIndex++) {
            this._edgesRenderers.data[edgesRendererIndex].render();
          }
          engine.setAlphaMode(0);
        }
        engine.setStencilBuffer(stencilState);
      }
      _renderOpaqueSorted(subMeshes) {
        return RenderingGroup._RenderSorted(subMeshes, this._opaqueSortCompareFn, this._scene.activeCamera, false);
      }
      _renderAlphaTestSorted(subMeshes) {
        return RenderingGroup._RenderSorted(subMeshes, this._alphaTestSortCompareFn, this._scene.activeCamera, false);
      }
      _renderTransparentSorted(subMeshes) {
        return RenderingGroup._RenderSorted(subMeshes, this._transparentSortCompareFn, this._scene.activeCamera, true);
      }
      static _RenderSorted(subMeshes, sortCompareFn, camera, transparent) {
        let subIndex = 0;
        let subMesh;
        const cameraPosition = camera ? camera.globalPosition : RenderingGroup._ZeroVector;
        if (transparent) {
          for (; subIndex < subMeshes.length; subIndex++) {
            subMesh = subMeshes.data[subIndex];
            subMesh._alphaIndex = subMesh.getMesh().alphaIndex;
            subMesh._distanceToCamera = Vector3.Distance(subMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
          }
        }
        const sortedArray = subMeshes.length === subMeshes.data.length ? subMeshes.data : subMeshes.data.slice(0, subMeshes.length);
        if (sortCompareFn) {
          sortedArray.sort(sortCompareFn);
        }
        const scene = sortedArray[0].getMesh().getScene();
        for (subIndex = 0; subIndex < sortedArray.length; subIndex++) {
          subMesh = sortedArray[subIndex];
          if (scene._activeMeshesFrozenButKeepClipping && !subMesh.isInFrustum(scene._frustumPlanes)) {
            continue;
          }
          if (transparent) {
            const material = subMesh.getMaterial();
            if (material && material.needDepthPrePass) {
              const engine = material.getScene().getEngine();
              engine.setColorWrite(false);
              engine.setAlphaMode(0);
              subMesh.render(false);
              engine.setColorWrite(true);
            }
          }
          subMesh.render(transparent);
        }
      }
      static defaultTransparentSortCompare(a, b) {
        if (a._alphaIndex > b._alphaIndex) {
          return 1;
        }
        if (a._alphaIndex < b._alphaIndex) {
          return -1;
        }
        return RenderingGroup.backToFrontSortCompare(a, b);
      }
      static backToFrontSortCompare(a, b) {
        if (a._distanceToCamera < b._distanceToCamera) {
          return 1;
        }
        if (a._distanceToCamera > b._distanceToCamera) {
          return -1;
        }
        return 0;
      }
      static frontToBackSortCompare(a, b) {
        if (a._distanceToCamera < b._distanceToCamera) {
          return -1;
        }
        if (a._distanceToCamera > b._distanceToCamera) {
          return 1;
        }
        return 0;
      }
      static PainterSortCompare(a, b) {
        const meshA = a.getMesh();
        const meshB = b.getMesh();
        if (meshA.material && meshB.material) {
          return meshA.material.uniqueId - meshB.material.uniqueId;
        }
        return meshA.uniqueId - meshB.uniqueId;
      }
      prepare() {
        this._opaqueSubMeshes.reset();
        this._transparentSubMeshes.reset();
        this._alphaTestSubMeshes.reset();
        this._depthOnlySubMeshes.reset();
        this._particleSystems.reset();
        this.prepareSprites();
        this._edgesRenderers.reset();
        this._empty = true;
      }
      prepareSprites() {
        this._spriteManagers.reset();
      }
      dispose() {
        this._opaqueSubMeshes.dispose();
        this._transparentSubMeshes.dispose();
        this._alphaTestSubMeshes.dispose();
        this._depthOnlySubMeshes.dispose();
        this._particleSystems.dispose();
        this._spriteManagers.dispose();
        this._edgesRenderers.dispose();
      }
      dispatch(subMesh, mesh, material) {
        if (mesh === void 0) {
          mesh = subMesh.getMesh();
        }
        if (material === void 0) {
          material = subMesh.getMaterial();
        }
        if (material === null || material === void 0) {
          return;
        }
        if (material.needAlphaBlendingForMesh(mesh)) {
          this._transparentSubMeshes.push(subMesh);
        } else if (material.needAlphaTesting()) {
          if (material.needDepthPrePass) {
            this._depthOnlySubMeshes.push(subMesh);
          }
          this._alphaTestSubMeshes.push(subMesh);
        } else {
          if (material.needDepthPrePass) {
            this._depthOnlySubMeshes.push(subMesh);
          }
          this._opaqueSubMeshes.push(subMesh);
        }
        mesh._renderingGroup = this;
        if (mesh._edgesRenderer && mesh._edgesRenderer.isEnabled) {
          this._edgesRenderers.pushNoDuplicate(mesh._edgesRenderer);
        }
        this._empty = false;
      }
      dispatchSprites(spriteManager) {
        this._spriteManagers.push(spriteManager);
        this._empty = false;
      }
      dispatchParticles(particleSystem) {
        this._particleSystems.push(particleSystem);
        this._empty = false;
      }
      _renderParticles(activeMeshes) {
        if (this._particleSystems.length === 0) {
          return;
        }
        const activeCamera = this._scene.activeCamera;
        this._scene.onBeforeParticlesRenderingObservable.notifyObservers(this._scene);
        for (let particleIndex = 0; particleIndex < this._particleSystems.length; particleIndex++) {
          const particleSystem = this._particleSystems.data[particleIndex];
          if ((activeCamera && activeCamera.layerMask & particleSystem.layerMask) === 0) {
            continue;
          }
          const emitter = particleSystem.emitter;
          if (!emitter.position || !activeMeshes || activeMeshes.indexOf(emitter) !== -1) {
            this._scene._activeParticles.addCount(particleSystem.render(), false);
          }
        }
        this._scene.onAfterParticlesRenderingObservable.notifyObservers(this._scene);
      }
      _renderSprites() {
        if (!this._scene.spritesEnabled || this._spriteManagers.length === 0) {
          return;
        }
        const activeCamera = this._scene.activeCamera;
        this._scene.onBeforeSpritesRenderingObservable.notifyObservers(this._scene);
        for (let id = 0; id < this._spriteManagers.length; id++) {
          const spriteManager = this._spriteManagers.data[id];
          if ((activeCamera && activeCamera.layerMask & spriteManager.layerMask) !== 0) {
            spriteManager.render();
          }
        }
        this._scene.onAfterSpritesRenderingObservable.notifyObservers(this._scene);
      }
    };
    RenderingGroup._ZeroVector = Vector3.Zero();
  }
});

// node_modules/@babylonjs/core/Rendering/renderingManager.js
var RenderingGroupInfo, RenderingManager;
var init_renderingManager = __esm({
  "node_modules/@babylonjs/core/Rendering/renderingManager.js"() {
    init_renderingGroup();
    RenderingGroupInfo = class {
    };
    RenderingManager = class {
      get maintainStateBetweenFrames() {
        return this._maintainStateBetweenFrames;
      }
      set maintainStateBetweenFrames(value) {
        if (value === this._maintainStateBetweenFrames) {
          return;
        }
        this._maintainStateBetweenFrames = value;
        if (!this._maintainStateBetweenFrames) {
          for (const mesh of this._scene.meshes) {
            if (mesh.subMeshes) {
              for (const subMesh of mesh.subMeshes) {
                subMesh._wasDispatched = false;
              }
            }
          }
          if (this._scene.spriteManagers) {
            for (const spriteManager of this._scene.spriteManagers) {
              spriteManager._wasDispatched = false;
            }
          }
          for (const particleSystem of this._scene.particleSystems) {
            particleSystem._wasDispatched = false;
          }
        }
      }
      constructor(scene) {
        this._useSceneAutoClearSetup = false;
        this._renderingGroups = new Array();
        this._autoClearDepthStencil = {};
        this._customOpaqueSortCompareFn = {};
        this._customAlphaTestSortCompareFn = {};
        this._customTransparentSortCompareFn = {};
        this._renderingGroupInfo = new RenderingGroupInfo();
        this._maintainStateBetweenFrames = false;
        this._scene = scene;
        for (let i = RenderingManager.MIN_RENDERINGGROUPS; i < RenderingManager.MAX_RENDERINGGROUPS; i++) {
          this._autoClearDepthStencil[i] = { autoClear: true, depth: true, stencil: true };
        }
      }
      getRenderingGroup(id) {
        const renderingGroupId = id || 0;
        this._prepareRenderingGroup(renderingGroupId);
        return this._renderingGroups[renderingGroupId];
      }
      _clearDepthStencilBuffer(depth = true, stencil = true) {
        if (this._depthStencilBufferAlreadyCleaned) {
          return;
        }
        this._scene.getEngine().clear(null, false, depth, stencil);
        this._depthStencilBufferAlreadyCleaned = true;
      }
      render(customRenderFunction, activeMeshes, renderParticles, renderSprites) {
        const info = this._renderingGroupInfo;
        info.scene = this._scene;
        info.camera = this._scene.activeCamera;
        if (this._scene.spriteManagers && renderSprites) {
          for (let index = 0; index < this._scene.spriteManagers.length; index++) {
            const manager = this._scene.spriteManagers[index];
            this.dispatchSprites(manager);
          }
        }
        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
          this._depthStencilBufferAlreadyCleaned = index === RenderingManager.MIN_RENDERINGGROUPS;
          const renderingGroup = this._renderingGroups[index];
          if (!renderingGroup || renderingGroup._empty) {
            continue;
          }
          const renderingGroupMask = Math.pow(2, index);
          info.renderingGroupId = index;
          this._scene.onBeforeRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
          if (RenderingManager.AUTOCLEAR) {
            const autoClear = this._useSceneAutoClearSetup ? this._scene.getAutoClearDepthStencilSetup(index) : this._autoClearDepthStencil[index];
            if (autoClear && autoClear.autoClear) {
              this._clearDepthStencilBuffer(autoClear.depth, autoClear.stencil);
            }
          }
          for (const step of this._scene._beforeRenderingGroupDrawStage) {
            step.action(index);
          }
          renderingGroup.render(customRenderFunction, renderSprites, renderParticles, activeMeshes);
          for (const step of this._scene._afterRenderingGroupDrawStage) {
            step.action(index);
          }
          this._scene.onAfterRenderingGroupObservable.notifyObservers(info, renderingGroupMask);
        }
      }
      reset() {
        if (this.maintainStateBetweenFrames) {
          return;
        }
        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
          const renderingGroup = this._renderingGroups[index];
          if (renderingGroup) {
            renderingGroup.prepare();
          }
        }
      }
      resetSprites() {
        if (this.maintainStateBetweenFrames) {
          return;
        }
        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
          const renderingGroup = this._renderingGroups[index];
          if (renderingGroup) {
            renderingGroup.prepareSprites();
          }
        }
      }
      dispose() {
        this.freeRenderingGroups();
        this._renderingGroups.length = 0;
        this._renderingGroupInfo = null;
      }
      freeRenderingGroups() {
        for (let index = RenderingManager.MIN_RENDERINGGROUPS; index < RenderingManager.MAX_RENDERINGGROUPS; index++) {
          const renderingGroup = this._renderingGroups[index];
          if (renderingGroup) {
            renderingGroup.dispose();
          }
        }
      }
      _prepareRenderingGroup(renderingGroupId) {
        if (this._renderingGroups[renderingGroupId] === void 0) {
          this._renderingGroups[renderingGroupId] = new RenderingGroup(renderingGroupId, this._scene, this._customOpaqueSortCompareFn[renderingGroupId], this._customAlphaTestSortCompareFn[renderingGroupId], this._customTransparentSortCompareFn[renderingGroupId]);
        }
      }
      dispatchSprites(spriteManager) {
        if (this.maintainStateBetweenFrames && spriteManager._wasDispatched) {
          return;
        }
        spriteManager._wasDispatched = true;
        this.getRenderingGroup(spriteManager.renderingGroupId).dispatchSprites(spriteManager);
      }
      dispatchParticles(particleSystem) {
        if (this.maintainStateBetweenFrames && particleSystem._wasDispatched) {
          return;
        }
        particleSystem._wasDispatched = true;
        this.getRenderingGroup(particleSystem.renderingGroupId).dispatchParticles(particleSystem);
      }
      dispatch(subMesh, mesh, material) {
        if (mesh === void 0) {
          mesh = subMesh.getMesh();
        }
        if (this.maintainStateBetweenFrames && subMesh._wasDispatched) {
          return;
        }
        subMesh._wasDispatched = true;
        this.getRenderingGroup(mesh.renderingGroupId).dispatch(subMesh, mesh, material);
      }
      setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
        this._customOpaqueSortCompareFn[renderingGroupId] = opaqueSortCompareFn;
        this._customAlphaTestSortCompareFn[renderingGroupId] = alphaTestSortCompareFn;
        this._customTransparentSortCompareFn[renderingGroupId] = transparentSortCompareFn;
        if (this._renderingGroups[renderingGroupId]) {
          const group = this._renderingGroups[renderingGroupId];
          group.opaqueSortCompareFn = this._customOpaqueSortCompareFn[renderingGroupId];
          group.alphaTestSortCompareFn = this._customAlphaTestSortCompareFn[renderingGroupId];
          group.transparentSortCompareFn = this._customTransparentSortCompareFn[renderingGroupId];
        }
      }
      setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
        this._autoClearDepthStencil[renderingGroupId] = {
          autoClear: autoClearDepthStencil,
          depth,
          stencil
        };
      }
      getAutoClearDepthStencilSetup(index) {
        return this._autoClearDepthStencil[index];
      }
    };
    RenderingManager.MAX_RENDERINGGROUPS = 4;
    RenderingManager.MIN_RENDERINGGROUPS = 0;
    RenderingManager.AUTOCLEAR = true;
  }
});

// node_modules/@babylonjs/core/sceneComponent.js
var SceneComponentConstants, Stage;
var init_sceneComponent = __esm({
  "node_modules/@babylonjs/core/sceneComponent.js"() {
    SceneComponentConstants = class {
    };
    SceneComponentConstants.NAME_EFFECTLAYER = "EffectLayer";
    SceneComponentConstants.NAME_LAYER = "Layer";
    SceneComponentConstants.NAME_LENSFLARESYSTEM = "LensFlareSystem";
    SceneComponentConstants.NAME_BOUNDINGBOXRENDERER = "BoundingBoxRenderer";
    SceneComponentConstants.NAME_PARTICLESYSTEM = "ParticleSystem";
    SceneComponentConstants.NAME_GAMEPAD = "Gamepad";
    SceneComponentConstants.NAME_SIMPLIFICATIONQUEUE = "SimplificationQueue";
    SceneComponentConstants.NAME_GEOMETRYBUFFERRENDERER = "GeometryBufferRenderer";
    SceneComponentConstants.NAME_PREPASSRENDERER = "PrePassRenderer";
    SceneComponentConstants.NAME_DEPTHRENDERER = "DepthRenderer";
    SceneComponentConstants.NAME_DEPTHPEELINGRENDERER = "DepthPeelingRenderer";
    SceneComponentConstants.NAME_POSTPROCESSRENDERPIPELINEMANAGER = "PostProcessRenderPipelineManager";
    SceneComponentConstants.NAME_SPRITE = "Sprite";
    SceneComponentConstants.NAME_SUBSURFACE = "SubSurface";
    SceneComponentConstants.NAME_OUTLINERENDERER = "Outline";
    SceneComponentConstants.NAME_PROCEDURALTEXTURE = "ProceduralTexture";
    SceneComponentConstants.NAME_SHADOWGENERATOR = "ShadowGenerator";
    SceneComponentConstants.NAME_OCTREE = "Octree";
    SceneComponentConstants.NAME_PHYSICSENGINE = "PhysicsEngine";
    SceneComponentConstants.NAME_AUDIO = "Audio";
    SceneComponentConstants.NAME_FLUIDRENDERER = "FluidRenderer";
    SceneComponentConstants.STEP_ISREADYFORMESH_EFFECTLAYER = 0;
    SceneComponentConstants.STEP_BEFOREEVALUATEACTIVEMESH_BOUNDINGBOXRENDERER = 0;
    SceneComponentConstants.STEP_EVALUATESUBMESH_BOUNDINGBOXRENDERER = 0;
    SceneComponentConstants.STEP_PREACTIVEMESH_BOUNDINGBOXRENDERER = 0;
    SceneComponentConstants.STEP_CAMERADRAWRENDERTARGET_EFFECTLAYER = 1;
    SceneComponentConstants.STEP_BEFORECAMERADRAW_PREPASS = 0;
    SceneComponentConstants.STEP_BEFORECAMERADRAW_EFFECTLAYER = 1;
    SceneComponentConstants.STEP_BEFORECAMERADRAW_LAYER = 2;
    SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_PREPASS = 0;
    SceneComponentConstants.STEP_BEFORERENDERTARGETDRAW_LAYER = 1;
    SceneComponentConstants.STEP_BEFORERENDERINGMESH_PREPASS = 0;
    SceneComponentConstants.STEP_BEFORERENDERINGMESH_OUTLINE = 1;
    SceneComponentConstants.STEP_AFTERRENDERINGMESH_PREPASS = 0;
    SceneComponentConstants.STEP_AFTERRENDERINGMESH_OUTLINE = 1;
    SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_EFFECTLAYER_DRAW = 0;
    SceneComponentConstants.STEP_AFTERRENDERINGGROUPDRAW_BOUNDINGBOXRENDERER = 1;
    SceneComponentConstants.STEP_BEFORECAMERAUPDATE_SIMPLIFICATIONQUEUE = 0;
    SceneComponentConstants.STEP_BEFORECAMERAUPDATE_GAMEPAD = 1;
    SceneComponentConstants.STEP_BEFORECLEAR_PROCEDURALTEXTURE = 0;
    SceneComponentConstants.STEP_BEFORECLEAR_PREPASS = 1;
    SceneComponentConstants.STEP_BEFORERENDERTARGETCLEAR_PREPASS = 0;
    SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_PREPASS = 0;
    SceneComponentConstants.STEP_AFTERRENDERTARGETDRAW_LAYER = 1;
    SceneComponentConstants.STEP_AFTERCAMERADRAW_PREPASS = 0;
    SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER = 1;
    SceneComponentConstants.STEP_AFTERCAMERADRAW_LENSFLARESYSTEM = 2;
    SceneComponentConstants.STEP_AFTERCAMERADRAW_EFFECTLAYER_DRAW = 3;
    SceneComponentConstants.STEP_AFTERCAMERADRAW_LAYER = 4;
    SceneComponentConstants.STEP_AFTERCAMERADRAW_FLUIDRENDERER = 5;
    SceneComponentConstants.STEP_AFTERCAMERAPOSTPROCESS_LAYER = 0;
    SceneComponentConstants.STEP_AFTERRENDERTARGETPOSTPROCESS_LAYER = 0;
    SceneComponentConstants.STEP_AFTERRENDER_AUDIO = 0;
    SceneComponentConstants.STEP_GATHERRENDERTARGETS_DEPTHRENDERER = 0;
    SceneComponentConstants.STEP_GATHERRENDERTARGETS_GEOMETRYBUFFERRENDERER = 1;
    SceneComponentConstants.STEP_GATHERRENDERTARGETS_SHADOWGENERATOR = 2;
    SceneComponentConstants.STEP_GATHERRENDERTARGETS_POSTPROCESSRENDERPIPELINEMANAGER = 3;
    SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_DEPTHRENDERER = 0;
    SceneComponentConstants.STEP_GATHERACTIVECAMERARENDERTARGETS_FLUIDRENDERER = 1;
    SceneComponentConstants.STEP_POINTERMOVE_SPRITE = 0;
    SceneComponentConstants.STEP_POINTERDOWN_SPRITE = 0;
    SceneComponentConstants.STEP_POINTERUP_SPRITE = 0;
    Stage = class extends Array {
      constructor(items) {
        super(...items);
      }
      static Create() {
        return Object.create(Stage.prototype);
      }
      registerStep(index, component, action) {
        let i = 0;
        let maxIndex = Number.MAX_VALUE;
        for (; i < this.length; i++) {
          const step = this[i];
          maxIndex = step.index;
          if (index < maxIndex) {
            break;
          }
        }
        this.splice(i, 0, { index, component, action: action.bind(component) });
      }
      clear() {
        this.length = 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Events/pointerEvents.js
var PointerEventTypes, PointerInfoBase, PointerInfoPre, PointerInfo;
var init_pointerEvents = __esm({
  "node_modules/@babylonjs/core/Events/pointerEvents.js"() {
    init_math_vector();
    PointerEventTypes = class {
    };
    PointerEventTypes.POINTERDOWN = 1;
    PointerEventTypes.POINTERUP = 2;
    PointerEventTypes.POINTERMOVE = 4;
    PointerEventTypes.POINTERWHEEL = 8;
    PointerEventTypes.POINTERPICK = 16;
    PointerEventTypes.POINTERTAP = 32;
    PointerEventTypes.POINTERDOUBLETAP = 64;
    PointerInfoBase = class {
      constructor(type, event) {
        this.type = type;
        this.event = event;
      }
    };
    PointerInfoPre = class extends PointerInfoBase {
      constructor(type, event, localX, localY) {
        super(type, event);
        this.ray = null;
        this.originalPickingInfo = null;
        this.skipOnPointerObservable = false;
        this.localPosition = new Vector2(localX, localY);
      }
    };
    PointerInfo = class extends PointerInfoBase {
      get pickInfo() {
        if (!this._pickInfo) {
          this._generatePickInfo();
        }
        return this._pickInfo;
      }
      constructor(type, event, pickInfo, inputManager = null) {
        super(type, event);
        this._pickInfo = pickInfo;
        this._inputManager = inputManager;
      }
      _generatePickInfo() {
        if (this._inputManager) {
          this._pickInfo = this._inputManager._pickMove(this.event);
          this._inputManager._setRayOnPointerInfo(this._pickInfo, this.event);
          this._inputManager = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Actions/abstractActionManager.js
var AbstractActionManager;
var init_abstractActionManager = __esm({
  "node_modules/@babylonjs/core/Actions/abstractActionManager.js"() {
    AbstractActionManager = class {
      constructor() {
        this.hoverCursor = "";
        this.actions = new Array();
        this.isRecursive = false;
      }
      static get HasTriggers() {
        for (const t in AbstractActionManager.Triggers) {
          if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {
            return true;
          }
        }
        return false;
      }
      static get HasPickTriggers() {
        for (const t in AbstractActionManager.Triggers) {
          if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {
            const tAsInt = parseInt(t);
            if (tAsInt >= 1 && tAsInt <= 7) {
              return true;
            }
          }
        }
        return false;
      }
      static HasSpecificTrigger(trigger) {
        for (const t in AbstractActionManager.Triggers) {
          if (Object.prototype.hasOwnProperty.call(AbstractActionManager.Triggers, t)) {
            const tAsInt = parseInt(t);
            if (tAsInt === trigger) {
              return true;
            }
          }
        }
        return false;
      }
    };
    AbstractActionManager.Triggers = {};
  }
});

// node_modules/@babylonjs/core/Events/keyboardEvents.js
var KeyboardEventTypes, KeyboardInfo, KeyboardInfoPre;
var init_keyboardEvents = __esm({
  "node_modules/@babylonjs/core/Events/keyboardEvents.js"() {
    KeyboardEventTypes = class {
    };
    KeyboardEventTypes.KEYDOWN = 1;
    KeyboardEventTypes.KEYUP = 2;
    KeyboardInfo = class {
      constructor(type, event) {
        this.type = type;
        this.event = event;
      }
    };
    KeyboardInfoPre = class extends KeyboardInfo {
      get skipOnPointerObservable() {
        return this.skipOnKeyboardObservable;
      }
      set skipOnPointerObservable(value) {
        this.skipOnKeyboardObservable = value;
      }
      constructor(type, event) {
        super(type, event);
        this.type = type;
        this.event = event;
        this.skipOnKeyboardObservable = false;
      }
    };
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js
var DeviceType, PointerInput, NativePointerInput, DualShockInput, DualSenseInput, XboxInput, SwitchInput;
var init_deviceEnums = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceEnums.js"() {
    (function(DeviceType2) {
      DeviceType2[DeviceType2["Generic"] = 0] = "Generic";
      DeviceType2[DeviceType2["Keyboard"] = 1] = "Keyboard";
      DeviceType2[DeviceType2["Mouse"] = 2] = "Mouse";
      DeviceType2[DeviceType2["Touch"] = 3] = "Touch";
      DeviceType2[DeviceType2["DualShock"] = 4] = "DualShock";
      DeviceType2[DeviceType2["Xbox"] = 5] = "Xbox";
      DeviceType2[DeviceType2["Switch"] = 6] = "Switch";
      DeviceType2[DeviceType2["DualSense"] = 7] = "DualSense";
    })(DeviceType || (DeviceType = {}));
    (function(PointerInput2) {
      PointerInput2[PointerInput2["Horizontal"] = 0] = "Horizontal";
      PointerInput2[PointerInput2["Vertical"] = 1] = "Vertical";
      PointerInput2[PointerInput2["LeftClick"] = 2] = "LeftClick";
      PointerInput2[PointerInput2["MiddleClick"] = 3] = "MiddleClick";
      PointerInput2[PointerInput2["RightClick"] = 4] = "RightClick";
      PointerInput2[PointerInput2["BrowserBack"] = 5] = "BrowserBack";
      PointerInput2[PointerInput2["BrowserForward"] = 6] = "BrowserForward";
      PointerInput2[PointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
      PointerInput2[PointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
      PointerInput2[PointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
      PointerInput2[PointerInput2["Move"] = 12] = "Move";
    })(PointerInput || (PointerInput = {}));
    (function(NativePointerInput2) {
      NativePointerInput2[NativePointerInput2["Horizontal"] = 0] = "Horizontal";
      NativePointerInput2[NativePointerInput2["Vertical"] = 1] = "Vertical";
      NativePointerInput2[NativePointerInput2["LeftClick"] = 2] = "LeftClick";
      NativePointerInput2[NativePointerInput2["MiddleClick"] = 3] = "MiddleClick";
      NativePointerInput2[NativePointerInput2["RightClick"] = 4] = "RightClick";
      NativePointerInput2[NativePointerInput2["BrowserBack"] = 5] = "BrowserBack";
      NativePointerInput2[NativePointerInput2["BrowserForward"] = 6] = "BrowserForward";
      NativePointerInput2[NativePointerInput2["MouseWheelX"] = 7] = "MouseWheelX";
      NativePointerInput2[NativePointerInput2["MouseWheelY"] = 8] = "MouseWheelY";
      NativePointerInput2[NativePointerInput2["MouseWheelZ"] = 9] = "MouseWheelZ";
      NativePointerInput2[NativePointerInput2["DeltaHorizontal"] = 10] = "DeltaHorizontal";
      NativePointerInput2[NativePointerInput2["DeltaVertical"] = 11] = "DeltaVertical";
    })(NativePointerInput || (NativePointerInput = {}));
    (function(DualShockInput2) {
      DualShockInput2[DualShockInput2["Cross"] = 0] = "Cross";
      DualShockInput2[DualShockInput2["Circle"] = 1] = "Circle";
      DualShockInput2[DualShockInput2["Square"] = 2] = "Square";
      DualShockInput2[DualShockInput2["Triangle"] = 3] = "Triangle";
      DualShockInput2[DualShockInput2["L1"] = 4] = "L1";
      DualShockInput2[DualShockInput2["R1"] = 5] = "R1";
      DualShockInput2[DualShockInput2["L2"] = 6] = "L2";
      DualShockInput2[DualShockInput2["R2"] = 7] = "R2";
      DualShockInput2[DualShockInput2["Share"] = 8] = "Share";
      DualShockInput2[DualShockInput2["Options"] = 9] = "Options";
      DualShockInput2[DualShockInput2["L3"] = 10] = "L3";
      DualShockInput2[DualShockInput2["R3"] = 11] = "R3";
      DualShockInput2[DualShockInput2["DPadUp"] = 12] = "DPadUp";
      DualShockInput2[DualShockInput2["DPadDown"] = 13] = "DPadDown";
      DualShockInput2[DualShockInput2["DPadLeft"] = 14] = "DPadLeft";
      DualShockInput2[DualShockInput2["DPadRight"] = 15] = "DPadRight";
      DualShockInput2[DualShockInput2["Home"] = 16] = "Home";
      DualShockInput2[DualShockInput2["TouchPad"] = 17] = "TouchPad";
      DualShockInput2[DualShockInput2["LStickXAxis"] = 18] = "LStickXAxis";
      DualShockInput2[DualShockInput2["LStickYAxis"] = 19] = "LStickYAxis";
      DualShockInput2[DualShockInput2["RStickXAxis"] = 20] = "RStickXAxis";
      DualShockInput2[DualShockInput2["RStickYAxis"] = 21] = "RStickYAxis";
    })(DualShockInput || (DualShockInput = {}));
    (function(DualSenseInput2) {
      DualSenseInput2[DualSenseInput2["Cross"] = 0] = "Cross";
      DualSenseInput2[DualSenseInput2["Circle"] = 1] = "Circle";
      DualSenseInput2[DualSenseInput2["Square"] = 2] = "Square";
      DualSenseInput2[DualSenseInput2["Triangle"] = 3] = "Triangle";
      DualSenseInput2[DualSenseInput2["L1"] = 4] = "L1";
      DualSenseInput2[DualSenseInput2["R1"] = 5] = "R1";
      DualSenseInput2[DualSenseInput2["L2"] = 6] = "L2";
      DualSenseInput2[DualSenseInput2["R2"] = 7] = "R2";
      DualSenseInput2[DualSenseInput2["Create"] = 8] = "Create";
      DualSenseInput2[DualSenseInput2["Options"] = 9] = "Options";
      DualSenseInput2[DualSenseInput2["L3"] = 10] = "L3";
      DualSenseInput2[DualSenseInput2["R3"] = 11] = "R3";
      DualSenseInput2[DualSenseInput2["DPadUp"] = 12] = "DPadUp";
      DualSenseInput2[DualSenseInput2["DPadDown"] = 13] = "DPadDown";
      DualSenseInput2[DualSenseInput2["DPadLeft"] = 14] = "DPadLeft";
      DualSenseInput2[DualSenseInput2["DPadRight"] = 15] = "DPadRight";
      DualSenseInput2[DualSenseInput2["Home"] = 16] = "Home";
      DualSenseInput2[DualSenseInput2["TouchPad"] = 17] = "TouchPad";
      DualSenseInput2[DualSenseInput2["LStickXAxis"] = 18] = "LStickXAxis";
      DualSenseInput2[DualSenseInput2["LStickYAxis"] = 19] = "LStickYAxis";
      DualSenseInput2[DualSenseInput2["RStickXAxis"] = 20] = "RStickXAxis";
      DualSenseInput2[DualSenseInput2["RStickYAxis"] = 21] = "RStickYAxis";
    })(DualSenseInput || (DualSenseInput = {}));
    (function(XboxInput2) {
      XboxInput2[XboxInput2["A"] = 0] = "A";
      XboxInput2[XboxInput2["B"] = 1] = "B";
      XboxInput2[XboxInput2["X"] = 2] = "X";
      XboxInput2[XboxInput2["Y"] = 3] = "Y";
      XboxInput2[XboxInput2["LB"] = 4] = "LB";
      XboxInput2[XboxInput2["RB"] = 5] = "RB";
      XboxInput2[XboxInput2["LT"] = 6] = "LT";
      XboxInput2[XboxInput2["RT"] = 7] = "RT";
      XboxInput2[XboxInput2["Back"] = 8] = "Back";
      XboxInput2[XboxInput2["Start"] = 9] = "Start";
      XboxInput2[XboxInput2["LS"] = 10] = "LS";
      XboxInput2[XboxInput2["RS"] = 11] = "RS";
      XboxInput2[XboxInput2["DPadUp"] = 12] = "DPadUp";
      XboxInput2[XboxInput2["DPadDown"] = 13] = "DPadDown";
      XboxInput2[XboxInput2["DPadLeft"] = 14] = "DPadLeft";
      XboxInput2[XboxInput2["DPadRight"] = 15] = "DPadRight";
      XboxInput2[XboxInput2["Home"] = 16] = "Home";
      XboxInput2[XboxInput2["LStickXAxis"] = 17] = "LStickXAxis";
      XboxInput2[XboxInput2["LStickYAxis"] = 18] = "LStickYAxis";
      XboxInput2[XboxInput2["RStickXAxis"] = 19] = "RStickXAxis";
      XboxInput2[XboxInput2["RStickYAxis"] = 20] = "RStickYAxis";
    })(XboxInput || (XboxInput = {}));
    (function(SwitchInput2) {
      SwitchInput2[SwitchInput2["B"] = 0] = "B";
      SwitchInput2[SwitchInput2["A"] = 1] = "A";
      SwitchInput2[SwitchInput2["Y"] = 2] = "Y";
      SwitchInput2[SwitchInput2["X"] = 3] = "X";
      SwitchInput2[SwitchInput2["L"] = 4] = "L";
      SwitchInput2[SwitchInput2["R"] = 5] = "R";
      SwitchInput2[SwitchInput2["ZL"] = 6] = "ZL";
      SwitchInput2[SwitchInput2["ZR"] = 7] = "ZR";
      SwitchInput2[SwitchInput2["Minus"] = 8] = "Minus";
      SwitchInput2[SwitchInput2["Plus"] = 9] = "Plus";
      SwitchInput2[SwitchInput2["LS"] = 10] = "LS";
      SwitchInput2[SwitchInput2["RS"] = 11] = "RS";
      SwitchInput2[SwitchInput2["DPadUp"] = 12] = "DPadUp";
      SwitchInput2[SwitchInput2["DPadDown"] = 13] = "DPadDown";
      SwitchInput2[SwitchInput2["DPadLeft"] = 14] = "DPadLeft";
      SwitchInput2[SwitchInput2["DPadRight"] = 15] = "DPadRight";
      SwitchInput2[SwitchInput2["Home"] = 16] = "Home";
      SwitchInput2[SwitchInput2["Capture"] = 17] = "Capture";
      SwitchInput2[SwitchInput2["LStickXAxis"] = 18] = "LStickXAxis";
      SwitchInput2[SwitchInput2["LStickYAxis"] = 19] = "LStickYAxis";
      SwitchInput2[SwitchInput2["RStickXAxis"] = 20] = "RStickXAxis";
      SwitchInput2[SwitchInput2["RStickYAxis"] = 21] = "RStickYAxis";
    })(SwitchInput || (SwitchInput = {}));
  }
});

// node_modules/@babylonjs/core/Events/deviceInputEvents.js
var DeviceInputEventType, EventConstants;
var init_deviceInputEvents = __esm({
  "node_modules/@babylonjs/core/Events/deviceInputEvents.js"() {
    (function(DeviceInputEventType2) {
      DeviceInputEventType2[DeviceInputEventType2["PointerMove"] = 0] = "PointerMove";
      DeviceInputEventType2[DeviceInputEventType2["PointerDown"] = 1] = "PointerDown";
      DeviceInputEventType2[DeviceInputEventType2["PointerUp"] = 2] = "PointerUp";
    })(DeviceInputEventType || (DeviceInputEventType = {}));
    EventConstants = class {
    };
    EventConstants.DOM_DELTA_PIXEL = 0;
    EventConstants.DOM_DELTA_LINE = 1;
    EventConstants.DOM_DELTA_PAGE = 2;
  }
});

// node_modules/@babylonjs/core/DeviceInput/eventFactory.js
var DeviceEventFactory;
var init_eventFactory = __esm({
  "node_modules/@babylonjs/core/DeviceInput/eventFactory.js"() {
    init_deviceInputEvents();
    init_deviceEnums();
    DeviceEventFactory = class {
      static CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId) {
        switch (deviceType) {
          case DeviceType.Keyboard:
            return this._CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo);
          case DeviceType.Mouse:
            if (inputIndex === PointerInput.MouseWheelX || inputIndex === PointerInput.MouseWheelY || inputIndex === PointerInput.MouseWheelZ) {
              return this._CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
            }
          case DeviceType.Touch:
            return this._CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId);
          default:
            throw `Unable to generate event for device ${DeviceType[deviceType]}`;
        }
      }
      static _CreatePointerEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo, pointerId) {
        const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        if (deviceType === DeviceType.Mouse) {
          evt.deviceType = DeviceType.Mouse;
          evt.pointerId = 1;
          evt.pointerType = "mouse";
        } else {
          evt.deviceType = DeviceType.Touch;
          evt.pointerId = pointerId !== null && pointerId !== void 0 ? pointerId : deviceSlot;
          evt.pointerType = "touch";
        }
        let buttons = 0;
        buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.LeftClick);
        buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.RightClick) * 2;
        buttons += deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.MiddleClick) * 4;
        evt.buttons = buttons;
        if (inputIndex === PointerInput.Move) {
          evt.type = "pointermove";
        } else if (inputIndex >= PointerInput.LeftClick && inputIndex <= PointerInput.RightClick) {
          evt.type = currentState === 1 ? "pointerdown" : "pointerup";
          evt.button = inputIndex - 2;
        }
        return evt;
      }
      static _CreateWheelEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        const evt = this._CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo);
        evt.pointerId = 1;
        evt.type = "wheel";
        evt.deltaMode = EventConstants.DOM_DELTA_PIXEL;
        evt.deltaX = 0;
        evt.deltaY = 0;
        evt.deltaZ = 0;
        switch (inputIndex) {
          case PointerInput.MouseWheelX:
            evt.deltaX = currentState;
            break;
          case PointerInput.MouseWheelY:
            evt.deltaY = currentState;
            break;
          case PointerInput.MouseWheelZ:
            evt.deltaZ = currentState;
            break;
        }
        return evt;
      }
      static _CreateMouseEvent(deviceType, deviceSlot, inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        const evt = this._CreateEvent(elementToAttachTo);
        const pointerX = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Horizontal);
        const pointerY = deviceInputSystem.pollInput(deviceType, deviceSlot, PointerInput.Vertical);
        if (elementToAttachTo) {
          evt.movementX = 0;
          evt.movementY = 0;
          evt.offsetX = evt.movementX - elementToAttachTo.getBoundingClientRect().x;
          evt.offsetY = evt.movementY - elementToAttachTo.getBoundingClientRect().y;
        } else {
          evt.movementX = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaHorizontal);
          evt.movementY = deviceInputSystem.pollInput(deviceType, deviceSlot, NativePointerInput.DeltaVertical);
          evt.offsetX = 0;
          evt.offsetY = 0;
        }
        this._CheckNonCharacterKeys(evt, deviceInputSystem);
        evt.clientX = pointerX;
        evt.clientY = pointerY;
        evt.x = pointerX;
        evt.y = pointerY;
        evt.deviceType = deviceType;
        evt.deviceSlot = deviceSlot;
        evt.inputIndex = inputIndex;
        return evt;
      }
      static _CreateKeyboardEvent(inputIndex, currentState, deviceInputSystem, elementToAttachTo) {
        const evt = this._CreateEvent(elementToAttachTo);
        this._CheckNonCharacterKeys(evt, deviceInputSystem);
        evt.deviceType = DeviceType.Keyboard;
        evt.deviceSlot = 0;
        evt.inputIndex = inputIndex;
        evt.type = currentState === 1 ? "keydown" : "keyup";
        evt.key = String.fromCharCode(inputIndex);
        evt.keyCode = inputIndex;
        return evt;
      }
      static _CheckNonCharacterKeys(evt, deviceInputSystem) {
        const isKeyboardActive = deviceInputSystem.isDeviceAvailable(DeviceType.Keyboard);
        const altKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 18) === 1;
        const ctrlKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 17) === 1;
        const metaKey = isKeyboardActive && (deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 91) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 92) === 1 || deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 93) === 1);
        const shiftKey = isKeyboardActive && deviceInputSystem.pollInput(DeviceType.Keyboard, 0, 16) === 1;
        evt.altKey = altKey;
        evt.ctrlKey = ctrlKey;
        evt.metaKey = metaKey;
        evt.shiftKey = shiftKey;
      }
      static _CreateEvent(elementToAttachTo) {
        const evt = {};
        evt.preventDefault = () => {
        };
        evt.target = elementToAttachTo;
        return evt;
      }
    };
  }
});

// node_modules/@babylonjs/core/DeviceInput/nativeDeviceInputSystem.js
var NativeDeviceInputSystem;
var init_nativeDeviceInputSystem = __esm({
  "node_modules/@babylonjs/core/DeviceInput/nativeDeviceInputSystem.js"() {
    init_eventFactory();
    init_deviceEnums();
    NativeDeviceInputSystem = class {
      constructor(onDeviceConnected, onDeviceDisconnected, onInputChanged) {
        this._nativeInput = _native.DeviceInputSystem ? new _native.DeviceInputSystem(onDeviceConnected, onDeviceDisconnected, (deviceType, deviceSlot, inputIndex, currentState) => {
          const evt = DeviceEventFactory.CreateDeviceEvent(deviceType, deviceSlot, inputIndex, currentState, this);
          onInputChanged(deviceType, deviceSlot, evt);
        }) : this._createDummyNativeInput();
      }
      pollInput(deviceType, deviceSlot, inputIndex) {
        return this._nativeInput.pollInput(deviceType, deviceSlot, inputIndex);
      }
      isDeviceAvailable(deviceType) {
        return deviceType === DeviceType.Mouse || deviceType === DeviceType.Touch;
      }
      dispose() {
        this._nativeInput.dispose();
      }
      _createDummyNativeInput() {
        const nativeInput = {
          pollInput: () => {
            return 0;
          },
          isDeviceAvailable: () => {
            return false;
          },
          dispose: () => {
          }
        };
        return nativeInput;
      }
    };
  }
});

// node_modules/@babylonjs/core/DeviceInput/webDeviceInputSystem.js
var MAX_KEYCODES, MAX_POINTER_INPUTS, WebDeviceInputSystem;
var init_webDeviceInputSystem = __esm({
  "node_modules/@babylonjs/core/DeviceInput/webDeviceInputSystem.js"() {
    init_domManagement();
    init_tools();
    init_eventFactory();
    init_deviceEnums();
    MAX_KEYCODES = 255;
    MAX_POINTER_INPUTS = Object.keys(PointerInput).length / 2;
    WebDeviceInputSystem = class {
      constructor(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged) {
        this._inputs = [];
        this._keyboardActive = false;
        this._pointerActive = false;
        this._usingSafari = Tools.IsSafari();
        this._usingMacOS = IsNavigatorAvailable() && /(Mac|iPhone|iPod|iPad)/i.test(navigator.platform);
        this._keyboardDownEvent = (evt) => {
        };
        this._keyboardUpEvent = (evt) => {
        };
        this._keyboardBlurEvent = (evt) => {
        };
        this._pointerMoveEvent = (evt) => {
        };
        this._pointerDownEvent = (evt) => {
        };
        this._pointerUpEvent = (evt) => {
        };
        this._pointerCancelEvent = (evt) => {
        };
        this._pointerWheelEvent = (evt) => {
        };
        this._pointerBlurEvent = (evt) => {
        };
        this._pointerMacOSChromeOutEvent = (evt) => {
        };
        this._eventsAttached = false;
        this._mouseId = -1;
        this._isUsingFirefox = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Firefox") !== -1;
        this._isUsingChromium = IsNavigatorAvailable() && navigator.userAgent && navigator.userAgent.indexOf("Chrome") !== -1;
        this._maxTouchPoints = 0;
        this._pointerInputClearObserver = null;
        this._gamepadConnectedEvent = (evt) => {
        };
        this._gamepadDisconnectedEvent = (evt) => {
        };
        this._eventPrefix = Tools.GetPointerPrefix(engine);
        this._engine = engine;
        this._onDeviceConnected = onDeviceConnected;
        this._onDeviceDisconnected = onDeviceDisconnected;
        this._onInputChanged = onInputChanged;
        this._mouseId = this._isUsingFirefox ? 0 : 1;
        this._enableEvents();
        if (this._usingMacOS) {
          this._metaKeys = [];
        }
        if (!this._engine._onEngineViewChanged) {
          this._engine._onEngineViewChanged = () => {
            this._enableEvents();
          };
        }
      }
      pollInput(deviceType, deviceSlot, inputIndex) {
        const device = this._inputs[deviceType][deviceSlot];
        if (!device) {
          throw `Unable to find device ${DeviceType[deviceType]}`;
        }
        if (deviceType >= DeviceType.DualShock && deviceType <= DeviceType.DualSense) {
          this._updateDevice(deviceType, deviceSlot, inputIndex);
        }
        const currentValue = device[inputIndex];
        if (currentValue === void 0) {
          throw `Unable to find input ${inputIndex} for device ${DeviceType[deviceType]} in slot ${deviceSlot}`;
        }
        if (inputIndex === PointerInput.Move) {
          Tools.Warn(`Unable to provide information for PointerInput.Move.  Try using PointerInput.Horizontal or PointerInput.Vertical for move data.`);
        }
        return currentValue;
      }
      isDeviceAvailable(deviceType) {
        return this._inputs[deviceType] !== void 0;
      }
      dispose() {
        this._onDeviceConnected = () => {
        };
        this._onDeviceDisconnected = () => {
        };
        this._onInputChanged = () => {
        };
        delete this._engine._onEngineViewChanged;
        if (this._elementToAttachTo) {
          this._disableEvents();
        }
      }
      _enableEvents() {
        const inputElement = this === null || this === void 0 ? void 0 : this._engine.getInputElement();
        if (inputElement && (!this._eventsAttached || this._elementToAttachTo !== inputElement)) {
          this._disableEvents();
          if (this._inputs) {
            for (const inputs of this._inputs) {
              if (inputs) {
                for (const deviceSlotKey in inputs) {
                  const deviceSlot = +deviceSlotKey;
                  const device = inputs[deviceSlot];
                  if (device) {
                    for (let inputIndex = 0; inputIndex < device.length; inputIndex++) {
                      device[inputIndex] = 0;
                    }
                  }
                }
              }
            }
          }
          this._elementToAttachTo = inputElement;
          this._elementToAttachTo.tabIndex = this._elementToAttachTo.tabIndex !== -1 ? this._elementToAttachTo.tabIndex : this._engine.canvasTabIndex;
          this._handleKeyActions();
          this._handlePointerActions();
          this._handleGamepadActions();
          this._eventsAttached = true;
          this._checkForConnectedDevices();
        }
      }
      _disableEvents() {
        if (this._elementToAttachTo) {
          this._elementToAttachTo.removeEventListener("blur", this._keyboardBlurEvent);
          this._elementToAttachTo.removeEventListener("blur", this._pointerBlurEvent);
          this._elementToAttachTo.removeEventListener("keydown", this._keyboardDownEvent);
          this._elementToAttachTo.removeEventListener("keyup", this._keyboardUpEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "down", this._pointerDownEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "up", this._pointerUpEvent);
          this._elementToAttachTo.removeEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
          this._elementToAttachTo.removeEventListener(this._wheelEventName, this._pointerWheelEvent);
          if (this._usingMacOS && this._isUsingChromium) {
            this._elementToAttachTo.removeEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent);
          }
          window.removeEventListener("gamepadconnected", this._gamepadConnectedEvent);
          window.removeEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
        }
        if (this._pointerInputClearObserver) {
          this._engine.onEndFrameObservable.remove(this._pointerInputClearObserver);
        }
        this._eventsAttached = false;
      }
      _checkForConnectedDevices() {
        if (navigator.getGamepads) {
          const gamepads = navigator.getGamepads();
          for (const gamepad of gamepads) {
            if (gamepad) {
              this._addGamePad(gamepad);
            }
          }
        }
        if (typeof matchMedia === "function" && matchMedia("(pointer:fine)").matches) {
          this._addPointerDevice(DeviceType.Mouse, 0, 0, 0);
        }
      }
      _addGamePad(gamepad) {
        const deviceType = this._getGamepadDeviceType(gamepad.id);
        const deviceSlot = gamepad.index;
        this._gamepads = this._gamepads || new Array(gamepad.index + 1);
        this._registerDevice(deviceType, deviceSlot, gamepad.buttons.length + gamepad.axes.length);
        this._gamepads[deviceSlot] = deviceType;
      }
      _addPointerDevice(deviceType, deviceSlot, currentX, currentY) {
        if (!this._pointerActive) {
          this._pointerActive = true;
        }
        this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
        const pointer = this._inputs[deviceType][deviceSlot];
        pointer[0] = currentX;
        pointer[1] = currentY;
      }
      _registerDevice(deviceType, deviceSlot, numberOfInputs) {
        if (deviceSlot === void 0) {
          throw `Unable to register device ${DeviceType[deviceType]} to undefined slot.`;
        }
        if (!this._inputs[deviceType]) {
          this._inputs[deviceType] = {};
        }
        if (!this._inputs[deviceType][deviceSlot]) {
          const device = new Array(numberOfInputs);
          device.fill(0);
          this._inputs[deviceType][deviceSlot] = device;
          this._onDeviceConnected(deviceType, deviceSlot);
        }
      }
      _unregisterDevice(deviceType, deviceSlot) {
        if (this._inputs[deviceType][deviceSlot]) {
          delete this._inputs[deviceType][deviceSlot];
          this._onDeviceDisconnected(deviceType, deviceSlot);
        }
      }
      _handleKeyActions() {
        this._keyboardDownEvent = (evt) => {
          if (!this._keyboardActive) {
            this._keyboardActive = true;
            this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
          }
          const kbKey = this._inputs[DeviceType.Keyboard][0];
          if (kbKey) {
            kbKey[evt.keyCode] = 1;
            const deviceEvent = evt;
            deviceEvent.inputIndex = evt.keyCode;
            if (this._usingMacOS && evt.metaKey && evt.key !== "Meta") {
              if (!this._metaKeys.includes(evt.keyCode)) {
                this._metaKeys.push(evt.keyCode);
              }
            }
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        };
        this._keyboardUpEvent = (evt) => {
          if (!this._keyboardActive) {
            this._keyboardActive = true;
            this._registerDevice(DeviceType.Keyboard, 0, MAX_KEYCODES);
          }
          const kbKey = this._inputs[DeviceType.Keyboard][0];
          if (kbKey) {
            kbKey[evt.keyCode] = 0;
            const deviceEvent = evt;
            deviceEvent.inputIndex = evt.keyCode;
            if (this._usingMacOS && evt.key === "Meta" && this._metaKeys.length > 0) {
              for (const keyCode of this._metaKeys) {
                const deviceEvent2 = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, keyCode, 0, this, this._elementToAttachTo);
                kbKey[keyCode] = 0;
                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent2);
              }
              this._metaKeys.splice(0, this._metaKeys.length);
            }
            this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
          }
        };
        this._keyboardBlurEvent = () => {
          if (this._keyboardActive) {
            const kbKey = this._inputs[DeviceType.Keyboard][0];
            for (let i = 0; i < kbKey.length; i++) {
              if (kbKey[i] !== 0) {
                kbKey[i] = 0;
                const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Keyboard, 0, i, 0, this, this._elementToAttachTo);
                this._onInputChanged(DeviceType.Keyboard, 0, deviceEvent);
              }
            }
            if (this._usingMacOS) {
              this._metaKeys.splice(0, this._metaKeys.length);
            }
          }
        };
        this._elementToAttachTo.addEventListener("keydown", this._keyboardDownEvent);
        this._elementToAttachTo.addEventListener("keyup", this._keyboardUpEvent);
        this._elementToAttachTo.addEventListener("blur", this._keyboardBlurEvent);
      }
      _handlePointerActions() {
        this._maxTouchPoints = IsNavigatorAvailable() && navigator.maxTouchPoints || 2;
        if (!this._activeTouchIds) {
          this._activeTouchIds = new Array(this._maxTouchPoints);
        }
        for (let i = 0; i < this._maxTouchPoints; i++) {
          this._activeTouchIds[i] = -1;
        }
        this._pointerMoveEvent = (evt) => {
          const deviceType = this._getPointerType(evt);
          let deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
          if (deviceType === DeviceType.Touch && deviceSlot === -1) {
            const idx = this._activeTouchIds.indexOf(-1);
            if (idx >= 0) {
              deviceSlot = idx;
              this._activeTouchIds[idx] = evt.pointerId;
              this._onDeviceConnected(deviceType, deviceSlot);
            } else {
              Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
              return;
            }
          }
          if (!this._inputs[deviceType]) {
            this._inputs[deviceType] = {};
          }
          if (!this._inputs[deviceType][deviceSlot]) {
            this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
          }
          const pointer = this._inputs[deviceType][deviceSlot];
          if (pointer) {
            const deviceEvent = evt;
            deviceEvent.inputIndex = PointerInput.Move;
            pointer[PointerInput.Horizontal] = evt.clientX;
            pointer[PointerInput.Vertical] = evt.clientY;
            if (deviceType === DeviceType.Touch && pointer[PointerInput.LeftClick] === 0) {
              pointer[PointerInput.LeftClick] = 1;
            }
            if (evt.pointerId === void 0) {
              evt.pointerId = this._mouseId;
            }
            this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            if (!this._usingSafari && evt.button !== -1) {
              deviceEvent.inputIndex = evt.button + 2;
              pointer[evt.button + 2] = pointer[evt.button + 2] ? 0 : 1;
              this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
          }
        };
        this._pointerDownEvent = (evt) => {
          const deviceType = this._getPointerType(evt);
          let deviceSlot = deviceType === DeviceType.Mouse ? 0 : evt.pointerId;
          if (deviceType === DeviceType.Touch) {
            const idx = this._activeTouchIds.indexOf(-1);
            if (idx >= 0) {
              deviceSlot = idx;
              this._activeTouchIds[idx] = evt.pointerId;
            } else {
              Tools.Warn(`Max number of touches exceeded.  Ignoring touches in excess of ${this._maxTouchPoints}`);
              return;
            }
          }
          if (!this._inputs[deviceType]) {
            this._inputs[deviceType] = {};
          }
          if (!this._inputs[deviceType][deviceSlot]) {
            this._addPointerDevice(deviceType, deviceSlot, evt.clientX, evt.clientY);
          } else if (deviceType === DeviceType.Touch) {
            this._onDeviceConnected(deviceType, deviceSlot);
          }
          const pointer = this._inputs[deviceType][deviceSlot];
          if (pointer) {
            const previousHorizontal = pointer[PointerInput.Horizontal];
            const previousVertical = pointer[PointerInput.Vertical];
            if (deviceType === DeviceType.Mouse) {
              if (evt.pointerId === void 0) {
                evt.pointerId = this._mouseId;
              }
              if (!document.pointerLockElement) {
                try {
                  this._elementToAttachTo.setPointerCapture(this._mouseId);
                } catch (e) {
                }
              }
            } else {
              if (evt.pointerId && !document.pointerLockElement) {
                try {
                  this._elementToAttachTo.setPointerCapture(evt.pointerId);
                } catch (e) {
                }
              }
            }
            pointer[PointerInput.Horizontal] = evt.clientX;
            pointer[PointerInput.Vertical] = evt.clientY;
            pointer[evt.button + 2] = 1;
            const deviceEvent = evt;
            deviceEvent.inputIndex = evt.button + 2;
            this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
              deviceEvent.inputIndex = PointerInput.Move;
              this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
          }
        };
        this._pointerUpEvent = (evt) => {
          var _a, _b, _c, _d, _e;
          const deviceType = this._getPointerType(evt);
          const deviceSlot = deviceType === DeviceType.Mouse ? 0 : this._activeTouchIds.indexOf(evt.pointerId);
          if (deviceType === DeviceType.Touch) {
            if (deviceSlot === -1) {
              return;
            } else {
              this._activeTouchIds[deviceSlot] = -1;
            }
          }
          const pointer = (_a = this._inputs[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
          if (pointer && pointer[evt.button + 2] !== 0) {
            const previousHorizontal = pointer[PointerInput.Horizontal];
            const previousVertical = pointer[PointerInput.Vertical];
            pointer[PointerInput.Horizontal] = evt.clientX;
            pointer[PointerInput.Vertical] = evt.clientY;
            pointer[evt.button + 2] = 0;
            const deviceEvent = evt;
            if (evt.pointerId === void 0) {
              evt.pointerId = this._mouseId;
            }
            if (previousHorizontal !== evt.clientX || previousVertical !== evt.clientY) {
              deviceEvent.inputIndex = PointerInput.Move;
              this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
            deviceEvent.inputIndex = evt.button + 2;
            if (deviceType === DeviceType.Mouse && this._mouseId >= 0 && ((_c = (_b = this._elementToAttachTo).hasPointerCapture) === null || _c === void 0 ? void 0 : _c.call(_b, this._mouseId))) {
              this._elementToAttachTo.releasePointerCapture(this._mouseId);
            } else if (evt.pointerId && ((_e = (_d = this._elementToAttachTo).hasPointerCapture) === null || _e === void 0 ? void 0 : _e.call(_d, evt.pointerId))) {
              this._elementToAttachTo.releasePointerCapture(evt.pointerId);
            }
            this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            if (deviceType === DeviceType.Touch) {
              this._onDeviceDisconnected(deviceType, deviceSlot);
            }
          }
        };
        this._pointerCancelEvent = (evt) => {
          var _a, _b, _c, _d;
          if (evt.pointerType === "mouse") {
            const pointer = this._inputs[DeviceType.Mouse][0];
            if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {
              this._elementToAttachTo.releasePointerCapture(this._mouseId);
            }
            for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
              if (pointer[inputIndex] === 1) {
                pointer[inputIndex] = 0;
                const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
                this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
              }
            }
          } else {
            const deviceSlot = this._activeTouchIds.indexOf(evt.pointerId);
            if (deviceSlot === -1) {
              return;
            }
            if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, evt.pointerId)) {
              this._elementToAttachTo.releasePointerCapture(evt.pointerId);
            }
            this._inputs[DeviceType.Touch][deviceSlot][PointerInput.LeftClick] = 0;
            const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, evt.pointerId);
            this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
            this._activeTouchIds[deviceSlot] = -1;
            this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
          }
        };
        this._wheelEventName = "onwheel" in document.createElement("div") ? "wheel" : document.onmousewheel !== void 0 ? "mousewheel" : "DOMMouseScroll";
        let passiveSupported = false;
        const noop = function() {
        };
        try {
          const options = Object.defineProperty({}, "passive", {
            get: function() {
              passiveSupported = true;
            }
          });
          this._elementToAttachTo.addEventListener("test", noop, options);
          this._elementToAttachTo.removeEventListener("test", noop, options);
        } catch (e) {
        }
        this._pointerBlurEvent = () => {
          var _a, _b, _c, _d, _e;
          if (this.isDeviceAvailable(DeviceType.Mouse)) {
            const pointer = this._inputs[DeviceType.Mouse][0];
            if (this._mouseId >= 0 && ((_b = (_a = this._elementToAttachTo).hasPointerCapture) === null || _b === void 0 ? void 0 : _b.call(_a, this._mouseId))) {
              this._elementToAttachTo.releasePointerCapture(this._mouseId);
            }
            for (let inputIndex = PointerInput.LeftClick; inputIndex <= PointerInput.BrowserForward; inputIndex++) {
              if (pointer[inputIndex] === 1) {
                pointer[inputIndex] = 0;
                const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Mouse, 0, inputIndex, 0, this, this._elementToAttachTo);
                this._onInputChanged(DeviceType.Mouse, 0, deviceEvent);
              }
            }
          }
          if (this.isDeviceAvailable(DeviceType.Touch)) {
            const pointer = this._inputs[DeviceType.Touch];
            for (let deviceSlot = 0; deviceSlot < this._activeTouchIds.length; deviceSlot++) {
              const pointerId = this._activeTouchIds[deviceSlot];
              if ((_d = (_c = this._elementToAttachTo).hasPointerCapture) === null || _d === void 0 ? void 0 : _d.call(_c, pointerId)) {
                this._elementToAttachTo.releasePointerCapture(pointerId);
              }
              if (pointerId !== -1 && ((_e = pointer[deviceSlot]) === null || _e === void 0 ? void 0 : _e[PointerInput.LeftClick]) === 1) {
                pointer[deviceSlot][PointerInput.LeftClick] = 0;
                const deviceEvent = DeviceEventFactory.CreateDeviceEvent(DeviceType.Touch, deviceSlot, PointerInput.LeftClick, 0, this, this._elementToAttachTo, pointerId);
                this._onInputChanged(DeviceType.Touch, deviceSlot, deviceEvent);
                this._activeTouchIds[deviceSlot] = -1;
                this._onDeviceDisconnected(DeviceType.Touch, deviceSlot);
              }
            }
          }
        };
        this._pointerWheelEvent = (evt) => {
          const deviceType = DeviceType.Mouse;
          const deviceSlot = 0;
          if (!this._inputs[deviceType]) {
            this._inputs[deviceType] = [];
          }
          if (!this._inputs[deviceType][deviceSlot]) {
            this._pointerActive = true;
            this._registerDevice(deviceType, deviceSlot, MAX_POINTER_INPUTS);
          }
          const pointer = this._inputs[deviceType][deviceSlot];
          if (pointer) {
            pointer[PointerInput.MouseWheelX] = evt.deltaX || 0;
            pointer[PointerInput.MouseWheelY] = evt.deltaY || evt.wheelDelta || 0;
            pointer[PointerInput.MouseWheelZ] = evt.deltaZ || 0;
            const deviceEvent = evt;
            if (evt.pointerId === void 0) {
              evt.pointerId = this._mouseId;
            }
            if (pointer[PointerInput.MouseWheelX] !== 0) {
              deviceEvent.inputIndex = PointerInput.MouseWheelX;
              this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
            if (pointer[PointerInput.MouseWheelY] !== 0) {
              deviceEvent.inputIndex = PointerInput.MouseWheelY;
              this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
            if (pointer[PointerInput.MouseWheelZ] !== 0) {
              deviceEvent.inputIndex = PointerInput.MouseWheelZ;
              this._onInputChanged(deviceType, deviceSlot, deviceEvent);
            }
          }
        };
        if (this._usingMacOS && this._isUsingChromium) {
          this._pointerMacOSChromeOutEvent = (evt) => {
            if (evt.buttons > 1) {
              this._pointerCancelEvent(evt);
            }
          };
          this._elementToAttachTo.addEventListener("lostpointercapture", this._pointerMacOSChromeOutEvent);
        }
        this._elementToAttachTo.addEventListener(this._eventPrefix + "move", this._pointerMoveEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "down", this._pointerDownEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "up", this._pointerUpEvent);
        this._elementToAttachTo.addEventListener(this._eventPrefix + "cancel", this._pointerCancelEvent);
        this._elementToAttachTo.addEventListener("blur", this._pointerBlurEvent);
        this._elementToAttachTo.addEventListener(this._wheelEventName, this._pointerWheelEvent, passiveSupported ? { passive: false } : false);
        this._pointerInputClearObserver = this._engine.onEndFrameObservable.add(() => {
          if (this.isDeviceAvailable(DeviceType.Mouse)) {
            const pointer = this._inputs[DeviceType.Mouse][0];
            pointer[PointerInput.MouseWheelX] = 0;
            pointer[PointerInput.MouseWheelY] = 0;
            pointer[PointerInput.MouseWheelZ] = 0;
          }
        });
      }
      _handleGamepadActions() {
        this._gamepadConnectedEvent = (evt) => {
          this._addGamePad(evt.gamepad);
        };
        this._gamepadDisconnectedEvent = (evt) => {
          if (this._gamepads) {
            const deviceType = this._getGamepadDeviceType(evt.gamepad.id);
            const deviceSlot = evt.gamepad.index;
            this._unregisterDevice(deviceType, deviceSlot);
            delete this._gamepads[deviceSlot];
          }
        };
        window.addEventListener("gamepadconnected", this._gamepadConnectedEvent);
        window.addEventListener("gamepaddisconnected", this._gamepadDisconnectedEvent);
      }
      _updateDevice(deviceType, deviceSlot, inputIndex) {
        const gp = navigator.getGamepads()[deviceSlot];
        if (gp && deviceType === this._gamepads[deviceSlot]) {
          const device = this._inputs[deviceType][deviceSlot];
          if (inputIndex >= gp.buttons.length) {
            device[inputIndex] = gp.axes[inputIndex - gp.buttons.length].valueOf();
          } else {
            device[inputIndex] = gp.buttons[inputIndex].value;
          }
        }
      }
      _getGamepadDeviceType(deviceName) {
        if (deviceName.indexOf("054c") !== -1) {
          return deviceName.indexOf("0ce6") !== -1 ? DeviceType.DualSense : DeviceType.DualShock;
        } else if (deviceName.indexOf("Xbox One") !== -1 || deviceName.search("Xbox 360") !== -1 || deviceName.search("xinput") !== -1) {
          return DeviceType.Xbox;
        } else if (deviceName.indexOf("057e") !== -1) {
          return DeviceType.Switch;
        }
        return DeviceType.Generic;
      }
      _getPointerType(evt) {
        let deviceType = DeviceType.Mouse;
        if (evt.pointerType === "touch" || evt.pointerType === "pen" || evt.touches) {
          deviceType = DeviceType.Touch;
        }
        return deviceType;
      }
    };
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js
var DeviceSource;
var init_deviceSource = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSource.js"() {
    init_observable();
    DeviceSource = class {
      constructor(deviceInputSystem, deviceType, deviceSlot = 0) {
        this.deviceType = deviceType;
        this.deviceSlot = deviceSlot;
        this.onInputChangedObservable = new Observable();
        this._deviceInputSystem = deviceInputSystem;
      }
      getInput(inputIndex) {
        return this._deviceInputSystem.pollInput(this.deviceType, this.deviceSlot, inputIndex);
      }
    };
  }
});

// node_modules/@babylonjs/core/DeviceInput/internalDeviceSourceManager.js
var InternalDeviceSourceManager;
var init_internalDeviceSourceManager = __esm({
  "node_modules/@babylonjs/core/DeviceInput/internalDeviceSourceManager.js"() {
    init_deviceEnums();
    init_nativeDeviceInputSystem();
    init_webDeviceInputSystem();
    init_deviceSource();
    InternalDeviceSourceManager = class {
      constructor(engine) {
        this._registeredManagers = new Array();
        this._refCount = 0;
        this.registerManager = (manager) => {
          for (let deviceType = 0; deviceType < this._devices.length; deviceType++) {
            const device = this._devices[deviceType];
            for (const deviceSlotKey in device) {
              const deviceSlot = +deviceSlotKey;
              manager._addDevice(new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot));
            }
          }
          this._registeredManagers.push(manager);
        };
        this.unregisterManager = (manager) => {
          const idx = this._registeredManagers.indexOf(manager);
          if (idx > -1) {
            this._registeredManagers.splice(idx, 1);
          }
        };
        const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
        this._devices = new Array(numberOfDeviceTypes);
        const onDeviceConnected = (deviceType, deviceSlot) => {
          if (!this._devices[deviceType]) {
            this._devices[deviceType] = new Array();
          }
          if (!this._devices[deviceType][deviceSlot]) {
            this._devices[deviceType][deviceSlot] = deviceSlot;
          }
          for (const manager of this._registeredManagers) {
            const deviceSource = new DeviceSource(this._deviceInputSystem, deviceType, deviceSlot);
            manager._addDevice(deviceSource);
          }
        };
        const onDeviceDisconnected = (deviceType, deviceSlot) => {
          var _a;
          if ((_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) {
            delete this._devices[deviceType][deviceSlot];
          }
          for (const manager of this._registeredManagers) {
            manager._removeDevice(deviceType, deviceSlot);
          }
        };
        const onInputChanged = (deviceType, deviceSlot, eventData) => {
          if (eventData) {
            for (const manager of this._registeredManagers) {
              manager._onInputChanged(deviceType, deviceSlot, eventData);
            }
          }
        };
        if (typeof _native !== "undefined") {
          this._deviceInputSystem = new NativeDeviceInputSystem(onDeviceConnected, onDeviceDisconnected, onInputChanged);
        } else {
          this._deviceInputSystem = new WebDeviceInputSystem(engine, onDeviceConnected, onDeviceDisconnected, onInputChanged);
        }
      }
      dispose() {
        this._deviceInputSystem.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js
var DeviceSourceManager;
var init_deviceSourceManager = __esm({
  "node_modules/@babylonjs/core/DeviceInput/InputDevices/deviceSourceManager.js"() {
    init_deviceEnums();
    init_observable();
    init_internalDeviceSourceManager();
    DeviceSourceManager = class {
      getDeviceSource(deviceType, deviceSlot) {
        if (deviceSlot === void 0) {
          if (this._firstDevice[deviceType] === void 0) {
            return null;
          }
          deviceSlot = this._firstDevice[deviceType];
        }
        if (!this._devices[deviceType] || this._devices[deviceType][deviceSlot] === void 0) {
          return null;
        }
        return this._devices[deviceType][deviceSlot];
      }
      getDeviceSources(deviceType) {
        if (!this._devices[deviceType]) {
          return [];
        }
        return this._devices[deviceType].filter((source) => {
          return !!source;
        });
      }
      constructor(engine) {
        const numberOfDeviceTypes = Object.keys(DeviceType).length / 2;
        this._devices = new Array(numberOfDeviceTypes);
        this._firstDevice = new Array(numberOfDeviceTypes);
        this._engine = engine;
        if (!this._engine._deviceSourceManager) {
          this._engine._deviceSourceManager = new InternalDeviceSourceManager(engine);
        }
        this._engine._deviceSourceManager._refCount++;
        this.onDeviceConnectedObservable = new Observable((observer) => {
          for (const devices of this._devices) {
            if (devices) {
              for (const device of devices) {
                if (device) {
                  this.onDeviceConnectedObservable.notifyObserver(observer, device);
                }
              }
            }
          }
        });
        this.onDeviceDisconnectedObservable = new Observable();
        this._engine._deviceSourceManager.registerManager(this);
        this._onDisposeObserver = engine.onDisposeObservable.add(() => {
          this.dispose();
        });
      }
      dispose() {
        this.onDeviceConnectedObservable.clear();
        this.onDeviceDisconnectedObservable.clear();
        if (this._engine._deviceSourceManager) {
          this._engine._deviceSourceManager.unregisterManager(this);
          if (--this._engine._deviceSourceManager._refCount < 1) {
            this._engine._deviceSourceManager.dispose();
            delete this._engine._deviceSourceManager;
          }
        }
        this._engine.onDisposeObservable.remove(this._onDisposeObserver);
      }
      _addDevice(deviceSource) {
        if (!this._devices[deviceSource.deviceType]) {
          this._devices[deviceSource.deviceType] = new Array();
        }
        if (!this._devices[deviceSource.deviceType][deviceSource.deviceSlot]) {
          this._devices[deviceSource.deviceType][deviceSource.deviceSlot] = deviceSource;
          this._updateFirstDevices(deviceSource.deviceType);
        }
        this.onDeviceConnectedObservable.notifyObservers(deviceSource);
      }
      _removeDevice(deviceType, deviceSlot) {
        var _a, _b;
        const deviceSource = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot];
        this.onDeviceDisconnectedObservable.notifyObservers(deviceSource);
        if ((_b = this._devices[deviceType]) === null || _b === void 0 ? void 0 : _b[deviceSlot]) {
          delete this._devices[deviceType][deviceSlot];
        }
        this._updateFirstDevices(deviceType);
      }
      _onInputChanged(deviceType, deviceSlot, eventData) {
        var _a, _b;
        (_b = (_a = this._devices[deviceType]) === null || _a === void 0 ? void 0 : _a[deviceSlot]) === null || _b === void 0 ? void 0 : _b.onInputChangedObservable.notifyObservers(eventData);
      }
      _updateFirstDevices(type) {
        switch (type) {
          case DeviceType.Keyboard:
          case DeviceType.Mouse:
            this._firstDevice[type] = 0;
            break;
          case DeviceType.Touch:
          case DeviceType.DualSense:
          case DeviceType.DualShock:
          case DeviceType.Xbox:
          case DeviceType.Switch:
          case DeviceType.Generic: {
            delete this._firstDevice[type];
            const devices = this._devices[type];
            if (devices) {
              for (let i = 0; i < devices.length; i++) {
                if (devices[i]) {
                  this._firstDevice[type] = i;
                  break;
                }
              }
            }
            break;
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Inputs/scene.inputManager.js
var _ClickInfo, InputManager;
var init_scene_inputManager = __esm({
  "node_modules/@babylonjs/core/Inputs/scene.inputManager.js"() {
    init_pointerEvents();
    init_abstractActionManager();
    init_pickingInfo();
    init_math_vector();
    init_actionEvent();
    init_keyboardEvents();
    init_deviceEnums();
    init_deviceSourceManager();
    init_engineStore();
    _ClickInfo = class {
      constructor() {
        this._singleClick = false;
        this._doubleClick = false;
        this._hasSwiped = false;
        this._ignore = false;
      }
      get singleClick() {
        return this._singleClick;
      }
      get doubleClick() {
        return this._doubleClick;
      }
      get hasSwiped() {
        return this._hasSwiped;
      }
      get ignore() {
        return this._ignore;
      }
      set singleClick(b) {
        this._singleClick = b;
      }
      set doubleClick(b) {
        this._doubleClick = b;
      }
      set hasSwiped(b) {
        this._hasSwiped = b;
      }
      set ignore(b) {
        this._ignore = b;
      }
    };
    InputManager = class {
      constructor(scene) {
        this._alreadyAttached = false;
        this._meshPickProceed = false;
        this._currentPickResult = null;
        this._previousPickResult = null;
        this._totalPointersPressed = 0;
        this._doubleClickOccured = false;
        this._isSwiping = false;
        this._swipeButtonPressed = -1;
        this._skipPointerTap = false;
        this._isMultiTouchGesture = false;
        this._pointerX = 0;
        this._pointerY = 0;
        this._startingPointerPosition = new Vector2(0, 0);
        this._previousStartingPointerPosition = new Vector2(0, 0);
        this._startingPointerTime = 0;
        this._previousStartingPointerTime = 0;
        this._pointerCaptures = {};
        this._meshUnderPointerId = {};
        this._movePointerInfo = null;
        this._cameraObserverCount = 0;
        this._delayedClicks = [null, null, null, null, null];
        this._deviceSourceManager = null;
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
      }
      get meshUnderPointer() {
        if (this._movePointerInfo) {
          this._movePointerInfo._generatePickInfo();
          this._movePointerInfo = null;
        }
        return this._pointerOverMesh;
      }
      getMeshUnderPointerByPointerId(pointerId) {
        return this._meshUnderPointerId[pointerId] || null;
      }
      get unTranslatedPointer() {
        return new Vector2(this._unTranslatedPointerX, this._unTranslatedPointerY);
      }
      get pointerX() {
        return this._pointerX;
      }
      set pointerX(value) {
        this._pointerX = value;
      }
      get pointerY() {
        return this._pointerY;
      }
      set pointerY(value) {
        this._pointerY = value;
      }
      _updatePointerPosition(evt) {
        const canvasRect = this._scene.getEngine().getInputElementClientRect();
        if (!canvasRect) {
          return;
        }
        this._pointerX = evt.clientX - canvasRect.left;
        this._pointerY = evt.clientY - canvasRect.top;
        this._unTranslatedPointerX = this._pointerX;
        this._unTranslatedPointerY = this._pointerY;
      }
      _processPointerMove(pickResult, evt) {
        const scene = this._scene;
        const engine = scene.getEngine();
        const canvas = engine.getInputElement();
        if (canvas) {
          canvas.tabIndex = engine.canvasTabIndex;
          if (!scene.doNotHandleCursors) {
            canvas.style.cursor = scene.defaultCursor;
          }
        }
        this._setCursorAndPointerOverMesh(pickResult, evt, scene);
        for (const step of scene._pointerMoveStage) {
          pickResult = pickResult || this._pickMove(evt);
          const isMeshPicked = (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) ? true : false;
          pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, isMeshPicked, canvas);
        }
        const type = evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE;
        if (scene.onPointerMove) {
          pickResult = pickResult || this._pickMove(evt);
          scene.onPointerMove(evt, pickResult, type);
        }
        let pointerInfo;
        if (pickResult) {
          pointerInfo = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pickResult, evt);
        } else {
          pointerInfo = new PointerInfo(type, evt, null, this);
          this._movePointerInfo = pointerInfo;
        }
        if (scene.onPointerObservable.hasObservers()) {
          scene.onPointerObservable.notifyObservers(pointerInfo, type);
        }
      }
      _setRayOnPointerInfo(pickInfo, event) {
        const scene = this._scene;
        if (pickInfo && scene._pickingAvailable) {
          if (!pickInfo.ray) {
            pickInfo.ray = scene.createPickingRay(event.offsetX, event.offsetY, Matrix.Identity(), scene.activeCamera);
          }
        }
      }
      _addCameraPointerObserver(observer, mask) {
        this._cameraObserverCount++;
        return this._scene.onPointerObservable.add(observer, mask);
      }
      _removeCameraPointerObserver(observer) {
        this._cameraObserverCount--;
        return this._scene.onPointerObservable.remove(observer);
      }
      _checkForPicking() {
        return !!(this._scene.onPointerObservable.observers.length > this._cameraObserverCount || this._scene.onPointerPick);
      }
      _checkPrePointerObservable(pickResult, evt, type) {
        const scene = this._scene;
        const pi = new PointerInfoPre(type, evt, this._unTranslatedPointerX, this._unTranslatedPointerY);
        if (pickResult) {
          pi.originalPickingInfo = pickResult;
          pi.ray = pickResult.ray;
          if (pickResult.originMesh) {
            pi.nearInteractionPickingInfo = pickResult;
          }
        }
        scene.onPrePointerObservable.notifyObservers(pi, type);
        if (pi.skipOnPointerObservable) {
          return true;
        } else {
          return false;
        }
      }
      _pickMove(evt) {
        const scene = this._scene;
        const pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerMovePredicate, scene.pointerMoveFastCheck, scene.cameraToUseForPointers, scene.pointerMoveTrianglePredicate);
        this._setCursorAndPointerOverMesh(pickResult, evt, scene);
        return pickResult;
      }
      _setCursorAndPointerOverMesh(pickResult, evt, scene) {
        const engine = scene.getEngine();
        const canvas = engine.getInputElement();
        if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {
          this.setPointerOverMesh(pickResult.pickedMesh, evt.pointerId, pickResult, evt);
          if (!scene.doNotHandleCursors && canvas && this._pointerOverMesh) {
            const actionManager = this._pointerOverMesh._getActionManagerForTrigger();
            if (actionManager && actionManager.hasPointerTriggers) {
              canvas.style.cursor = actionManager.hoverCursor || scene.hoverCursor;
            }
          }
        } else {
          this.setPointerOverMesh(null, evt.pointerId, pickResult, evt);
        }
      }
      simulatePointerMove(pickResult, pointerEventInit) {
        const evt = new PointerEvent("pointermove", pointerEventInit);
        evt.inputIndex = PointerInput.Move;
        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERMOVE)) {
          return;
        }
        this._processPointerMove(pickResult, evt);
      }
      simulatePointerDown(pickResult, pointerEventInit) {
        const evt = new PointerEvent("pointerdown", pointerEventInit);
        evt.inputIndex = evt.button + 2;
        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERDOWN)) {
          return;
        }
        this._processPointerDown(pickResult, evt);
      }
      _processPointerDown(pickResult, evt) {
        const scene = this._scene;
        if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {
          this._pickedDownMesh = pickResult.pickedMesh;
          const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
          if (actionManager) {
            if (actionManager.hasPickTriggers) {
              actionManager.processTrigger(5, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
              switch (evt.button) {
                case 0:
                  actionManager.processTrigger(2, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
                  break;
                case 1:
                  actionManager.processTrigger(4, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
                  break;
                case 2:
                  actionManager.processTrigger(3, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
                  break;
              }
            }
            if (actionManager.hasSpecificTrigger(8)) {
              window.setTimeout(() => {
                const pickResult2 = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.actionManager && mesh.actionManager.hasSpecificTrigger(8) && mesh === this._pickedDownMesh, false, scene.cameraToUseForPointers);
                if ((pickResult2 === null || pickResult2 === void 0 ? void 0 : pickResult2.pickedMesh) && actionManager) {
                  if (this._totalPointersPressed !== 0 && Date.now() - this._startingPointerTime > InputManager.LongPressDelay && !this._isPointerSwiping()) {
                    this._startingPointerTime = 0;
                    actionManager.processTrigger(8, ActionEvent.CreateNew(pickResult2.pickedMesh, evt));
                  }
                }
              }, InputManager.LongPressDelay);
            }
          }
        } else {
          for (const step of scene._pointerDownStage) {
            pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, false);
          }
        }
        let pointerInfo;
        const type = PointerEventTypes.POINTERDOWN;
        if (pickResult) {
          if (scene.onPointerDown) {
            scene.onPointerDown(evt, pickResult, type);
          }
          pointerInfo = new PointerInfo(type, evt, pickResult);
          this._setRayOnPointerInfo(pickResult, evt);
        } else {
          pointerInfo = new PointerInfo(type, evt, null, this);
        }
        if (scene.onPointerObservable.hasObservers()) {
          scene.onPointerObservable.notifyObservers(pointerInfo, type);
        }
      }
      _isPointerSwiping() {
        return this._isSwiping;
      }
      simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
        const evt = new PointerEvent("pointerup", pointerEventInit);
        evt.inputIndex = PointerInput.Move;
        const clickInfo = new _ClickInfo();
        if (doubleTap) {
          clickInfo.doubleClick = true;
        } else {
          clickInfo.singleClick = true;
        }
        if (this._checkPrePointerObservable(pickResult, evt, PointerEventTypes.POINTERUP)) {
          return;
        }
        this._processPointerUp(pickResult, evt, clickInfo);
      }
      _processPointerUp(pickResult, evt, clickInfo) {
        const scene = this._scene;
        if (pickResult === null || pickResult === void 0 ? void 0 : pickResult.pickedMesh) {
          this._pickedUpMesh = pickResult.pickedMesh;
          if (this._pickedDownMesh === this._pickedUpMesh) {
            if (scene.onPointerPick) {
              scene.onPointerPick(evt, pickResult);
            }
            if (clickInfo.singleClick && !clickInfo.ignore && scene.onPointerObservable.observers.length > this._cameraObserverCount) {
              const type = PointerEventTypes.POINTERPICK;
              const pi = new PointerInfo(type, evt, pickResult);
              this._setRayOnPointerInfo(pickResult, evt);
              scene.onPointerObservable.notifyObservers(pi, type);
            }
          }
          const actionManager = pickResult.pickedMesh._getActionManagerForTrigger();
          if (actionManager && !clickInfo.ignore) {
            actionManager.processTrigger(7, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
            if (!clickInfo.hasSwiped && clickInfo.singleClick) {
              actionManager.processTrigger(1, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
            }
            const doubleClickActionManager = pickResult.pickedMesh._getActionManagerForTrigger(6);
            if (clickInfo.doubleClick && doubleClickActionManager) {
              doubleClickActionManager.processTrigger(6, ActionEvent.CreateNew(pickResult.pickedMesh, evt, pickResult));
            }
          }
        } else {
          if (!clickInfo.ignore) {
            for (const step of scene._pointerUpStage) {
              pickResult = step.action(this._unTranslatedPointerX, this._unTranslatedPointerY, pickResult, evt, clickInfo.doubleClick);
            }
          }
        }
        if (this._pickedDownMesh && this._pickedDownMesh !== this._pickedUpMesh) {
          const pickedDownActionManager = this._pickedDownMesh._getActionManagerForTrigger(16);
          if (pickedDownActionManager) {
            pickedDownActionManager.processTrigger(16, ActionEvent.CreateNew(this._pickedDownMesh, evt));
          }
        }
        if (!clickInfo.ignore) {
          const pi = new PointerInfo(PointerEventTypes.POINTERUP, evt, pickResult);
          this._setRayOnPointerInfo(pickResult, evt);
          scene.onPointerObservable.notifyObservers(pi, PointerEventTypes.POINTERUP);
          if (scene.onPointerUp) {
            scene.onPointerUp(evt, pickResult, PointerEventTypes.POINTERUP);
          }
          if (!clickInfo.hasSwiped && !this._skipPointerTap && !this._isMultiTouchGesture) {
            let type = 0;
            if (clickInfo.singleClick) {
              type = PointerEventTypes.POINTERTAP;
            } else if (clickInfo.doubleClick) {
              type = PointerEventTypes.POINTERDOUBLETAP;
            }
            if (type) {
              const pi2 = new PointerInfo(type, evt, pickResult);
              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
                scene.onPointerObservable.notifyObservers(pi2, type);
              }
            }
          }
        }
      }
      isPointerCaptured(pointerId = 0) {
        return this._pointerCaptures[pointerId];
      }
      attachControl(attachUp = true, attachDown = true, attachMove = true, elementToAttachTo = null) {
        const scene = this._scene;
        const engine = scene.getEngine();
        if (!elementToAttachTo) {
          elementToAttachTo = engine.getInputElement();
        }
        if (this._alreadyAttached) {
          this.detachControl();
        }
        if (elementToAttachTo) {
          this._alreadyAttachedTo = elementToAttachTo;
        }
        this._deviceSourceManager = new DeviceSourceManager(engine);
        this._initActionManager = (act) => {
          if (!this._meshPickProceed) {
            const pickResult = scene.skipPointerUpPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerUp ? null : scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerUpPredicate, scene.pointerUpFastCheck, scene.cameraToUseForPointers);
            this._currentPickResult = pickResult;
            if (pickResult) {
              act = pickResult.hit && pickResult.pickedMesh ? pickResult.pickedMesh._getActionManagerForTrigger() : null;
            }
            this._meshPickProceed = true;
          }
          return act;
        };
        this._delayedSimpleClick = (btn, clickInfo, cb) => {
          if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay && !this._doubleClickOccured || btn !== this._previousButtonPressed) {
            this._doubleClickOccured = false;
            clickInfo.singleClick = true;
            clickInfo.ignore = false;
            if (this._delayedClicks[btn]) {
              const evt = this._delayedClicks[btn].evt;
              const type = PointerEventTypes.POINTERTAP;
              const pi = new PointerInfo(type, evt, this._currentPickResult);
              if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
                scene.onPointerObservable.notifyObservers(pi, type);
              }
              this._delayedClicks[btn] = null;
            }
          }
        };
        this._initClickEvent = (obs1, obs2, evt, cb) => {
          var _a, _b;
          const clickInfo = new _ClickInfo();
          this._currentPickResult = null;
          let act = null;
          let checkPicking = obs1.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs2.hasSpecificMask(PointerEventTypes.POINTERPICK) || obs1.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERTAP) || obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
          if (!checkPicking && AbstractActionManager) {
            act = this._initActionManager(act, clickInfo);
            if (act) {
              checkPicking = act.hasPickTriggers;
            }
          }
          let needToIgnoreNext = false;
          if (checkPicking) {
            const btn = evt.button;
            clickInfo.hasSwiped = this._isPointerSwiping();
            if (!clickInfo.hasSwiped) {
              let checkSingleClickImmediately = !InputManager.ExclusiveDoubleClickMode;
              if (!checkSingleClickImmediately) {
                checkSingleClickImmediately = !obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) && !obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
                if (checkSingleClickImmediately && !AbstractActionManager.HasSpecificTrigger(6)) {
                  act = this._initActionManager(act, clickInfo);
                  if (act) {
                    checkSingleClickImmediately = !act.hasSpecificTrigger(6);
                  }
                }
              }
              if (checkSingleClickImmediately) {
                if (Date.now() - this._previousStartingPointerTime > InputManager.DoubleClickDelay || btn !== this._previousButtonPressed) {
                  clickInfo.singleClick = true;
                  cb(clickInfo, this._currentPickResult);
                  needToIgnoreNext = true;
                }
              } else {
                const delayedClick = {
                  evt,
                  clickInfo,
                  timeoutId: window.setTimeout(this._delayedSimpleClick.bind(this, btn, clickInfo, cb), InputManager.DoubleClickDelay)
                };
                this._delayedClicks[btn] = delayedClick;
              }
              let checkDoubleClick = obs1.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP) || obs2.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP);
              if (!checkDoubleClick && AbstractActionManager.HasSpecificTrigger(6)) {
                act = this._initActionManager(act, clickInfo);
                if (act) {
                  checkDoubleClick = act.hasSpecificTrigger(6);
                }
              }
              if (checkDoubleClick) {
                if (btn === this._previousButtonPressed && Date.now() - this._previousStartingPointerTime < InputManager.DoubleClickDelay && !this._doubleClickOccured) {
                  if (!clickInfo.hasSwiped && !this._isPointerSwiping()) {
                    this._previousStartingPointerTime = 0;
                    this._doubleClickOccured = true;
                    clickInfo.doubleClick = true;
                    clickInfo.ignore = false;
                    if (InputManager.ExclusiveDoubleClickMode && this._delayedClicks[btn]) {
                      clearTimeout((_a = this._delayedClicks[btn]) === null || _a === void 0 ? void 0 : _a.timeoutId);
                      this._delayedClicks[btn] = null;
                    }
                    cb(clickInfo, this._currentPickResult);
                  } else {
                    this._doubleClickOccured = false;
                    this._previousStartingPointerTime = this._startingPointerTime;
                    this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
                    this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
                    this._previousButtonPressed = btn;
                    if (InputManager.ExclusiveDoubleClickMode) {
                      if (this._delayedClicks[btn]) {
                        clearTimeout((_b = this._delayedClicks[btn]) === null || _b === void 0 ? void 0 : _b.timeoutId);
                        this._delayedClicks[btn] = null;
                      }
                      cb(clickInfo, this._previousPickResult);
                    } else {
                      cb(clickInfo, this._currentPickResult);
                    }
                  }
                  needToIgnoreNext = true;
                } else {
                  this._doubleClickOccured = false;
                  this._previousStartingPointerTime = this._startingPointerTime;
                  this._previousStartingPointerPosition.x = this._startingPointerPosition.x;
                  this._previousStartingPointerPosition.y = this._startingPointerPosition.y;
                  this._previousButtonPressed = btn;
                }
              }
            }
          }
          if (!needToIgnoreNext) {
            cb(clickInfo, this._currentPickResult);
          }
        };
        this._onPointerMove = (evt) => {
          this._updatePointerPosition(evt);
          if (!this._isSwiping && this._swipeButtonPressed !== -1) {
            this._isSwiping = Math.abs(this._startingPointerPosition.x - this._pointerX) > InputManager.DragMovementThreshold || Math.abs(this._startingPointerPosition.y - this._pointerY) > InputManager.DragMovementThreshold;
          }
          if (engine.isPointerLock) {
            engine._verifyPointerLock();
          }
          if (this._checkPrePointerObservable(null, evt, evt.inputIndex >= PointerInput.MouseWheelX && evt.inputIndex <= PointerInput.MouseWheelZ ? PointerEventTypes.POINTERWHEEL : PointerEventTypes.POINTERMOVE)) {
            return;
          }
          if (!scene.cameraToUseForPointers && !scene.activeCamera) {
            return;
          }
          if (scene.skipPointerMovePicking) {
            this._processPointerMove(new PickingInfo(), evt);
            return;
          }
          if (!scene.pointerMovePredicate) {
            scene.pointerMovePredicate = (mesh) => mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (mesh.enablePointerMoveEvents || scene.constantlyUpdateMeshUnderPointer || mesh._getActionManagerForTrigger() !== null) && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
          }
          const pickResult = scene._registeredActions > 0 || scene.constantlyUpdateMeshUnderPointer ? this._pickMove(evt) : null;
          this._processPointerMove(pickResult, evt);
        };
        this._onPointerDown = (evt) => {
          var _a;
          this._totalPointersPressed++;
          this._pickedDownMesh = null;
          this._meshPickProceed = false;
          if (InputManager.ExclusiveDoubleClickMode) {
            for (let i = 0; i < this._delayedClicks.length; i++) {
              if (this._delayedClicks[i]) {
                if (evt.button === i) {
                  clearTimeout((_a = this._delayedClicks[i]) === null || _a === void 0 ? void 0 : _a.timeoutId);
                } else {
                  const clickInfo = this._delayedClicks[i].clickInfo;
                  this._doubleClickOccured = false;
                  clickInfo.singleClick = true;
                  clickInfo.ignore = false;
                  const prevEvt = this._delayedClicks[i].evt;
                  const type = PointerEventTypes.POINTERTAP;
                  const pi = new PointerInfo(type, prevEvt, this._currentPickResult);
                  if (scene.onPointerObservable.hasObservers() && scene.onPointerObservable.hasSpecificMask(type)) {
                    scene.onPointerObservable.notifyObservers(pi, type);
                  }
                  this._delayedClicks[i] = null;
                }
              }
            }
          }
          this._updatePointerPosition(evt);
          if (this._swipeButtonPressed === -1) {
            this._swipeButtonPressed = evt.button;
          }
          if (scene.preventDefaultOnPointerDown && elementToAttachTo) {
            evt.preventDefault();
            elementToAttachTo.focus();
          }
          this._startingPointerPosition.x = this._pointerX;
          this._startingPointerPosition.y = this._pointerY;
          this._startingPointerTime = Date.now();
          if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOWN)) {
            return;
          }
          if (!scene.cameraToUseForPointers && !scene.activeCamera) {
            return;
          }
          this._pointerCaptures[evt.pointerId] = true;
          if (!scene.pointerDownPredicate) {
            scene.pointerDownPredicate = (mesh) => {
              return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
            };
          }
          this._pickedDownMesh = null;
          let pickResult;
          if (scene.skipPointerDownPicking || scene._registeredActions === 0 && !this._checkForPicking() && !scene.onPointerDown) {
            pickResult = new PickingInfo();
          } else {
            pickResult = scene.pick(this._unTranslatedPointerX, this._unTranslatedPointerY, scene.pointerDownPredicate, scene.pointerDownFastCheck, scene.cameraToUseForPointers);
          }
          this._processPointerDown(pickResult, evt);
        };
        this._onPointerUp = (evt) => {
          if (this._totalPointersPressed === 0) {
            return;
          }
          this._totalPointersPressed--;
          this._pickedUpMesh = null;
          this._meshPickProceed = false;
          this._updatePointerPosition(evt);
          if (scene.preventDefaultOnPointerUp && elementToAttachTo) {
            evt.preventDefault();
            elementToAttachTo.focus();
          }
          this._initClickEvent(scene.onPrePointerObservable, scene.onPointerObservable, evt, (clickInfo, pickResult) => {
            if (scene.onPrePointerObservable.hasObservers()) {
              this._skipPointerTap = false;
              if (!clickInfo.ignore) {
                if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERUP)) {
                  if (this._swipeButtonPressed === evt.button) {
                    this._isSwiping = false;
                    this._swipeButtonPressed = -1;
                  }
                  if (evt.buttons === 0) {
                    this._pointerCaptures[evt.pointerId] = false;
                  }
                  return;
                }
                if (!clickInfo.hasSwiped) {
                  if (clickInfo.singleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERTAP)) {
                    if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERTAP)) {
                      this._skipPointerTap = true;
                    }
                  }
                  if (clickInfo.doubleClick && scene.onPrePointerObservable.hasSpecificMask(PointerEventTypes.POINTERDOUBLETAP)) {
                    if (this._checkPrePointerObservable(null, evt, PointerEventTypes.POINTERDOUBLETAP)) {
                      this._skipPointerTap = true;
                    }
                  }
                }
              }
            }
            if (!this._pointerCaptures[evt.pointerId]) {
              if (this._swipeButtonPressed === evt.button) {
                this._isSwiping = false;
                this._swipeButtonPressed = -1;
              }
              return;
            }
            if (evt.buttons === 0) {
              this._pointerCaptures[evt.pointerId] = false;
            }
            if (!scene.cameraToUseForPointers && !scene.activeCamera) {
              return;
            }
            if (!scene.pointerUpPredicate) {
              scene.pointerUpPredicate = (mesh) => {
                return mesh.isPickable && mesh.isVisible && mesh.isReady() && mesh.isEnabled() && (!scene.cameraToUseForPointers || (scene.cameraToUseForPointers.layerMask & mesh.layerMask) !== 0);
              };
            }
            if (!this._meshPickProceed && (AbstractActionManager && AbstractActionManager.HasTriggers || this._checkForPicking() || scene.onPointerUp)) {
              this._initActionManager(null, clickInfo);
            }
            if (!pickResult) {
              pickResult = this._currentPickResult;
            }
            this._processPointerUp(pickResult, evt, clickInfo);
            this._previousPickResult = this._currentPickResult;
            if (this._swipeButtonPressed === evt.button) {
              this._isSwiping = false;
              this._swipeButtonPressed = -1;
            }
          });
        };
        this._onKeyDown = (evt) => {
          const type = KeyboardEventTypes.KEYDOWN;
          if (scene.onPreKeyboardObservable.hasObservers()) {
            const pi = new KeyboardInfoPre(type, evt);
            scene.onPreKeyboardObservable.notifyObservers(pi, type);
            if (pi.skipOnKeyboardObservable) {
              return;
            }
          }
          if (scene.onKeyboardObservable.hasObservers()) {
            const pi = new KeyboardInfo(type, evt);
            scene.onKeyboardObservable.notifyObservers(pi, type);
          }
          if (scene.actionManager) {
            scene.actionManager.processTrigger(14, ActionEvent.CreateNewFromScene(scene, evt));
          }
        };
        this._onKeyUp = (evt) => {
          const type = KeyboardEventTypes.KEYUP;
          if (scene.onPreKeyboardObservable.hasObservers()) {
            const pi = new KeyboardInfoPre(type, evt);
            scene.onPreKeyboardObservable.notifyObservers(pi, type);
            if (pi.skipOnKeyboardObservable) {
              return;
            }
          }
          if (scene.onKeyboardObservable.hasObservers()) {
            const pi = new KeyboardInfo(type, evt);
            scene.onKeyboardObservable.notifyObservers(pi, type);
          }
          if (scene.actionManager) {
            scene.actionManager.processTrigger(15, ActionEvent.CreateNewFromScene(scene, evt));
          }
        };
        this._deviceSourceManager.onDeviceConnectedObservable.add((deviceSource) => {
          if (deviceSource.deviceType === DeviceType.Mouse) {
            deviceSource.onInputChangedObservable.add((eventData) => {
              if (eventData.inputIndex === PointerInput.LeftClick || eventData.inputIndex === PointerInput.MiddleClick || eventData.inputIndex === PointerInput.RightClick || eventData.inputIndex === PointerInput.BrowserBack || eventData.inputIndex === PointerInput.BrowserForward) {
                if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
                  this._onPointerDown(eventData);
                } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
                  this._onPointerUp(eventData);
                }
              } else if (attachMove) {
                if (eventData.inputIndex === PointerInput.Move) {
                  this._onPointerMove(eventData);
                } else if (eventData.inputIndex === PointerInput.MouseWheelX || eventData.inputIndex === PointerInput.MouseWheelY || eventData.inputIndex === PointerInput.MouseWheelZ) {
                  this._onPointerMove(eventData);
                }
              }
            });
          } else if (deviceSource.deviceType === DeviceType.Touch) {
            deviceSource.onInputChangedObservable.add((eventData) => {
              if (eventData.inputIndex === PointerInput.LeftClick) {
                if (attachDown && deviceSource.getInput(eventData.inputIndex) === 1) {
                  this._onPointerDown(eventData);
                  if (this._totalPointersPressed > 1) {
                    this._isMultiTouchGesture = true;
                  }
                } else if (attachUp && deviceSource.getInput(eventData.inputIndex) === 0) {
                  this._onPointerUp(eventData);
                  if (this._totalPointersPressed === 0) {
                    this._isMultiTouchGesture = false;
                  }
                }
              }
              if (attachMove && eventData.inputIndex === PointerInput.Move) {
                this._onPointerMove(eventData);
              }
            });
          } else if (deviceSource.deviceType === DeviceType.Keyboard) {
            deviceSource.onInputChangedObservable.add((eventData) => {
              if (eventData.type === "keydown") {
                this._onKeyDown(eventData);
              } else if (eventData.type === "keyup") {
                this._onKeyUp(eventData);
              }
            });
          }
        });
        this._alreadyAttached = true;
      }
      detachControl() {
        if (this._alreadyAttached) {
          this._deviceSourceManager.dispose();
          this._deviceSourceManager = null;
          if (this._alreadyAttachedTo && !this._scene.doNotHandleCursors) {
            this._alreadyAttachedTo.style.cursor = this._scene.defaultCursor;
          }
          this._alreadyAttached = false;
          this._alreadyAttachedTo = null;
        }
      }
      setPointerOverMesh(mesh, pointerId = 0, pickResult, evt) {
        if (this._meshUnderPointerId[pointerId] === mesh && (!mesh || !mesh._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting)) {
          return;
        }
        const underPointerMesh = this._meshUnderPointerId[pointerId];
        let actionManager;
        if (underPointerMesh) {
          actionManager = underPointerMesh._getActionManagerForTrigger(10);
          if (actionManager) {
            actionManager.processTrigger(10, ActionEvent.CreateNew(underPointerMesh, evt, { pointerId }));
          }
        }
        if (mesh) {
          this._meshUnderPointerId[pointerId] = mesh;
          this._pointerOverMesh = mesh;
          actionManager = mesh._getActionManagerForTrigger(9);
          if (actionManager) {
            actionManager.processTrigger(9, ActionEvent.CreateNew(mesh, evt, { pointerId, pickResult }));
          }
        } else {
          delete this._meshUnderPointerId[pointerId];
          this._pointerOverMesh = null;
        }
      }
      getPointerOverMesh() {
        return this.meshUnderPointer;
      }
      _invalidateMesh(mesh) {
        if (this._pointerOverMesh === mesh) {
          this._pointerOverMesh = null;
        }
        if (this._pickedDownMesh === mesh) {
          this._pickedDownMesh = null;
        }
        if (this._pickedUpMesh === mesh) {
          this._pickedUpMesh = null;
        }
        for (const pointerId in this._meshUnderPointerId) {
          if (this._meshUnderPointerId[pointerId] === mesh) {
            delete this._meshUnderPointerId[pointerId];
          }
        }
      }
    };
    InputManager.DragMovementThreshold = 10;
    InputManager.LongPressDelay = 500;
    InputManager.DoubleClickDelay = 300;
    InputManager.ExclusiveDoubleClickMode = false;
  }
});

// node_modules/@babylonjs/core/Misc/perfCounter.js
var PerfCounter;
var init_perfCounter = __esm({
  "node_modules/@babylonjs/core/Misc/perfCounter.js"() {
    init_precisionDate();
    PerfCounter = class {
      get min() {
        return this._min;
      }
      get max() {
        return this._max;
      }
      get average() {
        return this._average;
      }
      get lastSecAverage() {
        return this._lastSecAverage;
      }
      get current() {
        return this._current;
      }
      get total() {
        return this._totalAccumulated;
      }
      get count() {
        return this._totalValueCount;
      }
      constructor() {
        this._startMonitoringTime = 0;
        this._min = 0;
        this._max = 0;
        this._average = 0;
        this._lastSecAverage = 0;
        this._current = 0;
        this._totalValueCount = 0;
        this._totalAccumulated = 0;
        this._lastSecAccumulated = 0;
        this._lastSecTime = 0;
        this._lastSecValueCount = 0;
      }
      fetchNewFrame() {
        this._totalValueCount++;
        this._current = 0;
        this._lastSecValueCount++;
      }
      addCount(newCount, fetchResult) {
        if (!PerfCounter.Enabled) {
          return;
        }
        this._current += newCount;
        if (fetchResult) {
          this._fetchResult();
        }
      }
      beginMonitoring() {
        if (!PerfCounter.Enabled) {
          return;
        }
        this._startMonitoringTime = PrecisionDate.Now;
      }
      endMonitoring(newFrame = true) {
        if (!PerfCounter.Enabled) {
          return;
        }
        if (newFrame) {
          this.fetchNewFrame();
        }
        const currentTime = PrecisionDate.Now;
        this._current = currentTime - this._startMonitoringTime;
        if (newFrame) {
          this._fetchResult();
        }
      }
      endFrame() {
        this._fetchResult();
      }
      _fetchResult() {
        this._totalAccumulated += this._current;
        this._lastSecAccumulated += this._current;
        this._min = Math.min(this._min, this._current);
        this._max = Math.max(this._max, this._current);
        this._average = this._totalAccumulated / this._totalValueCount;
        const now = PrecisionDate.Now;
        if (now - this._lastSecTime > 1e3) {
          this._lastSecAverage = this._lastSecAccumulated / this._lastSecValueCount;
          this._lastSecTime = now;
          this._lastSecAccumulated = 0;
          this._lastSecValueCount = 0;
        }
      }
    };
    PerfCounter.Enabled = true;
  }
});

// node_modules/@babylonjs/core/Maths/math.plane.js
var Plane;
var init_math_plane = __esm({
  "node_modules/@babylonjs/core/Maths/math.plane.js"() {
    init_math_vector();
    Plane = class {
      constructor(a, b, c, d) {
        this.normal = new Vector3(a, b, c);
        this.d = d;
      }
      asArray() {
        return [this.normal.x, this.normal.y, this.normal.z, this.d];
      }
      clone() {
        return new Plane(this.normal.x, this.normal.y, this.normal.z, this.d);
      }
      getClassName() {
        return "Plane";
      }
      getHashCode() {
        let hash = this.normal.getHashCode();
        hash = hash * 397 ^ (this.d | 0);
        return hash;
      }
      normalize() {
        const norm = Math.sqrt(this.normal.x * this.normal.x + this.normal.y * this.normal.y + this.normal.z * this.normal.z);
        let magnitude = 0;
        if (norm !== 0) {
          magnitude = 1 / norm;
        }
        this.normal.x *= magnitude;
        this.normal.y *= magnitude;
        this.normal.z *= magnitude;
        this.d *= magnitude;
        return this;
      }
      transform(transformation) {
        const invertedMatrix = Plane._TmpMatrix;
        transformation.invertToRef(invertedMatrix);
        const m = invertedMatrix.m;
        const x = this.normal.x;
        const y = this.normal.y;
        const z = this.normal.z;
        const d = this.d;
        const normalX = x * m[0] + y * m[1] + z * m[2] + d * m[3];
        const normalY = x * m[4] + y * m[5] + z * m[6] + d * m[7];
        const normalZ = x * m[8] + y * m[9] + z * m[10] + d * m[11];
        const finalD = x * m[12] + y * m[13] + z * m[14] + d * m[15];
        return new Plane(normalX, normalY, normalZ, finalD);
      }
      dotCoordinate(point) {
        return this.normal.x * point.x + this.normal.y * point.y + this.normal.z * point.z + this.d;
      }
      copyFromPoints(point1, point2, point3) {
        const x1 = point2.x - point1.x;
        const y1 = point2.y - point1.y;
        const z1 = point2.z - point1.z;
        const x2 = point3.x - point1.x;
        const y2 = point3.y - point1.y;
        const z2 = point3.z - point1.z;
        const yz = y1 * z2 - z1 * y2;
        const xz = z1 * x2 - x1 * z2;
        const xy = x1 * y2 - y1 * x2;
        const pyth = Math.sqrt(yz * yz + xz * xz + xy * xy);
        let invPyth;
        if (pyth !== 0) {
          invPyth = 1 / pyth;
        } else {
          invPyth = 0;
        }
        this.normal.x = yz * invPyth;
        this.normal.y = xz * invPyth;
        this.normal.z = xy * invPyth;
        this.d = -(this.normal.x * point1.x + this.normal.y * point1.y + this.normal.z * point1.z);
        return this;
      }
      isFrontFacingTo(direction, epsilon) {
        const dot = Vector3.Dot(this.normal, direction);
        return dot <= epsilon;
      }
      signedDistanceTo(point) {
        return Vector3.Dot(point, this.normal) + this.d;
      }
      static FromArray(array) {
        return new Plane(array[0], array[1], array[2], array[3]);
      }
      static FromPoints(point1, point2, point3) {
        const result = new Plane(0, 0, 0, 0);
        result.copyFromPoints(point1, point2, point3);
        return result;
      }
      static FromPositionAndNormal(origin, normal) {
        const result = new Plane(0, 0, 0, 0);
        normal.normalize();
        result.normal = normal;
        result.d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
        return result;
      }
      static SignedDistanceToPlaneFromPositionAndNormal(origin, normal, point) {
        const d = -(normal.x * origin.x + normal.y * origin.y + normal.z * origin.z);
        return Vector3.Dot(point, normal) + d;
      }
    };
    Plane._TmpMatrix = Matrix.Identity();
  }
});

// node_modules/@babylonjs/core/Maths/math.frustum.js
var Frustum;
var init_math_frustum = __esm({
  "node_modules/@babylonjs/core/Maths/math.frustum.js"() {
    init_math_plane();
    Frustum = class {
      static GetPlanes(transform) {
        const frustumPlanes = [];
        for (let index = 0; index < 6; index++) {
          frustumPlanes.push(new Plane(0, 0, 0, 0));
        }
        Frustum.GetPlanesToRef(transform, frustumPlanes);
        return frustumPlanes;
      }
      static GetNearPlaneToRef(transform, frustumPlane) {
        const m = transform.m;
        frustumPlane.normal.x = m[3] + m[2];
        frustumPlane.normal.y = m[7] + m[6];
        frustumPlane.normal.z = m[11] + m[10];
        frustumPlane.d = m[15] + m[14];
        frustumPlane.normalize();
      }
      static GetFarPlaneToRef(transform, frustumPlane) {
        const m = transform.m;
        frustumPlane.normal.x = m[3] - m[2];
        frustumPlane.normal.y = m[7] - m[6];
        frustumPlane.normal.z = m[11] - m[10];
        frustumPlane.d = m[15] - m[14];
        frustumPlane.normalize();
      }
      static GetLeftPlaneToRef(transform, frustumPlane) {
        const m = transform.m;
        frustumPlane.normal.x = m[3] + m[0];
        frustumPlane.normal.y = m[7] + m[4];
        frustumPlane.normal.z = m[11] + m[8];
        frustumPlane.d = m[15] + m[12];
        frustumPlane.normalize();
      }
      static GetRightPlaneToRef(transform, frustumPlane) {
        const m = transform.m;
        frustumPlane.normal.x = m[3] - m[0];
        frustumPlane.normal.y = m[7] - m[4];
        frustumPlane.normal.z = m[11] - m[8];
        frustumPlane.d = m[15] - m[12];
        frustumPlane.normalize();
      }
      static GetTopPlaneToRef(transform, frustumPlane) {
        const m = transform.m;
        frustumPlane.normal.x = m[3] - m[1];
        frustumPlane.normal.y = m[7] - m[5];
        frustumPlane.normal.z = m[11] - m[9];
        frustumPlane.d = m[15] - m[13];
        frustumPlane.normalize();
      }
      static GetBottomPlaneToRef(transform, frustumPlane) {
        const m = transform.m;
        frustumPlane.normal.x = m[3] + m[1];
        frustumPlane.normal.y = m[7] + m[5];
        frustumPlane.normal.z = m[11] + m[9];
        frustumPlane.d = m[15] + m[13];
        frustumPlane.normalize();
      }
      static GetPlanesToRef(transform, frustumPlanes) {
        Frustum.GetNearPlaneToRef(transform, frustumPlanes[0]);
        Frustum.GetFarPlaneToRef(transform, frustumPlanes[1]);
        Frustum.GetLeftPlaneToRef(transform, frustumPlanes[2]);
        Frustum.GetRightPlaneToRef(transform, frustumPlanes[3]);
        Frustum.GetTopPlaneToRef(transform, frustumPlanes[4]);
        Frustum.GetBottomPlaneToRef(transform, frustumPlanes[5]);
      }
      static IsPointInFrustum(point, frustumPlanes) {
        for (let i = 0; i < 6; i++) {
          if (frustumPlanes[i].dotCoordinate(point) < 0) {
            return false;
          }
        }
        return true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js
var UniqueIdGenerator;
var init_uniqueIdGenerator = __esm({
  "node_modules/@babylonjs/core/Misc/uniqueIdGenerator.js"() {
    UniqueIdGenerator = class {
      static get UniqueId() {
        const result = this._UniqueIdCounter;
        this._UniqueIdCounter++;
        return result;
      }
    };
    UniqueIdGenerator._UniqueIdCounter = 1;
  }
});

// node_modules/@babylonjs/core/Lights/lightConstants.js
var LightConstants;
var init_lightConstants = __esm({
  "node_modules/@babylonjs/core/Lights/lightConstants.js"() {
    LightConstants = class {
      static CompareLightsPriority(a, b) {
        if (a.shadowEnabled !== b.shadowEnabled) {
          return (b.shadowEnabled ? 1 : 0) - (a.shadowEnabled ? 1 : 0);
        }
        return b.renderPriority - a.renderPriority;
      }
    };
    LightConstants.FALLOFF_DEFAULT = 0;
    LightConstants.FALLOFF_PHYSICAL = 1;
    LightConstants.FALLOFF_GLTF = 2;
    LightConstants.FALLOFF_STANDARD = 3;
    LightConstants.LIGHTMAP_DEFAULT = 0;
    LightConstants.LIGHTMAP_SPECULAR = 1;
    LightConstants.LIGHTMAP_SHADOWSONLY = 2;
    LightConstants.INTENSITYMODE_AUTOMATIC = 0;
    LightConstants.INTENSITYMODE_LUMINOUSPOWER = 1;
    LightConstants.INTENSITYMODE_LUMINOUSINTENSITY = 2;
    LightConstants.INTENSITYMODE_ILLUMINANCE = 3;
    LightConstants.INTENSITYMODE_LUMINANCE = 4;
    LightConstants.LIGHTTYPEID_POINTLIGHT = 0;
    LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT = 1;
    LightConstants.LIGHTTYPEID_SPOTLIGHT = 2;
    LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT = 3;
  }
});

// node_modules/@babylonjs/core/Inputs/pointerPickingConfiguration.js
var PointerPickingConfiguration;
var init_pointerPickingConfiguration = __esm({
  "node_modules/@babylonjs/core/Inputs/pointerPickingConfiguration.js"() {
    PointerPickingConfiguration = class {
      constructor() {
        this.pointerDownFastCheck = false;
        this.pointerUpFastCheck = false;
        this.pointerMoveFastCheck = false;
        this.skipPointerMovePicking = false;
        this.skipPointerDownPicking = false;
        this.skipPointerUpPicking = false;
      }
    };
  }
});

// node_modules/@babylonjs/core/scene.js
var ScenePerformancePriority, Scene;
var init_scene = __esm({
  "node_modules/@babylonjs/core/scene.js"() {
    init_tools();
    init_precisionDate();
    init_observable();
    init_smartArray();
    init_stringDictionary();
    init_tags();
    init_math_vector();
    init_abstractScene();
    init_imageProcessingConfiguration();
    init_uniformBuffer();
    init_pickingInfo();
    init_actionEvent();
    init_postProcessManager();
    init_renderingManager();
    init_sceneComponent();
    init_domManagement();
    init_engineStore();
    init_devTools();
    init_scene_inputManager();
    init_perfCounter();
    init_math_color();
    init_math_frustum();
    init_uniqueIdGenerator();
    init_fileTools();
    init_lightConstants();
    init_arrayTools();
    init_pointerPickingConfiguration();
    (function(ScenePerformancePriority2) {
      ScenePerformancePriority2[ScenePerformancePriority2["BackwardCompatible"] = 0] = "BackwardCompatible";
      ScenePerformancePriority2[ScenePerformancePriority2["Intermediate"] = 1] = "Intermediate";
      ScenePerformancePriority2[ScenePerformancePriority2["Aggressive"] = 2] = "Aggressive";
    })(ScenePerformancePriority || (ScenePerformancePriority = {}));
    Scene = class extends AbstractScene {
      static DefaultMaterialFactory(scene) {
        throw _WarnImport("StandardMaterial");
      }
      static CollisionCoordinatorFactory() {
        throw _WarnImport("DefaultCollisionCoordinator");
      }
      get environmentTexture() {
        return this._environmentTexture;
      }
      set environmentTexture(value) {
        if (this._environmentTexture === value) {
          return;
        }
        this._environmentTexture = value;
        this.markAllMaterialsAsDirty(1);
      }
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      get performancePriority() {
        return this._performancePriority;
      }
      set performancePriority(value) {
        if (value === this._performancePriority) {
          return;
        }
        this._performancePriority = value;
        switch (value) {
          case ScenePerformancePriority.BackwardCompatible:
            this.skipFrustumClipping = false;
            this._renderingManager.maintainStateBetweenFrames = false;
            this.skipPointerMovePicking = false;
            this.autoClear = true;
            break;
          case ScenePerformancePriority.Intermediate:
            this.skipFrustumClipping = false;
            this._renderingManager.maintainStateBetweenFrames = false;
            this.skipPointerMovePicking = true;
            this.autoClear = false;
            break;
          case ScenePerformancePriority.Aggressive:
            this.skipFrustumClipping = true;
            this._renderingManager.maintainStateBetweenFrames = true;
            this.skipPointerMovePicking = true;
            this.autoClear = false;
            break;
        }
        this.onScenePerformancePriorityChangedObservable.notifyObservers(value);
      }
      set forceWireframe(value) {
        if (this._forceWireframe === value) {
          return;
        }
        this._forceWireframe = value;
        this.markAllMaterialsAsDirty(16);
      }
      get forceWireframe() {
        return this._forceWireframe;
      }
      set skipFrustumClipping(value) {
        if (this._skipFrustumClipping === value) {
          return;
        }
        this._skipFrustumClipping = value;
      }
      get skipFrustumClipping() {
        return this._skipFrustumClipping;
      }
      set forcePointsCloud(value) {
        if (this._forcePointsCloud === value) {
          return;
        }
        this._forcePointsCloud = value;
        this.markAllMaterialsAsDirty(16);
      }
      get forcePointsCloud() {
        return this._forcePointsCloud;
      }
      get animationPropertiesOverride() {
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      set beforeRender(callback) {
        if (this._onBeforeRenderObserver) {
          this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        if (callback) {
          this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
        }
      }
      set afterRender(callback) {
        if (this._onAfterRenderObserver) {
          this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        if (callback) {
          this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
        }
      }
      set beforeCameraRender(callback) {
        if (this._onBeforeCameraRenderObserver) {
          this.onBeforeCameraRenderObservable.remove(this._onBeforeCameraRenderObserver);
        }
        this._onBeforeCameraRenderObserver = this.onBeforeCameraRenderObservable.add(callback);
      }
      set afterCameraRender(callback) {
        if (this._onAfterCameraRenderObserver) {
          this.onAfterCameraRenderObservable.remove(this._onAfterCameraRenderObserver);
        }
        this._onAfterCameraRenderObserver = this.onAfterCameraRenderObservable.add(callback);
      }
      get pointerDownPredicate() {
        return this._pointerPickingConfiguration.pointerDownPredicate;
      }
      set pointerDownPredicate(value) {
        this._pointerPickingConfiguration.pointerDownPredicate = value;
      }
      get pointerUpPredicate() {
        return this._pointerPickingConfiguration.pointerUpPredicate;
      }
      set pointerUpPredicate(value) {
        this._pointerPickingConfiguration.pointerUpPredicate = value;
      }
      get pointerMovePredicate() {
        return this._pointerPickingConfiguration.pointerMovePredicate;
      }
      set pointerMovePredicate(value) {
        this._pointerPickingConfiguration.pointerMovePredicate = value;
      }
      get pointerDownFastCheck() {
        return this._pointerPickingConfiguration.pointerDownFastCheck;
      }
      set pointerDownFastCheck(value) {
        this._pointerPickingConfiguration.pointerDownFastCheck = value;
      }
      get pointerUpFastCheck() {
        return this._pointerPickingConfiguration.pointerUpFastCheck;
      }
      set pointerUpFastCheck(value) {
        this._pointerPickingConfiguration.pointerUpFastCheck = value;
      }
      get pointerMoveFastCheck() {
        return this._pointerPickingConfiguration.pointerMoveFastCheck;
      }
      set pointerMoveFastCheck(value) {
        this._pointerPickingConfiguration.pointerMoveFastCheck = value;
      }
      get skipPointerMovePicking() {
        return this._pointerPickingConfiguration.skipPointerMovePicking;
      }
      set skipPointerMovePicking(value) {
        this._pointerPickingConfiguration.skipPointerMovePicking = value;
      }
      get skipPointerDownPicking() {
        return this._pointerPickingConfiguration.skipPointerDownPicking;
      }
      set skipPointerDownPicking(value) {
        this._pointerPickingConfiguration.skipPointerDownPicking = value;
      }
      get skipPointerUpPicking() {
        return this._pointerPickingConfiguration.skipPointerUpPicking;
      }
      set skipPointerUpPicking(value) {
        this._pointerPickingConfiguration.skipPointerUpPicking = value;
      }
      get unTranslatedPointer() {
        return this._inputManager.unTranslatedPointer;
      }
      static get DragMovementThreshold() {
        return InputManager.DragMovementThreshold;
      }
      static set DragMovementThreshold(value) {
        InputManager.DragMovementThreshold = value;
      }
      static get LongPressDelay() {
        return InputManager.LongPressDelay;
      }
      static set LongPressDelay(value) {
        InputManager.LongPressDelay = value;
      }
      static get DoubleClickDelay() {
        return InputManager.DoubleClickDelay;
      }
      static set DoubleClickDelay(value) {
        InputManager.DoubleClickDelay = value;
      }
      static get ExclusiveDoubleClickMode() {
        return InputManager.ExclusiveDoubleClickMode;
      }
      static set ExclusiveDoubleClickMode(value) {
        InputManager.ExclusiveDoubleClickMode = value;
      }
      bindEyePosition(effect, variableName = "vEyePosition", isVector3 = false) {
        var _a;
        const eyePosition = this._forcedViewPosition ? this._forcedViewPosition : this._mirroredCameraPosition ? this._mirroredCameraPosition : (_a = this.activeCamera.globalPosition) !== null && _a !== void 0 ? _a : this.activeCamera.devicePosition;
        const invertNormal = this.useRightHandedSystem === (this._mirroredCameraPosition != null);
        TmpVectors.Vector4[0].set(eyePosition.x, eyePosition.y, eyePosition.z, invertNormal ? -1 : 1);
        if (effect) {
          if (isVector3) {
            effect.setFloat3(variableName, TmpVectors.Vector4[0].x, TmpVectors.Vector4[0].y, TmpVectors.Vector4[0].z);
          } else {
            effect.setVector4(variableName, TmpVectors.Vector4[0]);
          }
        }
        return TmpVectors.Vector4[0];
      }
      finalizeSceneUbo() {
        const ubo = this.getSceneUniformBuffer();
        const eyePosition = this.bindEyePosition(null);
        ubo.updateFloat4("vEyePosition", eyePosition.x, eyePosition.y, eyePosition.z, eyePosition.w);
        ubo.update();
        return ubo;
      }
      set useRightHandedSystem(value) {
        if (this._useRightHandedSystem === value) {
          return;
        }
        this._useRightHandedSystem = value;
        this.markAllMaterialsAsDirty(16);
      }
      get useRightHandedSystem() {
        return this._useRightHandedSystem;
      }
      setStepId(newStepId) {
        this._currentStepId = newStepId;
      }
      getStepId() {
        return this._currentStepId;
      }
      getInternalStep() {
        return this._currentInternalStep;
      }
      set fogEnabled(value) {
        if (this._fogEnabled === value) {
          return;
        }
        this._fogEnabled = value;
        this.markAllMaterialsAsDirty(16);
      }
      get fogEnabled() {
        return this._fogEnabled;
      }
      set fogMode(value) {
        if (this._fogMode === value) {
          return;
        }
        this._fogMode = value;
        this.markAllMaterialsAsDirty(16);
      }
      get fogMode() {
        return this._fogMode;
      }
      get prePass() {
        return !!this.prePassRenderer && this.prePassRenderer.defaultRT.enabled;
      }
      set shadowsEnabled(value) {
        if (this._shadowsEnabled === value) {
          return;
        }
        this._shadowsEnabled = value;
        this.markAllMaterialsAsDirty(2);
      }
      get shadowsEnabled() {
        return this._shadowsEnabled;
      }
      set lightsEnabled(value) {
        if (this._lightsEnabled === value) {
          return;
        }
        this._lightsEnabled = value;
        this.markAllMaterialsAsDirty(2);
      }
      get lightsEnabled() {
        return this._lightsEnabled;
      }
      get activeCameras() {
        return this._activeCameras;
      }
      set activeCameras(cameras) {
        if (this._unObserveActiveCameras) {
          this._unObserveActiveCameras();
          this._unObserveActiveCameras = null;
        }
        if (cameras) {
          this._unObserveActiveCameras = _ObserveArray(cameras, () => {
            this.onActiveCamerasChanged.notifyObservers(this);
          });
        }
        this._activeCameras = cameras;
      }
      get activeCamera() {
        return this._activeCamera;
      }
      set activeCamera(value) {
        if (value === this._activeCamera) {
          return;
        }
        this._activeCamera = value;
        this.onActiveCameraChanged.notifyObservers(this);
      }
      get defaultMaterial() {
        if (!this._defaultMaterial) {
          this._defaultMaterial = Scene.DefaultMaterialFactory(this);
        }
        return this._defaultMaterial;
      }
      set defaultMaterial(value) {
        this._defaultMaterial = value;
      }
      set texturesEnabled(value) {
        if (this._texturesEnabled === value) {
          return;
        }
        this._texturesEnabled = value;
        this.markAllMaterialsAsDirty(1);
      }
      get texturesEnabled() {
        return this._texturesEnabled;
      }
      set skeletonsEnabled(value) {
        if (this._skeletonsEnabled === value) {
          return;
        }
        this._skeletonsEnabled = value;
        this.markAllMaterialsAsDirty(8);
      }
      get skeletonsEnabled() {
        return this._skeletonsEnabled;
      }
      get collisionCoordinator() {
        if (!this._collisionCoordinator) {
          this._collisionCoordinator = Scene.CollisionCoordinatorFactory();
          this._collisionCoordinator.init(this);
        }
        return this._collisionCoordinator;
      }
      get renderingManager() {
        return this._renderingManager;
      }
      get frustumPlanes() {
        return this._frustumPlanes;
      }
      _registerTransientComponents() {
        if (this._transientComponents.length > 0) {
          for (const component of this._transientComponents) {
            component.register();
          }
          this._transientComponents.length = 0;
        }
      }
      _addComponent(component) {
        this._components.push(component);
        this._transientComponents.push(component);
        const serializableComponent = component;
        if (serializableComponent.addFromContainer && serializableComponent.serialize) {
          this._serializableComponents.push(serializableComponent);
        }
      }
      _getComponent(name) {
        for (const component of this._components) {
          if (component.name === name) {
            return component;
          }
        }
        return null;
      }
      constructor(engine, options) {
        super();
        this._inputManager = new InputManager(this);
        this.cameraToUseForPointers = null;
        this._isScene = true;
        this._blockEntityCollection = false;
        this.autoClear = true;
        this.autoClearDepthAndStencil = true;
        this.clearColor = new Color4(0.2, 0.2, 0.3, 1);
        this.ambientColor = new Color3(0, 0, 0);
        this.environmentIntensity = 1;
        this._performancePriority = ScenePerformancePriority.BackwardCompatible;
        this.onScenePerformancePriorityChangedObservable = new Observable();
        this._forceWireframe = false;
        this._skipFrustumClipping = false;
        this._forcePointsCloud = false;
        this.animationsEnabled = true;
        this._animationPropertiesOverride = null;
        this.useConstantAnimationDeltaTime = false;
        this.constantlyUpdateMeshUnderPointer = false;
        this.hoverCursor = "pointer";
        this.defaultCursor = "";
        this.doNotHandleCursors = false;
        this.preventDefaultOnPointerDown = true;
        this.preventDefaultOnPointerUp = true;
        this.metadata = null;
        this.reservedDataStore = null;
        this.disableOfflineSupportExceptionRules = new Array();
        this.onDisposeObservable = new Observable();
        this._onDisposeObserver = null;
        this.onBeforeRenderObservable = new Observable();
        this._onBeforeRenderObserver = null;
        this.onAfterRenderObservable = new Observable();
        this.onAfterRenderCameraObservable = new Observable();
        this._onAfterRenderObserver = null;
        this.onBeforeAnimationsObservable = new Observable();
        this.onAfterAnimationsObservable = new Observable();
        this.onBeforeDrawPhaseObservable = new Observable();
        this.onAfterDrawPhaseObservable = new Observable();
        this.onReadyObservable = new Observable();
        this.onBeforeCameraRenderObservable = new Observable();
        this._onBeforeCameraRenderObserver = null;
        this.onAfterCameraRenderObservable = new Observable();
        this._onAfterCameraRenderObserver = null;
        this.onBeforeActiveMeshesEvaluationObservable = new Observable();
        this.onAfterActiveMeshesEvaluationObservable = new Observable();
        this.onBeforeParticlesRenderingObservable = new Observable();
        this.onAfterParticlesRenderingObservable = new Observable();
        this.onDataLoadedObservable = new Observable();
        this.onNewCameraAddedObservable = new Observable();
        this.onCameraRemovedObservable = new Observable();
        this.onNewLightAddedObservable = new Observable();
        this.onLightRemovedObservable = new Observable();
        this.onNewGeometryAddedObservable = new Observable();
        this.onGeometryRemovedObservable = new Observable();
        this.onNewTransformNodeAddedObservable = new Observable();
        this.onTransformNodeRemovedObservable = new Observable();
        this.onNewMeshAddedObservable = new Observable();
        this.onMeshRemovedObservable = new Observable();
        this.onNewSkeletonAddedObservable = new Observable();
        this.onSkeletonRemovedObservable = new Observable();
        this.onNewMaterialAddedObservable = new Observable();
        this.onNewMultiMaterialAddedObservable = new Observable();
        this.onMaterialRemovedObservable = new Observable();
        this.onMultiMaterialRemovedObservable = new Observable();
        this.onNewTextureAddedObservable = new Observable();
        this.onTextureRemovedObservable = new Observable();
        this.onBeforeRenderTargetsRenderObservable = new Observable();
        this.onAfterRenderTargetsRenderObservable = new Observable();
        this.onBeforeStepObservable = new Observable();
        this.onAfterStepObservable = new Observable();
        this.onActiveCameraChanged = new Observable();
        this.onActiveCamerasChanged = new Observable();
        this.onBeforeRenderingGroupObservable = new Observable();
        this.onAfterRenderingGroupObservable = new Observable();
        this.onMeshImportedObservable = new Observable();
        this.onAnimationFileImportedObservable = new Observable();
        this._registeredForLateAnimationBindings = new SmartArrayNoDuplicate(256);
        this._pointerPickingConfiguration = new PointerPickingConfiguration();
        this.onPrePointerObservable = new Observable();
        this.onPointerObservable = new Observable();
        this.onPreKeyboardObservable = new Observable();
        this.onKeyboardObservable = new Observable();
        this._useRightHandedSystem = false;
        this._timeAccumulator = 0;
        this._currentStepId = 0;
        this._currentInternalStep = 0;
        this._fogEnabled = true;
        this._fogMode = Scene.FOGMODE_NONE;
        this.fogColor = new Color3(0.2, 0.2, 0.3);
        this.fogDensity = 0.1;
        this.fogStart = 0;
        this.fogEnd = 1e3;
        this.needsPreviousWorldMatrices = false;
        this._shadowsEnabled = true;
        this._lightsEnabled = true;
        this._unObserveActiveCameras = null;
        this._texturesEnabled = true;
        this.physicsEnabled = true;
        this.particlesEnabled = true;
        this.spritesEnabled = true;
        this._skeletonsEnabled = true;
        this.lensFlaresEnabled = true;
        this.collisionsEnabled = true;
        this.gravity = new Vector3(0, -9.807, 0);
        this.postProcessesEnabled = true;
        this.renderTargetsEnabled = true;
        this.dumpNextRenderTargets = false;
        this.customRenderTargets = new Array();
        this.importedMeshesFiles = new Array();
        this.probesEnabled = true;
        this._meshesForIntersections = new SmartArrayNoDuplicate(256);
        this.proceduralTexturesEnabled = true;
        this._totalVertices = new PerfCounter();
        this._activeIndices = new PerfCounter();
        this._activeParticles = new PerfCounter();
        this._activeBones = new PerfCounter();
        this._animationTime = 0;
        this.animationTimeScale = 1;
        this._renderId = 0;
        this._frameId = 0;
        this._executeWhenReadyTimeoutId = null;
        this._intermediateRendering = false;
        this._defaultFrameBufferCleared = false;
        this._viewUpdateFlag = -1;
        this._projectionUpdateFlag = -1;
        this._toBeDisposed = new Array(256);
        this._activeRequests = new Array();
        this._pendingData = new Array();
        this._isDisposed = false;
        this.dispatchAllSubMeshesOfActiveMeshes = false;
        this._activeMeshes = new SmartArray(256);
        this._processedMaterials = new SmartArray(256);
        this._renderTargets = new SmartArrayNoDuplicate(256);
        this._materialsRenderTargets = new SmartArrayNoDuplicate(256);
        this._activeParticleSystems = new SmartArray(256);
        this._activeSkeletons = new SmartArrayNoDuplicate(32);
        this._softwareSkinnedMeshes = new SmartArrayNoDuplicate(32);
        this._activeAnimatables = new Array();
        this._transformMatrix = Matrix.Zero();
        this.requireLightSorting = false;
        this._components = [];
        this._serializableComponents = [];
        this._transientComponents = [];
        this._beforeCameraUpdateStage = Stage.Create();
        this._beforeClearStage = Stage.Create();
        this._beforeRenderTargetClearStage = Stage.Create();
        this._gatherRenderTargetsStage = Stage.Create();
        this._gatherActiveCameraRenderTargetsStage = Stage.Create();
        this._isReadyForMeshStage = Stage.Create();
        this._beforeEvaluateActiveMeshStage = Stage.Create();
        this._evaluateSubMeshStage = Stage.Create();
        this._preActiveMeshStage = Stage.Create();
        this._cameraDrawRenderTargetStage = Stage.Create();
        this._beforeCameraDrawStage = Stage.Create();
        this._beforeRenderTargetDrawStage = Stage.Create();
        this._beforeRenderingGroupDrawStage = Stage.Create();
        this._beforeRenderingMeshStage = Stage.Create();
        this._afterRenderingMeshStage = Stage.Create();
        this._afterRenderingGroupDrawStage = Stage.Create();
        this._afterCameraDrawStage = Stage.Create();
        this._afterCameraPostProcessStage = Stage.Create();
        this._afterRenderTargetDrawStage = Stage.Create();
        this._afterRenderTargetPostProcessStage = Stage.Create();
        this._afterRenderStage = Stage.Create();
        this._pointerMoveStage = Stage.Create();
        this._pointerDownStage = Stage.Create();
        this._pointerUpStage = Stage.Create();
        this._geometriesByUniqueId = null;
        this._defaultMeshCandidates = {
          data: [],
          length: 0
        };
        this._defaultSubMeshCandidates = {
          data: [],
          length: 0
        };
        this._preventFreeActiveMeshesAndRenderingGroups = false;
        this._activeMeshesFrozen = false;
        this._activeMeshesFrozenButKeepClipping = false;
        this._skipEvaluateActiveMeshesCompletely = false;
        this._allowPostProcessClearColor = true;
        this.getDeterministicFrameTime = () => {
          return this._engine.getTimeStep();
        };
        this._registeredActions = 0;
        this._blockMaterialDirtyMechanism = false;
        this._perfCollector = null;
        this.activeCameras = new Array();
        const fullOptions = Object.assign({ useGeometryUniqueIdsMap: true, useMaterialMeshMap: true, useClonedMeshMap: true, virtual: false }, options);
        this._engine = engine || EngineStore.LastCreatedEngine;
        if (!fullOptions.virtual) {
          EngineStore._LastCreatedScene = this;
          this._engine.scenes.push(this);
        } else {
          this._engine._virtualScenes.push(this);
        }
        this._uid = null;
        this._renderingManager = new RenderingManager(this);
        if (PostProcessManager) {
          this.postProcessManager = new PostProcessManager(this);
        }
        if (IsWindowObjectExist()) {
          this.attachControl();
        }
        this._createUbo();
        if (ImageProcessingConfiguration) {
          this._imageProcessingConfiguration = new ImageProcessingConfiguration();
        }
        this.setDefaultCandidateProviders();
        if (fullOptions.useGeometryUniqueIdsMap) {
          this._geometriesByUniqueId = {};
        }
        this.useMaterialMeshMap = fullOptions.useMaterialMeshMap;
        this.useClonedMeshMap = fullOptions.useClonedMeshMap;
        if (!options || !options.virtual) {
          this._engine.onNewSceneAddedObservable.notifyObservers(this);
        }
      }
      getClassName() {
        return "Scene";
      }
      _getDefaultMeshCandidates() {
        this._defaultMeshCandidates.data = this.meshes;
        this._defaultMeshCandidates.length = this.meshes.length;
        return this._defaultMeshCandidates;
      }
      _getDefaultSubMeshCandidates(mesh) {
        this._defaultSubMeshCandidates.data = mesh.subMeshes;
        this._defaultSubMeshCandidates.length = mesh.subMeshes.length;
        return this._defaultSubMeshCandidates;
      }
      setDefaultCandidateProviders() {
        this.getActiveMeshCandidates = this._getDefaultMeshCandidates.bind(this);
        this.getActiveSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
        this.getIntersectingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
        this.getCollidingSubMeshCandidates = this._getDefaultSubMeshCandidates.bind(this);
      }
      get meshUnderPointer() {
        return this._inputManager.meshUnderPointer;
      }
      get pointerX() {
        return this._inputManager.pointerX;
      }
      set pointerX(value) {
        this._inputManager.pointerX = value;
      }
      get pointerY() {
        return this._inputManager.pointerY;
      }
      set pointerY(value) {
        this._inputManager.pointerY = value;
      }
      getCachedMaterial() {
        return this._cachedMaterial;
      }
      getCachedEffect() {
        return this._cachedEffect;
      }
      getCachedVisibility() {
        return this._cachedVisibility;
      }
      isCachedMaterialInvalid(material, effect, visibility = 1) {
        return this._cachedEffect !== effect || this._cachedMaterial !== material || this._cachedVisibility !== visibility;
      }
      getEngine() {
        return this._engine;
      }
      getTotalVertices() {
        return this._totalVertices.current;
      }
      get totalVerticesPerfCounter() {
        return this._totalVertices;
      }
      getActiveIndices() {
        return this._activeIndices.current;
      }
      get totalActiveIndicesPerfCounter() {
        return this._activeIndices;
      }
      getActiveParticles() {
        return this._activeParticles.current;
      }
      get activeParticlesPerfCounter() {
        return this._activeParticles;
      }
      getActiveBones() {
        return this._activeBones.current;
      }
      get activeBonesPerfCounter() {
        return this._activeBones;
      }
      getActiveMeshes() {
        return this._activeMeshes;
      }
      getAnimationRatio() {
        return this._animationRatio !== void 0 ? this._animationRatio : 1;
      }
      getRenderId() {
        return this._renderId;
      }
      getFrameId() {
        return this._frameId;
      }
      incrementRenderId() {
        this._renderId++;
      }
      _createUbo() {
        this.setSceneUniformBuffer(this.createSceneUniformBuffer());
      }
      simulatePointerMove(pickResult, pointerEventInit) {
        this._inputManager.simulatePointerMove(pickResult, pointerEventInit);
        return this;
      }
      simulatePointerDown(pickResult, pointerEventInit) {
        this._inputManager.simulatePointerDown(pickResult, pointerEventInit);
        return this;
      }
      simulatePointerUp(pickResult, pointerEventInit, doubleTap) {
        this._inputManager.simulatePointerUp(pickResult, pointerEventInit, doubleTap);
        return this;
      }
      isPointerCaptured(pointerId = 0) {
        return this._inputManager.isPointerCaptured(pointerId);
      }
      attachControl(attachUp = true, attachDown = true, attachMove = true) {
        this._inputManager.attachControl(attachUp, attachDown, attachMove);
      }
      detachControl() {
        this._inputManager.detachControl();
      }
      isReady(checkRenderTargets = true) {
        var _a, _b, _c;
        if (this._isDisposed) {
          return false;
        }
        let index;
        const engine = this.getEngine();
        const currentRenderPassId = engine.currentRenderPassId;
        engine.currentRenderPassId = (_b = (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : currentRenderPassId;
        let isReady = true;
        if (this._pendingData.length > 0) {
          isReady = false;
        }
        (_c = this.prePassRenderer) === null || _c === void 0 ? void 0 : _c.update();
        if (checkRenderTargets) {
          this._processedMaterials.reset();
          this._materialsRenderTargets.reset();
        }
        for (index = 0; index < this.meshes.length; index++) {
          const mesh = this.meshes[index];
          if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
            continue;
          }
          if (!mesh.isReady(true)) {
            isReady = false;
            continue;
          }
          const hardwareInstancedRendering = mesh.hasThinInstances || mesh.getClassName() === "InstancedMesh" || mesh.getClassName() === "InstancedLinesMesh" || engine.getCaps().instancedArrays && mesh.instances.length > 0;
          for (const step of this._isReadyForMeshStage) {
            if (!step.action(mesh, hardwareInstancedRendering)) {
              isReady = false;
            }
          }
          if (!checkRenderTargets) {
            continue;
          }
          const mat = mesh.material || this.defaultMaterial;
          if (mat) {
            if (mat._storeEffectOnSubMeshes) {
              for (const subMesh of mesh.subMeshes) {
                const material = subMesh.getMaterial();
                if (material && material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
                  if (this._processedMaterials.indexOf(material) === -1) {
                    this._processedMaterials.push(material);
                    this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
                  }
                }
              }
            } else {
              if (mat.hasRenderTargetTextures && mat.getRenderTargetTextures != null) {
                if (this._processedMaterials.indexOf(mat) === -1) {
                  this._processedMaterials.push(mat);
                  this._materialsRenderTargets.concatWithNoDuplicate(mat.getRenderTargetTextures());
                }
              }
            }
          }
        }
        if (checkRenderTargets) {
          for (index = 0; index < this._materialsRenderTargets.length; ++index) {
            const rtt = this._materialsRenderTargets.data[index];
            if (!rtt.isReadyForRendering()) {
              isReady = false;
            }
          }
        }
        for (index = 0; index < this.geometries.length; index++) {
          const geometry = this.geometries[index];
          if (geometry.delayLoadState === 2) {
            isReady = false;
          }
        }
        if (this.activeCameras && this.activeCameras.length > 0) {
          for (const camera of this.activeCameras) {
            if (!camera.isReady(true)) {
              isReady = false;
            }
          }
        } else if (this.activeCamera) {
          if (!this.activeCamera.isReady(true)) {
            isReady = false;
          }
        }
        for (const particleSystem of this.particleSystems) {
          if (!particleSystem.isReady()) {
            isReady = false;
          }
        }
        if (this.layers) {
          for (const layer of this.layers) {
            if (!layer.isReady()) {
              isReady = false;
            }
          }
        }
        if (!engine.areAllEffectsReady()) {
          isReady = false;
        }
        engine.currentRenderPassId = currentRenderPassId;
        return isReady;
      }
      resetCachedMaterial() {
        this._cachedMaterial = null;
        this._cachedEffect = null;
        this._cachedVisibility = null;
      }
      registerBeforeRender(func) {
        this.onBeforeRenderObservable.add(func);
      }
      unregisterBeforeRender(func) {
        this.onBeforeRenderObservable.removeCallback(func);
      }
      registerAfterRender(func) {
        this.onAfterRenderObservable.add(func);
      }
      unregisterAfterRender(func) {
        this.onAfterRenderObservable.removeCallback(func);
      }
      _executeOnceBeforeRender(func) {
        const execFunc = () => {
          func();
          setTimeout(() => {
            this.unregisterBeforeRender(execFunc);
          });
        };
        this.registerBeforeRender(execFunc);
      }
      executeOnceBeforeRender(func, timeout) {
        if (timeout !== void 0) {
          setTimeout(() => {
            this._executeOnceBeforeRender(func);
          }, timeout);
        } else {
          this._executeOnceBeforeRender(func);
        }
      }
      addPendingData(data) {
        this._pendingData.push(data);
      }
      removePendingData(data) {
        const wasLoading = this.isLoading;
        const index = this._pendingData.indexOf(data);
        if (index !== -1) {
          this._pendingData.splice(index, 1);
        }
        if (wasLoading && !this.isLoading) {
          this.onDataLoadedObservable.notifyObservers(this);
        }
      }
      getWaitingItemsCount() {
        return this._pendingData.length;
      }
      get isLoading() {
        return this._pendingData.length > 0;
      }
      executeWhenReady(func, checkRenderTargets = false) {
        this.onReadyObservable.addOnce(func);
        if (this._executeWhenReadyTimeoutId !== null) {
          return;
        }
        this._checkIsReady(checkRenderTargets);
      }
      whenReadyAsync(checkRenderTargets = false) {
        return new Promise((resolve) => {
          this.executeWhenReady(() => {
            resolve();
          }, checkRenderTargets);
        });
      }
      _checkIsReady(checkRenderTargets = false) {
        this._registerTransientComponents();
        if (this.isReady(checkRenderTargets)) {
          this.onReadyObservable.notifyObservers(this);
          this.onReadyObservable.clear();
          this._executeWhenReadyTimeoutId = null;
          return;
        }
        if (this._isDisposed) {
          this.onReadyObservable.clear();
          this._executeWhenReadyTimeoutId = null;
          return;
        }
        this._executeWhenReadyTimeoutId = setTimeout(() => {
          this.incrementRenderId();
          this._checkIsReady(checkRenderTargets);
        }, 100);
      }
      get animatables() {
        return this._activeAnimatables;
      }
      resetLastAnimationTimeFrame() {
        this._animationTimeLast = PrecisionDate.Now;
      }
      getViewMatrix() {
        return this._viewMatrix;
      }
      getProjectionMatrix() {
        return this._projectionMatrix;
      }
      getTransformMatrix() {
        return this._transformMatrix;
      }
      setTransformMatrix(viewL, projectionL, viewR, projectionR) {
        if (!viewR && !projectionR && this._multiviewSceneUbo) {
          this._multiviewSceneUbo.dispose();
          this._multiviewSceneUbo = null;
        }
        if (this._viewUpdateFlag === viewL.updateFlag && this._projectionUpdateFlag === projectionL.updateFlag) {
          return;
        }
        this._viewUpdateFlag = viewL.updateFlag;
        this._projectionUpdateFlag = projectionL.updateFlag;
        this._viewMatrix = viewL;
        this._projectionMatrix = projectionL;
        this._viewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        if (!this._frustumPlanes) {
          this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
        } else {
          Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
        }
        if (this._multiviewSceneUbo && this._multiviewSceneUbo.useUbo) {
          this._updateMultiviewUbo(viewR, projectionR);
        } else if (this._sceneUbo.useUbo) {
          this._sceneUbo.updateMatrix("viewProjection", this._transformMatrix);
          this._sceneUbo.updateMatrix("view", this._viewMatrix);
          this._sceneUbo.updateMatrix("projection", this._projectionMatrix);
        }
      }
      getSceneUniformBuffer() {
        return this._multiviewSceneUbo ? this._multiviewSceneUbo : this._sceneUbo;
      }
      createSceneUniformBuffer(name) {
        const sceneUbo = new UniformBuffer(this._engine, void 0, false, name !== null && name !== void 0 ? name : "scene");
        sceneUbo.addUniform("viewProjection", 16);
        sceneUbo.addUniform("view", 16);
        sceneUbo.addUniform("projection", 16);
        sceneUbo.addUniform("vEyePosition", 4);
        return sceneUbo;
      }
      setSceneUniformBuffer(ubo) {
        this._sceneUbo = ubo;
        this._viewUpdateFlag = -1;
        this._projectionUpdateFlag = -1;
      }
      getUniqueId() {
        return UniqueIdGenerator.UniqueId;
      }
      addMesh(newMesh, recursive = false) {
        if (this._blockEntityCollection) {
          return;
        }
        this.meshes.push(newMesh);
        newMesh._resyncLightSources();
        if (!newMesh.parent) {
          newMesh._addToSceneRootNodes();
        }
        this.onNewMeshAddedObservable.notifyObservers(newMesh);
        if (recursive) {
          newMesh.getChildMeshes().forEach((m) => {
            this.addMesh(m);
          });
        }
      }
      removeMesh(toRemove, recursive = false) {
        const index = this.meshes.indexOf(toRemove);
        if (index !== -1) {
          this.meshes[index] = this.meshes[this.meshes.length - 1];
          this.meshes.pop();
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        this._inputManager._invalidateMesh(toRemove);
        this.onMeshRemovedObservable.notifyObservers(toRemove);
        if (recursive) {
          toRemove.getChildMeshes().forEach((m) => {
            this.removeMesh(m);
          });
        }
        return index;
      }
      addTransformNode(newTransformNode) {
        if (this._blockEntityCollection) {
          return;
        }
        if (newTransformNode.getScene() === this && newTransformNode._indexInSceneTransformNodesArray !== -1) {
          return;
        }
        newTransformNode._indexInSceneTransformNodesArray = this.transformNodes.length;
        this.transformNodes.push(newTransformNode);
        if (!newTransformNode.parent) {
          newTransformNode._addToSceneRootNodes();
        }
        this.onNewTransformNodeAddedObservable.notifyObservers(newTransformNode);
      }
      removeTransformNode(toRemove) {
        const index = toRemove._indexInSceneTransformNodesArray;
        if (index !== -1) {
          if (index !== this.transformNodes.length - 1) {
            const lastNode = this.transformNodes[this.transformNodes.length - 1];
            this.transformNodes[index] = lastNode;
            lastNode._indexInSceneTransformNodesArray = index;
          }
          toRemove._indexInSceneTransformNodesArray = -1;
          this.transformNodes.pop();
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        this.onTransformNodeRemovedObservable.notifyObservers(toRemove);
        return index;
      }
      removeSkeleton(toRemove) {
        const index = this.skeletons.indexOf(toRemove);
        if (index !== -1) {
          this.skeletons.splice(index, 1);
          this.onSkeletonRemovedObservable.notifyObservers(toRemove);
          this._executeActiveContainerCleanup(this._activeSkeletons);
        }
        return index;
      }
      removeMorphTargetManager(toRemove) {
        const index = this.morphTargetManagers.indexOf(toRemove);
        if (index !== -1) {
          this.morphTargetManagers.splice(index, 1);
        }
        return index;
      }
      removeLight(toRemove) {
        const index = this.lights.indexOf(toRemove);
        if (index !== -1) {
          for (const mesh of this.meshes) {
            mesh._removeLightSource(toRemove, false);
          }
          this.lights.splice(index, 1);
          this.sortLightsByPriority();
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        this.onLightRemovedObservable.notifyObservers(toRemove);
        return index;
      }
      removeCamera(toRemove) {
        const index = this.cameras.indexOf(toRemove);
        if (index !== -1) {
          this.cameras.splice(index, 1);
          if (!toRemove.parent) {
            toRemove._removeFromSceneRootNodes();
          }
        }
        if (this.activeCameras) {
          const index2 = this.activeCameras.indexOf(toRemove);
          if (index2 !== -1) {
            this.activeCameras.splice(index2, 1);
          }
        }
        if (this.activeCamera === toRemove) {
          if (this.cameras.length > 0) {
            this.activeCamera = this.cameras[0];
          } else {
            this.activeCamera = null;
          }
        }
        this.onCameraRemovedObservable.notifyObservers(toRemove);
        return index;
      }
      removeParticleSystem(toRemove) {
        const index = this.particleSystems.indexOf(toRemove);
        if (index !== -1) {
          this.particleSystems.splice(index, 1);
          this._executeActiveContainerCleanup(this._activeParticleSystems);
        }
        return index;
      }
      removeAnimation(toRemove) {
        const index = this.animations.indexOf(toRemove);
        if (index !== -1) {
          this.animations.splice(index, 1);
        }
        return index;
      }
      stopAnimation(target, animationName, targetMask) {
      }
      removeAnimationGroup(toRemove) {
        const index = this.animationGroups.indexOf(toRemove);
        if (index !== -1) {
          this.animationGroups.splice(index, 1);
        }
        return index;
      }
      removeMultiMaterial(toRemove) {
        const index = this.multiMaterials.indexOf(toRemove);
        if (index !== -1) {
          this.multiMaterials.splice(index, 1);
        }
        this.onMultiMaterialRemovedObservable.notifyObservers(toRemove);
        return index;
      }
      removeMaterial(toRemove) {
        const index = toRemove._indexInSceneMaterialArray;
        if (index !== -1 && index < this.materials.length) {
          if (index !== this.materials.length - 1) {
            const lastMaterial = this.materials[this.materials.length - 1];
            this.materials[index] = lastMaterial;
            lastMaterial._indexInSceneMaterialArray = index;
          }
          toRemove._indexInSceneMaterialArray = -1;
          this.materials.pop();
        }
        this.onMaterialRemovedObservable.notifyObservers(toRemove);
        return index;
      }
      removeActionManager(toRemove) {
        const index = this.actionManagers.indexOf(toRemove);
        if (index !== -1) {
          this.actionManagers.splice(index, 1);
        }
        return index;
      }
      removeTexture(toRemove) {
        const index = this.textures.indexOf(toRemove);
        if (index !== -1) {
          this.textures.splice(index, 1);
        }
        this.onTextureRemovedObservable.notifyObservers(toRemove);
        return index;
      }
      addLight(newLight) {
        if (this._blockEntityCollection) {
          return;
        }
        this.lights.push(newLight);
        this.sortLightsByPriority();
        if (!newLight.parent) {
          newLight._addToSceneRootNodes();
        }
        for (const mesh of this.meshes) {
          if (mesh.lightSources.indexOf(newLight) === -1) {
            mesh.lightSources.push(newLight);
            mesh._resyncLightSources();
          }
        }
        this.onNewLightAddedObservable.notifyObservers(newLight);
      }
      sortLightsByPriority() {
        if (this.requireLightSorting) {
          this.lights.sort(LightConstants.CompareLightsPriority);
        }
      }
      addCamera(newCamera) {
        if (this._blockEntityCollection) {
          return;
        }
        this.cameras.push(newCamera);
        this.onNewCameraAddedObservable.notifyObservers(newCamera);
        if (!newCamera.parent) {
          newCamera._addToSceneRootNodes();
        }
      }
      addSkeleton(newSkeleton) {
        if (this._blockEntityCollection) {
          return;
        }
        this.skeletons.push(newSkeleton);
        this.onNewSkeletonAddedObservable.notifyObservers(newSkeleton);
      }
      addParticleSystem(newParticleSystem) {
        if (this._blockEntityCollection) {
          return;
        }
        this.particleSystems.push(newParticleSystem);
      }
      addAnimation(newAnimation) {
        if (this._blockEntityCollection) {
          return;
        }
        this.animations.push(newAnimation);
      }
      addAnimationGroup(newAnimationGroup) {
        if (this._blockEntityCollection) {
          return;
        }
        this.animationGroups.push(newAnimationGroup);
      }
      addMultiMaterial(newMultiMaterial) {
        if (this._blockEntityCollection) {
          return;
        }
        this.multiMaterials.push(newMultiMaterial);
        this.onNewMultiMaterialAddedObservable.notifyObservers(newMultiMaterial);
      }
      addMaterial(newMaterial) {
        if (this._blockEntityCollection) {
          return;
        }
        if (newMaterial.getScene() === this && newMaterial._indexInSceneMaterialArray !== -1) {
          return;
        }
        newMaterial._indexInSceneMaterialArray = this.materials.length;
        this.materials.push(newMaterial);
        this.onNewMaterialAddedObservable.notifyObservers(newMaterial);
      }
      addMorphTargetManager(newMorphTargetManager) {
        if (this._blockEntityCollection) {
          return;
        }
        this.morphTargetManagers.push(newMorphTargetManager);
      }
      addGeometry(newGeometry) {
        if (this._blockEntityCollection) {
          return;
        }
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[newGeometry.uniqueId] = this.geometries.length;
        }
        this.geometries.push(newGeometry);
      }
      addActionManager(newActionManager) {
        this.actionManagers.push(newActionManager);
      }
      addTexture(newTexture) {
        if (this._blockEntityCollection) {
          return;
        }
        this.textures.push(newTexture);
        this.onNewTextureAddedObservable.notifyObservers(newTexture);
      }
      switchActiveCamera(newCamera, attachControl = true) {
        const canvas = this._engine.getInputElement();
        if (!canvas) {
          return;
        }
        if (this.activeCamera) {
          this.activeCamera.detachControl();
        }
        this.activeCamera = newCamera;
        if (attachControl) {
          newCamera.attachControl();
        }
      }
      setActiveCameraById(id) {
        const camera = this.getCameraById(id);
        if (camera) {
          this.activeCamera = camera;
          return camera;
        }
        return null;
      }
      setActiveCameraByName(name) {
        const camera = this.getCameraByName(name);
        if (camera) {
          this.activeCamera = camera;
          return camera;
        }
        return null;
      }
      getAnimationGroupByName(name) {
        for (let index = 0; index < this.animationGroups.length; index++) {
          if (this.animationGroups[index].name === name) {
            return this.animationGroups[index];
          }
        }
        return null;
      }
      _getMaterial(allowMultiMaterials, predicate) {
        for (let index = 0; index < this.materials.length; index++) {
          const material = this.materials[index];
          if (predicate(material)) {
            return material;
          }
        }
        if (allowMultiMaterials) {
          for (let index = 0; index < this.multiMaterials.length; index++) {
            const material = this.multiMaterials[index];
            if (predicate(material)) {
              return material;
            }
          }
        }
        return null;
      }
      getMaterialByUniqueID(uniqueId, allowMultiMaterials = false) {
        return this._getMaterial(allowMultiMaterials, (m) => m.uniqueId === uniqueId);
      }
      getMaterialById(id, allowMultiMaterials = false) {
        return this._getMaterial(allowMultiMaterials, (m) => m.id === id);
      }
      getMaterialByName(name, allowMultiMaterials = false) {
        return this._getMaterial(allowMultiMaterials, (m) => m.name === name);
      }
      getLastMaterialById(id, allowMultiMaterials = false) {
        for (let index = this.materials.length - 1; index >= 0; index--) {
          if (this.materials[index].id === id) {
            return this.materials[index];
          }
        }
        if (allowMultiMaterials) {
          for (let index = this.multiMaterials.length - 1; index >= 0; index--) {
            if (this.multiMaterials[index].id === id) {
              return this.multiMaterials[index];
            }
          }
        }
        return null;
      }
      getTextureByUniqueId(uniqueId) {
        for (let index = 0; index < this.textures.length; index++) {
          if (this.textures[index].uniqueId === uniqueId) {
            return this.textures[index];
          }
        }
        return null;
      }
      getTextureByName(name) {
        for (let index = 0; index < this.textures.length; index++) {
          if (this.textures[index].name === name) {
            return this.textures[index];
          }
        }
        return null;
      }
      getCameraById(id) {
        for (let index = 0; index < this.cameras.length; index++) {
          if (this.cameras[index].id === id) {
            return this.cameras[index];
          }
        }
        return null;
      }
      getCameraByUniqueId(uniqueId) {
        for (let index = 0; index < this.cameras.length; index++) {
          if (this.cameras[index].uniqueId === uniqueId) {
            return this.cameras[index];
          }
        }
        return null;
      }
      getCameraByName(name) {
        for (let index = 0; index < this.cameras.length; index++) {
          if (this.cameras[index].name === name) {
            return this.cameras[index];
          }
        }
        return null;
      }
      getBoneById(id) {
        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
          const skeleton = this.skeletons[skeletonIndex];
          for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
            if (skeleton.bones[boneIndex].id === id) {
              return skeleton.bones[boneIndex];
            }
          }
        }
        return null;
      }
      getBoneByName(name) {
        for (let skeletonIndex = 0; skeletonIndex < this.skeletons.length; skeletonIndex++) {
          const skeleton = this.skeletons[skeletonIndex];
          for (let boneIndex = 0; boneIndex < skeleton.bones.length; boneIndex++) {
            if (skeleton.bones[boneIndex].name === name) {
              return skeleton.bones[boneIndex];
            }
          }
        }
        return null;
      }
      getLightByName(name) {
        for (let index = 0; index < this.lights.length; index++) {
          if (this.lights[index].name === name) {
            return this.lights[index];
          }
        }
        return null;
      }
      getLightById(id) {
        for (let index = 0; index < this.lights.length; index++) {
          if (this.lights[index].id === id) {
            return this.lights[index];
          }
        }
        return null;
      }
      getLightByUniqueId(uniqueId) {
        for (let index = 0; index < this.lights.length; index++) {
          if (this.lights[index].uniqueId === uniqueId) {
            return this.lights[index];
          }
        }
        return null;
      }
      getParticleSystemById(id) {
        for (let index = 0; index < this.particleSystems.length; index++) {
          if (this.particleSystems[index].id === id) {
            return this.particleSystems[index];
          }
        }
        return null;
      }
      getGeometryById(id) {
        for (let index = 0; index < this.geometries.length; index++) {
          if (this.geometries[index].id === id) {
            return this.geometries[index];
          }
        }
        return null;
      }
      _getGeometryByUniqueId(uniqueId) {
        if (this._geometriesByUniqueId) {
          const index = this._geometriesByUniqueId[uniqueId];
          if (index !== void 0) {
            return this.geometries[index];
          }
        } else {
          for (let index = 0; index < this.geometries.length; index++) {
            if (this.geometries[index].uniqueId === uniqueId) {
              return this.geometries[index];
            }
          }
        }
        return null;
      }
      pushGeometry(geometry, force) {
        if (!force && this._getGeometryByUniqueId(geometry.uniqueId)) {
          return false;
        }
        this.addGeometry(geometry);
        this.onNewGeometryAddedObservable.notifyObservers(geometry);
        return true;
      }
      removeGeometry(geometry) {
        let index;
        if (this._geometriesByUniqueId) {
          index = this._geometriesByUniqueId[geometry.uniqueId];
          if (index === void 0) {
            return false;
          }
        } else {
          index = this.geometries.indexOf(geometry);
          if (index < 0) {
            return false;
          }
        }
        if (index !== this.geometries.length - 1) {
          const lastGeometry = this.geometries[this.geometries.length - 1];
          if (lastGeometry) {
            this.geometries[index] = lastGeometry;
            if (this._geometriesByUniqueId) {
              this._geometriesByUniqueId[lastGeometry.uniqueId] = index;
            }
          }
        }
        if (this._geometriesByUniqueId) {
          this._geometriesByUniqueId[geometry.uniqueId] = void 0;
        }
        this.geometries.pop();
        this.onGeometryRemovedObservable.notifyObservers(geometry);
        return true;
      }
      getGeometries() {
        return this.geometries;
      }
      getMeshById(id) {
        for (let index = 0; index < this.meshes.length; index++) {
          if (this.meshes[index].id === id) {
            return this.meshes[index];
          }
        }
        return null;
      }
      getMeshesById(id) {
        return this.meshes.filter(function(m) {
          return m.id === id;
        });
      }
      getTransformNodeById(id) {
        for (let index = 0; index < this.transformNodes.length; index++) {
          if (this.transformNodes[index].id === id) {
            return this.transformNodes[index];
          }
        }
        return null;
      }
      getTransformNodeByUniqueId(uniqueId) {
        for (let index = 0; index < this.transformNodes.length; index++) {
          if (this.transformNodes[index].uniqueId === uniqueId) {
            return this.transformNodes[index];
          }
        }
        return null;
      }
      getTransformNodesById(id) {
        return this.transformNodes.filter(function(m) {
          return m.id === id;
        });
      }
      getMeshByUniqueId(uniqueId) {
        for (let index = 0; index < this.meshes.length; index++) {
          if (this.meshes[index].uniqueId === uniqueId) {
            return this.meshes[index];
          }
        }
        return null;
      }
      getLastMeshById(id) {
        for (let index = this.meshes.length - 1; index >= 0; index--) {
          if (this.meshes[index].id === id) {
            return this.meshes[index];
          }
        }
        return null;
      }
      getLastTransformNodeById(id) {
        for (let index = this.transformNodes.length - 1; index >= 0; index--) {
          if (this.transformNodes[index].id === id) {
            return this.transformNodes[index];
          }
        }
        return null;
      }
      getLastEntryById(id) {
        let index;
        for (index = this.meshes.length - 1; index >= 0; index--) {
          if (this.meshes[index].id === id) {
            return this.meshes[index];
          }
        }
        for (index = this.transformNodes.length - 1; index >= 0; index--) {
          if (this.transformNodes[index].id === id) {
            return this.transformNodes[index];
          }
        }
        for (index = this.cameras.length - 1; index >= 0; index--) {
          if (this.cameras[index].id === id) {
            return this.cameras[index];
          }
        }
        for (index = this.lights.length - 1; index >= 0; index--) {
          if (this.lights[index].id === id) {
            return this.lights[index];
          }
        }
        return null;
      }
      getNodeById(id) {
        const mesh = this.getMeshById(id);
        if (mesh) {
          return mesh;
        }
        const transformNode = this.getTransformNodeById(id);
        if (transformNode) {
          return transformNode;
        }
        const light = this.getLightById(id);
        if (light) {
          return light;
        }
        const camera = this.getCameraById(id);
        if (camera) {
          return camera;
        }
        const bone = this.getBoneById(id);
        if (bone) {
          return bone;
        }
        return null;
      }
      getNodeByName(name) {
        const mesh = this.getMeshByName(name);
        if (mesh) {
          return mesh;
        }
        const transformNode = this.getTransformNodeByName(name);
        if (transformNode) {
          return transformNode;
        }
        const light = this.getLightByName(name);
        if (light) {
          return light;
        }
        const camera = this.getCameraByName(name);
        if (camera) {
          return camera;
        }
        const bone = this.getBoneByName(name);
        if (bone) {
          return bone;
        }
        return null;
      }
      getMeshByName(name) {
        for (let index = 0; index < this.meshes.length; index++) {
          if (this.meshes[index].name === name) {
            return this.meshes[index];
          }
        }
        return null;
      }
      getTransformNodeByName(name) {
        for (let index = 0; index < this.transformNodes.length; index++) {
          if (this.transformNodes[index].name === name) {
            return this.transformNodes[index];
          }
        }
        return null;
      }
      getLastSkeletonById(id) {
        for (let index = this.skeletons.length - 1; index >= 0; index--) {
          if (this.skeletons[index].id === id) {
            return this.skeletons[index];
          }
        }
        return null;
      }
      getSkeletonByUniqueId(uniqueId) {
        for (let index = 0; index < this.skeletons.length; index++) {
          if (this.skeletons[index].uniqueId === uniqueId) {
            return this.skeletons[index];
          }
        }
        return null;
      }
      getSkeletonById(id) {
        for (let index = 0; index < this.skeletons.length; index++) {
          if (this.skeletons[index].id === id) {
            return this.skeletons[index];
          }
        }
        return null;
      }
      getSkeletonByName(name) {
        for (let index = 0; index < this.skeletons.length; index++) {
          if (this.skeletons[index].name === name) {
            return this.skeletons[index];
          }
        }
        return null;
      }
      getMorphTargetManagerById(id) {
        for (let index = 0; index < this.morphTargetManagers.length; index++) {
          if (this.morphTargetManagers[index].uniqueId === id) {
            return this.morphTargetManagers[index];
          }
        }
        return null;
      }
      getMorphTargetById(id) {
        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
          const morphTargetManager = this.morphTargetManagers[managerIndex];
          for (let index = 0; index < morphTargetManager.numTargets; ++index) {
            const target = morphTargetManager.getTarget(index);
            if (target.id === id) {
              return target;
            }
          }
        }
        return null;
      }
      getMorphTargetByName(name) {
        for (let managerIndex = 0; managerIndex < this.morphTargetManagers.length; ++managerIndex) {
          const morphTargetManager = this.morphTargetManagers[managerIndex];
          for (let index = 0; index < morphTargetManager.numTargets; ++index) {
            const target = morphTargetManager.getTarget(index);
            if (target.name === name) {
              return target;
            }
          }
        }
        return null;
      }
      getPostProcessByName(name) {
        for (let postProcessIndex = 0; postProcessIndex < this.postProcesses.length; ++postProcessIndex) {
          const postProcess = this.postProcesses[postProcessIndex];
          if (postProcess.name === name) {
            return postProcess;
          }
        }
        return null;
      }
      isActiveMesh(mesh) {
        return this._activeMeshes.indexOf(mesh) !== -1;
      }
      get uid() {
        if (!this._uid) {
          this._uid = Tools.RandomId();
        }
        return this._uid;
      }
      addExternalData(key, data) {
        if (!this._externalData) {
          this._externalData = new StringDictionary();
        }
        return this._externalData.add(key, data);
      }
      getExternalData(key) {
        if (!this._externalData) {
          return null;
        }
        return this._externalData.get(key);
      }
      getOrAddExternalDataWithFactory(key, factory) {
        if (!this._externalData) {
          this._externalData = new StringDictionary();
        }
        return this._externalData.getOrAddWithFactory(key, factory);
      }
      removeExternalData(key) {
        return this._externalData.remove(key);
      }
      _evaluateSubMesh(subMesh, mesh, initialMesh, forcePush) {
        if (forcePush || subMesh.isInFrustum(this._frustumPlanes)) {
          for (const step of this._evaluateSubMeshStage) {
            step.action(mesh, subMesh);
          }
          const material = subMesh.getMaterial();
          if (material !== null && material !== void 0) {
            if (material.hasRenderTargetTextures && material.getRenderTargetTextures != null) {
              if (this._processedMaterials.indexOf(material) === -1) {
                this._processedMaterials.push(material);
                this._materialsRenderTargets.concatWithNoDuplicate(material.getRenderTargetTextures());
              }
            }
            this._renderingManager.dispatch(subMesh, mesh, material);
          }
        }
      }
      freeProcessedMaterials() {
        this._processedMaterials.dispose();
      }
      get blockfreeActiveMeshesAndRenderingGroups() {
        return this._preventFreeActiveMeshesAndRenderingGroups;
      }
      set blockfreeActiveMeshesAndRenderingGroups(value) {
        if (this._preventFreeActiveMeshesAndRenderingGroups === value) {
          return;
        }
        if (value) {
          this.freeActiveMeshes();
          this.freeRenderingGroups();
        }
        this._preventFreeActiveMeshesAndRenderingGroups = value;
      }
      freeActiveMeshes() {
        if (this.blockfreeActiveMeshesAndRenderingGroups) {
          return;
        }
        this._activeMeshes.dispose();
        if (this.activeCamera && this.activeCamera._activeMeshes) {
          this.activeCamera._activeMeshes.dispose();
        }
        if (this.activeCameras) {
          for (let i = 0; i < this.activeCameras.length; i++) {
            const activeCamera = this.activeCameras[i];
            if (activeCamera && activeCamera._activeMeshes) {
              activeCamera._activeMeshes.dispose();
            }
          }
        }
      }
      freeRenderingGroups() {
        if (this.blockfreeActiveMeshesAndRenderingGroups) {
          return;
        }
        if (this._renderingManager) {
          this._renderingManager.freeRenderingGroups();
        }
        if (this.textures) {
          for (let i = 0; i < this.textures.length; i++) {
            const texture = this.textures[i];
            if (texture && texture.renderList) {
              texture.freeRenderingGroups();
            }
          }
        }
      }
      _isInIntermediateRendering() {
        return this._intermediateRendering;
      }
      freezeActiveMeshes(skipEvaluateActiveMeshes = false, onSuccess, onError, freezeMeshes = true, keepFrustumCulling = false) {
        this.executeWhenReady(() => {
          if (!this.activeCamera) {
            onError && onError("No active camera found");
            return;
          }
          if (!this._frustumPlanes) {
            this.updateTransformMatrix();
          }
          this._evaluateActiveMeshes();
          this._activeMeshesFrozen = true;
          this._activeMeshesFrozenButKeepClipping = keepFrustumCulling;
          this._skipEvaluateActiveMeshesCompletely = skipEvaluateActiveMeshes;
          if (freezeMeshes) {
            for (let index = 0; index < this._activeMeshes.length; index++) {
              this._activeMeshes.data[index]._freeze();
            }
          }
          onSuccess && onSuccess();
        });
        return this;
      }
      unfreezeActiveMeshes() {
        for (let index = 0; index < this.meshes.length; index++) {
          const mesh = this.meshes[index];
          if (mesh._internalAbstractMeshDataInfo) {
            mesh._internalAbstractMeshDataInfo._isActive = false;
          }
        }
        for (let index = 0; index < this._activeMeshes.length; index++) {
          this._activeMeshes.data[index]._unFreeze();
        }
        this._activeMeshesFrozen = false;
        return this;
      }
      _executeActiveContainerCleanup(container) {
        const isInFastMode = this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1;
        if (!isInFastMode && this._activeMeshesFrozen && this._activeMeshes.length) {
          return;
        }
        this.onBeforeRenderObservable.addOnce(() => container.dispose());
      }
      _evaluateActiveMeshes() {
        var _a;
        if (this._engine.snapshotRendering && this._engine.snapshotRenderingMode === 1) {
          if (this._activeMeshes.length > 0) {
            (_a = this.activeCamera) === null || _a === void 0 ? void 0 : _a._activeMeshes.reset();
            this._activeMeshes.reset();
            this._renderingManager.reset();
            this._processedMaterials.reset();
            this._activeParticleSystems.reset();
            this._activeSkeletons.reset();
            this._softwareSkinnedMeshes.reset();
          }
          return;
        }
        if (this._activeMeshesFrozen && this._activeMeshes.length) {
          if (!this._skipEvaluateActiveMeshesCompletely) {
            const len2 = this._activeMeshes.length;
            for (let i = 0; i < len2; i++) {
              const mesh = this._activeMeshes.data[i];
              mesh.computeWorldMatrix();
            }
          }
          if (this._activeParticleSystems) {
            const psLength = this._activeParticleSystems.length;
            for (let i = 0; i < psLength; i++) {
              this._activeParticleSystems.data[i].animate();
            }
          }
          this._renderingManager.resetSprites();
          return;
        }
        if (!this.activeCamera) {
          return;
        }
        this.onBeforeActiveMeshesEvaluationObservable.notifyObservers(this);
        this.activeCamera._activeMeshes.reset();
        this._activeMeshes.reset();
        this._renderingManager.reset();
        this._processedMaterials.reset();
        this._activeParticleSystems.reset();
        this._activeSkeletons.reset();
        this._softwareSkinnedMeshes.reset();
        this._materialsRenderTargets.reset();
        for (const step of this._beforeEvaluateActiveMeshStage) {
          step.action();
        }
        const meshes = this.getActiveMeshCandidates();
        const len = meshes.length;
        for (let i = 0; i < len; i++) {
          const mesh = meshes.data[i];
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = false;
          if (mesh.isBlocked) {
            continue;
          }
          this._totalVertices.addCount(mesh.getTotalVertices(), false);
          if (!mesh.isReady() || !mesh.isEnabled() || mesh.scaling.hasAZeroComponent) {
            continue;
          }
          mesh.computeWorldMatrix();
          if (mesh.actionManager && mesh.actionManager.hasSpecificTriggers2(12, 13)) {
            this._meshesForIntersections.pushNoDuplicate(mesh);
          }
          let meshToRender = this.customLODSelector ? this.customLODSelector(mesh, this.activeCamera) : mesh.getLOD(this.activeCamera);
          mesh._internalAbstractMeshDataInfo._currentLOD = meshToRender;
          mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
          if (meshToRender === void 0 || meshToRender === null) {
            continue;
          }
          if (meshToRender !== mesh && meshToRender.billboardMode !== 0) {
            meshToRender.computeWorldMatrix();
          }
          mesh._preActivate();
          if (mesh.isVisible && mesh.visibility > 0 && (mesh.layerMask & this.activeCamera.layerMask) !== 0 && (this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh || mesh.isInFrustum(this._frustumPlanes))) {
            this._activeMeshes.push(mesh);
            this.activeCamera._activeMeshes.push(mesh);
            if (meshToRender !== mesh) {
              meshToRender._activate(this._renderId, false);
            }
            for (const step of this._preActiveMeshStage) {
              step.action(mesh);
            }
            if (mesh._activate(this._renderId, false)) {
              if (!mesh.isAnInstance) {
                meshToRender._internalAbstractMeshDataInfo._onlyForInstances = false;
              } else {
                if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                  meshToRender = mesh;
                }
              }
              meshToRender._internalAbstractMeshDataInfo._isActive = true;
              this._activeMesh(mesh, meshToRender);
            }
            mesh._postActivate();
          }
        }
        this.onAfterActiveMeshesEvaluationObservable.notifyObservers(this);
        if (this.particlesEnabled) {
          this.onBeforeParticlesRenderingObservable.notifyObservers(this);
          for (let particleIndex = 0; particleIndex < this.particleSystems.length; particleIndex++) {
            const particleSystem = this.particleSystems[particleIndex];
            if (!particleSystem.isStarted() || !particleSystem.emitter) {
              continue;
            }
            const emitter = particleSystem.emitter;
            if (!emitter.position || emitter.isEnabled()) {
              this._activeParticleSystems.push(particleSystem);
              particleSystem.animate();
              this._renderingManager.dispatchParticles(particleSystem);
            }
          }
          this.onAfterParticlesRenderingObservable.notifyObservers(this);
        }
      }
      _activeMesh(sourceMesh, mesh) {
        if (this._skeletonsEnabled && mesh.skeleton !== null && mesh.skeleton !== void 0) {
          if (this._activeSkeletons.pushNoDuplicate(mesh.skeleton)) {
            mesh.skeleton.prepare();
            this._activeBones.addCount(mesh.skeleton.bones.length, false);
          }
          if (!mesh.computeBonesUsingShaders) {
            this._softwareSkinnedMeshes.pushNoDuplicate(mesh);
          }
        }
        let forcePush = sourceMesh.hasInstances || sourceMesh.isAnInstance || this.dispatchAllSubMeshesOfActiveMeshes || this._skipFrustumClipping || mesh.alwaysSelectAsActiveMesh;
        if (mesh && mesh.subMeshes && mesh.subMeshes.length > 0) {
          const subMeshes = this.getActiveSubMeshCandidates(mesh);
          const len = subMeshes.length;
          forcePush = forcePush || len === 1;
          for (let i = 0; i < len; i++) {
            const subMesh = subMeshes.data[i];
            this._evaluateSubMesh(subMesh, mesh, sourceMesh, forcePush);
          }
        }
      }
      updateTransformMatrix(force) {
        if (!this.activeCamera) {
          return;
        }
        if (this.activeCamera._renderingMultiview) {
          const leftCamera = this.activeCamera._rigCameras[0];
          const rightCamera = this.activeCamera._rigCameras[1];
          this.setTransformMatrix(leftCamera.getViewMatrix(), leftCamera.getProjectionMatrix(force), rightCamera.getViewMatrix(), rightCamera.getProjectionMatrix(force));
        } else {
          this.setTransformMatrix(this.activeCamera.getViewMatrix(), this.activeCamera.getProjectionMatrix(force));
        }
      }
      _bindFrameBuffer(camera, clear = true) {
        if (camera && camera._multiviewTexture) {
          camera._multiviewTexture._bindFrameBuffer();
        } else if (camera && camera.outputRenderTarget) {
          camera.outputRenderTarget._bindFrameBuffer();
        } else {
          if (!this._engine._currentFrameBufferIsDefaultFrameBuffer()) {
            this._engine.restoreDefaultFramebuffer();
          }
        }
        if (clear) {
          this._clearFrameBuffer(camera);
        }
      }
      _clearFrameBuffer(camera) {
        if (camera && camera._multiviewTexture) {
        } else if (camera && camera.outputRenderTarget && !camera._renderingMultiview) {
          const rtt = camera.outputRenderTarget;
          if (rtt.onClearObservable.hasObservers()) {
            rtt.onClearObservable.notifyObservers(this._engine);
          } else if (!rtt.skipInitialClear) {
            if (this.autoClear) {
              this._engine.clear(rtt.clearColor || this.clearColor, !rtt._cleared, true, true);
            }
            rtt._cleared = true;
          }
        } else {
          if (!this._defaultFrameBufferCleared) {
            this._defaultFrameBufferCleared = true;
            this._clear();
          } else {
            this._engine.clear(null, false, true, true);
          }
        }
      }
      _renderForCamera(camera, rigParent, bindFrameBuffer = true) {
        var _a, _b, _c;
        if (camera && camera._skipRendering) {
          return;
        }
        const engine = this._engine;
        this._activeCamera = camera;
        if (!this.activeCamera) {
          throw new Error("Active camera not set");
        }
        engine.setViewport(this.activeCamera.viewport);
        this.resetCachedMaterial();
        this._renderId++;
        if (!this.prePass && bindFrameBuffer) {
          let skipInitialClear = true;
          if (camera._renderingMultiview && camera.outputRenderTarget) {
            skipInitialClear = camera.outputRenderTarget.skipInitialClear;
            if (this.autoClear) {
              this._defaultFrameBufferCleared = false;
              camera.outputRenderTarget.skipInitialClear = false;
            }
          }
          this._bindFrameBuffer(this._activeCamera);
          if (camera._renderingMultiview && camera.outputRenderTarget) {
            camera.outputRenderTarget.skipInitialClear = skipInitialClear;
          }
        }
        this.updateTransformMatrix();
        this.onBeforeCameraRenderObservable.notifyObservers(this.activeCamera);
        this._evaluateActiveMeshes();
        for (let softwareSkinnedMeshIndex = 0; softwareSkinnedMeshIndex < this._softwareSkinnedMeshes.length; softwareSkinnedMeshIndex++) {
          const mesh = this._softwareSkinnedMeshes.data[softwareSkinnedMeshIndex];
          mesh.applySkeleton(mesh.skeleton);
        }
        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
        this._renderTargets.concatWithNoDuplicate(this._materialsRenderTargets);
        if (camera.customRenderTargets && camera.customRenderTargets.length > 0) {
          this._renderTargets.concatWithNoDuplicate(camera.customRenderTargets);
        }
        if (rigParent && rigParent.customRenderTargets && rigParent.customRenderTargets.length > 0) {
          this._renderTargets.concatWithNoDuplicate(rigParent.customRenderTargets);
        }
        if (this.environmentTexture && this.environmentTexture.isRenderTarget) {
          this._renderTargets.pushNoDuplicate(this.environmentTexture);
        }
        for (const step of this._gatherActiveCameraRenderTargetsStage) {
          step.action(this._renderTargets);
        }
        let needRebind = false;
        if (this.renderTargetsEnabled) {
          this._intermediateRendering = true;
          if (this._renderTargets.length > 0) {
            Tools.StartPerformanceCounter("Render targets", this._renderTargets.length > 0);
            for (let renderIndex = 0; renderIndex < this._renderTargets.length; renderIndex++) {
              const renderTarget = this._renderTargets.data[renderIndex];
              if (renderTarget._shouldRender()) {
                this._renderId++;
                const hasSpecialRenderTargetCamera = renderTarget.activeCamera && renderTarget.activeCamera !== this.activeCamera;
                renderTarget.render(hasSpecialRenderTargetCamera, this.dumpNextRenderTargets);
                needRebind = true;
              }
            }
            Tools.EndPerformanceCounter("Render targets", this._renderTargets.length > 0);
            this._renderId++;
          }
          for (const step of this._cameraDrawRenderTargetStage) {
            needRebind = step.action(this.activeCamera) || needRebind;
          }
          this._intermediateRendering = false;
        }
        this._engine.currentRenderPassId = (_c = (_b = (_a = camera.outputRenderTarget) === null || _a === void 0 ? void 0 : _a.renderPassId) !== null && _b !== void 0 ? _b : camera.renderPassId) !== null && _c !== void 0 ? _c : 0;
        if (needRebind && !this.prePass) {
          this._bindFrameBuffer(this._activeCamera, false);
        }
        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
        if (this.postProcessManager && !camera._multiviewTexture && !this.prePass) {
          this.postProcessManager._prepareFrame();
        }
        for (const step of this._beforeCameraDrawStage) {
          step.action(this.activeCamera);
        }
        this.onBeforeDrawPhaseObservable.notifyObservers(this);
        if (engine.snapshotRendering && engine.snapshotRenderingMode === 1) {
          this.finalizeSceneUbo();
        }
        this._renderingManager.render(null, null, true, true);
        this.onAfterDrawPhaseObservable.notifyObservers(this);
        for (const step of this._afterCameraDrawStage) {
          step.action(this.activeCamera);
        }
        if (this.postProcessManager && !camera._multiviewTexture) {
          const texture = camera.outputRenderTarget ? camera.outputRenderTarget.renderTarget : void 0;
          this.postProcessManager._finalizeFrame(camera.isIntermediate, texture);
        }
        for (const step of this._afterCameraPostProcessStage) {
          step.action(this.activeCamera);
        }
        this._renderTargets.reset();
        this.onAfterCameraRenderObservable.notifyObservers(this.activeCamera);
      }
      _processSubCameras(camera, bindFrameBuffer = true) {
        if (camera.cameraRigMode === 0 || camera._renderingMultiview) {
          if (camera._renderingMultiview && !this._multiviewSceneUbo) {
            this._createMultiviewUbo();
          }
          this._renderForCamera(camera, void 0, bindFrameBuffer);
          this.onAfterRenderCameraObservable.notifyObservers(camera);
          return;
        }
        if (camera._useMultiviewToSingleView) {
          this._renderMultiviewToSingleView(camera);
        } else {
          this.onBeforeCameraRenderObservable.notifyObservers(camera);
          for (let index = 0; index < camera._rigCameras.length; index++) {
            this._renderForCamera(camera._rigCameras[index], camera);
          }
        }
        this._activeCamera = camera;
        this.updateTransformMatrix();
        this.onAfterRenderCameraObservable.notifyObservers(camera);
      }
      _checkIntersections() {
        for (let index = 0; index < this._meshesForIntersections.length; index++) {
          const sourceMesh = this._meshesForIntersections.data[index];
          if (!sourceMesh.actionManager) {
            continue;
          }
          for (let actionIndex = 0; sourceMesh.actionManager && actionIndex < sourceMesh.actionManager.actions.length; actionIndex++) {
            const action = sourceMesh.actionManager.actions[actionIndex];
            if (action.trigger === 12 || action.trigger === 13) {
              const parameters = action.getTriggerParameter();
              const otherMesh = parameters.mesh ? parameters.mesh : parameters;
              const areIntersecting = otherMesh.intersectsMesh(sourceMesh, parameters.usePreciseIntersection);
              const currentIntersectionInProgress = sourceMesh._intersectionsInProgress.indexOf(otherMesh);
              if (areIntersecting && currentIntersectionInProgress === -1) {
                if (action.trigger === 12) {
                  action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
                  sourceMesh._intersectionsInProgress.push(otherMesh);
                } else if (action.trigger === 13) {
                  sourceMesh._intersectionsInProgress.push(otherMesh);
                }
              } else if (!areIntersecting && currentIntersectionInProgress > -1) {
                if (action.trigger === 13) {
                  action._executeCurrent(ActionEvent.CreateNew(sourceMesh, void 0, otherMesh));
                }
                if (!sourceMesh.actionManager.hasSpecificTrigger(13, (parameter) => {
                  const parameterMesh = parameter.mesh ? parameter.mesh : parameter;
                  return otherMesh === parameterMesh;
                }) || action.trigger === 13) {
                  sourceMesh._intersectionsInProgress.splice(currentIntersectionInProgress, 1);
                }
              }
            }
          }
        }
      }
      _advancePhysicsEngineStep(step) {
      }
      _animate() {
      }
      animate() {
        if (this._engine.isDeterministicLockStep()) {
          let deltaTime = Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime)) + this._timeAccumulator;
          const defaultFrameTime = this._engine.getTimeStep();
          const defaultFPS = 1e3 / defaultFrameTime / 1e3;
          let stepsTaken = 0;
          const maxSubSteps = this._engine.getLockstepMaxSteps();
          let internalSteps = Math.floor(deltaTime / defaultFrameTime);
          internalSteps = Math.min(internalSteps, maxSubSteps);
          while (deltaTime > 0 && stepsTaken < internalSteps) {
            this.onBeforeStepObservable.notifyObservers(this);
            this._animationRatio = defaultFrameTime * defaultFPS;
            this._animate();
            this.onAfterAnimationsObservable.notifyObservers(this);
            if (this.physicsEnabled) {
              this._advancePhysicsEngineStep(defaultFrameTime);
            }
            this.onAfterStepObservable.notifyObservers(this);
            this._currentStepId++;
            stepsTaken++;
            deltaTime -= defaultFrameTime;
          }
          this._timeAccumulator = deltaTime < 0 ? 0 : deltaTime;
        } else {
          const deltaTime = this.useConstantAnimationDeltaTime ? 16 : Math.max(Scene.MinDeltaTime, Math.min(this._engine.getDeltaTime(), Scene.MaxDeltaTime));
          this._animationRatio = deltaTime * (60 / 1e3);
          this._animate();
          this.onAfterAnimationsObservable.notifyObservers(this);
          if (this.physicsEnabled) {
            this._advancePhysicsEngineStep(deltaTime);
          }
        }
      }
      _clear() {
        if (this.autoClearDepthAndStencil || this.autoClear) {
          this._engine.clear(this.clearColor, this.autoClear || this.forceWireframe || this.forcePointsCloud, this.autoClearDepthAndStencil, this.autoClearDepthAndStencil);
        }
      }
      _checkCameraRenderTarget(camera) {
        var _a;
        if ((camera === null || camera === void 0 ? void 0 : camera.outputRenderTarget) && !(camera === null || camera === void 0 ? void 0 : camera.isRigCamera)) {
          camera.outputRenderTarget._cleared = false;
        }
        if ((_a = camera === null || camera === void 0 ? void 0 : camera.rigCameras) === null || _a === void 0 ? void 0 : _a.length) {
          for (let i = 0; i < camera.rigCameras.length; ++i) {
            const rtt = camera.rigCameras[i].outputRenderTarget;
            if (rtt) {
              rtt._cleared = false;
            }
          }
        }
      }
      resetDrawCache(passId) {
        if (!this.meshes) {
          return;
        }
        for (const mesh of this.meshes) {
          mesh.resetDrawCache(passId);
        }
      }
      render(updateCameras = true, ignoreAnimations = false) {
        var _a, _b, _c;
        if (this.isDisposed) {
          return;
        }
        if (this.onReadyObservable.hasObservers() && this._executeWhenReadyTimeoutId === null) {
          this._checkIsReady();
        }
        this._frameId++;
        this._defaultFrameBufferCleared = false;
        this._checkCameraRenderTarget(this.activeCamera);
        if ((_a = this.activeCameras) === null || _a === void 0 ? void 0 : _a.length) {
          this.activeCameras.forEach(this._checkCameraRenderTarget);
        }
        this._registerTransientComponents();
        this._activeParticles.fetchNewFrame();
        this._totalVertices.fetchNewFrame();
        this._activeIndices.fetchNewFrame();
        this._activeBones.fetchNewFrame();
        this._meshesForIntersections.reset();
        this.resetCachedMaterial();
        this.onBeforeAnimationsObservable.notifyObservers(this);
        if (this.actionManager) {
          this.actionManager.processTrigger(11);
        }
        if (!ignoreAnimations) {
          this.animate();
        }
        for (const step of this._beforeCameraUpdateStage) {
          step.action();
        }
        if (updateCameras) {
          if (this.activeCameras && this.activeCameras.length > 0) {
            for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
              const camera = this.activeCameras[cameraIndex];
              camera.update();
              if (camera.cameraRigMode !== 0) {
                for (let index = 0; index < camera._rigCameras.length; index++) {
                  camera._rigCameras[index].update();
                }
              }
            }
          } else if (this.activeCamera) {
            this.activeCamera.update();
            if (this.activeCamera.cameraRigMode !== 0) {
              for (let index = 0; index < this.activeCamera._rigCameras.length; index++) {
                this.activeCamera._rigCameras[index].update();
              }
            }
          }
        }
        this.onBeforeRenderObservable.notifyObservers(this);
        const engine = this.getEngine();
        this.onBeforeRenderTargetsRenderObservable.notifyObservers(this);
        const currentActiveCamera = ((_b = this.activeCameras) === null || _b === void 0 ? void 0 : _b.length) ? this.activeCameras[0] : this.activeCamera;
        if (this.renderTargetsEnabled) {
          Tools.StartPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
          this._intermediateRendering = true;
          for (let customIndex = 0; customIndex < this.customRenderTargets.length; customIndex++) {
            const renderTarget = this.customRenderTargets[customIndex];
            if (renderTarget._shouldRender()) {
              this._renderId++;
              this.activeCamera = renderTarget.activeCamera || this.activeCamera;
              if (!this.activeCamera) {
                throw new Error("Active camera not set");
              }
              engine.setViewport(this.activeCamera.viewport);
              this.updateTransformMatrix();
              renderTarget.render(currentActiveCamera !== this.activeCamera, this.dumpNextRenderTargets);
            }
          }
          Tools.EndPerformanceCounter("Custom render targets", this.customRenderTargets.length > 0);
          this._intermediateRendering = false;
          this._renderId++;
        }
        this._engine.currentRenderPassId = (_c = currentActiveCamera === null || currentActiveCamera === void 0 ? void 0 : currentActiveCamera.renderPassId) !== null && _c !== void 0 ? _c : 0;
        this.activeCamera = currentActiveCamera;
        if (this._activeCamera && this._activeCamera.cameraRigMode !== 22 && !this.prePass) {
          this._bindFrameBuffer(this._activeCamera, false);
        }
        this.onAfterRenderTargetsRenderObservable.notifyObservers(this);
        for (const step of this._beforeClearStage) {
          step.action();
        }
        this._clearFrameBuffer(this.activeCamera);
        for (const step of this._gatherRenderTargetsStage) {
          step.action(this._renderTargets);
        }
        if (this.activeCameras && this.activeCameras.length > 0) {
          for (let cameraIndex = 0; cameraIndex < this.activeCameras.length; cameraIndex++) {
            this._processSubCameras(this.activeCameras[cameraIndex], cameraIndex > 0);
          }
        } else {
          if (!this.activeCamera) {
            throw new Error("No camera defined");
          }
          this._processSubCameras(this.activeCamera, !!this.activeCamera.outputRenderTarget);
        }
        this._checkIntersections();
        for (const step of this._afterRenderStage) {
          step.action();
        }
        if (this.afterRender) {
          this.afterRender();
        }
        this.onAfterRenderObservable.notifyObservers(this);
        if (this._toBeDisposed.length) {
          for (let index = 0; index < this._toBeDisposed.length; index++) {
            const data = this._toBeDisposed[index];
            if (data) {
              data.dispose();
            }
          }
          this._toBeDisposed.length = 0;
        }
        if (this.dumpNextRenderTargets) {
          this.dumpNextRenderTargets = false;
        }
        this._activeBones.addCount(0, true);
        this._activeIndices.addCount(0, true);
        this._activeParticles.addCount(0, true);
        this._engine.restoreDefaultFramebuffer();
      }
      freezeMaterials() {
        for (let i = 0; i < this.materials.length; i++) {
          this.materials[i].freeze();
        }
      }
      unfreezeMaterials() {
        for (let i = 0; i < this.materials.length; i++) {
          this.materials[i].unfreeze();
        }
      }
      dispose() {
        if (this.isDisposed) {
          return;
        }
        this.beforeRender = null;
        this.afterRender = null;
        this.metadata = null;
        this.skeletons.length = 0;
        this.morphTargetManagers.length = 0;
        this._transientComponents.length = 0;
        this._isReadyForMeshStage.clear();
        this._beforeEvaluateActiveMeshStage.clear();
        this._evaluateSubMeshStage.clear();
        this._preActiveMeshStage.clear();
        this._cameraDrawRenderTargetStage.clear();
        this._beforeCameraDrawStage.clear();
        this._beforeRenderTargetDrawStage.clear();
        this._beforeRenderingGroupDrawStage.clear();
        this._beforeRenderingMeshStage.clear();
        this._afterRenderingMeshStage.clear();
        this._afterRenderingGroupDrawStage.clear();
        this._afterCameraDrawStage.clear();
        this._afterRenderTargetDrawStage.clear();
        this._afterRenderStage.clear();
        this._beforeCameraUpdateStage.clear();
        this._beforeClearStage.clear();
        this._gatherRenderTargetsStage.clear();
        this._gatherActiveCameraRenderTargetsStage.clear();
        this._pointerMoveStage.clear();
        this._pointerDownStage.clear();
        this._pointerUpStage.clear();
        this.importedMeshesFiles = new Array();
        if (this.stopAllAnimations) {
          this._activeAnimatables.forEach((animatable) => {
            animatable.onAnimationEndObservable.clear();
            animatable.onAnimationEnd = null;
          });
          this.stopAllAnimations();
        }
        this.resetCachedMaterial();
        if (this.activeCamera) {
          this.activeCamera._activeMeshes.dispose();
          this.activeCamera = null;
        }
        this.activeCameras = null;
        this._activeMeshes.dispose();
        this._renderingManager.dispose();
        this._processedMaterials.dispose();
        this._activeParticleSystems.dispose();
        this._activeSkeletons.dispose();
        this._softwareSkinnedMeshes.dispose();
        this._renderTargets.dispose();
        this._materialsRenderTargets.dispose();
        this._registeredForLateAnimationBindings.dispose();
        this._meshesForIntersections.dispose();
        this._toBeDisposed.length = 0;
        const activeRequests = this._activeRequests.slice();
        for (const request of activeRequests) {
          request.abort();
        }
        this._activeRequests.length = 0;
        try {
          this.onDisposeObservable.notifyObservers(this);
        } catch (e) {
          console.error("An error occurred while calling onDisposeObservable!", e);
        }
        this.detachControl();
        const canvas = this._engine.getInputElement();
        if (canvas) {
          for (let index2 = 0; index2 < this.cameras.length; index2++) {
            this.cameras[index2].detachControl();
          }
        }
        this._disposeList(this.animationGroups);
        this._disposeList(this.lights);
        this._disposeList(this.meshes, (item) => item.dispose(true));
        this._disposeList(this.transformNodes, (item) => item.dispose(true));
        const cameras = this.cameras;
        this._disposeList(cameras);
        if (this._defaultMaterial) {
          this._defaultMaterial.dispose();
        }
        this._disposeList(this.multiMaterials);
        this._disposeList(this.materials);
        this._disposeList(this.particleSystems);
        this._disposeList(this.postProcesses);
        this._disposeList(this.textures);
        this._disposeList(this.morphTargetManagers);
        this._sceneUbo.dispose();
        if (this._multiviewSceneUbo) {
          this._multiviewSceneUbo.dispose();
        }
        this.postProcessManager.dispose();
        this._disposeList(this._components);
        let index = this._engine.scenes.indexOf(this);
        if (index > -1) {
          this._engine.scenes.splice(index, 1);
        }
        if (EngineStore._LastCreatedScene === this) {
          if (this._engine.scenes.length > 0) {
            EngineStore._LastCreatedScene = this._engine.scenes[this._engine.scenes.length - 1];
          } else {
            EngineStore._LastCreatedScene = null;
          }
        }
        index = this._engine._virtualScenes.indexOf(this);
        if (index > -1) {
          this._engine._virtualScenes.splice(index, 1);
        }
        this._engine.wipeCaches(true);
        this.onDisposeObservable.clear();
        this.onBeforeRenderObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onBeforeRenderTargetsRenderObservable.clear();
        this.onAfterRenderTargetsRenderObservable.clear();
        this.onAfterStepObservable.clear();
        this.onBeforeStepObservable.clear();
        this.onBeforeActiveMeshesEvaluationObservable.clear();
        this.onAfterActiveMeshesEvaluationObservable.clear();
        this.onBeforeParticlesRenderingObservable.clear();
        this.onAfterParticlesRenderingObservable.clear();
        this.onBeforeDrawPhaseObservable.clear();
        this.onAfterDrawPhaseObservable.clear();
        this.onBeforeAnimationsObservable.clear();
        this.onAfterAnimationsObservable.clear();
        this.onDataLoadedObservable.clear();
        this.onBeforeRenderingGroupObservable.clear();
        this.onAfterRenderingGroupObservable.clear();
        this.onMeshImportedObservable.clear();
        this.onBeforeCameraRenderObservable.clear();
        this.onAfterCameraRenderObservable.clear();
        this.onAfterRenderCameraObservable.clear();
        this.onReadyObservable.clear();
        this.onNewCameraAddedObservable.clear();
        this.onCameraRemovedObservable.clear();
        this.onNewLightAddedObservable.clear();
        this.onLightRemovedObservable.clear();
        this.onNewGeometryAddedObservable.clear();
        this.onGeometryRemovedObservable.clear();
        this.onNewTransformNodeAddedObservable.clear();
        this.onTransformNodeRemovedObservable.clear();
        this.onNewMeshAddedObservable.clear();
        this.onMeshRemovedObservable.clear();
        this.onNewSkeletonAddedObservable.clear();
        this.onSkeletonRemovedObservable.clear();
        this.onNewMaterialAddedObservable.clear();
        this.onNewMultiMaterialAddedObservable.clear();
        this.onMaterialRemovedObservable.clear();
        this.onMultiMaterialRemovedObservable.clear();
        this.onNewTextureAddedObservable.clear();
        this.onTextureRemovedObservable.clear();
        this.onPrePointerObservable.clear();
        this.onPointerObservable.clear();
        this.onPreKeyboardObservable.clear();
        this.onKeyboardObservable.clear();
        this.onActiveCameraChanged.clear();
        this.onScenePerformancePriorityChangedObservable.clear();
        this._isDisposed = true;
      }
      _disposeList(items, callback) {
        const itemsCopy = items.slice(0);
        callback = callback !== null && callback !== void 0 ? callback : (item) => item.dispose();
        for (const item of itemsCopy) {
          callback(item);
        }
        items.length = 0;
      }
      get isDisposed() {
        return this._isDisposed;
      }
      clearCachedVertexData() {
        for (let meshIndex = 0; meshIndex < this.meshes.length; meshIndex++) {
          const mesh = this.meshes[meshIndex];
          const geometry = mesh.geometry;
          if (geometry) {
            geometry.clearCachedData();
          }
        }
      }
      cleanCachedTextureBuffer() {
        for (const baseTexture of this.textures) {
          const buffer = baseTexture._buffer;
          if (buffer) {
            baseTexture._buffer = null;
          }
        }
      }
      getWorldExtends(filterPredicate) {
        const min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        const max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        filterPredicate = filterPredicate || (() => true);
        this.meshes.filter(filterPredicate).forEach((mesh) => {
          mesh.computeWorldMatrix(true);
          if (!mesh.subMeshes || mesh.subMeshes.length === 0 || mesh.infiniteDistance) {
            return;
          }
          const boundingInfo = mesh.getBoundingInfo();
          const minBox = boundingInfo.boundingBox.minimumWorld;
          const maxBox = boundingInfo.boundingBox.maximumWorld;
          Vector3.CheckExtends(minBox, min, max);
          Vector3.CheckExtends(maxBox, min, max);
        });
        return {
          min,
          max
        };
      }
      createPickingRay(x, y, world, camera, cameraViewSpace = false) {
        throw _WarnImport("Ray");
      }
      createPickingRayToRef(x, y, world, result, camera, cameraViewSpace = false, enableDistantPicking = false) {
        throw _WarnImport("Ray");
      }
      createPickingRayInCameraSpace(x, y, camera) {
        throw _WarnImport("Ray");
      }
      createPickingRayInCameraSpaceToRef(x, y, result, camera) {
        throw _WarnImport("Ray");
      }
      get _pickingAvailable() {
        return false;
      }
      pick(x, y, predicate, fastCheck, camera, trianglePredicate) {
        return new PickingInfo();
      }
      pickWithBoundingInfo(x, y, predicate, fastCheck, camera) {
        return new PickingInfo();
      }
      pickWithRay(ray, predicate, fastCheck, trianglePredicate) {
        throw _WarnImport("Ray");
      }
      multiPick(x, y, predicate, camera, trianglePredicate) {
        throw _WarnImport("Ray");
      }
      multiPickWithRay(ray, predicate, trianglePredicate) {
        throw _WarnImport("Ray");
      }
      setPointerOverMesh(mesh, pointerId, pickResult) {
        this._inputManager.setPointerOverMesh(mesh, pointerId, pickResult);
      }
      getPointerOverMesh() {
        return this._inputManager.getPointerOverMesh();
      }
      _rebuildGeometries() {
        for (const geometry of this.geometries) {
          geometry._rebuild();
        }
        for (const mesh of this.meshes) {
          mesh._rebuild();
        }
        if (this.postProcessManager) {
          this.postProcessManager._rebuild();
        }
        for (const component of this._components) {
          component.rebuild();
        }
        for (const system of this.particleSystems) {
          system.rebuild();
        }
        if (this.spriteManagers) {
          for (const spriteMgr of this.spriteManagers) {
            spriteMgr.rebuild();
          }
        }
      }
      _rebuildTextures() {
        for (const texture of this.textures) {
          texture._rebuild();
        }
        this.markAllMaterialsAsDirty(1);
      }
      _getByTags(list, tagsQuery, forEach) {
        if (tagsQuery === void 0) {
          return list;
        }
        const listByTags = [];
        forEach = forEach || ((item) => {
          return;
        });
        for (const i in list) {
          const item = list[i];
          if (Tags && Tags.MatchesQuery(item, tagsQuery)) {
            listByTags.push(item);
            forEach(item);
          }
        }
        return listByTags;
      }
      getMeshesByTags(tagsQuery, forEach) {
        return this._getByTags(this.meshes, tagsQuery, forEach);
      }
      getCamerasByTags(tagsQuery, forEach) {
        return this._getByTags(this.cameras, tagsQuery, forEach);
      }
      getLightsByTags(tagsQuery, forEach) {
        return this._getByTags(this.lights, tagsQuery, forEach);
      }
      getMaterialByTags(tagsQuery, forEach) {
        return this._getByTags(this.materials, tagsQuery, forEach).concat(this._getByTags(this.multiMaterials, tagsQuery, forEach));
      }
      getTransformNodesByTags(tagsQuery, forEach) {
        return this._getByTags(this.transformNodes, tagsQuery, forEach);
      }
      setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
      }
      setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth = true, stencil = true) {
        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil, depth, stencil);
      }
      getAutoClearDepthStencilSetup(index) {
        return this._renderingManager.getAutoClearDepthStencilSetup(index);
      }
      get blockMaterialDirtyMechanism() {
        return this._blockMaterialDirtyMechanism;
      }
      set blockMaterialDirtyMechanism(value) {
        if (this._blockMaterialDirtyMechanism === value) {
          return;
        }
        this._blockMaterialDirtyMechanism = value;
        if (!value) {
          this.markAllMaterialsAsDirty(63);
        }
      }
      markAllMaterialsAsDirty(flag, predicate) {
        if (this._blockMaterialDirtyMechanism) {
          return;
        }
        for (const material of this.materials) {
          if (predicate && !predicate(material)) {
            continue;
          }
          material.markAsDirty(flag);
        }
      }
      _loadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
        const request = LoadFile(fileOrUrl, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
        this._activeRequests.push(request);
        request.onCompleteObservable.add((request2) => {
          this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
        });
        return request;
      }
      _loadFileAsync(fileOrUrl, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
        return new Promise((resolve, reject) => {
          this._loadFile(fileOrUrl, (data) => {
            resolve(data);
          }, onProgress, useOfflineSupport, useArrayBuffer, (request, exception) => {
            reject(exception);
          }, onOpened);
        });
      }
      _requestFile(url, onSuccess, onProgress, useOfflineSupport, useArrayBuffer, onError, onOpened) {
        const request = RequestFile(url, onSuccess, onProgress, useOfflineSupport ? this.offlineProvider : void 0, useArrayBuffer, onError, onOpened);
        this._activeRequests.push(request);
        request.onCompleteObservable.add((request2) => {
          this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
        });
        return request;
      }
      _requestFileAsync(url, onProgress, useOfflineSupport, useArrayBuffer, onOpened) {
        return new Promise((resolve, reject) => {
          this._requestFile(url, (data) => {
            resolve(data);
          }, onProgress, useOfflineSupport, useArrayBuffer, (error) => {
            reject(error);
          }, onOpened);
        });
      }
      _readFile(file, onSuccess, onProgress, useArrayBuffer, onError) {
        const request = ReadFile(file, onSuccess, onProgress, useArrayBuffer, onError);
        this._activeRequests.push(request);
        request.onCompleteObservable.add((request2) => {
          this._activeRequests.splice(this._activeRequests.indexOf(request2), 1);
        });
        return request;
      }
      _readFileAsync(file, onProgress, useArrayBuffer) {
        return new Promise((resolve, reject) => {
          this._readFile(file, (data) => {
            resolve(data);
          }, onProgress, useArrayBuffer, (error) => {
            reject(error);
          });
        });
      }
      getPerfCollector() {
        throw _WarnImport("performanceViewerSceneExtension");
      }
      setActiveCameraByID(id) {
        return this.setActiveCameraById(id);
      }
      getMaterialByID(id) {
        return this.getMaterialById(id);
      }
      getLastMaterialByID(id) {
        return this.getLastMaterialById(id);
      }
      getTextureByUniqueID(uniqueId) {
        return this.getTextureByUniqueId(uniqueId);
      }
      getCameraByID(id) {
        return this.getCameraById(id);
      }
      getCameraByUniqueID(uniqueId) {
        return this.getCameraByUniqueId(uniqueId);
      }
      getBoneByID(id) {
        return this.getBoneById(id);
      }
      getLightByID(id) {
        return this.getLightById(id);
      }
      getLightByUniqueID(uniqueId) {
        return this.getLightByUniqueId(uniqueId);
      }
      getParticleSystemByID(id) {
        return this.getParticleSystemById(id);
      }
      getGeometryByID(id) {
        return this.getGeometryById(id);
      }
      getMeshByID(id) {
        return this.getMeshById(id);
      }
      getMeshByUniqueID(uniqueId) {
        return this.getMeshByUniqueId(uniqueId);
      }
      getLastMeshByID(id) {
        return this.getLastMeshById(id);
      }
      getMeshesByID(id) {
        return this.getMeshesById(id);
      }
      getTransformNodeByID(id) {
        return this.getTransformNodeById(id);
      }
      getTransformNodeByUniqueID(uniqueId) {
        return this.getTransformNodeByUniqueId(uniqueId);
      }
      getTransformNodesByID(id) {
        return this.getTransformNodesById(id);
      }
      getNodeByID(id) {
        return this.getNodeById(id);
      }
      getLastEntryByID(id) {
        return this.getLastEntryById(id);
      }
      getLastSkeletonByID(id) {
        return this.getLastSkeletonById(id);
      }
    };
    Scene.FOGMODE_NONE = 0;
    Scene.FOGMODE_EXP = 1;
    Scene.FOGMODE_EXP2 = 2;
    Scene.FOGMODE_LINEAR = 3;
    Scene.MinDeltaTime = 1;
    Scene.MaxDeltaTime = 1e3;
  }
});

export {
  AbstractScene,
  init_abstractScene,
  AbstractActionManager,
  init_abstractActionManager,
  Color3,
  Color4,
  TmpColors,
  init_math_color,
  ActionEvent,
  init_actionEvent,
  Logger,
  init_logger,
  DeepCopier,
  init_deepCopier,
  AndOrNotEvaluator,
  init_andOrNotEvaluator,
  Tags,
  init_tags,
  _WarnImport,
  init_devTools,
  expandToProperty,
  serialize,
  serializeAsTexture,
  serializeAsColor3,
  serializeAsFresnelParameters,
  serializeAsVector2,
  serializeAsVector3,
  serializeAsMeshReference,
  serializeAsColorCurves,
  serializeAsColor4,
  serializeAsImageProcessingConfiguration,
  serializeAsQuaternion,
  serializeAsMatrix,
  serializeAsCameraReference,
  SerializationHelper,
  nativeOverride,
  init_decorators,
  __decorate,
  init_tslib_es6,
  WebRequest,
  init_webRequest,
  IsWindowObjectExist,
  IsNavigatorAvailable,
  IsDocumentAvailable,
  GetDOMTextContent,
  DomManagement,
  init_domManagement,
  PrecisionDate,
  init_precisionDate,
  FilesInputStore,
  init_filesInputStore,
  RetryStrategy,
  init_retryStrategy,
  BaseError,
  ErrorCodes,
  RuntimeError,
  init_error,
  EndsWith,
  StartsWith,
  Decode,
  EncodeArrayBufferToBase64,
  DecodeBase64ToString,
  DecodeBase64ToBinary,
  PadNumber,
  StringTools,
  init_stringTools,
  ShaderLanguage,
  init_shaderLanguage,
  ShaderProcessor,
  init_shaderProcessor,
  ShaderStore,
  init_shaderStore,
  Effect,
  init_effect,
  DepthCullingState,
  init_depthCullingState,
  StencilState,
  init_stencilState,
  AlphaState,
  init_alphaCullingState,
  TextureSampler,
  init_textureSampler,
  InternalTextureSource,
  InternalTexture,
  init_internalTexture,
  WebGL2ShaderProcessor,
  init_webGL2ShaderProcessors,
  DataBuffer,
  init_dataBuffer,
  WebGLDataBuffer,
  init_webGLDataBuffer,
  WebGLPipelineContext,
  init_webGLPipelineContext,
  WebGLHardwareTexture,
  init_webGLHardwareTexture,
  DrawWrapper,
  init_drawWrapper,
  StencilStateComposer,
  init_stencilStateComposer,
  ThinEngine,
  init_thinEngine,
  TimingTools,
  init_timingTools,
  LoadFileError,
  RequestFileError,
  ReadFileError,
  FileToolsOptions,
  SetCorsBehavior,
  LoadImage,
  ReadFile,
  LoadFile,
  RequestFile,
  IsFileURL,
  IsBase64DataUrl,
  TestBase64DataUrl,
  DecodeBase64UrlToBinary,
  DecodeBase64UrlToString,
  FileTools,
  _injectLTSFileTools,
  init_fileTools,
  InstantiationTools,
  init_instantiationTools,
  RandomGUID,
  GUID,
  init_guid,
  Tools,
  className,
  AsyncLoop,
  init_tools,
  SmartArray,
  SmartArrayNoDuplicate,
  init_smartArray,
  StringDictionary,
  init_stringDictionary,
  MaterialDefines,
  init_materialDefines,
  ColorCurves,
  init_colorCurves,
  ImageProcessingConfigurationDefines,
  ImageProcessingConfiguration,
  init_imageProcessingConfiguration,
  init_engine_uniformBuffer,
  UniformBuffer,
  init_uniformBuffer,
  Buffer,
  VertexBuffer,
  init_buffer,
  PickingInfo,
  init_pickingInfo,
  PostProcessManager,
  init_postProcessManager,
  RenderingGroup,
  init_renderingGroup,
  RenderingGroupInfo,
  RenderingManager,
  init_renderingManager,
  SceneComponentConstants,
  Stage,
  init_sceneComponent,
  PointerEventTypes,
  PointerInfoBase,
  PointerInfoPre,
  PointerInfo,
  init_pointerEvents,
  KeyboardEventTypes,
  KeyboardInfo,
  KeyboardInfoPre,
  init_keyboardEvents,
  DeviceType,
  PointerInput,
  NativePointerInput,
  DualShockInput,
  DualSenseInput,
  XboxInput,
  SwitchInput,
  init_deviceEnums,
  DeviceInputEventType,
  EventConstants,
  init_deviceInputEvents,
  DeviceSource,
  init_deviceSource,
  DeviceSourceManager,
  init_deviceSourceManager,
  PerfCounter,
  init_perfCounter,
  Plane,
  init_math_plane,
  Frustum,
  init_math_frustum,
  UniqueIdGenerator,
  init_uniqueIdGenerator,
  LightConstants,
  init_lightConstants,
  ScenePerformancePriority,
  Scene,
  init_scene
};
//# sourceMappingURL=chunk-YCJ6WHUD.js.map
