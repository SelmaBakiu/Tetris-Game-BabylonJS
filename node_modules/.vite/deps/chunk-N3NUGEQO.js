var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __esm = (fn, res) => function __init() {
  return fn && (res = (0, fn[__getOwnPropNames(fn)[0]])(fn = 0)), res;
};
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/@babylonjs/core/Maths/math.scalar.js
var Scalar;
var init_math_scalar = __esm({
  "node_modules/@babylonjs/core/Maths/math.scalar.js"() {
    Scalar = class {
      static WithinEpsilon(a, b, epsilon = 1401298e-51) {
        return Math.abs(a - b) <= epsilon;
      }
      static ToHex(i) {
        const str = i.toString(16);
        if (i <= 15) {
          return ("0" + str).toUpperCase();
        }
        return str.toUpperCase();
      }
      static Sign(value) {
        value = +value;
        if (value === 0 || isNaN(value)) {
          return value;
        }
        return value > 0 ? 1 : -1;
      }
      static Clamp(value, min = 0, max = 1) {
        return Math.min(max, Math.max(min, value));
      }
      static Log2(value) {
        return Math.log(value) * Math.LOG2E;
      }
      static ILog2(value) {
        if (Math.log2) {
          return Math.floor(Math.log2(value));
        }
        if (value < 0) {
          return NaN;
        } else if (value === 0) {
          return -Infinity;
        }
        let n = 0;
        if (value < 1) {
          while (value < 1) {
            n++;
            value = value * 2;
          }
          n = -n;
        } else if (value > 1) {
          while (value > 1) {
            n++;
            value = Math.floor(value / 2);
          }
        }
        return n;
      }
      static Repeat(value, length) {
        return value - Math.floor(value / length) * length;
      }
      static Normalize(value, min, max) {
        return (value - min) / (max - min);
      }
      static Denormalize(normalized, min, max) {
        return normalized * (max - min) + min;
      }
      static DeltaAngle(current, target) {
        let num = Scalar.Repeat(target - current, 360);
        if (num > 180) {
          num -= 360;
        }
        return num;
      }
      static PingPong(tx, length) {
        const t = Scalar.Repeat(tx, length * 2);
        return length - Math.abs(t - length);
      }
      static SmoothStep(from, to, tx) {
        let t = Scalar.Clamp(tx);
        t = -2 * t * t * t + 3 * t * t;
        return to * t + from * (1 - t);
      }
      static MoveTowards(current, target, maxDelta) {
        let result = 0;
        if (Math.abs(target - current) <= maxDelta) {
          result = target;
        } else {
          result = current + Scalar.Sign(target - current) * maxDelta;
        }
        return result;
      }
      static MoveTowardsAngle(current, target, maxDelta) {
        const num = Scalar.DeltaAngle(current, target);
        let result = 0;
        if (-maxDelta < num && num < maxDelta) {
          result = target;
        } else {
          target = current + num;
          result = Scalar.MoveTowards(current, target, maxDelta);
        }
        return result;
      }
      static Lerp(start, end, amount) {
        return start + (end - start) * amount;
      }
      static LerpAngle(start, end, amount) {
        let num = Scalar.Repeat(end - start, 360);
        if (num > 180) {
          num -= 360;
        }
        return start + num * Scalar.Clamp(amount);
      }
      static InverseLerp(a, b, value) {
        let result = 0;
        if (a != b) {
          result = Scalar.Clamp((value - a) / (b - a));
        } else {
          result = 0;
        }
        return result;
      }
      static Hermite(value1, tangent1, value2, tangent2, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const part1 = 2 * cubed - 3 * squared + 1;
        const part2 = -2 * cubed + 3 * squared;
        const part3 = cubed - 2 * squared + amount;
        const part4 = cubed - squared;
        return value1 * part1 + value2 * part2 + tangent1 * part3 + tangent2 * part4;
      }
      static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
        const t2 = time * time;
        return (t2 - time) * 6 * value1 + (3 * t2 - 4 * time + 1) * tangent1 + (-t2 + time) * 6 * value2 + (3 * t2 - 2 * time) * tangent2;
      }
      static RandomRange(min, max) {
        if (min === max) {
          return min;
        }
        return Math.random() * (max - min) + min;
      }
      static RangeToPercent(number, min, max) {
        return (number - min) / (max - min);
      }
      static PercentToRange(percent, min, max) {
        return (max - min) * percent + min;
      }
      static NormalizeRadians(angle) {
        angle -= Scalar.TwoPi * Math.floor((angle + Math.PI) / Scalar.TwoPi);
        return angle;
      }
      static HCF(a, b) {
        const r = a % b;
        if (r === 0) {
          return b;
        }
        return Scalar.HCF(b, r);
      }
    };
    Scalar.TwoPi = Math.PI * 2;
  }
});

// node_modules/@babylonjs/core/Maths/math.constants.js
var ToGammaSpace, ToLinearSpace, PHI, Epsilon;
var init_math_constants = __esm({
  "node_modules/@babylonjs/core/Maths/math.constants.js"() {
    ToGammaSpace = 1 / 2.2;
    ToLinearSpace = 2.2;
    PHI = (1 + Math.sqrt(5)) / 2;
    Epsilon = 1e-3;
  }
});

// node_modules/@babylonjs/core/Misc/arrayTools.js
function _observeArrayfunction(object, functionName, callback) {
  const oldFunction = object[functionName];
  if (typeof oldFunction !== "function") {
    return null;
  }
  const newFunction = function() {
    const previousLength = object.length;
    const returnValue = newFunction.previous.apply(object, arguments);
    callback(functionName, previousLength);
    return returnValue;
  };
  oldFunction.next = newFunction;
  newFunction.previous = oldFunction;
  object[functionName] = newFunction;
  return () => {
    const previous = newFunction.previous;
    if (!previous) {
      return;
    }
    const next = newFunction.next;
    if (next) {
      previous.next = next;
      next.previous = previous;
    } else {
      previous.next = void 0;
      object[functionName] = previous;
    }
    newFunction.next = void 0;
    newFunction.previous = void 0;
  };
}
function _ObserveArray(array, callback) {
  const unObserveFunctions = observedArrayFunctions.map((name) => {
    return _observeArrayfunction(array, name, callback);
  });
  return () => {
    unObserveFunctions.forEach((unObserveFunction) => {
      unObserveFunction === null || unObserveFunction === void 0 ? void 0 : unObserveFunction();
    });
  };
}
var ArrayTools, observedArrayFunctions;
var init_arrayTools = __esm({
  "node_modules/@babylonjs/core/Misc/arrayTools.js"() {
    ArrayTools = class {
      static BuildArray(size, itemBuilder) {
        const a = [];
        for (let i = 0; i < size; ++i) {
          a.push(itemBuilder());
        }
        return a;
      }
      static BuildTuple(size, itemBuilder) {
        return ArrayTools.BuildArray(size, itemBuilder);
      }
    };
    observedArrayFunctions = ["push", "splice", "pop", "shift", "unshift"];
  }
});

// node_modules/@babylonjs/core/Misc/typeStore.js
function RegisterClass(className, type) {
  _RegisteredTypes[className] = type;
}
function GetClass(fqdn) {
  return _RegisteredTypes[fqdn];
}
var _RegisteredTypes;
var init_typeStore = __esm({
  "node_modules/@babylonjs/core/Misc/typeStore.js"() {
    _RegisteredTypes = {};
  }
});

// node_modules/@babylonjs/core/Engines/performanceConfigurator.js
var PerformanceConfigurator;
var init_performanceConfigurator = __esm({
  "node_modules/@babylonjs/core/Engines/performanceConfigurator.js"() {
    PerformanceConfigurator = class {
      static SetMatrixPrecision(use64bits) {
        PerformanceConfigurator.MatrixTrackPrecisionChange = false;
        if (use64bits && !PerformanceConfigurator.MatrixUse64Bits) {
          if (PerformanceConfigurator.MatrixTrackedMatrices) {
            for (let m = 0; m < PerformanceConfigurator.MatrixTrackedMatrices.length; ++m) {
              const matrix = PerformanceConfigurator.MatrixTrackedMatrices[m];
              const values = matrix._m;
              matrix._m = new Array(16);
              for (let i = 0; i < 16; ++i) {
                matrix._m[i] = values[i];
              }
            }
          }
        }
        PerformanceConfigurator.MatrixUse64Bits = use64bits;
        PerformanceConfigurator.MatrixCurrentType = PerformanceConfigurator.MatrixUse64Bits ? Array : Float32Array;
        PerformanceConfigurator.MatrixTrackedMatrices = null;
      }
    };
    PerformanceConfigurator.MatrixUse64Bits = false;
    PerformanceConfigurator.MatrixTrackPrecisionChange = true;
    PerformanceConfigurator.MatrixCurrentType = Float32Array;
    PerformanceConfigurator.MatrixTrackedMatrices = [];
  }
});

// node_modules/@babylonjs/core/Misc/observable.js
var EventState, Observer, Observable;
var init_observable = __esm({
  "node_modules/@babylonjs/core/Misc/observable.js"() {
    EventState = class {
      constructor(mask, skipNextObservers = false, target, currentTarget) {
        this.initialize(mask, skipNextObservers, target, currentTarget);
      }
      initialize(mask, skipNextObservers = false, target, currentTarget) {
        this.mask = mask;
        this.skipNextObservers = skipNextObservers;
        this.target = target;
        this.currentTarget = currentTarget;
        return this;
      }
    };
    Observer = class {
      constructor(callback, mask, scope = null) {
        this.callback = callback;
        this.mask = mask;
        this.scope = scope;
        this._willBeUnregistered = false;
        this.unregisterOnNextCall = false;
        this._remove = null;
      }
      remove() {
        if (this._remove) {
          this._remove();
        }
      }
    };
    Observable = class {
      static FromPromise(promise, onErrorObservable) {
        const observable = new Observable();
        promise.then((ret) => {
          observable.notifyObservers(ret);
        }).catch((err) => {
          if (onErrorObservable) {
            onErrorObservable.notifyObservers(err);
          } else {
            throw err;
          }
        });
        return observable;
      }
      get observers() {
        return this._observers;
      }
      constructor(onObserverAdded, notifyIfTriggered = false) {
        this.notifyIfTriggered = notifyIfTriggered;
        this._observers = new Array();
        this._numObserversMarkedAsDeleted = 0;
        this._hasNotified = false;
        this._eventState = new EventState(0);
        if (onObserverAdded) {
          this._onObserverAdded = onObserverAdded;
        }
      }
      add(callback, mask = -1, insertFirst = false, scope = null, unregisterOnFirstCall = false) {
        if (!callback) {
          return null;
        }
        const observer = new Observer(callback, mask, scope);
        observer.unregisterOnNextCall = unregisterOnFirstCall;
        if (insertFirst) {
          this._observers.unshift(observer);
        } else {
          this._observers.push(observer);
        }
        if (this._onObserverAdded) {
          this._onObserverAdded(observer);
        }
        if (this._hasNotified && this.notifyIfTriggered) {
          if (this._lastNotifiedValue !== void 0) {
            this.notifyObserver(observer, this._lastNotifiedValue);
          }
        }
        observer._remove = () => {
          this.remove(observer);
        };
        return observer;
      }
      addOnce(callback) {
        return this.add(callback, void 0, void 0, void 0, true);
      }
      remove(observer) {
        if (!observer) {
          return false;
        }
        observer._remove = null;
        const index = this._observers.indexOf(observer);
        if (index !== -1) {
          this._deferUnregister(observer);
          return true;
        }
        return false;
      }
      removeCallback(callback, scope) {
        for (let index = 0; index < this._observers.length; index++) {
          const observer = this._observers[index];
          if (observer._willBeUnregistered) {
            continue;
          }
          if (observer.callback === callback && (!scope || scope === observer.scope)) {
            this._deferUnregister(observer);
            return true;
          }
        }
        return false;
      }
      _deferUnregister(observer) {
        if (observer._willBeUnregistered) {
          return;
        }
        this._numObserversMarkedAsDeleted++;
        observer.unregisterOnNextCall = false;
        observer._willBeUnregistered = true;
        setTimeout(() => {
          this._remove(observer);
        }, 0);
      }
      _remove(observer, updateCounter = true) {
        if (!observer) {
          return false;
        }
        const index = this._observers.indexOf(observer);
        if (index !== -1) {
          if (updateCounter) {
            this._numObserversMarkedAsDeleted--;
          }
          this._observers.splice(index, 1);
          return true;
        }
        return false;
      }
      makeObserverTopPriority(observer) {
        this._remove(observer, false);
        this._observers.unshift(observer);
      }
      makeObserverBottomPriority(observer) {
        this._remove(observer, false);
        this._observers.push(observer);
      }
      notifyObservers(eventData, mask = -1, target, currentTarget, userInfo) {
        if (this.notifyIfTriggered) {
          this._hasNotified = true;
          this._lastNotifiedValue = eventData;
        }
        if (!this._observers.length) {
          return true;
        }
        const state = this._eventState;
        state.mask = mask;
        state.target = target;
        state.currentTarget = currentTarget;
        state.skipNextObservers = false;
        state.lastReturnValue = eventData;
        state.userInfo = userInfo;
        for (const obs of this._observers) {
          if (obs._willBeUnregistered) {
            continue;
          }
          if (obs.mask & mask) {
            if (obs.unregisterOnNextCall) {
              this._deferUnregister(obs);
            }
            if (obs.scope) {
              state.lastReturnValue = obs.callback.apply(obs.scope, [eventData, state]);
            } else {
              state.lastReturnValue = obs.callback(eventData, state);
            }
          }
          if (state.skipNextObservers) {
            return false;
          }
        }
        return true;
      }
      notifyObserver(observer, eventData, mask = -1) {
        if (this.notifyIfTriggered) {
          this._hasNotified = true;
          this._lastNotifiedValue = eventData;
        }
        if (observer._willBeUnregistered) {
          return;
        }
        const state = this._eventState;
        state.mask = mask;
        state.skipNextObservers = false;
        if (observer.unregisterOnNextCall) {
          this._deferUnregister(observer);
        }
        observer.callback(eventData, state);
      }
      hasObservers() {
        return this._observers.length - this._numObserversMarkedAsDeleted > 0;
      }
      clear() {
        while (this._observers.length) {
          const o = this._observers.pop();
          if (o) {
            o._remove = null;
          }
        }
        this._onObserverAdded = null;
        this._numObserversMarkedAsDeleted = 0;
        this.cleanLastNotifiedState();
      }
      cleanLastNotifiedState() {
        this._hasNotified = false;
        this._lastNotifiedValue = void 0;
      }
      clone() {
        const result = new Observable();
        result._observers = this._observers.slice(0);
        return result;
      }
      hasSpecificMask(mask = -1) {
        for (const obs of this._observers) {
          if (obs.mask & mask || obs.mask === mask) {
            return true;
          }
        }
        return false;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/engineStore.js
var EngineStore;
var init_engineStore = __esm({
  "node_modules/@babylonjs/core/Engines/engineStore.js"() {
    init_observable();
    EngineStore = class {
      static get LastCreatedEngine() {
        if (this.Instances.length === 0) {
          return null;
        }
        return this.Instances[this.Instances.length - 1];
      }
      static get LastCreatedScene() {
        return this._LastCreatedScene;
      }
    };
    EngineStore.Instances = new Array();
    EngineStore.OnEnginesDisposedObservable = new Observable();
    EngineStore._LastCreatedScene = null;
    EngineStore.UseFallbackTexture = true;
    EngineStore.FallbackTexture = "";
  }
});

// node_modules/@babylonjs/core/Maths/math.vector.js
var _ExtractAsInt, Vector2, Vector3, Vector4, Quaternion, Matrix, MathTmp, TmpVectors, mtxConvertNDCToHalfZRange;
var init_math_vector = __esm({
  "node_modules/@babylonjs/core/Maths/math.vector.js"() {
    init_math_scalar();
    init_math_constants();
    init_arrayTools();
    init_typeStore();
    init_performanceConfigurator();
    init_engineStore();
    _ExtractAsInt = (value) => {
      return parseInt(value.toString().replace(/\W/g, ""));
    };
    Vector2 = class {
      constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
      }
      toString() {
        return `{X: ${this.x} Y: ${this.y}}`;
      }
      getClassName() {
        return "Vector2";
      }
      getHashCode() {
        const x = _ExtractAsInt(this.x);
        const y = _ExtractAsInt(this.y);
        let hash = x;
        hash = hash * 397 ^ y;
        return hash;
      }
      toArray(array, index = 0) {
        array[index] = this.x;
        array[index + 1] = this.y;
        return this;
      }
      fromArray(array, index = 0) {
        Vector2.FromArrayToRef(array, index, this);
        return this;
      }
      asArray() {
        const result = new Array();
        this.toArray(result, 0);
        return result;
      }
      copyFrom(source) {
        this.x = source.x;
        this.y = source.y;
        return this;
      }
      copyFromFloats(x, y) {
        this.x = x;
        this.y = y;
        return this;
      }
      set(x, y) {
        return this.copyFromFloats(x, y);
      }
      add(otherVector) {
        return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
      }
      addToRef(otherVector, result) {
        result.x = this.x + otherVector.x;
        result.y = this.y + otherVector.y;
        return result;
      }
      addInPlace(otherVector) {
        this.x += otherVector.x;
        this.y += otherVector.y;
        return this;
      }
      addVector3(otherVector) {
        return new this.constructor(this.x + otherVector.x, this.y + otherVector.y);
      }
      subtract(otherVector) {
        return new this.constructor(this.x - otherVector.x, this.y - otherVector.y);
      }
      subtractToRef(otherVector, result) {
        result.x = this.x - otherVector.x;
        result.y = this.y - otherVector.y;
        return result;
      }
      subtractInPlace(otherVector) {
        this.x -= otherVector.x;
        this.y -= otherVector.y;
        return this;
      }
      multiplyInPlace(otherVector) {
        this.x *= otherVector.x;
        this.y *= otherVector.y;
        return this;
      }
      multiply(otherVector) {
        return new this.constructor(this.x * otherVector.x, this.y * otherVector.y);
      }
      multiplyToRef(otherVector, result) {
        result.x = this.x * otherVector.x;
        result.y = this.y * otherVector.y;
        return result;
      }
      multiplyByFloats(x, y) {
        return new this.constructor(this.x * x, this.y * y);
      }
      divide(otherVector) {
        return new this.constructor(this.x / otherVector.x, this.y / otherVector.y);
      }
      divideToRef(otherVector, result) {
        result.x = this.x / otherVector.x;
        result.y = this.y / otherVector.y;
        return result;
      }
      divideInPlace(otherVector) {
        return this.divideToRef(otherVector, this);
      }
      negate() {
        return new this.constructor(-this.x, -this.y);
      }
      negateInPlace() {
        this.x *= -1;
        this.y *= -1;
        return this;
      }
      negateToRef(result) {
        return result.copyFromFloats(this.x * -1, this.y * -1);
      }
      scaleInPlace(scale) {
        this.x *= scale;
        this.y *= scale;
        return this;
      }
      scale(scale) {
        const result = new this.constructor(0, 0);
        this.scaleToRef(scale, result);
        return result;
      }
      scaleToRef(scale, result) {
        result.x = this.x * scale;
        result.y = this.y * scale;
        return result;
      }
      scaleAndAddToRef(scale, result) {
        result.x += this.x * scale;
        result.y += this.y * scale;
        return result;
      }
      equals(otherVector) {
        return otherVector && this.x === otherVector.x && this.y === otherVector.y;
      }
      equalsWithEpsilon(otherVector, epsilon = Epsilon) {
        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon);
      }
      floor() {
        return new this.constructor(Math.floor(this.x), Math.floor(this.y));
      }
      fract() {
        return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y));
      }
      rotateToRef(angle, result) {
        const cos = Math.cos(angle);
        const sin = Math.sin(angle);
        const x = cos * this.x - sin * this.y;
        const y = sin * this.x + cos * this.y;
        result.x = x;
        result.y = y;
        return result;
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y);
      }
      lengthSquared() {
        return this.x * this.x + this.y * this.y;
      }
      normalize() {
        Vector2.NormalizeToRef(this, this);
        return this;
      }
      clone() {
        return new this.constructor(this.x, this.y);
      }
      static Zero() {
        return new Vector2(0, 0);
      }
      static One() {
        return new Vector2(1, 1);
      }
      static Random(min = 0, max = 1) {
        return new Vector2(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));
      }
      static get ZeroReadOnly() {
        return Vector2._ZeroReadOnly;
      }
      static FromArray(array, offset = 0) {
        return new Vector2(array[offset], array[offset + 1]);
      }
      static FromArrayToRef(array, offset, result) {
        result.x = array[offset];
        result.y = array[offset + 1];
        return result;
      }
      static CatmullRom(value1, value2, value3, value4, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const x = 0.5 * (2 * value2.x + (-value1.x + value3.x) * amount + (2 * value1.x - 5 * value2.x + 4 * value3.x - value4.x) * squared + (-value1.x + 3 * value2.x - 3 * value3.x + value4.x) * cubed);
        const y = 0.5 * (2 * value2.y + (-value1.y + value3.y) * amount + (2 * value1.y - 5 * value2.y + 4 * value3.y - value4.y) * squared + (-value1.y + 3 * value2.y - 3 * value3.y + value4.y) * cubed);
        return new value1.constructor(x, y);
      }
      static Clamp(value, min, max) {
        let x = value.x;
        x = x > max.x ? max.x : x;
        x = x < min.x ? min.x : x;
        let y = value.y;
        y = y > max.y ? max.y : y;
        y = y < min.y ? min.y : y;
        return new value.constructor(x, y);
      }
      static Hermite(value1, tangent1, value2, tangent2, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const part1 = 2 * cubed - 3 * squared + 1;
        const part2 = -2 * cubed + 3 * squared;
        const part3 = cubed - 2 * squared + amount;
        const part4 = cubed - squared;
        const x = value1.x * part1 + value2.x * part2 + tangent1.x * part3 + tangent2.x * part4;
        const y = value1.y * part1 + value2.y * part2 + tangent1.y * part3 + tangent2.y * part4;
        return new value1.constructor(x, y);
      }
      static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
        const result = new value1.constructor();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      }
      static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
        const t2 = time * time;
        result.x = (t2 - time) * 6 * value1.x + (3 * t2 - 4 * time + 1) * tangent1.x + (-t2 + time) * 6 * value2.x + (3 * t2 - 2 * time) * tangent2.x;
        result.y = (t2 - time) * 6 * value1.y + (3 * t2 - 4 * time + 1) * tangent1.y + (-t2 + time) * 6 * value2.y + (3 * t2 - 2 * time) * tangent2.y;
        return result;
      }
      static Lerp(start, end, amount) {
        const x = start.x + (end.x - start.x) * amount;
        const y = start.y + (end.y - start.y) * amount;
        return new start.constructor(x, y);
      }
      static Dot(left, right) {
        return left.x * right.x + left.y * right.y;
      }
      static Normalize(vector) {
        const newVector = new vector.constructor();
        this.NormalizeToRef(vector, newVector);
        return newVector;
      }
      static NormalizeToRef(vector, result) {
        const len = vector.length();
        if (len === 0) {
          return result;
        }
        result.x = vector.x / len;
        result.y = vector.y / len;
        return result;
      }
      static Minimize(left, right) {
        const x = left.x < right.x ? left.x : right.x;
        const y = left.y < right.y ? left.y : right.y;
        return new left.constructor(x, y);
      }
      static Maximize(left, right) {
        const x = left.x > right.x ? left.x : right.x;
        const y = left.y > right.y ? left.y : right.y;
        return new left.constructor(x, y);
      }
      static Transform(vector, transformation) {
        const result = new vector.constructor();
        Vector2.TransformToRef(vector, transformation, result);
        return result;
      }
      static TransformToRef(vector, transformation, result) {
        const m = transformation.m;
        const x = vector.x * m[0] + vector.y * m[4] + m[12];
        const y = vector.x * m[1] + vector.y * m[5] + m[13];
        result.x = x;
        result.y = y;
        return result;
      }
      static PointInTriangle(p, p0, p1, p2) {
        const a = 1 / 2 * (-p1.y * p2.x + p0.y * (-p1.x + p2.x) + p0.x * (p1.y - p2.y) + p1.x * p2.y);
        const sign = a < 0 ? -1 : 1;
        const s = (p0.y * p2.x - p0.x * p2.y + (p2.y - p0.y) * p.x + (p0.x - p2.x) * p.y) * sign;
        const t = (p0.x * p1.y - p0.y * p1.x + (p0.y - p1.y) * p.x + (p1.x - p0.x) * p.y) * sign;
        return s > 0 && t > 0 && s + t < 2 * a * sign;
      }
      static Distance(value1, value2) {
        return Math.sqrt(Vector2.DistanceSquared(value1, value2));
      }
      static DistanceSquared(value1, value2) {
        const x = value1.x - value2.x;
        const y = value1.y - value2.y;
        return x * x + y * y;
      }
      static Center(value1, value2) {
        const result = new value1.constructor();
        return Vector2.CenterToRef(value1, value2, result);
      }
      static CenterToRef(value1, value2, ref) {
        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2);
      }
      static DistanceOfPointFromSegment(p, segA, segB) {
        const l2 = Vector2.DistanceSquared(segA, segB);
        if (l2 === 0) {
          return Vector2.Distance(p, segA);
        }
        const v = segB.subtract(segA);
        const t = Math.max(0, Math.min(1, Vector2.Dot(p.subtract(segA), v) / l2));
        const proj = segA.add(v.multiplyByFloats(t, t));
        return Vector2.Distance(p, proj);
      }
    };
    Vector2._ZeroReadOnly = Vector2.Zero();
    Vector3 = class {
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._isDirty = true;
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._isDirty = true;
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._isDirty = true;
      }
      constructor(x = 0, y = 0, z = 0) {
        this._isDirty = true;
        this._x = x;
        this._y = y;
        this._z = z;
      }
      toString() {
        return `{X: ${this._x} Y: ${this._y} Z: ${this._z}}`;
      }
      getClassName() {
        return "Vector3";
      }
      getHashCode() {
        const x = _ExtractAsInt(this._x);
        const y = _ExtractAsInt(this._y);
        const z = _ExtractAsInt(this._z);
        let hash = x;
        hash = hash * 397 ^ y;
        hash = hash * 397 ^ z;
        return hash;
      }
      asArray() {
        const result = [];
        this.toArray(result, 0);
        return result;
      }
      toArray(array, index = 0) {
        array[index] = this._x;
        array[index + 1] = this._y;
        array[index + 2] = this._z;
        return this;
      }
      fromArray(array, index = 0) {
        Vector3.FromArrayToRef(array, index, this);
        return this;
      }
      toQuaternion() {
        return Quaternion.RotationYawPitchRoll(this._y, this._x, this._z);
      }
      addInPlace(otherVector) {
        return this.addInPlaceFromFloats(otherVector._x, otherVector._y, otherVector._z);
      }
      addInPlaceFromFloats(x, y, z) {
        this._x += x;
        this._y += y;
        this._z += z;
        this._isDirty = true;
        return this;
      }
      add(otherVector) {
        return new this.constructor(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
      }
      addToRef(otherVector, result) {
        return result.copyFromFloats(this._x + otherVector._x, this._y + otherVector._y, this._z + otherVector._z);
      }
      subtractInPlace(otherVector) {
        this._x -= otherVector._x;
        this._y -= otherVector._y;
        this._z -= otherVector._z;
        this._isDirty = true;
        return this;
      }
      subtract(otherVector) {
        return new this.constructor(this._x - otherVector._x, this._y - otherVector._y, this._z - otherVector._z);
      }
      subtractToRef(otherVector, result) {
        return this.subtractFromFloatsToRef(otherVector._x, otherVector._y, otherVector._z, result);
      }
      subtractFromFloats(x, y, z) {
        return new this.constructor(this._x - x, this._y - y, this._z - z);
      }
      subtractFromFloatsToRef(x, y, z, result) {
        return result.copyFromFloats(this._x - x, this._y - y, this._z - z);
      }
      negate() {
        return new this.constructor(-this._x, -this._y, -this._z);
      }
      negateInPlace() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._isDirty = true;
        return this;
      }
      negateToRef(result) {
        return result.copyFromFloats(this._x * -1, this._y * -1, this._z * -1);
      }
      scaleInPlace(scale) {
        this._x *= scale;
        this._y *= scale;
        this._z *= scale;
        this._isDirty = true;
        return this;
      }
      scale(scale) {
        return new this.constructor(this._x * scale, this._y * scale, this._z * scale);
      }
      scaleToRef(scale, result) {
        return result.copyFromFloats(this._x * scale, this._y * scale, this._z * scale);
      }
      getNormalToRef(result) {
        const radius = this.length();
        let theta = Math.acos(this.y / radius);
        const phi = Math.atan2(this.z, this.x);
        if (theta > Math.PI / 2) {
          theta -= Math.PI / 2;
        } else {
          theta += Math.PI / 2;
        }
        const x = radius * Math.sin(theta) * Math.cos(phi);
        const y = radius * Math.cos(theta);
        const z = radius * Math.sin(theta) * Math.sin(phi);
        result.set(x, y, z);
        return result;
      }
      applyRotationQuaternionToRef(q, result) {
        const vx = this._x, vy = this._y, vz = this._z;
        const qx = q._x, qy = q._y, qz = q._z, qw = q._w;
        const tx = 2 * (qy * vz - qz * vy);
        const ty = 2 * (qz * vx - qx * vz);
        const tz = 2 * (qx * vy - qy * vx);
        result._x = vx + qw * tx + qy * tz - qz * ty;
        result._y = vy + qw * ty + qz * tx - qx * tz;
        result._z = vz + qw * tz + qx * ty - qy * tx;
        result._isDirty = true;
        return result;
      }
      applyRotationQuaternionInPlace(q) {
        return this.applyRotationQuaternionToRef(q, this);
      }
      applyRotationQuaternion(q) {
        return this.applyRotationQuaternionToRef(q, new this.constructor());
      }
      scaleAndAddToRef(scale, result) {
        return result.addInPlaceFromFloats(this._x * scale, this._y * scale, this._z * scale);
      }
      projectOnPlane(plane, origin) {
        const result = new this.constructor();
        this.projectOnPlaneToRef(plane, origin, result);
        return result;
      }
      projectOnPlaneToRef(plane, origin, result) {
        const n = plane.normal;
        const d = plane.d;
        const V = MathTmp.Vector3[0];
        this.subtractToRef(origin, V);
        V.normalize();
        const denom = Vector3.Dot(V, n);
        if (Math.abs(denom) < Math.pow(10, -10)) {
          result.setAll(Infinity);
        } else {
          const t = -(Vector3.Dot(origin, n) + d) / denom;
          const scaledV = V.scaleInPlace(t);
          origin.addToRef(scaledV, result);
        }
        return result;
      }
      equals(otherVector) {
        return otherVector && this._x === otherVector._x && this._y === otherVector._y && this._z === otherVector._z;
      }
      equalsWithEpsilon(otherVector, epsilon = Epsilon) {
        return otherVector && Scalar.WithinEpsilon(this._x, otherVector._x, epsilon) && Scalar.WithinEpsilon(this._y, otherVector._y, epsilon) && Scalar.WithinEpsilon(this._z, otherVector._z, epsilon);
      }
      equalsToFloats(x, y, z) {
        return this._x === x && this._y === y && this._z === z;
      }
      multiplyInPlace(otherVector) {
        this._x *= otherVector._x;
        this._y *= otherVector._y;
        this._z *= otherVector._z;
        this._isDirty = true;
        return this;
      }
      multiply(otherVector) {
        return this.multiplyByFloats(otherVector._x, otherVector._y, otherVector._z);
      }
      multiplyToRef(otherVector, result) {
        return result.copyFromFloats(this._x * otherVector._x, this._y * otherVector._y, this._z * otherVector._z);
      }
      multiplyByFloats(x, y, z) {
        return new this.constructor(this._x * x, this._y * y, this._z * z);
      }
      divide(otherVector) {
        return new this.constructor(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
      }
      divideToRef(otherVector, result) {
        return result.copyFromFloats(this._x / otherVector._x, this._y / otherVector._y, this._z / otherVector._z);
      }
      divideInPlace(otherVector) {
        return this.divideToRef(otherVector, this);
      }
      minimizeInPlace(other) {
        return this.minimizeInPlaceFromFloats(other._x, other._y, other._z);
      }
      maximizeInPlace(other) {
        return this.maximizeInPlaceFromFloats(other._x, other._y, other._z);
      }
      minimizeInPlaceFromFloats(x, y, z) {
        if (x < this._x) {
          this.x = x;
        }
        if (y < this._y) {
          this.y = y;
        }
        if (z < this._z) {
          this.z = z;
        }
        return this;
      }
      maximizeInPlaceFromFloats(x, y, z) {
        if (x > this._x) {
          this.x = x;
        }
        if (y > this._y) {
          this.y = y;
        }
        if (z > this._z) {
          this.z = z;
        }
        return this;
      }
      isNonUniformWithinEpsilon(epsilon) {
        const absX = Math.abs(this._x);
        const absY = Math.abs(this._y);
        if (!Scalar.WithinEpsilon(absX, absY, epsilon)) {
          return true;
        }
        const absZ = Math.abs(this._z);
        if (!Scalar.WithinEpsilon(absX, absZ, epsilon)) {
          return true;
        }
        if (!Scalar.WithinEpsilon(absY, absZ, epsilon)) {
          return true;
        }
        return false;
      }
      get isNonUniform() {
        const absX = Math.abs(this._x);
        const absY = Math.abs(this._y);
        if (absX !== absY) {
          return true;
        }
        const absZ = Math.abs(this._z);
        if (absX !== absZ) {
          return true;
        }
        return false;
      }
      floor() {
        return new this.constructor(Math.floor(this._x), Math.floor(this._y), Math.floor(this._z));
      }
      fract() {
        return new this.constructor(this._x - Math.floor(this._x), this._y - Math.floor(this._y), this._z - Math.floor(this._z));
      }
      length() {
        return Math.sqrt(this._x * this._x + this._y * this._y + this._z * this._z);
      }
      lengthSquared() {
        return this._x * this._x + this._y * this._y + this._z * this._z;
      }
      get hasAZeroComponent() {
        return this._x * this._y * this._z === 0;
      }
      normalize() {
        return this.normalizeFromLength(this.length());
      }
      reorderInPlace(order) {
        order = order.toLowerCase();
        if (order === "xyz") {
          return this;
        }
        MathTmp.Vector3[0].copyFrom(this);
        ["x", "y", "z"].forEach((val, i) => {
          this[val] = MathTmp.Vector3[0][order[i]];
        });
        return this;
      }
      rotateByQuaternionToRef(quaternion, result) {
        quaternion.toRotationMatrix(MathTmp.Matrix[0]);
        Vector3.TransformCoordinatesToRef(this, MathTmp.Matrix[0], result);
        return result;
      }
      rotateByQuaternionAroundPointToRef(quaternion, point, result) {
        this.subtractToRef(point, MathTmp.Vector3[0]);
        MathTmp.Vector3[0].rotateByQuaternionToRef(quaternion, MathTmp.Vector3[0]);
        point.addToRef(MathTmp.Vector3[0], result);
        return result;
      }
      cross(other) {
        const result = new this.constructor();
        return Vector3.CrossToRef(this, other, result);
      }
      normalizeFromLength(len) {
        if (len === 0 || len === 1) {
          return this;
        }
        return this.scaleInPlace(1 / len);
      }
      normalizeToNew() {
        const normalized = new this.constructor(0, 0, 0);
        this.normalizeToRef(normalized);
        return normalized;
      }
      normalizeToRef(reference) {
        const len = this.length();
        if (len === 0 || len === 1) {
          return reference.copyFromFloats(this._x, this._y, this._z);
        }
        return this.scaleToRef(1 / len, reference);
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z);
      }
      copyFrom(source) {
        return this.copyFromFloats(source._x, source._y, source._z);
      }
      copyFromFloats(x, y, z) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._isDirty = true;
        return this;
      }
      set(x, y, z) {
        return this.copyFromFloats(x, y, z);
      }
      setAll(v) {
        this._x = this._y = this._z = v;
        this._isDirty = true;
        return this;
      }
      static GetClipFactor(vector0, vector1, axis, size) {
        const d0 = Vector3.Dot(vector0, axis) - size;
        const d1 = Vector3.Dot(vector1, axis) - size;
        const s = d0 / (d0 - d1);
        return s;
      }
      static GetAngleBetweenVectors(vector0, vector1, normal) {
        const v0 = vector0.normalizeToRef(MathTmp.Vector3[1]);
        const v1 = vector1.normalizeToRef(MathTmp.Vector3[2]);
        let dot = Vector3.Dot(v0, v1);
        dot = Scalar.Clamp(dot, -1, 1);
        const angle = Math.acos(dot);
        const n = MathTmp.Vector3[3];
        Vector3.CrossToRef(v0, v1, n);
        if (Vector3.Dot(n, normal) > 0) {
          return isNaN(angle) ? 0 : angle;
        }
        return isNaN(angle) ? -Math.PI : -Math.acos(dot);
      }
      static GetAngleBetweenVectorsOnPlane(vector0, vector1, normal) {
        MathTmp.Vector3[0].copyFrom(vector0);
        const v0 = MathTmp.Vector3[0];
        MathTmp.Vector3[1].copyFrom(vector1);
        const v1 = MathTmp.Vector3[1];
        MathTmp.Vector3[2].copyFrom(normal);
        const vNormal = MathTmp.Vector3[2];
        const right = MathTmp.Vector3[3];
        const forward = MathTmp.Vector3[4];
        v0.normalize();
        v1.normalize();
        vNormal.normalize();
        Vector3.CrossToRef(vNormal, v0, right);
        Vector3.CrossToRef(right, vNormal, forward);
        const angle = Math.atan2(Vector3.Dot(v1, right), Vector3.Dot(v1, forward));
        return Scalar.NormalizeRadians(angle);
      }
      static PitchYawRollToMoveBetweenPointsToRef(start, target, ref) {
        const diff = TmpVectors.Vector3[0];
        target.subtractToRef(start, diff);
        ref._y = Math.atan2(diff.x, diff.z) || 0;
        ref._x = Math.atan2(Math.sqrt(diff.x ** 2 + diff.z ** 2), diff.y) || 0;
        ref._z = 0;
        ref._isDirty = true;
        return ref;
      }
      static PitchYawRollToMoveBetweenPoints(start, target) {
        const ref = Vector3.Zero();
        return Vector3.PitchYawRollToMoveBetweenPointsToRef(start, target, ref);
      }
      static SlerpToRef(vector0, vector1, slerp, result) {
        slerp = Scalar.Clamp(slerp, 0, 1);
        const vector0Dir = MathTmp.Vector3[0];
        const vector1Dir = MathTmp.Vector3[1];
        vector0Dir.copyFrom(vector0);
        const vector0Length = vector0Dir.length();
        vector0Dir.normalizeFromLength(vector0Length);
        vector1Dir.copyFrom(vector1);
        const vector1Length = vector1Dir.length();
        vector1Dir.normalizeFromLength(vector1Length);
        const dot = Vector3.Dot(vector0Dir, vector1Dir);
        let scale0;
        let scale1;
        if (dot < 1 - Epsilon) {
          const omega = Math.acos(dot);
          const invSin = 1 / Math.sin(omega);
          scale0 = Math.sin((1 - slerp) * omega) * invSin;
          scale1 = Math.sin(slerp * omega) * invSin;
        } else {
          scale0 = 1 - slerp;
          scale1 = slerp;
        }
        vector0Dir.scaleInPlace(scale0);
        vector1Dir.scaleInPlace(scale1);
        result.copyFrom(vector0Dir).addInPlace(vector1Dir);
        result.scaleInPlace(Scalar.Lerp(vector0Length, vector1Length, slerp));
        return result;
      }
      static SmoothToRef(source, goal, deltaTime, lerpTime, result) {
        Vector3.SlerpToRef(source, goal, lerpTime === 0 ? 1 : deltaTime / lerpTime, result);
        return result;
      }
      static FromArray(array, offset = 0) {
        return new Vector3(array[offset], array[offset + 1], array[offset + 2]);
      }
      static FromFloatArray(array, offset) {
        return Vector3.FromArray(array, offset);
      }
      static FromArrayToRef(array, offset, result) {
        result._x = array[offset];
        result._y = array[offset + 1];
        result._z = array[offset + 2];
        result._isDirty = true;
        return result;
      }
      static FromFloatArrayToRef(array, offset, result) {
        return Vector3.FromArrayToRef(array, offset, result);
      }
      static FromFloatsToRef(x, y, z, result) {
        result.copyFromFloats(x, y, z);
        return result;
      }
      static Zero() {
        return new Vector3(0, 0, 0);
      }
      static One() {
        return new Vector3(1, 1, 1);
      }
      static Up() {
        return new Vector3(0, 1, 0);
      }
      static get UpReadOnly() {
        return Vector3._UpReadOnly;
      }
      static get DownReadOnly() {
        return Vector3._DownReadOnly;
      }
      static get RightReadOnly() {
        return Vector3._RightReadOnly;
      }
      static get LeftReadOnly() {
        return Vector3._LeftReadOnly;
      }
      static get LeftHandedForwardReadOnly() {
        return Vector3._LeftHandedForwardReadOnly;
      }
      static get RightHandedForwardReadOnly() {
        return Vector3._RightHandedForwardReadOnly;
      }
      static get LeftHandedBackwardReadOnly() {
        return Vector3._LeftHandedBackwardReadOnly;
      }
      static get RightHandedBackwardReadOnly() {
        return Vector3._RightHandedBackwardReadOnly;
      }
      static get ZeroReadOnly() {
        return Vector3._ZeroReadOnly;
      }
      static get OneReadOnly() {
        return Vector3._OneReadOnly;
      }
      static Down() {
        return new Vector3(0, -1, 0);
      }
      static Forward(rightHandedSystem = false) {
        return new Vector3(0, 0, rightHandedSystem ? -1 : 1);
      }
      static Backward(rightHandedSystem = false) {
        return new Vector3(0, 0, rightHandedSystem ? 1 : -1);
      }
      static Right() {
        return new Vector3(1, 0, 0);
      }
      static Left() {
        return new Vector3(-1, 0, 0);
      }
      static Random(min = 0, max = 1) {
        return new Vector3(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));
      }
      static TransformCoordinates(vector, transformation) {
        const result = Vector3.Zero();
        Vector3.TransformCoordinatesToRef(vector, transformation, result);
        return result;
      }
      static TransformCoordinatesToRef(vector, transformation, result) {
        Vector3.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
        return result;
      }
      static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {
        const m = transformation.m;
        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
        const rw = 1 / (x * m[3] + y * m[7] + z * m[11] + m[15]);
        result._x = rx * rw;
        result._y = ry * rw;
        result._z = rz * rw;
        result._isDirty = true;
        return result;
      }
      static TransformNormal(vector, transformation) {
        const result = Vector3.Zero();
        Vector3.TransformNormalToRef(vector, transformation, result);
        return result;
      }
      static TransformNormalToRef(vector, transformation, result) {
        this.TransformNormalFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
        return result;
      }
      static TransformNormalFromFloatsToRef(x, y, z, transformation, result) {
        const m = transformation.m;
        result._x = x * m[0] + y * m[4] + z * m[8];
        result._y = x * m[1] + y * m[5] + z * m[9];
        result._z = x * m[2] + y * m[6] + z * m[10];
        result._isDirty = true;
        return result;
      }
      static CatmullRom(value1, value2, value3, value4, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const x = 0.5 * (2 * value2._x + (-value1._x + value3._x) * amount + (2 * value1._x - 5 * value2._x + 4 * value3._x - value4._x) * squared + (-value1._x + 3 * value2._x - 3 * value3._x + value4._x) * cubed);
        const y = 0.5 * (2 * value2._y + (-value1._y + value3._y) * amount + (2 * value1._y - 5 * value2._y + 4 * value3._y - value4._y) * squared + (-value1._y + 3 * value2._y - 3 * value3._y + value4._y) * cubed);
        const z = 0.5 * (2 * value2._z + (-value1._z + value3._z) * amount + (2 * value1._z - 5 * value2._z + 4 * value3._z - value4._z) * squared + (-value1._z + 3 * value2._z - 3 * value3._z + value4._z) * cubed);
        return new value1.constructor(x, y, z);
      }
      static Clamp(value, min, max) {
        const result = new value.constructor();
        Vector3.ClampToRef(value, min, max, result);
        return result;
      }
      static ClampToRef(value, min, max, result) {
        let x = value._x;
        x = x > max._x ? max._x : x;
        x = x < min._x ? min._x : x;
        let y = value._y;
        y = y > max._y ? max._y : y;
        y = y < min._y ? min._y : y;
        let z = value._z;
        z = z > max._z ? max._z : z;
        z = z < min._z ? min._z : z;
        result.copyFromFloats(x, y, z);
        return result;
      }
      static CheckExtends(v, min, max) {
        min.minimizeInPlace(v);
        max.maximizeInPlace(v);
      }
      static Hermite(value1, tangent1, value2, tangent2, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const part1 = 2 * cubed - 3 * squared + 1;
        const part2 = -2 * cubed + 3 * squared;
        const part3 = cubed - 2 * squared + amount;
        const part4 = cubed - squared;
        const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
        const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
        const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
        return new value1.constructor(x, y, z);
      }
      static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
        const result = new value1.constructor();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      }
      static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
        const t2 = time * time;
        result._x = (t2 - time) * 6 * value1._x + (3 * t2 - 4 * time + 1) * tangent1._x + (-t2 + time) * 6 * value2._x + (3 * t2 - 2 * time) * tangent2._x;
        result._y = (t2 - time) * 6 * value1._y + (3 * t2 - 4 * time + 1) * tangent1._y + (-t2 + time) * 6 * value2._y + (3 * t2 - 2 * time) * tangent2._y;
        result._z = (t2 - time) * 6 * value1._z + (3 * t2 - 4 * time + 1) * tangent1._z + (-t2 + time) * 6 * value2._z + (3 * t2 - 2 * time) * tangent2._z;
        result._isDirty = true;
        return result;
      }
      static Lerp(start, end, amount) {
        const result = new start.constructor(0, 0, 0);
        Vector3.LerpToRef(start, end, amount, result);
        return result;
      }
      static LerpToRef(start, end, amount, result) {
        result._x = start._x + (end._x - start._x) * amount;
        result._y = start._y + (end._y - start._y) * amount;
        result._z = start._z + (end._z - start._z) * amount;
        result._isDirty = true;
        return result;
      }
      static Dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z;
      }
      static Cross(left, right) {
        const result = new left.constructor();
        Vector3.CrossToRef(left, right, result);
        return result;
      }
      static CrossToRef(left, right, result) {
        const x = left._y * right._z - left._z * right._y;
        const y = left._z * right._x - left._x * right._z;
        const z = left._x * right._y - left._y * right._x;
        result.copyFromFloats(x, y, z);
        return result;
      }
      static Normalize(vector) {
        const result = Vector3.Zero();
        Vector3.NormalizeToRef(vector, result);
        return result;
      }
      static NormalizeToRef(vector, result) {
        vector.normalizeToRef(result);
        return result;
      }
      static Project(vector, world, transform, viewport) {
        const result = new vector.constructor();
        Vector3.ProjectToRef(vector, world, transform, viewport, result);
        return result;
      }
      static ProjectToRef(vector, world, transform, viewport, result) {
        const cw = viewport.width;
        const ch = viewport.height;
        const cx = viewport.x;
        const cy = viewport.y;
        const viewportMatrix = MathTmp.Matrix[1];
        Matrix.FromValuesToRef(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, 0.5, 0, cx + cw / 2, ch / 2 + cy, 0.5, 1, viewportMatrix);
        const matrix = MathTmp.Matrix[0];
        world.multiplyToRef(transform, matrix);
        matrix.multiplyToRef(viewportMatrix, matrix);
        Vector3.TransformCoordinatesToRef(vector, matrix, result);
        return result;
      }
      static Reflect(inDirection, normal) {
        return this.ReflectToRef(inDirection, normal, new Vector3());
      }
      static ReflectToRef(inDirection, normal, ref) {
        const tmp = TmpVectors.Vector3[0];
        tmp.copyFrom(normal).scaleInPlace(2 * Vector3.Dot(inDirection, normal));
        return ref.copyFrom(inDirection).subtractInPlace(tmp);
      }
      static _UnprojectFromInvertedMatrixToRef(source, matrix, result) {
        Vector3.TransformCoordinatesToRef(source, matrix, result);
        const m = matrix.m;
        const num = source._x * m[3] + source._y * m[7] + source._z * m[11] + m[15];
        if (Scalar.WithinEpsilon(num, 1)) {
          result.scaleInPlace(1 / num);
        }
        return result;
      }
      static UnprojectFromTransform(source, viewportWidth, viewportHeight, world, transform) {
        return this.Unproject(source, viewportWidth, viewportHeight, world, transform, Matrix.IdentityReadOnly);
      }
      static Unproject(source, viewportWidth, viewportHeight, world, view, projection) {
        const result = new source.constructor();
        Vector3.UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result);
        return result;
      }
      static UnprojectToRef(source, viewportWidth, viewportHeight, world, view, projection, result) {
        Vector3.UnprojectFloatsToRef(source._x, source._y, source._z, viewportWidth, viewportHeight, world, view, projection, result);
        return result;
      }
      static UnprojectFloatsToRef(sourceX, sourceY, sourceZ, viewportWidth, viewportHeight, world, view, projection, result) {
        var _a;
        const matrix = MathTmp.Matrix[0];
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        matrix.invert();
        const screenSource = MathTmp.Vector3[0];
        screenSource.x = sourceX / viewportWidth * 2 - 1;
        screenSource.y = -(sourceY / viewportHeight * 2 - 1);
        if ((_a = EngineStore.LastCreatedEngine) === null || _a === void 0 ? void 0 : _a.isNDCHalfZRange) {
          screenSource.z = sourceZ;
        } else {
          screenSource.z = 2 * sourceZ - 1;
        }
        Vector3._UnprojectFromInvertedMatrixToRef(screenSource, matrix, result);
        return result;
      }
      static Minimize(left, right) {
        const min = new left.constructor();
        min.copyFrom(left);
        min.minimizeInPlace(right);
        return min;
      }
      static Maximize(left, right) {
        const max = new left.constructor();
        max.copyFrom(left);
        max.maximizeInPlace(right);
        return max;
      }
      static Distance(value1, value2) {
        return Math.sqrt(Vector3.DistanceSquared(value1, value2));
      }
      static DistanceSquared(value1, value2) {
        const x = value1._x - value2._x;
        const y = value1._y - value2._y;
        const z = value1._z - value2._z;
        return x * x + y * y + z * z;
      }
      static ProjectOnTriangleToRef(vector, p0, p1, p2, ref) {
        const p1p0 = MathTmp.Vector3[0];
        const p2p0 = MathTmp.Vector3[1];
        const p2p1 = MathTmp.Vector3[2];
        const normal = MathTmp.Vector3[3];
        const vectorp0 = MathTmp.Vector3[4];
        p1.subtractToRef(p0, p1p0);
        p2.subtractToRef(p0, p2p0);
        p2.subtractToRef(p1, p2p1);
        const p1p0L = p1p0.length();
        const p2p0L = p2p0.length();
        const p2p1L = p2p1.length();
        if (p1p0L < Epsilon || p2p0L < Epsilon || p2p1L < Epsilon) {
          ref.copyFrom(p0);
          return Vector3.Distance(vector, p0);
        }
        vector.subtractToRef(p0, vectorp0);
        Vector3.CrossToRef(p1p0, p2p0, normal);
        const nl = normal.length();
        if (nl < Epsilon) {
          ref.copyFrom(p0);
          return Vector3.Distance(vector, p0);
        }
        normal.normalizeFromLength(nl);
        let l = vectorp0.length();
        if (l < Epsilon) {
          ref.copyFrom(p0);
          return 0;
        }
        vectorp0.normalizeFromLength(l);
        const cosA = Vector3.Dot(normal, vectorp0);
        const projVector = MathTmp.Vector3[5];
        const proj = MathTmp.Vector3[6];
        projVector.copyFrom(normal).scaleInPlace(-l * cosA);
        proj.copyFrom(vector).addInPlace(projVector);
        const v0 = MathTmp.Vector3[4];
        const v1 = MathTmp.Vector3[5];
        const v2 = MathTmp.Vector3[7];
        const tmp = MathTmp.Vector3[8];
        v0.copyFrom(p1p0).scaleInPlace(1 / p1p0L);
        tmp.copyFrom(p2p0).scaleInPlace(1 / p2p0L);
        v0.addInPlace(tmp).scaleInPlace(-1);
        v1.copyFrom(p1p0).scaleInPlace(-1 / p1p0L);
        tmp.copyFrom(p2p1).scaleInPlace(1 / p2p1L);
        v1.addInPlace(tmp).scaleInPlace(-1);
        v2.copyFrom(p2p1).scaleInPlace(-1 / p2p1L);
        tmp.copyFrom(p2p0).scaleInPlace(-1 / p2p0L);
        v2.addInPlace(tmp).scaleInPlace(-1);
        const projP = MathTmp.Vector3[9];
        let dot;
        projP.copyFrom(proj).subtractInPlace(p0);
        Vector3.CrossToRef(v0, projP, tmp);
        dot = Vector3.Dot(tmp, normal);
        const s0 = dot;
        projP.copyFrom(proj).subtractInPlace(p1);
        Vector3.CrossToRef(v1, projP, tmp);
        dot = Vector3.Dot(tmp, normal);
        const s1 = dot;
        projP.copyFrom(proj).subtractInPlace(p2);
        Vector3.CrossToRef(v2, projP, tmp);
        dot = Vector3.Dot(tmp, normal);
        const s2 = dot;
        const edge = MathTmp.Vector3[10];
        let e0, e1;
        if (s0 > 0 && s1 < 0) {
          edge.copyFrom(p1p0);
          e0 = p0;
          e1 = p1;
        } else if (s1 > 0 && s2 < 0) {
          edge.copyFrom(p2p1);
          e0 = p1;
          e1 = p2;
        } else {
          edge.copyFrom(p2p0).scaleInPlace(-1);
          e0 = p2;
          e1 = p0;
        }
        const tmp2 = MathTmp.Vector3[9];
        const tmp3 = MathTmp.Vector3[4];
        e0.subtractToRef(proj, tmp);
        e1.subtractToRef(proj, tmp2);
        Vector3.CrossToRef(tmp, tmp2, tmp3);
        const isOutside = Vector3.Dot(tmp3, normal) < 0;
        if (!isOutside) {
          ref.copyFrom(proj);
          return Math.abs(l * cosA);
        }
        const r = MathTmp.Vector3[5];
        Vector3.CrossToRef(edge, tmp3, r);
        r.normalize();
        const e0proj = MathTmp.Vector3[9];
        e0proj.copyFrom(e0).subtractInPlace(proj);
        const e0projL = e0proj.length();
        if (e0projL < Epsilon) {
          ref.copyFrom(e0);
          return Vector3.Distance(vector, e0);
        }
        e0proj.normalizeFromLength(e0projL);
        const cosG = Vector3.Dot(r, e0proj);
        const triProj = MathTmp.Vector3[7];
        triProj.copyFrom(proj).addInPlace(r.scaleInPlace(e0projL * cosG));
        tmp.copyFrom(triProj).subtractInPlace(e0);
        l = edge.length();
        edge.normalizeFromLength(l);
        let t = Vector3.Dot(tmp, edge) / Math.max(l, Epsilon);
        t = Scalar.Clamp(t, 0, 1);
        triProj.copyFrom(e0).addInPlace(edge.scaleInPlace(t * l));
        ref.copyFrom(triProj);
        return Vector3.Distance(vector, triProj);
      }
      static Center(value1, value2) {
        return Vector3.CenterToRef(value1, value2, Vector3.Zero());
      }
      static CenterToRef(value1, value2, ref) {
        return ref.copyFromFloats((value1._x + value2._x) / 2, (value1._y + value2._y) / 2, (value1._z + value2._z) / 2);
      }
      static RotationFromAxis(axis1, axis2, axis3) {
        const rotation = new axis1.constructor();
        Vector3.RotationFromAxisToRef(axis1, axis2, axis3, rotation);
        return rotation;
      }
      static RotationFromAxisToRef(axis1, axis2, axis3, ref) {
        const quat = MathTmp.Quaternion[0];
        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
        quat.toEulerAnglesToRef(ref);
        return ref;
      }
    };
    Vector3._UpReadOnly = Vector3.Up();
    Vector3._DownReadOnly = Vector3.Down();
    Vector3._LeftHandedForwardReadOnly = Vector3.Forward(false);
    Vector3._RightHandedForwardReadOnly = Vector3.Forward(true);
    Vector3._LeftHandedBackwardReadOnly = Vector3.Backward(false);
    Vector3._RightHandedBackwardReadOnly = Vector3.Backward(true);
    Vector3._RightReadOnly = Vector3.Right();
    Vector3._LeftReadOnly = Vector3.Left();
    Vector3._ZeroReadOnly = Vector3.Zero();
    Vector3._OneReadOnly = Vector3.One();
    Vector4 = class {
      constructor(x = 0, y = 0, z = 0, w = 0) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
      }
      toString() {
        return `{X: ${this.x} Y: ${this.y} Z: ${this.z} W: ${this.w}}`;
      }
      getClassName() {
        return "Vector4";
      }
      getHashCode() {
        const x = _ExtractAsInt(this.x);
        const y = _ExtractAsInt(this.y);
        const z = _ExtractAsInt(this.z);
        const w = _ExtractAsInt(this.w);
        let hash = x;
        hash = hash * 397 ^ y;
        hash = hash * 397 ^ z;
        hash = hash * 397 ^ w;
        return hash;
      }
      asArray() {
        const result = new Array();
        this.toArray(result, 0);
        return result;
      }
      toArray(array, index) {
        if (index === void 0) {
          index = 0;
        }
        array[index] = this.x;
        array[index + 1] = this.y;
        array[index + 2] = this.z;
        array[index + 3] = this.w;
        return this;
      }
      fromArray(array, index = 0) {
        Vector4.FromArrayToRef(array, index, this);
        return this;
      }
      addInPlace(otherVector) {
        this.x += otherVector.x;
        this.y += otherVector.y;
        this.z += otherVector.z;
        this.w += otherVector.w;
        return this;
      }
      add(otherVector) {
        return new this.constructor(this.x + otherVector.x, this.y + otherVector.y, this.z + otherVector.z, this.w + otherVector.w);
      }
      addToRef(otherVector, result) {
        result.x = this.x + otherVector.x;
        result.y = this.y + otherVector.y;
        result.z = this.z + otherVector.z;
        result.w = this.w + otherVector.w;
        return result;
      }
      subtractInPlace(otherVector) {
        this.x -= otherVector.x;
        this.y -= otherVector.y;
        this.z -= otherVector.z;
        this.w -= otherVector.w;
        return this;
      }
      subtract(otherVector) {
        return new this.constructor(this.x - otherVector.x, this.y - otherVector.y, this.z - otherVector.z, this.w - otherVector.w);
      }
      subtractToRef(otherVector, result) {
        result.x = this.x - otherVector.x;
        result.y = this.y - otherVector.y;
        result.z = this.z - otherVector.z;
        result.w = this.w - otherVector.w;
        return result;
      }
      subtractFromFloats(x, y, z, w) {
        return new this.constructor(this.x - x, this.y - y, this.z - z, this.w - w);
      }
      subtractFromFloatsToRef(x, y, z, w, result) {
        result.x = this.x - x;
        result.y = this.y - y;
        result.z = this.z - z;
        result.w = this.w - w;
        return result;
      }
      negate() {
        return new this.constructor(-this.x, -this.y, -this.z, -this.w);
      }
      negateInPlace() {
        this.x *= -1;
        this.y *= -1;
        this.z *= -1;
        this.w *= -1;
        return this;
      }
      negateToRef(result) {
        return result.copyFromFloats(this.x * -1, this.y * -1, this.z * -1, this.w * -1);
      }
      scaleInPlace(scale) {
        this.x *= scale;
        this.y *= scale;
        this.z *= scale;
        this.w *= scale;
        return this;
      }
      scale(scale) {
        return new this.constructor(this.x * scale, this.y * scale, this.z * scale, this.w * scale);
      }
      scaleToRef(scale, result) {
        result.x = this.x * scale;
        result.y = this.y * scale;
        result.z = this.z * scale;
        result.w = this.w * scale;
        return result;
      }
      scaleAndAddToRef(scale, result) {
        result.x += this.x * scale;
        result.y += this.y * scale;
        result.z += this.z * scale;
        result.w += this.w * scale;
        return result;
      }
      equals(otherVector) {
        return otherVector && this.x === otherVector.x && this.y === otherVector.y && this.z === otherVector.z && this.w === otherVector.w;
      }
      equalsWithEpsilon(otherVector, epsilon = Epsilon) {
        return otherVector && Scalar.WithinEpsilon(this.x, otherVector.x, epsilon) && Scalar.WithinEpsilon(this.y, otherVector.y, epsilon) && Scalar.WithinEpsilon(this.z, otherVector.z, epsilon) && Scalar.WithinEpsilon(this.w, otherVector.w, epsilon);
      }
      equalsToFloats(x, y, z, w) {
        return this.x === x && this.y === y && this.z === z && this.w === w;
      }
      multiplyInPlace(otherVector) {
        this.x *= otherVector.x;
        this.y *= otherVector.y;
        this.z *= otherVector.z;
        this.w *= otherVector.w;
        return this;
      }
      multiply(otherVector) {
        return new this.constructor(this.x * otherVector.x, this.y * otherVector.y, this.z * otherVector.z, this.w * otherVector.w);
      }
      multiplyToRef(otherVector, result) {
        result.x = this.x * otherVector.x;
        result.y = this.y * otherVector.y;
        result.z = this.z * otherVector.z;
        result.w = this.w * otherVector.w;
        return result;
      }
      multiplyByFloats(x, y, z, w) {
        return new this.constructor(this.x * x, this.y * y, this.z * z, this.w * w);
      }
      divide(otherVector) {
        return new this.constructor(this.x / otherVector.x, this.y / otherVector.y, this.z / otherVector.z, this.w / otherVector.w);
      }
      divideToRef(otherVector, result) {
        result.x = this.x / otherVector.x;
        result.y = this.y / otherVector.y;
        result.z = this.z / otherVector.z;
        result.w = this.w / otherVector.w;
        return result;
      }
      divideInPlace(otherVector) {
        return this.divideToRef(otherVector, this);
      }
      minimizeInPlace(other) {
        if (other.x < this.x) {
          this.x = other.x;
        }
        if (other.y < this.y) {
          this.y = other.y;
        }
        if (other.z < this.z) {
          this.z = other.z;
        }
        if (other.w < this.w) {
          this.w = other.w;
        }
        return this;
      }
      maximizeInPlace(other) {
        if (other.x > this.x) {
          this.x = other.x;
        }
        if (other.y > this.y) {
          this.y = other.y;
        }
        if (other.z > this.z) {
          this.z = other.z;
        }
        if (other.w > this.w) {
          this.w = other.w;
        }
        return this;
      }
      floor() {
        return new this.constructor(Math.floor(this.x), Math.floor(this.y), Math.floor(this.z), Math.floor(this.w));
      }
      fract() {
        return new this.constructor(this.x - Math.floor(this.x), this.y - Math.floor(this.y), this.z - Math.floor(this.z), this.w - Math.floor(this.w));
      }
      length() {
        return Math.sqrt(this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w);
      }
      lengthSquared() {
        return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
      }
      normalize() {
        const len = this.length();
        if (len === 0) {
          return this;
        }
        return this.scaleInPlace(1 / len);
      }
      toVector3() {
        return new Vector3(this.x, this.y, this.z);
      }
      clone() {
        return new this.constructor(this.x, this.y, this.z, this.w);
      }
      copyFrom(source) {
        this.x = source.x;
        this.y = source.y;
        this.z = source.z;
        this.w = source.w;
        return this;
      }
      copyFromFloats(x, y, z, w) {
        this.x = x;
        this.y = y;
        this.z = z;
        this.w = w;
        return this;
      }
      set(x, y, z, w) {
        return this.copyFromFloats(x, y, z, w);
      }
      setAll(v) {
        this.x = this.y = this.z = this.w = v;
        return this;
      }
      static FromArray(array, offset) {
        if (!offset) {
          offset = 0;
        }
        return new Vector4(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
      }
      static FromArrayToRef(array, offset, result) {
        result.x = array[offset];
        result.y = array[offset + 1];
        result.z = array[offset + 2];
        result.w = array[offset + 3];
        return result;
      }
      static FromFloatArrayToRef(array, offset, result) {
        Vector4.FromArrayToRef(array, offset, result);
        return result;
      }
      static FromFloatsToRef(x, y, z, w, result) {
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = w;
        return result;
      }
      static Zero() {
        return new Vector4(0, 0, 0, 0);
      }
      static One() {
        return new Vector4(1, 1, 1, 1);
      }
      static Random(min = 0, max = 1) {
        return new Vector4(Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max), Scalar.RandomRange(min, max));
      }
      static get ZeroReadOnly() {
        return Vector4._ZeroReadOnly;
      }
      static Normalize(vector) {
        const result = Vector4.Zero();
        Vector4.NormalizeToRef(vector, result);
        return result;
      }
      static NormalizeToRef(vector, result) {
        result.copyFrom(vector);
        result.normalize();
        return result;
      }
      static Minimize(left, right) {
        const min = new left.constructor();
        min.copyFrom(left);
        min.minimizeInPlace(right);
        return min;
      }
      static Maximize(left, right) {
        const max = new left.constructor();
        max.copyFrom(left);
        max.maximizeInPlace(right);
        return max;
      }
      static Distance(value1, value2) {
        return Math.sqrt(Vector4.DistanceSquared(value1, value2));
      }
      static DistanceSquared(value1, value2) {
        const x = value1.x - value2.x;
        const y = value1.y - value2.y;
        const z = value1.z - value2.z;
        const w = value1.w - value2.w;
        return x * x + y * y + z * z + w * w;
      }
      static Center(value1, value2) {
        return Vector4.CenterToRef(value1, value2, Vector4.Zero());
      }
      static CenterToRef(value1, value2, ref) {
        return ref.copyFromFloats((value1.x + value2.x) / 2, (value1.y + value2.y) / 2, (value1.z + value2.z) / 2, (value1.w + value2.w) / 2);
      }
      static TransformCoordinates(vector, transformation) {
        const result = Vector4.Zero();
        Vector4.TransformCoordinatesToRef(vector, transformation, result);
        return result;
      }
      static TransformCoordinatesToRef(vector, transformation, result) {
        Vector4.TransformCoordinatesFromFloatsToRef(vector._x, vector._y, vector._z, transformation, result);
        return result;
      }
      static TransformCoordinatesFromFloatsToRef(x, y, z, transformation, result) {
        const m = transformation.m;
        const rx = x * m[0] + y * m[4] + z * m[8] + m[12];
        const ry = x * m[1] + y * m[5] + z * m[9] + m[13];
        const rz = x * m[2] + y * m[6] + z * m[10] + m[14];
        const rw = x * m[3] + y * m[7] + z * m[11] + m[15];
        result.x = rx;
        result.y = ry;
        result.z = rz;
        result.w = rw;
        return result;
      }
      static TransformNormal(vector, transformation) {
        const result = new vector.constructor();
        Vector4.TransformNormalToRef(vector, transformation, result);
        return result;
      }
      static TransformNormalToRef(vector, transformation, result) {
        const m = transformation.m;
        const x = vector.x * m[0] + vector.y * m[4] + vector.z * m[8];
        const y = vector.x * m[1] + vector.y * m[5] + vector.z * m[9];
        const z = vector.x * m[2] + vector.y * m[6] + vector.z * m[10];
        result.x = x;
        result.y = y;
        result.z = z;
        result.w = vector.w;
        return result;
      }
      static TransformNormalFromFloatsToRef(x, y, z, w, transformation, result) {
        const m = transformation.m;
        result.x = x * m[0] + y * m[4] + z * m[8];
        result.y = x * m[1] + y * m[5] + z * m[9];
        result.z = x * m[2] + y * m[6] + z * m[10];
        result.w = w;
        return result;
      }
      static FromVector3(source, w = 0) {
        return new Vector4(source._x, source._y, source._z, w);
      }
    };
    Vector4._ZeroReadOnly = Vector4.Zero();
    Quaternion = class {
      get x() {
        return this._x;
      }
      set x(value) {
        this._x = value;
        this._isDirty = true;
      }
      get y() {
        return this._y;
      }
      set y(value) {
        this._y = value;
        this._isDirty = true;
      }
      get z() {
        return this._z;
      }
      set z(value) {
        this._z = value;
        this._isDirty = true;
      }
      get w() {
        return this._w;
      }
      set w(value) {
        this._w = value;
        this._isDirty = true;
      }
      constructor(x = 0, y = 0, z = 0, w = 1) {
        this._isDirty = true;
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
      }
      toString() {
        return `{X: ${this._x} Y: ${this._y} Z: ${this._z} W: ${this._w}}`;
      }
      getClassName() {
        return "Quaternion";
      }
      getHashCode() {
        const x = _ExtractAsInt(this._x);
        const y = _ExtractAsInt(this._y);
        const z = _ExtractAsInt(this._z);
        const w = _ExtractAsInt(this._w);
        let hash = x;
        hash = hash * 397 ^ y;
        hash = hash * 397 ^ z;
        hash = hash * 397 ^ w;
        return hash;
      }
      asArray() {
        return [this._x, this._y, this._z, this._w];
      }
      toArray(array, index = 0) {
        array[index] = this._x;
        array[index + 1] = this._y;
        array[index + 2] = this._z;
        array[index + 3] = this._w;
        return this;
      }
      equals(otherQuaternion) {
        return otherQuaternion && this._x === otherQuaternion._x && this._y === otherQuaternion._y && this._z === otherQuaternion._z && this._w === otherQuaternion._w;
      }
      equalsWithEpsilon(otherQuaternion, epsilon = Epsilon) {
        return otherQuaternion && Scalar.WithinEpsilon(this._x, otherQuaternion._x, epsilon) && Scalar.WithinEpsilon(this._y, otherQuaternion._y, epsilon) && Scalar.WithinEpsilon(this._z, otherQuaternion._z, epsilon) && Scalar.WithinEpsilon(this._w, otherQuaternion._w, epsilon);
      }
      clone() {
        return new this.constructor(this._x, this._y, this._z, this._w);
      }
      copyFrom(other) {
        this._x = other._x;
        this._y = other._y;
        this._z = other._z;
        this._w = other._w;
        this._isDirty = true;
        return this;
      }
      copyFromFloats(x, y, z, w) {
        this._x = x;
        this._y = y;
        this._z = z;
        this._w = w;
        this._isDirty = true;
        return this;
      }
      set(x, y, z, w) {
        return this.copyFromFloats(x, y, z, w);
      }
      add(other) {
        return new this.constructor(this._x + other._x, this._y + other._y, this._z + other._z, this._w + other._w);
      }
      addInPlace(other) {
        this._x += other._x;
        this._y += other._y;
        this._z += other._z;
        this._w += other._w;
        this._isDirty = true;
        return this;
      }
      subtract(other) {
        return new this.constructor(this._x - other._x, this._y - other._y, this._z - other._z, this._w - other._w);
      }
      subtractInPlace(other) {
        this._x -= other._x;
        this._y -= other._y;
        this._z -= other._z;
        this._w -= other._w;
        this._isDirty = true;
        return this;
      }
      scale(value) {
        return new this.constructor(this._x * value, this._y * value, this._z * value, this._w * value);
      }
      scaleToRef(scale, result) {
        result._x = this._x * scale;
        result._y = this._y * scale;
        result._z = this._z * scale;
        result._w = this._w * scale;
        result._isDirty = true;
        return result;
      }
      scaleInPlace(value) {
        this._x *= value;
        this._y *= value;
        this._z *= value;
        this._w *= value;
        this._isDirty = true;
        return this;
      }
      scaleAndAddToRef(scale, result) {
        result._x += this._x * scale;
        result._y += this._y * scale;
        result._z += this._z * scale;
        result._w += this._w * scale;
        result._isDirty = true;
        return result;
      }
      multiply(q1) {
        const result = new this.constructor(0, 0, 0, 1);
        this.multiplyToRef(q1, result);
        return result;
      }
      multiplyToRef(q1, result) {
        const x = this._x * q1._w + this._y * q1._z - this._z * q1._y + this._w * q1._x;
        const y = -this._x * q1._z + this._y * q1._w + this._z * q1._x + this._w * q1._y;
        const z = this._x * q1._y - this._y * q1._x + this._z * q1._w + this._w * q1._z;
        const w = -this._x * q1._x - this._y * q1._y - this._z * q1._z + this._w * q1._w;
        result.copyFromFloats(x, y, z, w);
        return result;
      }
      multiplyInPlace(q1) {
        this.multiplyToRef(q1, this);
        return this;
      }
      conjugateToRef(ref) {
        ref.copyFromFloats(-this._x, -this._y, -this._z, this._w);
        return ref;
      }
      conjugateInPlace() {
        this._x *= -1;
        this._y *= -1;
        this._z *= -1;
        this._isDirty = true;
        return this;
      }
      conjugate() {
        return new this.constructor(-this._x, -this._y, -this._z, this._w);
      }
      invert() {
        const conjugate = this.conjugate();
        const lengthSquared = this.lengthSquared();
        if (lengthSquared == 0 || lengthSquared == 1) {
          return conjugate;
        }
        conjugate.scaleInPlace(1 / lengthSquared);
        return conjugate;
      }
      invertInPlace() {
        this.conjugateInPlace();
        const lengthSquared = this.lengthSquared();
        if (lengthSquared == 0 || lengthSquared == 1) {
          return this;
        }
        this.scaleInPlace(1 / lengthSquared);
        return this;
      }
      lengthSquared() {
        return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
      }
      length() {
        return Math.sqrt(this.lengthSquared());
      }
      normalize() {
        const len = this.length();
        if (len === 0) {
          return this;
        }
        const inv = 1 / len;
        this.scaleInPlace(inv);
        return this;
      }
      normalizeToNew() {
        const len = this.length();
        if (len === 0) {
          return this.clone();
        }
        const inv = 1 / len;
        return this.scale(inv);
      }
      toEulerAngles() {
        const result = Vector3.Zero();
        this.toEulerAnglesToRef(result);
        return result;
      }
      toEulerAnglesToRef(result) {
        const qz = this._z;
        const qx = this._x;
        const qy = this._y;
        const qw = this._w;
        const zAxisY = qy * qz - qx * qw;
        const limit = 0.4999999;
        if (zAxisY < -limit) {
          result._y = 2 * Math.atan2(qy, qw);
          result._x = Math.PI / 2;
          result._z = 0;
          result._isDirty = true;
        } else if (zAxisY > limit) {
          result._y = 2 * Math.atan2(qy, qw);
          result._x = -Math.PI / 2;
          result._z = 0;
          result._isDirty = true;
        } else {
          const sqw = qw * qw;
          const sqz = qz * qz;
          const sqx = qx * qx;
          const sqy = qy * qy;
          result._z = Math.atan2(2 * (qx * qy + qz * qw), -sqz - sqx + sqy + sqw);
          result._x = Math.asin(-2 * zAxisY);
          result._y = Math.atan2(2 * (qz * qx + qy * qw), sqz - sqx - sqy + sqw);
          result._isDirty = true;
        }
        return result;
      }
      toRotationMatrix(result) {
        Matrix.FromQuaternionToRef(this, result);
        return result;
      }
      fromRotationMatrix(matrix) {
        Quaternion.FromRotationMatrixToRef(matrix, this);
        return this;
      }
      static FromRotationMatrix(matrix) {
        const result = new Quaternion();
        Quaternion.FromRotationMatrixToRef(matrix, result);
        return result;
      }
      static FromRotationMatrixToRef(matrix, result) {
        const data = matrix.m;
        const m11 = data[0], m12 = data[4], m13 = data[8];
        const m21 = data[1], m22 = data[5], m23 = data[9];
        const m31 = data[2], m32 = data[6], m33 = data[10];
        const trace = m11 + m22 + m33;
        let s;
        if (trace > 0) {
          s = 0.5 / Math.sqrt(trace + 1);
          result._w = 0.25 / s;
          result._x = (m32 - m23) * s;
          result._y = (m13 - m31) * s;
          result._z = (m21 - m12) * s;
          result._isDirty = true;
        } else if (m11 > m22 && m11 > m33) {
          s = 2 * Math.sqrt(1 + m11 - m22 - m33);
          result._w = (m32 - m23) / s;
          result._x = 0.25 * s;
          result._y = (m12 + m21) / s;
          result._z = (m13 + m31) / s;
          result._isDirty = true;
        } else if (m22 > m33) {
          s = 2 * Math.sqrt(1 + m22 - m11 - m33);
          result._w = (m13 - m31) / s;
          result._x = (m12 + m21) / s;
          result._y = 0.25 * s;
          result._z = (m23 + m32) / s;
          result._isDirty = true;
        } else {
          s = 2 * Math.sqrt(1 + m33 - m11 - m22);
          result._w = (m21 - m12) / s;
          result._x = (m13 + m31) / s;
          result._y = (m23 + m32) / s;
          result._z = 0.25 * s;
          result._isDirty = true;
        }
        return result;
      }
      static Dot(left, right) {
        return left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
      }
      static AreClose(quat0, quat1, epsilon = 0.1) {
        const dot = Quaternion.Dot(quat0, quat1);
        return 1 - dot * dot <= epsilon;
      }
      static SmoothToRef(source, goal, deltaTime, lerpTime, result) {
        let slerp = lerpTime === 0 ? 1 : deltaTime / lerpTime;
        slerp = Scalar.Clamp(slerp, 0, 1);
        Quaternion.SlerpToRef(source, goal, slerp, result);
        return result;
      }
      static Zero() {
        return new Quaternion(0, 0, 0, 0);
      }
      static Inverse(q) {
        return new q.constructor(-q._x, -q._y, -q._z, q._w);
      }
      static InverseToRef(q, result) {
        result.set(-q._x, -q._y, -q._z, q._w);
        return result;
      }
      static Identity() {
        return new Quaternion(0, 0, 0, 1);
      }
      static IsIdentity(quaternion) {
        return quaternion && quaternion._x === 0 && quaternion._y === 0 && quaternion._z === 0 && quaternion._w === 1;
      }
      static RotationAxis(axis, angle) {
        return Quaternion.RotationAxisToRef(axis, angle, new Quaternion());
      }
      static RotationAxisToRef(axis, angle, result) {
        const sin = Math.sin(angle / 2);
        axis.normalize();
        result._w = Math.cos(angle / 2);
        result._x = axis._x * sin;
        result._y = axis._y * sin;
        result._z = axis._z * sin;
        result._isDirty = true;
        return result;
      }
      static FromArray(array, offset) {
        if (!offset) {
          offset = 0;
        }
        return new Quaternion(array[offset], array[offset + 1], array[offset + 2], array[offset + 3]);
      }
      static FromArrayToRef(array, offset, result) {
        result._x = array[offset];
        result._y = array[offset + 1];
        result._z = array[offset + 2];
        result._w = array[offset + 3];
        result._isDirty = true;
        return result;
      }
      static FromEulerAngles(x, y, z) {
        const q = new Quaternion();
        Quaternion.RotationYawPitchRollToRef(y, x, z, q);
        return q;
      }
      static FromEulerAnglesToRef(x, y, z, result) {
        Quaternion.RotationYawPitchRollToRef(y, x, z, result);
        return result;
      }
      static FromEulerVector(vec) {
        const q = new Quaternion();
        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, q);
        return q;
      }
      static FromEulerVectorToRef(vec, result) {
        Quaternion.RotationYawPitchRollToRef(vec._y, vec._x, vec._z, result);
        return result;
      }
      static FromUnitVectorsToRef(vecFrom, vecTo, result, epsilon = Epsilon) {
        const r = Vector3.Dot(vecFrom, vecTo) + 1;
        if (r < epsilon) {
          if (Math.abs(vecFrom.x) > Math.abs(vecFrom.z)) {
            result.set(-vecFrom.y, vecFrom.x, 0, 0);
          } else {
            result.set(0, -vecFrom.z, vecFrom.y, 0);
          }
        } else {
          Vector3.CrossToRef(vecFrom, vecTo, TmpVectors.Vector3[0]);
          result.set(TmpVectors.Vector3[0].x, TmpVectors.Vector3[0].y, TmpVectors.Vector3[0].z, r);
        }
        return result.normalize();
      }
      static RotationYawPitchRoll(yaw, pitch, roll) {
        const q = new Quaternion();
        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, q);
        return q;
      }
      static RotationYawPitchRollToRef(yaw, pitch, roll, result) {
        const halfRoll = roll * 0.5;
        const halfPitch = pitch * 0.5;
        const halfYaw = yaw * 0.5;
        const sinRoll = Math.sin(halfRoll);
        const cosRoll = Math.cos(halfRoll);
        const sinPitch = Math.sin(halfPitch);
        const cosPitch = Math.cos(halfPitch);
        const sinYaw = Math.sin(halfYaw);
        const cosYaw = Math.cos(halfYaw);
        result._x = cosYaw * sinPitch * cosRoll + sinYaw * cosPitch * sinRoll;
        result._y = sinYaw * cosPitch * cosRoll - cosYaw * sinPitch * sinRoll;
        result._z = cosYaw * cosPitch * sinRoll - sinYaw * sinPitch * cosRoll;
        result._w = cosYaw * cosPitch * cosRoll + sinYaw * sinPitch * sinRoll;
        result._isDirty = true;
        return result;
      }
      static RotationAlphaBetaGamma(alpha, beta, gamma) {
        const result = new Quaternion();
        Quaternion.RotationAlphaBetaGammaToRef(alpha, beta, gamma, result);
        return result;
      }
      static RotationAlphaBetaGammaToRef(alpha, beta, gamma, result) {
        const halfGammaPlusAlpha = (gamma + alpha) * 0.5;
        const halfGammaMinusAlpha = (gamma - alpha) * 0.5;
        const halfBeta = beta * 0.5;
        result._x = Math.cos(halfGammaMinusAlpha) * Math.sin(halfBeta);
        result._y = Math.sin(halfGammaMinusAlpha) * Math.sin(halfBeta);
        result._z = Math.sin(halfGammaPlusAlpha) * Math.cos(halfBeta);
        result._w = Math.cos(halfGammaPlusAlpha) * Math.cos(halfBeta);
        result._isDirty = true;
        return result;
      }
      static RotationQuaternionFromAxis(axis1, axis2, axis3) {
        const quat = new Quaternion(0, 0, 0, 0);
        Quaternion.RotationQuaternionFromAxisToRef(axis1, axis2, axis3, quat);
        return quat;
      }
      static RotationQuaternionFromAxisToRef(axis1, axis2, axis3, ref) {
        const rotMat = MathTmp.Matrix[0];
        Matrix.FromXYZAxesToRef(axis1.normalize(), axis2.normalize(), axis3.normalize(), rotMat);
        Quaternion.FromRotationMatrixToRef(rotMat, ref);
        return ref;
      }
      static FromLookDirectionLH(forward, up) {
        const quat = new Quaternion();
        Quaternion.FromLookDirectionLHToRef(forward, up, quat);
        return quat;
      }
      static FromLookDirectionLHToRef(forward, up, ref) {
        const rotMat = MathTmp.Matrix[0];
        Matrix.LookDirectionLHToRef(forward, up, rotMat);
        Quaternion.FromRotationMatrixToRef(rotMat, ref);
        return ref;
      }
      static FromLookDirectionRH(forward, up) {
        const quat = new Quaternion();
        Quaternion.FromLookDirectionRHToRef(forward, up, quat);
        return quat;
      }
      static FromLookDirectionRHToRef(forward, up, ref) {
        const rotMat = MathTmp.Matrix[0];
        Matrix.LookDirectionRHToRef(forward, up, rotMat);
        return Quaternion.FromRotationMatrixToRef(rotMat, ref);
      }
      static Slerp(left, right, amount) {
        const result = Quaternion.Identity();
        Quaternion.SlerpToRef(left, right, amount, result);
        return result;
      }
      static SlerpToRef(left, right, amount, result) {
        let num2;
        let num3;
        let num4 = left._x * right._x + left._y * right._y + left._z * right._z + left._w * right._w;
        let flag = false;
        if (num4 < 0) {
          flag = true;
          num4 = -num4;
        }
        if (num4 > 0.999999) {
          num3 = 1 - amount;
          num2 = flag ? -amount : amount;
        } else {
          const num5 = Math.acos(num4);
          const num6 = 1 / Math.sin(num5);
          num3 = Math.sin((1 - amount) * num5) * num6;
          num2 = flag ? -Math.sin(amount * num5) * num6 : Math.sin(amount * num5) * num6;
        }
        result._x = num3 * left._x + num2 * right._x;
        result._y = num3 * left._y + num2 * right._y;
        result._z = num3 * left._z + num2 * right._z;
        result._w = num3 * left._w + num2 * right._w;
        result._isDirty = true;
        return result;
      }
      static Hermite(value1, tangent1, value2, tangent2, amount) {
        const squared = amount * amount;
        const cubed = amount * squared;
        const part1 = 2 * cubed - 3 * squared + 1;
        const part2 = -2 * cubed + 3 * squared;
        const part3 = cubed - 2 * squared + amount;
        const part4 = cubed - squared;
        const x = value1._x * part1 + value2._x * part2 + tangent1._x * part3 + tangent2._x * part4;
        const y = value1._y * part1 + value2._y * part2 + tangent1._y * part3 + tangent2._y * part4;
        const z = value1._z * part1 + value2._z * part2 + tangent1._z * part3 + tangent2._z * part4;
        const w = value1._w * part1 + value2._w * part2 + tangent1._w * part3 + tangent2._w * part4;
        return new value1.constructor(x, y, z, w);
      }
      static Hermite1stDerivative(value1, tangent1, value2, tangent2, time) {
        const result = new value1.constructor();
        this.Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result);
        return result;
      }
      static Hermite1stDerivativeToRef(value1, tangent1, value2, tangent2, time, result) {
        const t2 = time * time;
        result._x = (t2 - time) * 6 * value1._x + (3 * t2 - 4 * time + 1) * tangent1._x + (-t2 + time) * 6 * value2._x + (3 * t2 - 2 * time) * tangent2._x;
        result._y = (t2 - time) * 6 * value1._y + (3 * t2 - 4 * time + 1) * tangent1._y + (-t2 + time) * 6 * value2._y + (3 * t2 - 2 * time) * tangent2._y;
        result._z = (t2 - time) * 6 * value1._z + (3 * t2 - 4 * time + 1) * tangent1._z + (-t2 + time) * 6 * value2._z + (3 * t2 - 2 * time) * tangent2._z;
        result._w = (t2 - time) * 6 * value1._w + (3 * t2 - 4 * time + 1) * tangent1._w + (-t2 + time) * 6 * value2._w + (3 * t2 - 2 * time) * tangent2._w;
        result._isDirty = true;
        return result;
      }
    };
    Matrix = class {
      static get Use64Bits() {
        return PerformanceConfigurator.MatrixUse64Bits;
      }
      get m() {
        return this._m;
      }
      markAsUpdated() {
        this.updateFlag = Matrix._UpdateFlagSeed++;
        this._isIdentity = false;
        this._isIdentity3x2 = false;
        this._isIdentityDirty = true;
        this._isIdentity3x2Dirty = true;
      }
      _updateIdentityStatus(isIdentity, isIdentityDirty = false, isIdentity3x2 = false, isIdentity3x2Dirty = true) {
        this._isIdentity = isIdentity;
        this._isIdentity3x2 = isIdentity || isIdentity3x2;
        this._isIdentityDirty = this._isIdentity ? false : isIdentityDirty;
        this._isIdentity3x2Dirty = this._isIdentity3x2 ? false : isIdentity3x2Dirty;
      }
      constructor() {
        this._isIdentity = false;
        this._isIdentityDirty = true;
        this._isIdentity3x2 = true;
        this._isIdentity3x2Dirty = true;
        this.updateFlag = -1;
        if (PerformanceConfigurator.MatrixTrackPrecisionChange) {
          PerformanceConfigurator.MatrixTrackedMatrices.push(this);
        }
        this._m = new PerformanceConfigurator.MatrixCurrentType(16);
        this.markAsUpdated();
      }
      isIdentity() {
        if (this._isIdentityDirty) {
          this._isIdentityDirty = false;
          const m = this._m;
          this._isIdentity = m[0] === 1 && m[1] === 0 && m[2] === 0 && m[3] === 0 && m[4] === 0 && m[5] === 1 && m[6] === 0 && m[7] === 0 && m[8] === 0 && m[9] === 0 && m[10] === 1 && m[11] === 0 && m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1;
        }
        return this._isIdentity;
      }
      isIdentityAs3x2() {
        if (this._isIdentity3x2Dirty) {
          this._isIdentity3x2Dirty = false;
          if (this._m[0] !== 1 || this._m[5] !== 1 || this._m[15] !== 1) {
            this._isIdentity3x2 = false;
          } else if (this._m[1] !== 0 || this._m[2] !== 0 || this._m[3] !== 0 || this._m[4] !== 0 || this._m[6] !== 0 || this._m[7] !== 0 || this._m[8] !== 0 || this._m[9] !== 0 || this._m[10] !== 0 || this._m[11] !== 0 || this._m[12] !== 0 || this._m[13] !== 0 || this._m[14] !== 0) {
            this._isIdentity3x2 = false;
          } else {
            this._isIdentity3x2 = true;
          }
        }
        return this._isIdentity3x2;
      }
      determinant() {
        if (this._isIdentity === true) {
          return 1;
        }
        const m = this._m;
        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
        const det_22_33 = m22 * m33 - m32 * m23;
        const det_21_33 = m21 * m33 - m31 * m23;
        const det_21_32 = m21 * m32 - m31 * m22;
        const det_20_33 = m20 * m33 - m30 * m23;
        const det_20_32 = m20 * m32 - m22 * m30;
        const det_20_31 = m20 * m31 - m30 * m21;
        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        return m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
      }
      toString() {
        return `{${this.m[0]}, ${this.m[1]}, ${this.m[2]}, ${this.m[3]}
${this.m[4]}, ${this.m[5]}, ${this.m[6]}, ${this.m[7]}
${this.m[8]}, ${this.m[9]}, ${this.m[10]}, ${this.m[11]}
${this.m[12]}, ${this.m[13]}, ${this.m[14]}, ${this.m[15]}}`;
      }
      toArray() {
        return this._m;
      }
      asArray() {
        return this._m;
      }
      invert() {
        this.invertToRef(this);
        return this;
      }
      reset() {
        Matrix.FromValuesToRef(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, this);
        this._updateIdentityStatus(false);
        return this;
      }
      add(other) {
        const result = new this.constructor();
        this.addToRef(other, result);
        return result;
      }
      addToRef(other, result) {
        const m = this._m;
        const resultM = result._m;
        const otherM = other.m;
        for (let index = 0; index < 16; index++) {
          resultM[index] = m[index] + otherM[index];
        }
        result.markAsUpdated();
        return result;
      }
      addToSelf(other) {
        const m = this._m;
        const otherM = other.m;
        for (let index = 0; index < 16; index++) {
          m[index] += otherM[index];
        }
        this.markAsUpdated();
        return this;
      }
      invertToRef(other) {
        if (this._isIdentity === true) {
          Matrix.IdentityToRef(other);
          return other;
        }
        const m = this._m;
        const m00 = m[0], m01 = m[1], m02 = m[2], m03 = m[3];
        const m10 = m[4], m11 = m[5], m12 = m[6], m13 = m[7];
        const m20 = m[8], m21 = m[9], m22 = m[10], m23 = m[11];
        const m30 = m[12], m31 = m[13], m32 = m[14], m33 = m[15];
        const det_22_33 = m22 * m33 - m32 * m23;
        const det_21_33 = m21 * m33 - m31 * m23;
        const det_21_32 = m21 * m32 - m31 * m22;
        const det_20_33 = m20 * m33 - m30 * m23;
        const det_20_32 = m20 * m32 - m22 * m30;
        const det_20_31 = m20 * m31 - m30 * m21;
        const cofact_00 = +(m11 * det_22_33 - m12 * det_21_33 + m13 * det_21_32);
        const cofact_01 = -(m10 * det_22_33 - m12 * det_20_33 + m13 * det_20_32);
        const cofact_02 = +(m10 * det_21_33 - m11 * det_20_33 + m13 * det_20_31);
        const cofact_03 = -(m10 * det_21_32 - m11 * det_20_32 + m12 * det_20_31);
        const det = m00 * cofact_00 + m01 * cofact_01 + m02 * cofact_02 + m03 * cofact_03;
        if (det === 0) {
          other.copyFrom(this);
          return other;
        }
        const detInv = 1 / det;
        const det_12_33 = m12 * m33 - m32 * m13;
        const det_11_33 = m11 * m33 - m31 * m13;
        const det_11_32 = m11 * m32 - m31 * m12;
        const det_10_33 = m10 * m33 - m30 * m13;
        const det_10_32 = m10 * m32 - m30 * m12;
        const det_10_31 = m10 * m31 - m30 * m11;
        const det_12_23 = m12 * m23 - m22 * m13;
        const det_11_23 = m11 * m23 - m21 * m13;
        const det_11_22 = m11 * m22 - m21 * m12;
        const det_10_23 = m10 * m23 - m20 * m13;
        const det_10_22 = m10 * m22 - m20 * m12;
        const det_10_21 = m10 * m21 - m20 * m11;
        const cofact_10 = -(m01 * det_22_33 - m02 * det_21_33 + m03 * det_21_32);
        const cofact_11 = +(m00 * det_22_33 - m02 * det_20_33 + m03 * det_20_32);
        const cofact_12 = -(m00 * det_21_33 - m01 * det_20_33 + m03 * det_20_31);
        const cofact_13 = +(m00 * det_21_32 - m01 * det_20_32 + m02 * det_20_31);
        const cofact_20 = +(m01 * det_12_33 - m02 * det_11_33 + m03 * det_11_32);
        const cofact_21 = -(m00 * det_12_33 - m02 * det_10_33 + m03 * det_10_32);
        const cofact_22 = +(m00 * det_11_33 - m01 * det_10_33 + m03 * det_10_31);
        const cofact_23 = -(m00 * det_11_32 - m01 * det_10_32 + m02 * det_10_31);
        const cofact_30 = -(m01 * det_12_23 - m02 * det_11_23 + m03 * det_11_22);
        const cofact_31 = +(m00 * det_12_23 - m02 * det_10_23 + m03 * det_10_22);
        const cofact_32 = -(m00 * det_11_23 - m01 * det_10_23 + m03 * det_10_21);
        const cofact_33 = +(m00 * det_11_22 - m01 * det_10_22 + m02 * det_10_21);
        Matrix.FromValuesToRef(cofact_00 * detInv, cofact_10 * detInv, cofact_20 * detInv, cofact_30 * detInv, cofact_01 * detInv, cofact_11 * detInv, cofact_21 * detInv, cofact_31 * detInv, cofact_02 * detInv, cofact_12 * detInv, cofact_22 * detInv, cofact_32 * detInv, cofact_03 * detInv, cofact_13 * detInv, cofact_23 * detInv, cofact_33 * detInv, other);
        return other;
      }
      addAtIndex(index, value) {
        this._m[index] += value;
        this.markAsUpdated();
        return this;
      }
      multiplyAtIndex(index, value) {
        this._m[index] *= value;
        this.markAsUpdated();
        return this;
      }
      setTranslationFromFloats(x, y, z) {
        this._m[12] = x;
        this._m[13] = y;
        this._m[14] = z;
        this.markAsUpdated();
        return this;
      }
      addTranslationFromFloats(x, y, z) {
        this._m[12] += x;
        this._m[13] += y;
        this._m[14] += z;
        this.markAsUpdated();
        return this;
      }
      setTranslation(vector3) {
        return this.setTranslationFromFloats(vector3._x, vector3._y, vector3._z);
      }
      getTranslation() {
        return new Vector3(this._m[12], this._m[13], this._m[14]);
      }
      getTranslationToRef(result) {
        result.x = this._m[12];
        result.y = this._m[13];
        result.z = this._m[14];
        return result;
      }
      removeRotationAndScaling() {
        const m = this.m;
        Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, m[12], m[13], m[14], m[15], this);
        this._updateIdentityStatus(m[12] === 0 && m[13] === 0 && m[14] === 0 && m[15] === 1);
        return this;
      }
      multiply(other) {
        const result = new this.constructor();
        this.multiplyToRef(other, result);
        return result;
      }
      copyFrom(other) {
        other.copyToArray(this._m);
        const o = other;
        this.updateFlag = o.updateFlag;
        this._updateIdentityStatus(o._isIdentity, o._isIdentityDirty, o._isIdentity3x2, o._isIdentity3x2Dirty);
        return this;
      }
      copyToArray(array, offset = 0) {
        const source = this._m;
        array[offset] = source[0];
        array[offset + 1] = source[1];
        array[offset + 2] = source[2];
        array[offset + 3] = source[3];
        array[offset + 4] = source[4];
        array[offset + 5] = source[5];
        array[offset + 6] = source[6];
        array[offset + 7] = source[7];
        array[offset + 8] = source[8];
        array[offset + 9] = source[9];
        array[offset + 10] = source[10];
        array[offset + 11] = source[11];
        array[offset + 12] = source[12];
        array[offset + 13] = source[13];
        array[offset + 14] = source[14];
        array[offset + 15] = source[15];
        return this;
      }
      multiplyToRef(other, result) {
        if (this._isIdentity) {
          result.copyFrom(other);
          return result;
        }
        if (other._isIdentity) {
          result.copyFrom(this);
          return result;
        }
        this.multiplyToArray(other, result._m, 0);
        result.markAsUpdated();
        return result;
      }
      multiplyToArray(other, result, offset) {
        const m = this._m;
        const otherM = other.m;
        const tm0 = m[0], tm1 = m[1], tm2 = m[2], tm3 = m[3];
        const tm4 = m[4], tm5 = m[5], tm6 = m[6], tm7 = m[7];
        const tm8 = m[8], tm9 = m[9], tm10 = m[10], tm11 = m[11];
        const tm12 = m[12], tm13 = m[13], tm14 = m[14], tm15 = m[15];
        const om0 = otherM[0], om1 = otherM[1], om2 = otherM[2], om3 = otherM[3];
        const om4 = otherM[4], om5 = otherM[5], om6 = otherM[6], om7 = otherM[7];
        const om8 = otherM[8], om9 = otherM[9], om10 = otherM[10], om11 = otherM[11];
        const om12 = otherM[12], om13 = otherM[13], om14 = otherM[14], om15 = otherM[15];
        result[offset] = tm0 * om0 + tm1 * om4 + tm2 * om8 + tm3 * om12;
        result[offset + 1] = tm0 * om1 + tm1 * om5 + tm2 * om9 + tm3 * om13;
        result[offset + 2] = tm0 * om2 + tm1 * om6 + tm2 * om10 + tm3 * om14;
        result[offset + 3] = tm0 * om3 + tm1 * om7 + tm2 * om11 + tm3 * om15;
        result[offset + 4] = tm4 * om0 + tm5 * om4 + tm6 * om8 + tm7 * om12;
        result[offset + 5] = tm4 * om1 + tm5 * om5 + tm6 * om9 + tm7 * om13;
        result[offset + 6] = tm4 * om2 + tm5 * om6 + tm6 * om10 + tm7 * om14;
        result[offset + 7] = tm4 * om3 + tm5 * om7 + tm6 * om11 + tm7 * om15;
        result[offset + 8] = tm8 * om0 + tm9 * om4 + tm10 * om8 + tm11 * om12;
        result[offset + 9] = tm8 * om1 + tm9 * om5 + tm10 * om9 + tm11 * om13;
        result[offset + 10] = tm8 * om2 + tm9 * om6 + tm10 * om10 + tm11 * om14;
        result[offset + 11] = tm8 * om3 + tm9 * om7 + tm10 * om11 + tm11 * om15;
        result[offset + 12] = tm12 * om0 + tm13 * om4 + tm14 * om8 + tm15 * om12;
        result[offset + 13] = tm12 * om1 + tm13 * om5 + tm14 * om9 + tm15 * om13;
        result[offset + 14] = tm12 * om2 + tm13 * om6 + tm14 * om10 + tm15 * om14;
        result[offset + 15] = tm12 * om3 + tm13 * om7 + tm14 * om11 + tm15 * om15;
        return this;
      }
      equals(value) {
        const other = value;
        if (!other) {
          return false;
        }
        if (this._isIdentity || other._isIdentity) {
          if (!this._isIdentityDirty && !other._isIdentityDirty) {
            return this._isIdentity && other._isIdentity;
          }
        }
        const m = this.m;
        const om = other.m;
        return m[0] === om[0] && m[1] === om[1] && m[2] === om[2] && m[3] === om[3] && m[4] === om[4] && m[5] === om[5] && m[6] === om[6] && m[7] === om[7] && m[8] === om[8] && m[9] === om[9] && m[10] === om[10] && m[11] === om[11] && m[12] === om[12] && m[13] === om[13] && m[14] === om[14] && m[15] === om[15];
      }
      clone() {
        const matrix = new this.constructor();
        matrix.copyFrom(this);
        return matrix;
      }
      getClassName() {
        return "Matrix";
      }
      getHashCode() {
        let hash = _ExtractAsInt(this._m[0]);
        for (let i = 1; i < 16; i++) {
          hash = hash * 397 ^ _ExtractAsInt(this._m[i]);
        }
        return hash;
      }
      decomposeToTransformNode(node) {
        node.rotationQuaternion = node.rotationQuaternion || new Quaternion();
        return this.decompose(node.scaling, node.rotationQuaternion, node.position);
      }
      decompose(scale, rotation, translation, preserveScalingNode) {
        if (this._isIdentity) {
          if (translation) {
            translation.setAll(0);
          }
          if (scale) {
            scale.setAll(1);
          }
          if (rotation) {
            rotation.copyFromFloats(0, 0, 0, 1);
          }
          return true;
        }
        const m = this._m;
        if (translation) {
          translation.copyFromFloats(m[12], m[13], m[14]);
        }
        scale = scale || MathTmp.Vector3[0];
        scale.x = Math.sqrt(m[0] * m[0] + m[1] * m[1] + m[2] * m[2]);
        scale.y = Math.sqrt(m[4] * m[4] + m[5] * m[5] + m[6] * m[6]);
        scale.z = Math.sqrt(m[8] * m[8] + m[9] * m[9] + m[10] * m[10]);
        if (preserveScalingNode) {
          const signX = preserveScalingNode.scaling.x < 0 ? -1 : 1;
          const signY = preserveScalingNode.scaling.y < 0 ? -1 : 1;
          const signZ = preserveScalingNode.scaling.z < 0 ? -1 : 1;
          scale.x *= signX;
          scale.y *= signY;
          scale.z *= signZ;
        } else {
          if (this.determinant() <= 0) {
            scale.y *= -1;
          }
        }
        if (scale._x === 0 || scale._y === 0 || scale._z === 0) {
          if (rotation) {
            rotation.copyFromFloats(0, 0, 0, 1);
          }
          return false;
        }
        if (rotation) {
          const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
          Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, MathTmp.Matrix[0]);
          Quaternion.FromRotationMatrixToRef(MathTmp.Matrix[0], rotation);
        }
        return true;
      }
      getRow(index) {
        if (index < 0 || index > 3) {
          return null;
        }
        const i = index * 4;
        return new Vector4(this._m[i + 0], this._m[i + 1], this._m[i + 2], this._m[i + 3]);
      }
      getRowToRef(index, rowVector) {
        if (index >= 0 && index < 3) {
          const i = index * 4;
          rowVector.x = this._m[i + 0];
          rowVector.y = this._m[i + 1];
          rowVector.z = this._m[i + 2];
          rowVector.w = this._m[i + 3];
        }
        return rowVector;
      }
      setRow(index, row) {
        return this.setRowFromFloats(index, row.x, row.y, row.z, row.w);
      }
      transpose() {
        const result = new this.constructor();
        Matrix.TransposeToRef(this, result);
        return result;
      }
      transposeToRef(result) {
        Matrix.TransposeToRef(this, result);
        return result;
      }
      setRowFromFloats(index, x, y, z, w) {
        if (index < 0 || index > 3) {
          return this;
        }
        const i = index * 4;
        this._m[i + 0] = x;
        this._m[i + 1] = y;
        this._m[i + 2] = z;
        this._m[i + 3] = w;
        this.markAsUpdated();
        return this;
      }
      scale(scale) {
        const result = new this.constructor();
        this.scaleToRef(scale, result);
        return result;
      }
      scaleToRef(scale, result) {
        for (let index = 0; index < 16; index++) {
          result._m[index] = this._m[index] * scale;
        }
        result.markAsUpdated();
        return result;
      }
      scaleAndAddToRef(scale, result) {
        for (let index = 0; index < 16; index++) {
          result._m[index] += this._m[index] * scale;
        }
        result.markAsUpdated();
        return result;
      }
      toNormalMatrix(ref) {
        const tmp = MathTmp.Matrix[0];
        this.invertToRef(tmp);
        tmp.transposeToRef(ref);
        const m = ref._m;
        Matrix.FromValuesToRef(m[0], m[1], m[2], 0, m[4], m[5], m[6], 0, m[8], m[9], m[10], 0, 0, 0, 0, 1, ref);
        return ref;
      }
      getRotationMatrix() {
        const result = new this.constructor();
        this.getRotationMatrixToRef(result);
        return result;
      }
      getRotationMatrixToRef(result) {
        const scale = MathTmp.Vector3[0];
        if (!this.decompose(scale)) {
          Matrix.IdentityToRef(result);
          return result;
        }
        const m = this._m;
        const sx = 1 / scale._x, sy = 1 / scale._y, sz = 1 / scale._z;
        Matrix.FromValuesToRef(m[0] * sx, m[1] * sx, m[2] * sx, 0, m[4] * sy, m[5] * sy, m[6] * sy, 0, m[8] * sz, m[9] * sz, m[10] * sz, 0, 0, 0, 0, 1, result);
        return result;
      }
      toggleModelMatrixHandInPlace() {
        const m = this._m;
        m[2] *= -1;
        m[6] *= -1;
        m[8] *= -1;
        m[9] *= -1;
        m[14] *= -1;
        this.markAsUpdated();
        return this;
      }
      toggleProjectionMatrixHandInPlace() {
        const m = this._m;
        m[8] *= -1;
        m[9] *= -1;
        m[10] *= -1;
        m[11] *= -1;
        this.markAsUpdated();
        return this;
      }
      static FromArray(array, offset = 0) {
        const result = new Matrix();
        Matrix.FromArrayToRef(array, offset, result);
        return result;
      }
      static FromArrayToRef(array, offset, result) {
        for (let index = 0; index < 16; index++) {
          result._m[index] = array[index + offset];
        }
        result.markAsUpdated();
        return result;
      }
      static FromFloat32ArrayToRefScaled(array, offset, scale, result) {
        for (let index = 0; index < 16; index++) {
          result._m[index] = array[index + offset] * scale;
        }
        result.markAsUpdated();
        return result;
      }
      static get IdentityReadOnly() {
        return Matrix._IdentityReadOnly;
      }
      static FromValuesToRef(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44, result) {
        const m = result._m;
        m[0] = initialM11;
        m[1] = initialM12;
        m[2] = initialM13;
        m[3] = initialM14;
        m[4] = initialM21;
        m[5] = initialM22;
        m[6] = initialM23;
        m[7] = initialM24;
        m[8] = initialM31;
        m[9] = initialM32;
        m[10] = initialM33;
        m[11] = initialM34;
        m[12] = initialM41;
        m[13] = initialM42;
        m[14] = initialM43;
        m[15] = initialM44;
        result.markAsUpdated();
      }
      static FromValues(initialM11, initialM12, initialM13, initialM14, initialM21, initialM22, initialM23, initialM24, initialM31, initialM32, initialM33, initialM34, initialM41, initialM42, initialM43, initialM44) {
        const result = new Matrix();
        const m = result._m;
        m[0] = initialM11;
        m[1] = initialM12;
        m[2] = initialM13;
        m[3] = initialM14;
        m[4] = initialM21;
        m[5] = initialM22;
        m[6] = initialM23;
        m[7] = initialM24;
        m[8] = initialM31;
        m[9] = initialM32;
        m[10] = initialM33;
        m[11] = initialM34;
        m[12] = initialM41;
        m[13] = initialM42;
        m[14] = initialM43;
        m[15] = initialM44;
        result.markAsUpdated();
        return result;
      }
      static Compose(scale, rotation, translation) {
        const result = new Matrix();
        Matrix.ComposeToRef(scale, rotation, translation, result);
        return result;
      }
      static ComposeToRef(scale, rotation, translation, result) {
        const m = result._m;
        const x = rotation._x, y = rotation._y, z = rotation._z, w = rotation._w;
        const x2 = x + x, y2 = y + y, z2 = z + z;
        const xx = x * x2, xy = x * y2, xz = x * z2;
        const yy = y * y2, yz = y * z2, zz = z * z2;
        const wx = w * x2, wy = w * y2, wz = w * z2;
        const sx = scale._x, sy = scale._y, sz = scale._z;
        m[0] = (1 - (yy + zz)) * sx;
        m[1] = (xy + wz) * sx;
        m[2] = (xz - wy) * sx;
        m[3] = 0;
        m[4] = (xy - wz) * sy;
        m[5] = (1 - (xx + zz)) * sy;
        m[6] = (yz + wx) * sy;
        m[7] = 0;
        m[8] = (xz + wy) * sz;
        m[9] = (yz - wx) * sz;
        m[10] = (1 - (xx + yy)) * sz;
        m[11] = 0;
        m[12] = translation._x;
        m[13] = translation._y;
        m[14] = translation._z;
        m[15] = 1;
        result.markAsUpdated();
        return result;
      }
      static Identity() {
        const identity = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1);
        identity._updateIdentityStatus(true);
        return identity;
      }
      static IdentityToRef(result) {
        Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(true);
        return result;
      }
      static Zero() {
        const zero = Matrix.FromValues(0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0);
        zero._updateIdentityStatus(false);
        return zero;
      }
      static RotationX(angle) {
        const result = new Matrix();
        Matrix.RotationXToRef(angle, result);
        return result;
      }
      static Invert(source) {
        const result = new source.constructor();
        source.invertToRef(result);
        return result;
      }
      static RotationXToRef(angle, result) {
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        Matrix.FromValuesToRef(1, 0, 0, 0, 0, c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(c === 1 && s === 0);
        return result;
      }
      static RotationY(angle) {
        const result = new Matrix();
        Matrix.RotationYToRef(angle, result);
        return result;
      }
      static RotationYToRef(angle, result) {
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        Matrix.FromValuesToRef(c, 0, -s, 0, 0, 1, 0, 0, s, 0, c, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(c === 1 && s === 0);
        return result;
      }
      static RotationZ(angle) {
        const result = new Matrix();
        Matrix.RotationZToRef(angle, result);
        return result;
      }
      static RotationZToRef(angle, result) {
        const s = Math.sin(angle);
        const c = Math.cos(angle);
        Matrix.FromValuesToRef(c, s, 0, 0, -s, c, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(c === 1 && s === 0);
        return result;
      }
      static RotationAxis(axis, angle) {
        const result = new Matrix();
        Matrix.RotationAxisToRef(axis, angle, result);
        return result;
      }
      static RotationAxisToRef(axis, angle, result) {
        const s = Math.sin(-angle);
        const c = Math.cos(-angle);
        const c1 = 1 - c;
        axis.normalize();
        const m = result._m;
        m[0] = axis._x * axis._x * c1 + c;
        m[1] = axis._x * axis._y * c1 - axis._z * s;
        m[2] = axis._x * axis._z * c1 + axis._y * s;
        m[3] = 0;
        m[4] = axis._y * axis._x * c1 + axis._z * s;
        m[5] = axis._y * axis._y * c1 + c;
        m[6] = axis._y * axis._z * c1 - axis._x * s;
        m[7] = 0;
        m[8] = axis._z * axis._x * c1 - axis._y * s;
        m[9] = axis._z * axis._y * c1 + axis._x * s;
        m[10] = axis._z * axis._z * c1 + c;
        m[11] = 0;
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        result.markAsUpdated();
        return result;
      }
      static RotationAlignToRef(from, to, result, useYAxisForCoplanar = false) {
        const c = Vector3.Dot(to, from);
        const m = result._m;
        if (c < -1 + Epsilon) {
          m[0] = -1;
          m[1] = 0;
          m[2] = 0;
          m[3] = 0;
          m[4] = 0;
          m[5] = useYAxisForCoplanar ? 1 : -1;
          m[6] = 0;
          m[7] = 0;
          m[8] = 0;
          m[9] = 0;
          m[10] = useYAxisForCoplanar ? -1 : 1;
          m[11] = 0;
        } else {
          const v = Vector3.Cross(to, from);
          const k = 1 / (1 + c);
          m[0] = v._x * v._x * k + c;
          m[1] = v._y * v._x * k - v._z;
          m[2] = v._z * v._x * k + v._y;
          m[3] = 0;
          m[4] = v._x * v._y * k + v._z;
          m[5] = v._y * v._y * k + c;
          m[6] = v._z * v._y * k - v._x;
          m[7] = 0;
          m[8] = v._x * v._z * k - v._y;
          m[9] = v._y * v._z * k + v._x;
          m[10] = v._z * v._z * k + c;
          m[11] = 0;
        }
        m[12] = 0;
        m[13] = 0;
        m[14] = 0;
        m[15] = 1;
        result.markAsUpdated();
        return result;
      }
      static RotationYawPitchRoll(yaw, pitch, roll) {
        const result = new Matrix();
        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, result);
        return result;
      }
      static RotationYawPitchRollToRef(yaw, pitch, roll, result) {
        Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, MathTmp.Quaternion[0]);
        MathTmp.Quaternion[0].toRotationMatrix(result);
        return result;
      }
      static Scaling(x, y, z) {
        const result = new Matrix();
        Matrix.ScalingToRef(x, y, z, result);
        return result;
      }
      static ScalingToRef(x, y, z, result) {
        Matrix.FromValuesToRef(x, 0, 0, 0, 0, y, 0, 0, 0, 0, z, 0, 0, 0, 0, 1, result);
        result._updateIdentityStatus(x === 1 && y === 1 && z === 1);
        return result;
      }
      static Translation(x, y, z) {
        const result = new Matrix();
        Matrix.TranslationToRef(x, y, z, result);
        return result;
      }
      static TranslationToRef(x, y, z, result) {
        Matrix.FromValuesToRef(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, x, y, z, 1, result);
        result._updateIdentityStatus(x === 0 && y === 0 && z === 0);
        return result;
      }
      static Lerp(startValue, endValue, gradient) {
        const result = new startValue.constructor();
        Matrix.LerpToRef(startValue, endValue, gradient, result);
        return result;
      }
      static LerpToRef(startValue, endValue, gradient, result) {
        const resultM = result._m;
        const startM = startValue.m;
        const endM = endValue.m;
        for (let index = 0; index < 16; index++) {
          resultM[index] = startM[index] * (1 - gradient) + endM[index] * gradient;
        }
        result.markAsUpdated();
        return result;
      }
      static DecomposeLerp(startValue, endValue, gradient) {
        const result = new startValue.constructor();
        Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
        return result;
      }
      static DecomposeLerpToRef(startValue, endValue, gradient, result) {
        const startScale = MathTmp.Vector3[0];
        const startRotation = MathTmp.Quaternion[0];
        const startTranslation = MathTmp.Vector3[1];
        startValue.decompose(startScale, startRotation, startTranslation);
        const endScale = MathTmp.Vector3[2];
        const endRotation = MathTmp.Quaternion[1];
        const endTranslation = MathTmp.Vector3[3];
        endValue.decompose(endScale, endRotation, endTranslation);
        const resultScale = MathTmp.Vector3[4];
        Vector3.LerpToRef(startScale, endScale, gradient, resultScale);
        const resultRotation = MathTmp.Quaternion[2];
        Quaternion.SlerpToRef(startRotation, endRotation, gradient, resultRotation);
        const resultTranslation = MathTmp.Vector3[5];
        Vector3.LerpToRef(startTranslation, endTranslation, gradient, resultTranslation);
        Matrix.ComposeToRef(resultScale, resultRotation, resultTranslation, result);
        return result;
      }
      static LookAtLH(eye, target, up) {
        const result = new Matrix();
        Matrix.LookAtLHToRef(eye, target, up, result);
        return result;
      }
      static LookAtLHToRef(eye, target, up, result) {
        const xAxis = MathTmp.Vector3[0];
        const yAxis = MathTmp.Vector3[1];
        const zAxis = MathTmp.Vector3[2];
        target.subtractToRef(eye, zAxis);
        zAxis.normalize();
        Vector3.CrossToRef(up, zAxis, xAxis);
        const xSquareLength = xAxis.lengthSquared();
        if (xSquareLength === 0) {
          xAxis.x = 1;
        } else {
          xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
        }
        Vector3.CrossToRef(zAxis, xAxis, yAxis);
        yAxis.normalize();
        const ex = -Vector3.Dot(xAxis, eye);
        const ey = -Vector3.Dot(yAxis, eye);
        const ez = -Vector3.Dot(zAxis, eye);
        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
      }
      static LookAtRH(eye, target, up) {
        const result = new Matrix();
        Matrix.LookAtRHToRef(eye, target, up, result);
        return result;
      }
      static LookAtRHToRef(eye, target, up, result) {
        const xAxis = MathTmp.Vector3[0];
        const yAxis = MathTmp.Vector3[1];
        const zAxis = MathTmp.Vector3[2];
        eye.subtractToRef(target, zAxis);
        zAxis.normalize();
        Vector3.CrossToRef(up, zAxis, xAxis);
        const xSquareLength = xAxis.lengthSquared();
        if (xSquareLength === 0) {
          xAxis.x = 1;
        } else {
          xAxis.normalizeFromLength(Math.sqrt(xSquareLength));
        }
        Vector3.CrossToRef(zAxis, xAxis, yAxis);
        yAxis.normalize();
        const ex = -Vector3.Dot(xAxis, eye);
        const ey = -Vector3.Dot(yAxis, eye);
        const ez = -Vector3.Dot(zAxis, eye);
        Matrix.FromValuesToRef(xAxis._x, yAxis._x, zAxis._x, 0, xAxis._y, yAxis._y, zAxis._y, 0, xAxis._z, yAxis._z, zAxis._z, 0, ex, ey, ez, 1, result);
        return result;
      }
      static LookDirectionLH(forward, up) {
        const result = new Matrix();
        Matrix.LookDirectionLHToRef(forward, up, result);
        return result;
      }
      static LookDirectionLHToRef(forward, up, result) {
        const back = MathTmp.Vector3[0];
        back.copyFrom(forward);
        back.scaleInPlace(-1);
        const left = MathTmp.Vector3[1];
        Vector3.CrossToRef(up, back, left);
        Matrix.FromValuesToRef(left._x, left._y, left._z, 0, up._x, up._y, up._z, 0, back._x, back._y, back._z, 0, 0, 0, 0, 1, result);
        return result;
      }
      static LookDirectionRH(forward, up) {
        const result = new Matrix();
        Matrix.LookDirectionRHToRef(forward, up, result);
        return result;
      }
      static LookDirectionRHToRef(forward, up, result) {
        const right = MathTmp.Vector3[2];
        Vector3.CrossToRef(up, forward, right);
        Matrix.FromValuesToRef(right._x, right._y, right._z, 0, up._x, up._y, up._z, 0, forward._x, forward._y, forward._z, 0, 0, 0, 0, 1, result);
        return result;
      }
      static OrthoLH(width, height, znear, zfar, halfZRange) {
        const matrix = new Matrix();
        Matrix.OrthoLHToRef(width, height, znear, zfar, matrix, halfZRange);
        return matrix;
      }
      static OrthoLHToRef(width, height, znear, zfar, result, halfZRange) {
        const n = znear;
        const f = zfar;
        const a = 2 / width;
        const b = 2 / height;
        const c = 2 / (f - n);
        const d = -(f + n) / (f - n);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, 0, 0, d, 1, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(a === 1 && b === 1 && c === 1 && d === 0);
        return result;
      }
      static OrthoOffCenterLH(left, right, bottom, top, znear, zfar, halfZRange) {
        const matrix = new Matrix();
        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
        return matrix;
      }
      static OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {
        const n = znear;
        const f = zfar;
        const a = 2 / (right - left);
        const b = 2 / (top - bottom);
        const c = 2 / (f - n);
        const d = -(f + n) / (f - n);
        const i0 = (left + right) / (left - right);
        const i1 = (top + bottom) / (bottom - top);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, 0, 0, 0, c, 0, i0, i1, d, 1, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result.markAsUpdated();
        return result;
      }
      static OrthoOffCenterRH(left, right, bottom, top, znear, zfar, halfZRange) {
        const matrix = new Matrix();
        Matrix.OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, matrix, halfZRange);
        return matrix;
      }
      static OrthoOffCenterRHToRef(left, right, bottom, top, znear, zfar, result, halfZRange) {
        Matrix.OrthoOffCenterLHToRef(left, right, bottom, top, znear, zfar, result, halfZRange);
        result._m[10] *= -1;
        return result;
      }
      static PerspectiveLH(width, height, znear, zfar, halfZRange, projectionPlaneTilt = 0) {
        const matrix = new Matrix();
        const n = znear;
        const f = zfar;
        const a = 2 * n / width;
        const b = 2 * n / height;
        const c = (f + n) / (f - n);
        const d = -2 * f * n / (f - n);
        const rot = Math.tan(projectionPlaneTilt);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, matrix);
        if (halfZRange) {
          matrix.multiplyToRef(mtxConvertNDCToHalfZRange, matrix);
        }
        matrix._updateIdentityStatus(false);
        return matrix;
      }
      static PerspectiveFovLH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
        const matrix = new Matrix();
        Matrix.PerspectiveFovLHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
        return matrix;
      }
      static PerspectiveFovLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
        const n = znear;
        const f = zfar;
        const t = 1 / Math.tan(fov * 0.5);
        const a = isVerticalFovFixed ? t / aspect : t;
        const b = isVerticalFovFixed ? t : t * aspect;
        const c = reverseDepthBufferMode && n === 0 ? -1 : f !== 0 ? (f + n) / (f - n) : 1;
        const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
        const rot = Math.tan(projectionPlaneTilt);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, 1, 0, 0, d, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
        return result;
      }
      static PerspectiveFovReverseLHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {
        const t = 1 / Math.tan(fov * 0.5);
        const a = isVerticalFovFixed ? t / aspect : t;
        const b = isVerticalFovFixed ? t : t * aspect;
        const rot = Math.tan(projectionPlaneTilt);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, 1, 0, 0, 1, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
        return result;
      }
      static PerspectiveFovRH(fov, aspect, znear, zfar, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
        const matrix = new Matrix();
        Matrix.PerspectiveFovRHToRef(fov, aspect, znear, zfar, matrix, true, halfZRange, projectionPlaneTilt, reverseDepthBufferMode);
        return matrix;
      }
      static PerspectiveFovRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0, reverseDepthBufferMode = false) {
        const n = znear;
        const f = zfar;
        const t = 1 / Math.tan(fov * 0.5);
        const a = isVerticalFovFixed ? t / aspect : t;
        const b = isVerticalFovFixed ? t : t * aspect;
        const c = reverseDepthBufferMode && n === 0 ? 1 : f !== 0 ? -(f + n) / (f - n) : -1;
        const d = reverseDepthBufferMode && n === 0 ? 2 * f : f !== 0 ? -2 * f * n / (f - n) : -2 * n;
        const rot = Math.tan(projectionPlaneTilt);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, c, -1, 0, 0, d, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
        return result;
      }
      static PerspectiveFovReverseRHToRef(fov, aspect, znear, zfar, result, isVerticalFovFixed = true, halfZRange, projectionPlaneTilt = 0) {
        const t = 1 / Math.tan(fov * 0.5);
        const a = isVerticalFovFixed ? t / aspect : t;
        const b = isVerticalFovFixed ? t : t * aspect;
        const rot = Math.tan(projectionPlaneTilt);
        Matrix.FromValuesToRef(a, 0, 0, 0, 0, b, 0, rot, 0, 0, -znear, -1, 0, 0, -1, 0, result);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result._updateIdentityStatus(false);
        return result;
      }
      static PerspectiveFovWebVRToRef(fov, znear, zfar, result, rightHanded = false, halfZRange, projectionPlaneTilt = 0) {
        const rightHandedFactor = rightHanded ? -1 : 1;
        const upTan = Math.tan(fov.upDegrees * Math.PI / 180);
        const downTan = Math.tan(fov.downDegrees * Math.PI / 180);
        const leftTan = Math.tan(fov.leftDegrees * Math.PI / 180);
        const rightTan = Math.tan(fov.rightDegrees * Math.PI / 180);
        const xScale = 2 / (leftTan + rightTan);
        const yScale = 2 / (upTan + downTan);
        const rot = Math.tan(projectionPlaneTilt);
        const m = result._m;
        m[0] = xScale;
        m[1] = m[2] = m[3] = m[4] = 0;
        m[5] = yScale;
        m[6] = 0;
        m[7] = rot;
        m[8] = (leftTan - rightTan) * xScale * 0.5;
        m[9] = -((upTan - downTan) * yScale * 0.5);
        m[10] = -zfar / (znear - zfar);
        m[11] = 1 * rightHandedFactor;
        m[12] = m[13] = m[15] = 0;
        m[14] = -(2 * zfar * znear) / (zfar - znear);
        if (halfZRange) {
          result.multiplyToRef(mtxConvertNDCToHalfZRange, result);
        }
        result.markAsUpdated();
        return result;
      }
      static GetFinalMatrix(viewport, world, view, projection, zmin, zmax) {
        const cw = viewport.width;
        const ch = viewport.height;
        const cx = viewport.x;
        const cy = viewport.y;
        const viewportMatrix = Matrix.FromValues(cw / 2, 0, 0, 0, 0, -ch / 2, 0, 0, 0, 0, zmax - zmin, 0, cx + cw / 2, ch / 2 + cy, zmin, 1);
        const matrix = new world.constructor();
        world.multiplyToRef(view, matrix);
        matrix.multiplyToRef(projection, matrix);
        return matrix.multiplyToRef(viewportMatrix, matrix);
      }
      static GetAsMatrix2x2(matrix) {
        const m = matrix.m;
        const arr = [m[0], m[1], m[4], m[5]];
        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
      }
      static GetAsMatrix3x3(matrix) {
        const m = matrix.m;
        const arr = [m[0], m[1], m[2], m[4], m[5], m[6], m[8], m[9], m[10]];
        return PerformanceConfigurator.MatrixUse64Bits ? arr : new Float32Array(arr);
      }
      static Transpose(matrix) {
        const result = new matrix.constructor();
        Matrix.TransposeToRef(matrix, result);
        return result;
      }
      static TransposeToRef(matrix, result) {
        const rm = result._m;
        const mm = matrix.m;
        rm[0] = mm[0];
        rm[1] = mm[4];
        rm[2] = mm[8];
        rm[3] = mm[12];
        rm[4] = mm[1];
        rm[5] = mm[5];
        rm[6] = mm[9];
        rm[7] = mm[13];
        rm[8] = mm[2];
        rm[9] = mm[6];
        rm[10] = mm[10];
        rm[11] = mm[14];
        rm[12] = mm[3];
        rm[13] = mm[7];
        rm[14] = mm[11];
        rm[15] = mm[15];
        result.markAsUpdated();
        result._updateIdentityStatus(matrix._isIdentity, matrix._isIdentityDirty);
        return result;
      }
      static Reflection(plane) {
        const matrix = new Matrix();
        Matrix.ReflectionToRef(plane, matrix);
        return matrix;
      }
      static ReflectionToRef(plane, result) {
        plane.normalize();
        const x = plane.normal.x;
        const y = plane.normal.y;
        const z = plane.normal.z;
        const temp = -2 * x;
        const temp2 = -2 * y;
        const temp3 = -2 * z;
        Matrix.FromValuesToRef(temp * x + 1, temp2 * x, temp3 * x, 0, temp * y, temp2 * y + 1, temp3 * y, 0, temp * z, temp2 * z, temp3 * z + 1, 0, temp * plane.d, temp2 * plane.d, temp3 * plane.d, 1, result);
        return result;
      }
      static FromXYZAxesToRef(xaxis, yaxis, zaxis, result) {
        Matrix.FromValuesToRef(xaxis._x, xaxis._y, xaxis._z, 0, yaxis._x, yaxis._y, yaxis._z, 0, zaxis._x, zaxis._y, zaxis._z, 0, 0, 0, 0, 1, result);
        return result;
      }
      static FromQuaternionToRef(quat, result) {
        const xx = quat._x * quat._x;
        const yy = quat._y * quat._y;
        const zz = quat._z * quat._z;
        const xy = quat._x * quat._y;
        const zw = quat._z * quat._w;
        const zx = quat._z * quat._x;
        const yw = quat._y * quat._w;
        const yz = quat._y * quat._z;
        const xw = quat._x * quat._w;
        result._m[0] = 1 - 2 * (yy + zz);
        result._m[1] = 2 * (xy + zw);
        result._m[2] = 2 * (zx - yw);
        result._m[3] = 0;
        result._m[4] = 2 * (xy - zw);
        result._m[5] = 1 - 2 * (zz + xx);
        result._m[6] = 2 * (yz + xw);
        result._m[7] = 0;
        result._m[8] = 2 * (zx + yw);
        result._m[9] = 2 * (yz - xw);
        result._m[10] = 1 - 2 * (yy + xx);
        result._m[11] = 0;
        result._m[12] = 0;
        result._m[13] = 0;
        result._m[14] = 0;
        result._m[15] = 1;
        result.markAsUpdated();
        return result;
      }
    };
    Matrix._UpdateFlagSeed = 0;
    Matrix._IdentityReadOnly = Matrix.Identity();
    MathTmp = class {
    };
    MathTmp.Vector3 = ArrayTools.BuildTuple(11, Vector3.Zero);
    MathTmp.Matrix = ArrayTools.BuildTuple(2, Matrix.Identity);
    MathTmp.Quaternion = ArrayTools.BuildTuple(3, Quaternion.Zero);
    TmpVectors = class {
    };
    TmpVectors.Vector2 = ArrayTools.BuildTuple(3, Vector2.Zero);
    TmpVectors.Vector3 = ArrayTools.BuildTuple(13, Vector3.Zero);
    TmpVectors.Vector4 = ArrayTools.BuildTuple(3, Vector4.Zero);
    TmpVectors.Quaternion = ArrayTools.BuildTuple(2, Quaternion.Zero);
    TmpVectors.Matrix = ArrayTools.BuildTuple(8, Matrix.Identity);
    RegisterClass("BABYLON.Vector2", Vector2);
    RegisterClass("BABYLON.Vector3", Vector3);
    RegisterClass("BABYLON.Vector4", Vector4);
    RegisterClass("BABYLON.Matrix", Matrix);
    mtxConvertNDCToHalfZRange = Matrix.FromValues(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0.5, 0, 0, 0, 0.5, 1);
  }
});

export {
  __esm,
  __commonJS,
  __export,
  __toCommonJS,
  EventState,
  Observer,
  Observable,
  init_observable,
  Scalar,
  init_math_scalar,
  ToGammaSpace,
  ToLinearSpace,
  PHI,
  Epsilon,
  init_math_constants,
  ArrayTools,
  _ObserveArray,
  init_arrayTools,
  RegisterClass,
  GetClass,
  init_typeStore,
  PerformanceConfigurator,
  init_performanceConfigurator,
  EngineStore,
  init_engineStore,
  Vector2,
  Vector3,
  Vector4,
  Quaternion,
  Matrix,
  TmpVectors,
  init_math_vector
};
//# sourceMappingURL=chunk-N3NUGEQO.js.map
