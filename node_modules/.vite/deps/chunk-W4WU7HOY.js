import {
  Engine,
  init_engine,
  init_engine_readTexture
} from "./chunk-Y23C3XZB.js";
import {
  AbstractScene,
  AsyncLoop,
  Buffer,
  Color3,
  Color4,
  Decode,
  DeepCopier,
  DrawWrapper,
  Effect,
  EncodeArrayBufferToBase64,
  ErrorCodes,
  EventConstants,
  Frustum,
  ImageProcessingConfiguration,
  InstantiationTools,
  InternalTexture,
  InternalTextureSource,
  IsBase64DataUrl,
  KeyboardEventTypes,
  LightConstants,
  LoadImage,
  Logger,
  MaterialDefines,
  PickingInfo,
  Plane,
  PointerEventTypes,
  PostProcessManager,
  RandomGUID,
  RenderingManager,
  RuntimeError,
  Scene,
  SceneComponentConstants,
  ScenePerformancePriority,
  SerializationHelper,
  ShaderLanguage,
  ShaderProcessor,
  ShaderStore,
  SmartArray,
  Tags,
  ThinEngine,
  TimingTools,
  TmpColors,
  Tools,
  UniformBuffer,
  VertexBuffer,
  WebRequest,
  _WarnImport,
  __decorate,
  expandToProperty,
  init_abstractScene,
  init_buffer,
  init_decorators,
  init_deepCopier,
  init_devTools,
  init_deviceInputEvents,
  init_drawWrapper,
  init_effect,
  init_error,
  init_fileTools,
  init_guid,
  init_imageProcessingConfiguration,
  init_instantiationTools,
  init_internalTexture,
  init_keyboardEvents,
  init_lightConstants,
  init_logger,
  init_materialDefines,
  init_math_color,
  init_math_frustum,
  init_math_plane,
  init_pickingInfo,
  init_pointerEvents,
  init_postProcessManager,
  init_renderingManager,
  init_scene,
  init_sceneComponent,
  init_shaderLanguage,
  init_shaderProcessor,
  init_shaderStore,
  init_smartArray,
  init_stringTools,
  init_tags,
  init_thinEngine,
  init_timingTools,
  init_tools,
  init_tslib_es6,
  init_uniformBuffer,
  init_webRequest,
  nativeOverride,
  serialize,
  serializeAsColor3,
  serializeAsColor4,
  serializeAsFresnelParameters,
  serializeAsImageProcessingConfiguration,
  serializeAsMatrix,
  serializeAsMeshReference,
  serializeAsQuaternion,
  serializeAsTexture,
  serializeAsVector2,
  serializeAsVector3
} from "./chunk-YCJ6WHUD.js";
import {
  ArrayTools,
  EngineStore,
  Epsilon,
  GetClass,
  Matrix,
  Observable,
  Quaternion,
  RegisterClass,
  Scalar,
  TmpVectors,
  ToLinearSpace,
  Vector2,
  Vector3,
  Vector4,
  _ObserveArray,
  __esm,
  init_arrayTools,
  init_engineStore,
  init_math_constants,
  init_math_scalar,
  init_math_vector,
  init_observable,
  init_typeStore
} from "./chunk-N3NUGEQO.js";

// node_modules/@babylonjs/core/Animations/animationKey.js
var AnimationKeyInterpolation;
var init_animationKey = __esm({
  "node_modules/@babylonjs/core/Animations/animationKey.js"() {
    (function(AnimationKeyInterpolation2) {
      AnimationKeyInterpolation2[AnimationKeyInterpolation2["NONE"] = 0] = "NONE";
      AnimationKeyInterpolation2[AnimationKeyInterpolation2["STEP"] = 1] = "STEP";
    })(AnimationKeyInterpolation || (AnimationKeyInterpolation = {}));
  }
});

// node_modules/@babylonjs/core/Animations/animationRange.js
var AnimationRange;
var init_animationRange = __esm({
  "node_modules/@babylonjs/core/Animations/animationRange.js"() {
    AnimationRange = class {
      constructor(name109, from, to) {
        this.name = name109;
        this.from = from;
        this.to = to;
      }
      clone() {
        return new AnimationRange(this.name, this.from, this.to);
      }
    };
  }
});

// node_modules/@babylonjs/core/node.js
var _InternalNodeDataInfo, Node;
var init_node = __esm({
  "node_modules/@babylonjs/core/node.js"() {
    init_tslib_es6();
    init_math_vector();
    init_decorators();
    init_observable();
    init_engineStore();
    init_devTools();
    _InternalNodeDataInfo = class {
      constructor() {
        this._doNotSerialize = false;
        this._isDisposed = false;
        this._sceneRootNodesIndex = -1;
        this._isEnabled = true;
        this._isParentEnabled = true;
        this._isReady = true;
        this._onEnabledStateChangedObservable = new Observable();
        this._onClonedObservable = new Observable();
      }
    };
    Node = class {
      static AddNodeConstructor(type, constructorFunc) {
        this._NodeConstructors[type] = constructorFunc;
      }
      static Construct(type, name109, scene, options) {
        const constructorFunc = this._NodeConstructors[type];
        if (!constructorFunc) {
          return null;
        }
        return constructorFunc(name109, scene, options);
      }
      set accessibilityTag(value) {
        this._accessibilityTag = value;
        this.onAccessibilityTagChangedObservable.notifyObservers(value);
      }
      get accessibilityTag() {
        return this._accessibilityTag;
      }
      get doNotSerialize() {
        if (this._nodeDataStorage._doNotSerialize) {
          return true;
        }
        if (this._parentNode) {
          return this._parentNode.doNotSerialize;
        }
        return false;
      }
      set doNotSerialize(value) {
        this._nodeDataStorage._doNotSerialize = value;
      }
      isDisposed() {
        return this._nodeDataStorage._isDisposed;
      }
      set parent(parent) {
        if (this._parentNode === parent) {
          return;
        }
        const previousParentNode = this._parentNode;
        if (this._parentNode && this._parentNode._children !== void 0 && this._parentNode._children !== null) {
          const index = this._parentNode._children.indexOf(this);
          if (index !== -1) {
            this._parentNode._children.splice(index, 1);
          }
          if (!parent && !this._nodeDataStorage._isDisposed) {
            this._addToSceneRootNodes();
          }
        }
        this._parentNode = parent;
        if (this._parentNode) {
          if (this._parentNode._children === void 0 || this._parentNode._children === null) {
            this._parentNode._children = new Array();
          }
          this._parentNode._children.push(this);
          if (!previousParentNode) {
            this._removeFromSceneRootNodes();
          }
        }
        this._syncParentEnabledState();
      }
      get parent() {
        return this._parentNode;
      }
      _serializeAsParent(serializationObject) {
        serializationObject.parentId = this.uniqueId;
      }
      _addToSceneRootNodes() {
        if (this._nodeDataStorage._sceneRootNodesIndex === -1) {
          this._nodeDataStorage._sceneRootNodesIndex = this._scene.rootNodes.length;
          this._scene.rootNodes.push(this);
        }
      }
      _removeFromSceneRootNodes() {
        if (this._nodeDataStorage._sceneRootNodesIndex !== -1) {
          const rootNodes = this._scene.rootNodes;
          const lastIdx = rootNodes.length - 1;
          rootNodes[this._nodeDataStorage._sceneRootNodesIndex] = rootNodes[lastIdx];
          rootNodes[this._nodeDataStorage._sceneRootNodesIndex]._nodeDataStorage._sceneRootNodesIndex = this._nodeDataStorage._sceneRootNodesIndex;
          this._scene.rootNodes.pop();
          this._nodeDataStorage._sceneRootNodesIndex = -1;
        }
      }
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      getClassName() {
        return "Node";
      }
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      get onEnabledStateChangedObservable() {
        return this._nodeDataStorage._onEnabledStateChangedObservable;
      }
      get onClonedObservable() {
        return this._nodeDataStorage._onClonedObservable;
      }
      constructor(name109, scene = null) {
        this._isDirty = false;
        this._nodeDataStorage = new _InternalNodeDataInfo();
        this.state = "";
        this.metadata = null;
        this.reservedDataStore = null;
        this._accessibilityTag = null;
        this.onAccessibilityTagChangedObservable = new Observable();
        this._parentContainer = null;
        this.animations = new Array();
        this._ranges = {};
        this.onReady = null;
        this._currentRenderId = -1;
        this._parentUpdateId = -1;
        this._childUpdateId = -1;
        this._waitingParentId = null;
        this._waitingParentInstanceIndex = null;
        this._waitingParsedUniqueId = null;
        this._cache = {};
        this._parentNode = null;
        this._children = null;
        this._worldMatrix = Matrix.Identity();
        this._worldMatrixDeterminant = 0;
        this._worldMatrixDeterminantIsDirty = true;
        this._animationPropertiesOverride = null;
        this._isNode = true;
        this.onDisposeObservable = new Observable();
        this._onDisposeObserver = null;
        this._behaviors = new Array();
        this.name = name109;
        this.id = name109;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.uniqueId = this._scene.getUniqueId();
        this._initCache();
      }
      getScene() {
        return this._scene;
      }
      getEngine() {
        return this._scene.getEngine();
      }
      addBehavior(behavior, attachImmediately = false) {
        const index = this._behaviors.indexOf(behavior);
        if (index !== -1) {
          return this;
        }
        behavior.init();
        if (this._scene.isLoading && !attachImmediately) {
          this._scene.onDataLoadedObservable.addOnce(() => {
            behavior.attach(this);
          });
        } else {
          behavior.attach(this);
        }
        this._behaviors.push(behavior);
        return this;
      }
      removeBehavior(behavior) {
        const index = this._behaviors.indexOf(behavior);
        if (index === -1) {
          return this;
        }
        this._behaviors[index].detach();
        this._behaviors.splice(index, 1);
        return this;
      }
      get behaviors() {
        return this._behaviors;
      }
      getBehaviorByName(name109) {
        for (const behavior of this._behaviors) {
          if (behavior.name === name109) {
            return behavior;
          }
        }
        return null;
      }
      getWorldMatrix() {
        if (this._currentRenderId !== this._scene.getRenderId()) {
          this.computeWorldMatrix();
        }
        return this._worldMatrix;
      }
      _getWorldMatrixDeterminant() {
        if (this._worldMatrixDeterminantIsDirty) {
          this._worldMatrixDeterminantIsDirty = false;
          this._worldMatrixDeterminant = this._worldMatrix.determinant();
        }
        return this._worldMatrixDeterminant;
      }
      get worldMatrixFromCache() {
        return this._worldMatrix;
      }
      _initCache() {
        this._cache = {};
        this._cache.parent = void 0;
      }
      updateCache(force) {
        if (!force && this.isSynchronized()) {
          return;
        }
        this._cache.parent = this.parent;
        this._updateCache();
      }
      _getActionManagerForTrigger(trigger, _initialCall = true) {
        if (!this.parent) {
          return null;
        }
        return this.parent._getActionManagerForTrigger(trigger, false);
      }
      _updateCache(_ignoreParentClass) {
      }
      _isSynchronized() {
        return true;
      }
      _markSyncedWithParent() {
        if (this._parentNode) {
          this._parentUpdateId = this._parentNode._childUpdateId;
        }
      }
      isSynchronizedWithParent() {
        if (!this._parentNode) {
          return true;
        }
        if (this._parentNode._isDirty || this._parentUpdateId !== this._parentNode._childUpdateId) {
          return false;
        }
        return this._parentNode.isSynchronized();
      }
      isSynchronized() {
        if (this._cache.parent !== this._parentNode) {
          this._cache.parent = this._parentNode;
          return false;
        }
        if (this._parentNode && !this.isSynchronizedWithParent()) {
          return false;
        }
        return this._isSynchronized();
      }
      isReady(_completeCheck = false) {
        return this._nodeDataStorage._isReady;
      }
      markAsDirty(_property) {
        this._currentRenderId = Number.MAX_VALUE;
        this._isDirty = true;
        return this;
      }
      isEnabled(checkAncestors = true) {
        if (checkAncestors === false) {
          return this._nodeDataStorage._isEnabled;
        }
        if (!this._nodeDataStorage._isEnabled) {
          return false;
        }
        return this._nodeDataStorage._isParentEnabled;
      }
      _syncParentEnabledState() {
        this._nodeDataStorage._isParentEnabled = this._parentNode ? this._parentNode.isEnabled() : true;
        if (this._children) {
          this._children.forEach((c) => {
            c._syncParentEnabledState();
          });
        }
      }
      setEnabled(value) {
        if (this._nodeDataStorage._isEnabled === value) {
          return;
        }
        this._nodeDataStorage._isEnabled = value;
        this._syncParentEnabledState();
        this._nodeDataStorage._onEnabledStateChangedObservable.notifyObservers(value);
      }
      isDescendantOf(ancestor) {
        if (this.parent) {
          if (this.parent === ancestor) {
            return true;
          }
          return this.parent.isDescendantOf(ancestor);
        }
        return false;
      }
      _getDescendants(results, directDescendantsOnly = false, predicate) {
        if (!this._children) {
          return;
        }
        for (let index = 0; index < this._children.length; index++) {
          const item = this._children[index];
          if (!predicate || predicate(item)) {
            results.push(item);
          }
          if (!directDescendantsOnly) {
            item._getDescendants(results, false, predicate);
          }
        }
      }
      getDescendants(directDescendantsOnly, predicate) {
        const results = new Array();
        this._getDescendants(results, directDescendantsOnly, predicate);
        return results;
      }
      getChildMeshes(directDescendantsOnly, predicate) {
        const results = [];
        this._getDescendants(results, directDescendantsOnly, (node) => {
          return (!predicate || predicate(node)) && node.cullingStrategy !== void 0;
        });
        return results;
      }
      getChildren(predicate, directDescendantsOnly = true) {
        return this.getDescendants(directDescendantsOnly, predicate);
      }
      _setReady(state) {
        if (state === this._nodeDataStorage._isReady) {
          return;
        }
        if (!state) {
          this._nodeDataStorage._isReady = false;
          return;
        }
        if (this.onReady) {
          this.onReady(this);
        }
        this._nodeDataStorage._isReady = true;
      }
      getAnimationByName(name109) {
        for (let i = 0; i < this.animations.length; i++) {
          const animation = this.animations[i];
          if (animation.name === name109) {
            return animation;
          }
        }
        return null;
      }
      createAnimationRange(name109, from, to) {
        if (!this._ranges[name109]) {
          this._ranges[name109] = Node._AnimationRangeFactory(name109, from, to);
          for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
            if (this.animations[i]) {
              this.animations[i].createRange(name109, from, to);
            }
          }
        }
      }
      deleteAnimationRange(name109, deleteFrames = true) {
        for (let i = 0, nAnimations = this.animations.length; i < nAnimations; i++) {
          if (this.animations[i]) {
            this.animations[i].deleteRange(name109, deleteFrames);
          }
        }
        this._ranges[name109] = null;
      }
      getAnimationRange(name109) {
        return this._ranges[name109] || null;
      }
      clone(name109, newParent, doNotCloneChildren) {
        const result = SerializationHelper.Clone(() => new Node(name109, this.getScene()), this);
        if (newParent) {
          result.parent = newParent;
        }
        if (!doNotCloneChildren) {
          const directDescendants = this.getDescendants(true);
          for (let index = 0; index < directDescendants.length; index++) {
            const child = directDescendants[index];
            child.clone(name109 + "." + child.name, result);
          }
        }
        return result;
      }
      getAnimationRanges() {
        const animationRanges = [];
        let name109;
        for (name109 in this._ranges) {
          animationRanges.push(this._ranges[name109]);
        }
        return animationRanges;
      }
      beginAnimation(name109, loop, speedRatio, onAnimationEnd) {
        const range = this.getAnimationRange(name109);
        if (!range) {
          return null;
        }
        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
      }
      serializeAnimationRanges() {
        const serializationRanges = [];
        for (const name109 in this._ranges) {
          const localRange = this._ranges[name109];
          if (!localRange) {
            continue;
          }
          const range = {};
          range.name = name109;
          range.from = localRange.from;
          range.to = localRange.to;
          serializationRanges.push(range);
        }
        return serializationRanges;
      }
      computeWorldMatrix(_force) {
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        return this._worldMatrix;
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this._nodeDataStorage._isDisposed = true;
        if (!doNotRecurse) {
          const nodes = this.getDescendants(true);
          for (const node of nodes) {
            node.dispose(doNotRecurse, disposeMaterialAndTextures);
          }
        }
        if (!this.parent) {
          this._removeFromSceneRootNodes();
        } else {
          this.parent = null;
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.onEnabledStateChangedObservable.clear();
        this.onClonedObservable.clear();
        for (const behavior of this._behaviors) {
          behavior.detach();
        }
        this._behaviors.length = 0;
        this.metadata = null;
      }
      static ParseAnimationRanges(node, parsedNode, _scene) {
        if (parsedNode.ranges) {
          for (let index = 0; index < parsedNode.ranges.length; index++) {
            const data = parsedNode.ranges[index];
            node.createAnimationRange(data.name, data.from, data.to);
          }
        }
      }
      getHierarchyBoundingVectors(includeDescendants = true, predicate = null) {
        this.getScene().incrementRenderId();
        this.computeWorldMatrix(true);
        let min;
        let max;
        const thisAbstractMesh = this;
        if (thisAbstractMesh.getBoundingInfo && thisAbstractMesh.subMeshes) {
          const boundingInfo = thisAbstractMesh.getBoundingInfo();
          min = boundingInfo.boundingBox.minimumWorld.clone();
          max = boundingInfo.boundingBox.maximumWorld.clone();
        } else {
          min = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
          max = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
        }
        if (includeDescendants) {
          const descendants = this.getDescendants(false);
          for (const descendant of descendants) {
            const childMesh = descendant;
            childMesh.computeWorldMatrix(true);
            if (predicate && !predicate(childMesh)) {
              continue;
            }
            if (!childMesh.getBoundingInfo || childMesh.getTotalVertices() === 0) {
              continue;
            }
            const childBoundingInfo = childMesh.getBoundingInfo();
            const boundingBox = childBoundingInfo.boundingBox;
            const minBox = boundingBox.minimumWorld;
            const maxBox = boundingBox.maximumWorld;
            Vector3.CheckExtends(minBox, min, max);
            Vector3.CheckExtends(maxBox, min, max);
          }
        }
        return {
          min,
          max
        };
      }
    };
    Node._AnimationRangeFactory = (_name, _from, _to) => {
      throw _WarnImport("AnimationRange");
    };
    Node._NodeConstructors = {};
    __decorate([
      serialize()
    ], Node.prototype, "name", void 0);
    __decorate([
      serialize()
    ], Node.prototype, "id", void 0);
    __decorate([
      serialize()
    ], Node.prototype, "uniqueId", void 0);
    __decorate([
      serialize()
    ], Node.prototype, "state", void 0);
    __decorate([
      serialize()
    ], Node.prototype, "metadata", void 0);
  }
});

// node_modules/@babylonjs/core/Maths/math.size.js
var Size;
var init_math_size = __esm({
  "node_modules/@babylonjs/core/Maths/math.size.js"() {
    Size = class {
      constructor(width, height) {
        this.width = width;
        this.height = height;
      }
      toString() {
        return `{W: ${this.width}, H: ${this.height}}`;
      }
      getClassName() {
        return "Size";
      }
      getHashCode() {
        let hash = this.width | 0;
        hash = hash * 397 ^ (this.height | 0);
        return hash;
      }
      copyFrom(src) {
        this.width = src.width;
        this.height = src.height;
      }
      copyFromFloats(width, height) {
        this.width = width;
        this.height = height;
        return this;
      }
      set(width, height) {
        return this.copyFromFloats(width, height);
      }
      multiplyByFloats(w, h) {
        return new Size(this.width * w, this.height * h);
      }
      clone() {
        return new Size(this.width, this.height);
      }
      equals(other) {
        if (!other) {
          return false;
        }
        return this.width === other.width && this.height === other.height;
      }
      get surface() {
        return this.width * this.height;
      }
      static Zero() {
        return new Size(0, 0);
      }
      add(otherSize) {
        const r = new Size(this.width + otherSize.width, this.height + otherSize.height);
        return r;
      }
      subtract(otherSize) {
        const r = new Size(this.width - otherSize.width, this.height - otherSize.height);
        return r;
      }
      static Lerp(start, end, amount) {
        const w = start.width + (end.width - start.width) * amount;
        const h = start.height + (end.height - start.height) * amount;
        return new Size(w, h);
      }
    };
  }
});

// node_modules/@babylonjs/core/Animations/animation.js
var _IAnimationState, evaluateAnimationState, Animation;
var init_animation = __esm({
  "node_modules/@babylonjs/core/Animations/animation.js"() {
    init_math_vector();
    init_math_color();
    init_math_scalar();
    init_decorators();
    init_typeStore();
    init_animationKey();
    init_animationRange();
    init_node();
    init_math_size();
    init_webRequest();
    _IAnimationState = class {
    };
    evaluateAnimationState = {
      key: 0,
      repeatCount: 0,
      loopMode: 2
    };
    Animation = class {
      static _PrepareAnimation(name109, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction) {
        let dataType = void 0;
        if (!isNaN(parseFloat(from)) && isFinite(from)) {
          dataType = Animation.ANIMATIONTYPE_FLOAT;
        } else if (from instanceof Quaternion) {
          dataType = Animation.ANIMATIONTYPE_QUATERNION;
        } else if (from instanceof Vector3) {
          dataType = Animation.ANIMATIONTYPE_VECTOR3;
        } else if (from instanceof Vector2) {
          dataType = Animation.ANIMATIONTYPE_VECTOR2;
        } else if (from instanceof Color3) {
          dataType = Animation.ANIMATIONTYPE_COLOR3;
        } else if (from instanceof Color4) {
          dataType = Animation.ANIMATIONTYPE_COLOR4;
        } else if (from instanceof Size) {
          dataType = Animation.ANIMATIONTYPE_SIZE;
        }
        if (dataType == void 0) {
          return null;
        }
        const animation = new Animation(name109, targetProperty, framePerSecond, dataType, loopMode);
        const keys = [
          { frame: 0, value: from },
          { frame: totalFrame, value: to }
        ];
        animation.setKeys(keys);
        if (easingFunction !== void 0) {
          animation.setEasingFunction(easingFunction);
        }
        return animation;
      }
      static CreateAnimation(property, animationType, framePerSecond, easingFunction) {
        const animation = new Animation(property + "Animation", property, framePerSecond, animationType, Animation.ANIMATIONLOOPMODE_CONSTANT);
        animation.setEasingFunction(easingFunction);
        return animation;
      }
      static CreateAndStartAnimation(name109, target, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd, scene) {
        const animation = Animation._PrepareAnimation(name109, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
        if (!animation) {
          return null;
        }
        if (target.getScene) {
          scene = target.getScene();
        }
        if (!scene) {
          return null;
        }
        return scene.beginDirectAnimation(target, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
      }
      static CreateAndStartHierarchyAnimation(name109, node, directDescendantsOnly, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
        const animation = Animation._PrepareAnimation(name109, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
        if (!animation) {
          return null;
        }
        const scene = node.getScene();
        return scene.beginDirectHierarchyAnimation(node, directDescendantsOnly, [animation], 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
      }
      static CreateMergeAndStartAnimation(name109, node, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction, onAnimationEnd) {
        const animation = Animation._PrepareAnimation(name109, targetProperty, framePerSecond, totalFrame, from, to, loopMode, easingFunction);
        if (!animation) {
          return null;
        }
        node.animations.push(animation);
        return node.getScene().beginAnimation(node, 0, totalFrame, animation.loopMode === 1, 1, onAnimationEnd);
      }
      static MakeAnimationAdditive(sourceAnimation, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {
        var _a, _b;
        let options;
        if (typeof referenceFrameOrOptions === "object") {
          options = referenceFrameOrOptions;
        } else {
          options = {
            referenceFrame: referenceFrameOrOptions !== null && referenceFrameOrOptions !== void 0 ? referenceFrameOrOptions : 0,
            range,
            cloneOriginalAnimation: cloneOriginal,
            clonedAnimationName: clonedName
          };
        }
        let animation = sourceAnimation;
        if (options.cloneOriginalAnimation) {
          animation = sourceAnimation.clone();
          animation.name = options.clonedAnimationName || animation.name;
        }
        if (!animation._keys.length) {
          return animation;
        }
        const referenceFrame = options.referenceFrame && options.referenceFrame >= 0 ? options.referenceFrame : 0;
        let startIndex = 0;
        const firstKey = animation._keys[0];
        let endIndex = animation._keys.length - 1;
        const lastKey = animation._keys[endIndex];
        const valueStore = {
          referenceValue: firstKey.value,
          referencePosition: TmpVectors.Vector3[0],
          referenceQuaternion: TmpVectors.Quaternion[0],
          referenceScaling: TmpVectors.Vector3[1],
          keyPosition: TmpVectors.Vector3[2],
          keyQuaternion: TmpVectors.Quaternion[1],
          keyScaling: TmpVectors.Vector3[3]
        };
        let from = firstKey.frame;
        let to = lastKey.frame;
        if (options.range) {
          const rangeValue = animation.getRange(options.range);
          if (rangeValue) {
            from = rangeValue.from;
            to = rangeValue.to;
          }
        } else {
          from = (_a = options.fromFrame) !== null && _a !== void 0 ? _a : from;
          to = (_b = options.toFrame) !== null && _b !== void 0 ? _b : to;
        }
        if (from !== firstKey.frame) {
          startIndex = animation.createKeyForFrame(from);
        }
        if (to !== lastKey.frame) {
          endIndex = animation.createKeyForFrame(to);
        }
        if (animation._keys.length === 1) {
          const value = animation._getKeyValue(animation._keys[0]);
          valueStore.referenceValue = value.clone ? value.clone() : value;
        } else if (referenceFrame <= firstKey.frame) {
          const value = animation._getKeyValue(firstKey.value);
          valueStore.referenceValue = value.clone ? value.clone() : value;
        } else if (referenceFrame >= lastKey.frame) {
          const value = animation._getKeyValue(lastKey.value);
          valueStore.referenceValue = value.clone ? value.clone() : value;
        } else {
          evaluateAnimationState.key = 0;
          const value = animation._interpolate(referenceFrame, evaluateAnimationState);
          valueStore.referenceValue = value.clone ? value.clone() : value;
        }
        if (animation.dataType === Animation.ANIMATIONTYPE_QUATERNION) {
          valueStore.referenceValue.normalize().conjugateInPlace();
        } else if (animation.dataType === Animation.ANIMATIONTYPE_MATRIX) {
          valueStore.referenceValue.decompose(valueStore.referenceScaling, valueStore.referenceQuaternion, valueStore.referencePosition);
          valueStore.referenceQuaternion.normalize().conjugateInPlace();
        }
        let startFrame = Number.MAX_VALUE;
        const clippedKeys = options.clipKeys ? [] : null;
        for (let index = startIndex; index <= endIndex; index++) {
          let key = animation._keys[index];
          if (clippedKeys) {
            key = {
              frame: key.frame,
              value: key.value.clone ? key.value.clone() : key.value,
              inTangent: key.inTangent,
              outTangent: key.outTangent,
              interpolation: key.interpolation,
              lockedTangent: key.lockedTangent
            };
            if (startFrame === Number.MAX_VALUE) {
              startFrame = key.frame;
            }
            key.frame -= startFrame;
            clippedKeys.push(key);
          }
          if (index && animation.dataType !== Animation.ANIMATIONTYPE_FLOAT && key.value === firstKey.value) {
            continue;
          }
          switch (animation.dataType) {
            case Animation.ANIMATIONTYPE_MATRIX:
              key.value.decompose(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition);
              valueStore.keyPosition.subtractInPlace(valueStore.referencePosition);
              valueStore.keyScaling.divideInPlace(valueStore.referenceScaling);
              valueStore.referenceQuaternion.multiplyToRef(valueStore.keyQuaternion, valueStore.keyQuaternion);
              Matrix.ComposeToRef(valueStore.keyScaling, valueStore.keyQuaternion, valueStore.keyPosition, key.value);
              break;
            case Animation.ANIMATIONTYPE_QUATERNION:
              valueStore.referenceValue.multiplyToRef(key.value, key.value);
              break;
            case Animation.ANIMATIONTYPE_VECTOR2:
            case Animation.ANIMATIONTYPE_VECTOR3:
            case Animation.ANIMATIONTYPE_COLOR3:
            case Animation.ANIMATIONTYPE_COLOR4:
              key.value.subtractToRef(valueStore.referenceValue, key.value);
              break;
            case Animation.ANIMATIONTYPE_SIZE:
              key.value.width -= valueStore.referenceValue.width;
              key.value.height -= valueStore.referenceValue.height;
              break;
            default:
              key.value -= valueStore.referenceValue;
          }
        }
        if (clippedKeys) {
          animation.setKeys(clippedKeys, true);
        }
        return animation;
      }
      static TransitionTo(property, targetValue, host, scene, frameRate, transition, duration, onAnimationEnd = null) {
        if (duration <= 0) {
          host[property] = targetValue;
          if (onAnimationEnd) {
            onAnimationEnd();
          }
          return null;
        }
        const endFrame = frameRate * (duration / 1e3);
        transition.setKeys([
          {
            frame: 0,
            value: host[property].clone ? host[property].clone() : host[property]
          },
          {
            frame: endFrame,
            value: targetValue
          }
        ]);
        if (!host.animations) {
          host.animations = [];
        }
        host.animations.push(transition);
        const animation = scene.beginAnimation(host, 0, endFrame, false);
        animation.onAnimationEnd = onAnimationEnd;
        return animation;
      }
      get runtimeAnimations() {
        return this._runtimeAnimations;
      }
      get hasRunningRuntimeAnimations() {
        for (const runtimeAnimation of this._runtimeAnimations) {
          if (!runtimeAnimation.isStopped()) {
            return true;
          }
        }
        return false;
      }
      constructor(name109, targetProperty, framePerSecond, dataType, loopMode, enableBlending) {
        this.name = name109;
        this.targetProperty = targetProperty;
        this.framePerSecond = framePerSecond;
        this.dataType = dataType;
        this.loopMode = loopMode;
        this.enableBlending = enableBlending;
        this._easingFunction = null;
        this._runtimeAnimations = new Array();
        this._events = new Array();
        this.blendingSpeed = 0.01;
        this._ranges = {};
        this.targetPropertyPath = targetProperty.split(".");
        this.dataType = dataType;
        this.loopMode = loopMode === void 0 ? Animation.ANIMATIONLOOPMODE_CYCLE : loopMode;
        this.uniqueId = Animation._UniqueIdGenerator++;
      }
      toString(fullDetails) {
        let ret = "Name: " + this.name + ", property: " + this.targetProperty;
        ret += ", datatype: " + ["Float", "Vector3", "Quaternion", "Matrix", "Color3", "Vector2"][this.dataType];
        ret += ", nKeys: " + (this._keys ? this._keys.length : "none");
        ret += ", nRanges: " + (this._ranges ? Object.keys(this._ranges).length : "none");
        if (fullDetails) {
          ret += ", Ranges: {";
          let first = true;
          for (const name109 in this._ranges) {
            if (first) {
              ret += ", ";
              first = false;
            }
            ret += name109;
          }
          ret += "}";
        }
        return ret;
      }
      addEvent(event) {
        this._events.push(event);
        this._events.sort((a, b) => a.frame - b.frame);
      }
      removeEvents(frame) {
        for (let index = 0; index < this._events.length; index++) {
          if (this._events[index].frame === frame) {
            this._events.splice(index, 1);
            index--;
          }
        }
      }
      getEvents() {
        return this._events;
      }
      createRange(name109, from, to) {
        if (!this._ranges[name109]) {
          this._ranges[name109] = new AnimationRange(name109, from, to);
        }
      }
      deleteRange(name109, deleteFrames = true) {
        const range = this._ranges[name109];
        if (!range) {
          return;
        }
        if (deleteFrames) {
          const from = range.from;
          const to = range.to;
          for (let key = this._keys.length - 1; key >= 0; key--) {
            if (this._keys[key].frame >= from && this._keys[key].frame <= to) {
              this._keys.splice(key, 1);
            }
          }
        }
        this._ranges[name109] = null;
      }
      getRange(name109) {
        return this._ranges[name109];
      }
      getKeys() {
        return this._keys;
      }
      getHighestFrame() {
        let ret = 0;
        for (let key = 0, nKeys = this._keys.length; key < nKeys; key++) {
          if (ret < this._keys[key].frame) {
            ret = this._keys[key].frame;
          }
        }
        return ret;
      }
      getEasingFunction() {
        return this._easingFunction;
      }
      setEasingFunction(easingFunction) {
        this._easingFunction = easingFunction;
      }
      floatInterpolateFunction(startValue, endValue, gradient) {
        return Scalar.Lerp(startValue, endValue, gradient);
      }
      floatInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
        return Scalar.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      }
      quaternionInterpolateFunction(startValue, endValue, gradient) {
        return Quaternion.Slerp(startValue, endValue, gradient);
      }
      quaternionInterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
        return Quaternion.Hermite(startValue, outTangent, endValue, inTangent, gradient).normalize();
      }
      vector3InterpolateFunction(startValue, endValue, gradient) {
        return Vector3.Lerp(startValue, endValue, gradient);
      }
      vector3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
        return Vector3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      }
      vector2InterpolateFunction(startValue, endValue, gradient) {
        return Vector2.Lerp(startValue, endValue, gradient);
      }
      vector2InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
        return Vector2.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      }
      sizeInterpolateFunction(startValue, endValue, gradient) {
        return Size.Lerp(startValue, endValue, gradient);
      }
      color3InterpolateFunction(startValue, endValue, gradient) {
        return Color3.Lerp(startValue, endValue, gradient);
      }
      color3InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
        return Color3.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      }
      color4InterpolateFunction(startValue, endValue, gradient) {
        return Color4.Lerp(startValue, endValue, gradient);
      }
      color4InterpolateFunctionWithTangents(startValue, outTangent, endValue, inTangent, gradient) {
        return Color4.Hermite(startValue, outTangent, endValue, inTangent, gradient);
      }
      _getKeyValue(value) {
        if (typeof value === "function") {
          return value();
        }
        return value;
      }
      evaluate(currentFrame) {
        evaluateAnimationState.key = 0;
        return this._interpolate(currentFrame, evaluateAnimationState);
      }
      _interpolate(currentFrame, state, searchClosestKeyOnly = false) {
        if (state.loopMode === Animation.ANIMATIONLOOPMODE_CONSTANT && state.repeatCount > 0) {
          return state.highLimitValue.clone ? state.highLimitValue.clone() : state.highLimitValue;
        }
        const keys = this._keys;
        const keysLength = keys.length;
        let key = state.key;
        while (key >= 0 && currentFrame < keys[key].frame) {
          --key;
        }
        while (key + 1 <= keysLength - 1 && currentFrame >= keys[key + 1].frame) {
          ++key;
        }
        state.key = key;
        if (key < 0) {
          return searchClosestKeyOnly ? void 0 : this._getKeyValue(keys[0].value);
        } else if (key + 1 > keysLength - 1) {
          return searchClosestKeyOnly ? void 0 : this._getKeyValue(keys[keysLength - 1].value);
        }
        const startKey = keys[key];
        const endKey = keys[key + 1];
        if (searchClosestKeyOnly && (currentFrame === startKey.frame || currentFrame === endKey.frame)) {
          return void 0;
        }
        const startValue = this._getKeyValue(startKey.value);
        const endValue = this._getKeyValue(endKey.value);
        if (startKey.interpolation === AnimationKeyInterpolation.STEP) {
          if (endKey.frame > currentFrame) {
            return startValue;
          } else {
            return endValue;
          }
        }
        const useTangent = startKey.outTangent !== void 0 && endKey.inTangent !== void 0;
        const frameDelta = endKey.frame - startKey.frame;
        let gradient = (currentFrame - startKey.frame) / frameDelta;
        const easingFunction = this.getEasingFunction();
        if (easingFunction !== null) {
          gradient = easingFunction.ease(gradient);
        }
        switch (this.dataType) {
          case Animation.ANIMATIONTYPE_FLOAT: {
            const floatValue = useTangent ? this.floatInterpolateFunctionWithTangents(startValue, startKey.outTangent * frameDelta, endValue, endKey.inTangent * frameDelta, gradient) : this.floatInterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return floatValue;
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return state.offsetValue * state.repeatCount + floatValue;
            }
            break;
          }
          case Animation.ANIMATIONTYPE_QUATERNION: {
            const quatValue = useTangent ? this.quaternionInterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.quaternionInterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return quatValue;
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return quatValue.addInPlace(state.offsetValue.scale(state.repeatCount));
            }
            return quatValue;
          }
          case Animation.ANIMATIONTYPE_VECTOR3: {
            const vec3Value = useTangent ? this.vector3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector3InterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return vec3Value;
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return vec3Value.add(state.offsetValue.scale(state.repeatCount));
            }
            break;
          }
          case Animation.ANIMATIONTYPE_VECTOR2: {
            const vec2Value = useTangent ? this.vector2InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.vector2InterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return vec2Value;
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return vec2Value.add(state.offsetValue.scale(state.repeatCount));
            }
            break;
          }
          case Animation.ANIMATIONTYPE_SIZE: {
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return this.sizeInterpolateFunction(startValue, endValue, gradient);
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return this.sizeInterpolateFunction(startValue, endValue, gradient).add(state.offsetValue.scale(state.repeatCount));
            }
            break;
          }
          case Animation.ANIMATIONTYPE_COLOR3: {
            const color3Value = useTangent ? this.color3InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color3InterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return color3Value;
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return color3Value.add(state.offsetValue.scale(state.repeatCount));
            }
            break;
          }
          case Animation.ANIMATIONTYPE_COLOR4: {
            const color4Value = useTangent ? this.color4InterpolateFunctionWithTangents(startValue, startKey.outTangent.scale(frameDelta), endValue, endKey.inTangent.scale(frameDelta), gradient) : this.color4InterpolateFunction(startValue, endValue, gradient);
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO:
                return color4Value;
              case Animation.ANIMATIONLOOPMODE_RELATIVE:
                return color4Value.add(state.offsetValue.scale(state.repeatCount));
            }
            break;
          }
          case Animation.ANIMATIONTYPE_MATRIX: {
            switch (state.loopMode) {
              case Animation.ANIMATIONLOOPMODE_CYCLE:
              case Animation.ANIMATIONLOOPMODE_CONSTANT:
              case Animation.ANIMATIONLOOPMODE_YOYO: {
                if (Animation.AllowMatricesInterpolation) {
                  return this.matrixInterpolateFunction(startValue, endValue, gradient, state.workValue);
                }
                return startValue;
              }
              case Animation.ANIMATIONLOOPMODE_RELATIVE: {
                return startValue;
              }
            }
            break;
          }
        }
        return 0;
      }
      matrixInterpolateFunction(startValue, endValue, gradient, result) {
        if (Animation.AllowMatrixDecomposeForInterpolation) {
          if (result) {
            Matrix.DecomposeLerpToRef(startValue, endValue, gradient, result);
            return result;
          }
          return Matrix.DecomposeLerp(startValue, endValue, gradient);
        }
        if (result) {
          Matrix.LerpToRef(startValue, endValue, gradient, result);
          return result;
        }
        return Matrix.Lerp(startValue, endValue, gradient);
      }
      clone() {
        const clone = new Animation(this.name, this.targetPropertyPath.join("."), this.framePerSecond, this.dataType, this.loopMode);
        clone.enableBlending = this.enableBlending;
        clone.blendingSpeed = this.blendingSpeed;
        if (this._keys) {
          clone.setKeys(this._keys);
        }
        if (this._ranges) {
          clone._ranges = {};
          for (const name109 in this._ranges) {
            const range = this._ranges[name109];
            if (!range) {
              continue;
            }
            clone._ranges[name109] = range.clone();
          }
        }
        return clone;
      }
      setKeys(values, dontClone = false) {
        this._keys = !dontClone ? values.slice(0) : values;
      }
      createKeyForFrame(frame) {
        evaluateAnimationState.key = 0;
        const value = this._interpolate(frame, evaluateAnimationState, true);
        if (!value) {
          return evaluateAnimationState.key === frame ? evaluateAnimationState.key : evaluateAnimationState.key + 1;
        }
        const newKey = {
          frame,
          value: value.clone ? value.clone() : value
        };
        this._keys.splice(evaluateAnimationState.key + 1, 0, newKey);
        return evaluateAnimationState.key + 1;
      }
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.property = this.targetProperty;
        serializationObject.framePerSecond = this.framePerSecond;
        serializationObject.dataType = this.dataType;
        serializationObject.loopBehavior = this.loopMode;
        serializationObject.enableBlending = this.enableBlending;
        serializationObject.blendingSpeed = this.blendingSpeed;
        const dataType = this.dataType;
        serializationObject.keys = [];
        const keys = this.getKeys();
        for (let index = 0; index < keys.length; index++) {
          const animationKey = keys[index];
          const key = {};
          key.frame = animationKey.frame;
          switch (dataType) {
            case Animation.ANIMATIONTYPE_FLOAT:
              key.values = [animationKey.value];
              if (animationKey.inTangent !== void 0) {
                key.values.push(animationKey.inTangent);
              }
              if (animationKey.outTangent !== void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.outTangent);
              }
              if (animationKey.interpolation !== void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                if (animationKey.outTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.interpolation);
              }
              break;
            case Animation.ANIMATIONTYPE_QUATERNION:
            case Animation.ANIMATIONTYPE_MATRIX:
            case Animation.ANIMATIONTYPE_VECTOR3:
            case Animation.ANIMATIONTYPE_COLOR3:
            case Animation.ANIMATIONTYPE_COLOR4:
              key.values = animationKey.value.asArray();
              if (animationKey.inTangent != void 0) {
                key.values.push(animationKey.inTangent.asArray());
              }
              if (animationKey.outTangent != void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.outTangent.asArray());
              }
              if (animationKey.interpolation !== void 0) {
                if (animationKey.inTangent === void 0) {
                  key.values.push(void 0);
                }
                if (animationKey.outTangent === void 0) {
                  key.values.push(void 0);
                }
                key.values.push(animationKey.interpolation);
              }
              break;
          }
          serializationObject.keys.push(key);
        }
        serializationObject.ranges = [];
        for (const name109 in this._ranges) {
          const source = this._ranges[name109];
          if (!source) {
            continue;
          }
          const range = {};
          range.name = name109;
          range.from = source.from;
          range.to = source.to;
          serializationObject.ranges.push(range);
        }
        return serializationObject;
      }
      static _UniversalLerp(left, right, amount) {
        const constructor = left.constructor;
        if (constructor.Lerp) {
          return constructor.Lerp(left, right, amount);
        } else if (constructor.Slerp) {
          return constructor.Slerp(left, right, amount);
        } else if (left.toFixed) {
          return left * (1 - amount) + amount * right;
        } else {
          return right;
        }
      }
      static Parse(parsedAnimation) {
        const animation = new Animation(parsedAnimation.name, parsedAnimation.property, parsedAnimation.framePerSecond, parsedAnimation.dataType, parsedAnimation.loopBehavior);
        const dataType = parsedAnimation.dataType;
        const keys = [];
        let data;
        let index;
        if (parsedAnimation.enableBlending) {
          animation.enableBlending = parsedAnimation.enableBlending;
        }
        if (parsedAnimation.blendingSpeed) {
          animation.blendingSpeed = parsedAnimation.blendingSpeed;
        }
        for (index = 0; index < parsedAnimation.keys.length; index++) {
          const key = parsedAnimation.keys[index];
          let inTangent = void 0;
          let outTangent = void 0;
          let interpolation = void 0;
          switch (dataType) {
            case Animation.ANIMATIONTYPE_FLOAT:
              data = key.values[0];
              if (key.values.length >= 2) {
                inTangent = key.values[1];
              }
              if (key.values.length >= 3) {
                outTangent = key.values[2];
              }
              if (key.values.length >= 4) {
                interpolation = key.values[3];
              }
              break;
            case Animation.ANIMATIONTYPE_QUATERNION:
              data = Quaternion.FromArray(key.values);
              if (key.values.length >= 8) {
                const _inTangent = Quaternion.FromArray(key.values.slice(4, 8));
                if (!_inTangent.equals(Quaternion.Zero())) {
                  inTangent = _inTangent;
                }
              }
              if (key.values.length >= 12) {
                const _outTangent = Quaternion.FromArray(key.values.slice(8, 12));
                if (!_outTangent.equals(Quaternion.Zero())) {
                  outTangent = _outTangent;
                }
              }
              if (key.values.length >= 13) {
                interpolation = key.values[12];
              }
              break;
            case Animation.ANIMATIONTYPE_MATRIX:
              data = Matrix.FromArray(key.values);
              if (key.values.length >= 17) {
                interpolation = key.values[16];
              }
              break;
            case Animation.ANIMATIONTYPE_COLOR3:
              data = Color3.FromArray(key.values);
              if (key.values[3]) {
                inTangent = Color3.FromArray(key.values[3]);
              }
              if (key.values[4]) {
                outTangent = Color3.FromArray(key.values[4]);
              }
              if (key.values[5]) {
                interpolation = key.values[5];
              }
              break;
            case Animation.ANIMATIONTYPE_COLOR4:
              data = Color4.FromArray(key.values);
              if (key.values[4]) {
                inTangent = Color4.FromArray(key.values[4]);
              }
              if (key.values[5]) {
                outTangent = Color4.FromArray(key.values[5]);
              }
              if (key.values[6]) {
                interpolation = Color4.FromArray(key.values[6]);
              }
              break;
            case Animation.ANIMATIONTYPE_VECTOR3:
            default:
              data = Vector3.FromArray(key.values);
              if (key.values[3]) {
                inTangent = Vector3.FromArray(key.values[3]);
              }
              if (key.values[4]) {
                outTangent = Vector3.FromArray(key.values[4]);
              }
              if (key.values[5]) {
                interpolation = key.values[5];
              }
              break;
          }
          const keyData = {};
          keyData.frame = key.frame;
          keyData.value = data;
          if (inTangent != void 0) {
            keyData.inTangent = inTangent;
          }
          if (outTangent != void 0) {
            keyData.outTangent = outTangent;
          }
          if (interpolation != void 0) {
            keyData.interpolation = interpolation;
          }
          keys.push(keyData);
        }
        animation.setKeys(keys);
        if (parsedAnimation.ranges) {
          for (index = 0; index < parsedAnimation.ranges.length; index++) {
            data = parsedAnimation.ranges[index];
            animation.createRange(data.name, data.from, data.to);
          }
        }
        return animation;
      }
      static AppendSerializedAnimations(source, destination) {
        SerializationHelper.AppendSerializedAnimations(source, destination);
      }
      static ParseFromFileAsync(name109, url) {
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                let serializationObject = JSON.parse(request.responseText);
                if (serializationObject.animations) {
                  serializationObject = serializationObject.animations;
                }
                if (serializationObject.length) {
                  const output = new Array();
                  for (const serializedAnimation of serializationObject) {
                    output.push(this.Parse(serializedAnimation));
                  }
                  resolve(output);
                } else {
                  const output = this.Parse(serializationObject);
                  if (name109) {
                    output.name = name109;
                  }
                  resolve(output);
                }
              } else {
                reject("Unable to load the animation");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      }
      static ParseFromSnippetAsync(snippetId) {
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                if (snippet.animations) {
                  const serializationObject = JSON.parse(snippet.animations);
                  const outputs = new Array();
                  for (const serializedAnimation of serializationObject.animations) {
                    const output = this.Parse(serializedAnimation);
                    output.snippetId = snippetId;
                    outputs.push(output);
                  }
                  resolve(outputs);
                } else {
                  const serializationObject = JSON.parse(snippet.animation);
                  const output = this.Parse(serializationObject);
                  output.snippetId = snippetId;
                  resolve(output);
                }
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    Animation._UniqueIdGenerator = 0;
    Animation.AllowMatricesInterpolation = false;
    Animation.AllowMatrixDecomposeForInterpolation = true;
    Animation.SnippetUrl = `https://snippet.babylonjs.com`;
    Animation.ANIMATIONTYPE_FLOAT = 0;
    Animation.ANIMATIONTYPE_VECTOR3 = 1;
    Animation.ANIMATIONTYPE_QUATERNION = 2;
    Animation.ANIMATIONTYPE_MATRIX = 3;
    Animation.ANIMATIONTYPE_COLOR3 = 4;
    Animation.ANIMATIONTYPE_COLOR4 = 7;
    Animation.ANIMATIONTYPE_VECTOR2 = 5;
    Animation.ANIMATIONTYPE_SIZE = 6;
    Animation.ANIMATIONLOOPMODE_RELATIVE = 0;
    Animation.ANIMATIONLOOPMODE_CYCLE = 1;
    Animation.ANIMATIONLOOPMODE_CONSTANT = 2;
    Animation.ANIMATIONLOOPMODE_YOYO = 4;
    Animation.CreateFromSnippetAsync = Animation.ParseFromSnippetAsync;
    RegisterClass("BABYLON.Animation", Animation);
    Node._AnimationRangeFactory = (name109, from, to) => new AnimationRange(name109, from, to);
  }
});

// node_modules/@babylonjs/core/Maths/math.axis.js
var Space, Axis, Coordinate;
var init_math_axis = __esm({
  "node_modules/@babylonjs/core/Maths/math.axis.js"() {
    init_math_vector();
    (function(Space2) {
      Space2[Space2["LOCAL"] = 0] = "LOCAL";
      Space2[Space2["WORLD"] = 1] = "WORLD";
      Space2[Space2["BONE"] = 2] = "BONE";
    })(Space || (Space = {}));
    Axis = class {
    };
    Axis.X = new Vector3(1, 0, 0);
    Axis.Y = new Vector3(0, 1, 0);
    Axis.Z = new Vector3(0, 0, 1);
    (function(Coordinate2) {
      Coordinate2[Coordinate2["X"] = 0] = "X";
      Coordinate2[Coordinate2["Y"] = 1] = "Y";
      Coordinate2[Coordinate2["Z"] = 2] = "Z";
    })(Coordinate || (Coordinate = {}));
  }
});

// node_modules/@babylonjs/core/Bones/bone.js
var Bone;
var init_bone = __esm({
  "node_modules/@babylonjs/core/Bones/bone.js"() {
    init_math_vector();
    init_arrayTools();
    init_node();
    init_math_axis();
    Bone = class extends Node {
      get _matrix() {
        this._compose();
        return this._localMatrix;
      }
      set _matrix(value) {
        if (value.updateFlag === this._localMatrix.updateFlag && !this._needToCompose) {
          return;
        }
        this._needToCompose = false;
        this._localMatrix.copyFrom(value);
        this._markAsDirtyAndDecompose();
      }
      constructor(name109, skeleton, parentBone = null, localMatrix = null, restMatrix = null, bindMatrix = null, index = null) {
        var _a;
        super(name109, skeleton.getScene());
        this.name = name109;
        this.children = new Array();
        this.animations = new Array();
        this._index = null;
        this._scalingDeterminant = 1;
        this._needToDecompose = true;
        this._needToCompose = false;
        this._linkedTransformNode = null;
        this._waitingTransformNodeId = null;
        this._skeleton = skeleton;
        this._localMatrix = (_a = localMatrix === null || localMatrix === void 0 ? void 0 : localMatrix.clone()) !== null && _a !== void 0 ? _a : Matrix.Identity();
        this._restMatrix = restMatrix !== null && restMatrix !== void 0 ? restMatrix : this._localMatrix.clone();
        this._bindMatrix = bindMatrix !== null && bindMatrix !== void 0 ? bindMatrix : this._localMatrix.clone();
        this._index = index;
        this._absoluteMatrix = new Matrix();
        this._absoluteBindMatrix = new Matrix();
        this._absoluteInverseBindMatrix = new Matrix();
        this._finalMatrix = new Matrix();
        skeleton.bones.push(this);
        this.setParent(parentBone, false);
        this._updateAbsoluteBindMatrices();
      }
      getClassName() {
        return "Bone";
      }
      getSkeleton() {
        return this._skeleton;
      }
      get parent() {
        return this._parentNode;
      }
      getParent() {
        return this.parent;
      }
      getChildren() {
        return this.children;
      }
      getIndex() {
        return this._index === null ? this.getSkeleton().bones.indexOf(this) : this._index;
      }
      set parent(newParent) {
        this.setParent(newParent);
      }
      setParent(parent, updateAbsoluteBindMatrices = true) {
        if (this.parent === parent) {
          return;
        }
        if (this.parent) {
          const index = this.parent.children.indexOf(this);
          if (index !== -1) {
            this.parent.children.splice(index, 1);
          }
        }
        this._parentNode = parent;
        if (this.parent) {
          this.parent.children.push(this);
        }
        if (updateAbsoluteBindMatrices) {
          this._updateAbsoluteBindMatrices();
        }
        this.markAsDirty();
      }
      getLocalMatrix() {
        this._compose();
        return this._localMatrix;
      }
      getBindMatrix() {
        return this._bindMatrix;
      }
      getBaseMatrix() {
        return this.getBindMatrix();
      }
      getRestMatrix() {
        return this._restMatrix;
      }
      getRestPose() {
        return this.getRestMatrix();
      }
      setRestMatrix(matrix) {
        this._restMatrix.copyFrom(matrix);
      }
      setRestPose(matrix) {
        this.setRestMatrix(matrix);
      }
      getBindPose() {
        return this.getBindMatrix();
      }
      setBindMatrix(matrix) {
        this.updateMatrix(matrix);
      }
      setBindPose(matrix) {
        this.setBindMatrix(matrix);
      }
      getFinalMatrix() {
        return this._finalMatrix;
      }
      getWorldMatrix() {
        return this.getFinalMatrix();
      }
      returnToRest() {
        var _a;
        if (this._linkedTransformNode) {
          const localScaling = TmpVectors.Vector3[0];
          const localRotation = TmpVectors.Quaternion[0];
          const localPosition = TmpVectors.Vector3[1];
          this.getRestMatrix().decompose(localScaling, localRotation, localPosition);
          this._linkedTransformNode.position.copyFrom(localPosition);
          this._linkedTransformNode.rotationQuaternion = (_a = this._linkedTransformNode.rotationQuaternion) !== null && _a !== void 0 ? _a : Quaternion.Identity();
          this._linkedTransformNode.rotationQuaternion.copyFrom(localRotation);
          this._linkedTransformNode.scaling.copyFrom(localScaling);
        } else {
          this._matrix = this._restMatrix;
        }
      }
      getAbsoluteInverseBindMatrix() {
        return this._absoluteInverseBindMatrix;
      }
      getInvertedAbsoluteTransform() {
        return this.getAbsoluteInverseBindMatrix();
      }
      getAbsoluteMatrix() {
        return this._absoluteMatrix;
      }
      getAbsoluteTransform() {
        return this._absoluteMatrix;
      }
      linkTransformNode(transformNode) {
        if (this._linkedTransformNode) {
          this._skeleton._numBonesWithLinkedTransformNode--;
        }
        this._linkedTransformNode = transformNode;
        if (this._linkedTransformNode) {
          this._skeleton._numBonesWithLinkedTransformNode++;
        }
      }
      getTransformNode() {
        return this._linkedTransformNode;
      }
      get position() {
        this._decompose();
        return this._localPosition;
      }
      set position(newPosition) {
        this._decompose();
        this._localPosition.copyFrom(newPosition);
        this._markAsDirtyAndCompose();
      }
      get rotation() {
        return this.getRotation();
      }
      set rotation(newRotation) {
        this.setRotation(newRotation);
      }
      get rotationQuaternion() {
        this._decompose();
        return this._localRotation;
      }
      set rotationQuaternion(newRotation) {
        this.setRotationQuaternion(newRotation);
      }
      get scaling() {
        return this.getScale();
      }
      set scaling(newScaling) {
        this.setScale(newScaling);
      }
      get animationPropertiesOverride() {
        return this._skeleton.animationPropertiesOverride;
      }
      _decompose() {
        if (!this._needToDecompose) {
          return;
        }
        this._needToDecompose = false;
        if (!this._localScaling) {
          this._localScaling = Vector3.Zero();
          this._localRotation = Quaternion.Zero();
          this._localPosition = Vector3.Zero();
        }
        this._localMatrix.decompose(this._localScaling, this._localRotation, this._localPosition);
      }
      _compose() {
        if (!this._needToCompose) {
          return;
        }
        if (!this._localScaling) {
          this._needToCompose = false;
          return;
        }
        this._needToCompose = false;
        Matrix.ComposeToRef(this._localScaling, this._localRotation, this._localPosition, this._localMatrix);
      }
      updateMatrix(bindMatrix, updateAbsoluteBindMatrices = true, updateLocalMatrix = true) {
        this._bindMatrix.copyFrom(bindMatrix);
        if (updateAbsoluteBindMatrices) {
          this._updateAbsoluteBindMatrices();
        }
        if (updateLocalMatrix) {
          this._matrix = bindMatrix;
        } else {
          this.markAsDirty();
        }
      }
      _updateAbsoluteBindMatrices(bindMatrix, updateChildren = true) {
        if (!bindMatrix) {
          bindMatrix = this._bindMatrix;
        }
        if (this.parent) {
          bindMatrix.multiplyToRef(this.parent._absoluteBindMatrix, this._absoluteBindMatrix);
        } else {
          this._absoluteBindMatrix.copyFrom(bindMatrix);
        }
        this._absoluteBindMatrix.invertToRef(this._absoluteInverseBindMatrix);
        if (updateChildren) {
          for (let index = 0; index < this.children.length; index++) {
            this.children[index]._updateAbsoluteBindMatrices();
          }
        }
        this._scalingDeterminant = this._absoluteBindMatrix.determinant() < 0 ? -1 : 1;
      }
      markAsDirty() {
        this._currentRenderId++;
        this._childUpdateId++;
        this._skeleton._markAsDirty();
        return this;
      }
      _markAsDirtyAndCompose() {
        this.markAsDirty();
        this._needToCompose = true;
      }
      _markAsDirtyAndDecompose() {
        this.markAsDirty();
        this._needToDecompose = true;
      }
      _updatePosition(vec, space = Space.LOCAL, tNode, translationMode = true) {
        const lm = this.getLocalMatrix();
        if (space == Space.LOCAL) {
          if (translationMode) {
            lm.addAtIndex(12, vec.x);
            lm.addAtIndex(13, vec.y);
            lm.addAtIndex(14, vec.z);
          } else {
            lm.setTranslationFromFloats(vec.x, vec.y, vec.z);
          }
        } else {
          let wm = null;
          if (tNode) {
            wm = tNode.getWorldMatrix();
          }
          this._skeleton.computeAbsoluteMatrices();
          const tmat = Bone._TmpMats[0];
          const tvec = Bone._TmpVecs[0];
          if (this.parent) {
            if (tNode && wm) {
              tmat.copyFrom(this.parent.getAbsoluteMatrix());
              tmat.multiplyToRef(wm, tmat);
            } else {
              tmat.copyFrom(this.parent.getAbsoluteMatrix());
            }
          } else {
            Matrix.IdentityToRef(tmat);
          }
          if (translationMode) {
            tmat.setTranslationFromFloats(0, 0, 0);
          }
          tmat.invert();
          Vector3.TransformCoordinatesToRef(vec, tmat, tvec);
          if (translationMode) {
            lm.addAtIndex(12, tvec.x);
            lm.addAtIndex(13, tvec.y);
            lm.addAtIndex(14, tvec.z);
          } else {
            lm.setTranslationFromFloats(tvec.x, tvec.y, tvec.z);
          }
        }
        this._markAsDirtyAndDecompose();
      }
      translate(vec, space = Space.LOCAL, tNode) {
        this._updatePosition(vec, space, tNode, true);
      }
      setPosition(position, space = Space.LOCAL, tNode) {
        this._updatePosition(position, space, tNode, false);
      }
      setAbsolutePosition(position, tNode) {
        this.setPosition(position, Space.WORLD, tNode);
      }
      scale(x, y, z, scaleChildren = false) {
        const locMat = this.getLocalMatrix();
        const scaleMat = Bone._TmpMats[0];
        Matrix.ScalingToRef(x, y, z, scaleMat);
        scaleMat.multiplyToRef(locMat, locMat);
        scaleMat.invert();
        for (const child of this.children) {
          const cm = child.getLocalMatrix();
          cm.multiplyToRef(scaleMat, cm);
          cm.multiplyAtIndex(12, x);
          cm.multiplyAtIndex(13, y);
          cm.multiplyAtIndex(14, z);
          child._markAsDirtyAndDecompose();
        }
        this._markAsDirtyAndDecompose();
        if (scaleChildren) {
          for (const child of this.children) {
            child.scale(x, y, z, scaleChildren);
          }
        }
      }
      setScale(scale) {
        this._decompose();
        this._localScaling.copyFrom(scale);
        this._markAsDirtyAndCompose();
      }
      getScale() {
        this._decompose();
        return this._localScaling;
      }
      getScaleToRef(result) {
        this._decompose();
        result.copyFrom(this._localScaling);
      }
      setYawPitchRoll(yaw, pitch, roll, space = Space.LOCAL, tNode) {
        if (space === Space.LOCAL) {
          const quat = Bone._TmpQuat;
          Quaternion.RotationYawPitchRollToRef(yaw, pitch, roll, quat);
          this.setRotationQuaternion(quat, space, tNode);
          return;
        }
        const rotMatInv = Bone._TmpMats[0];
        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
          return;
        }
        const rotMat = Bone._TmpMats[1];
        Matrix.RotationYawPitchRollToRef(yaw, pitch, roll, rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat);
        this._rotateWithMatrix(rotMat, space, tNode);
      }
      rotate(axis, amount, space = Space.LOCAL, tNode) {
        const rmat = Bone._TmpMats[0];
        rmat.setTranslationFromFloats(0, 0, 0);
        Matrix.RotationAxisToRef(axis, amount, rmat);
        this._rotateWithMatrix(rmat, space, tNode);
      }
      setAxisAngle(axis, angle, space = Space.LOCAL, tNode) {
        if (space === Space.LOCAL) {
          const quat = Bone._TmpQuat;
          Quaternion.RotationAxisToRef(axis, angle, quat);
          this.setRotationQuaternion(quat, space, tNode);
          return;
        }
        const rotMatInv = Bone._TmpMats[0];
        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
          return;
        }
        const rotMat = Bone._TmpMats[1];
        Matrix.RotationAxisToRef(axis, angle, rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat);
        this._rotateWithMatrix(rotMat, space, tNode);
      }
      setRotation(rotation, space = Space.LOCAL, tNode) {
        this.setYawPitchRoll(rotation.y, rotation.x, rotation.z, space, tNode);
      }
      setRotationQuaternion(quat, space = Space.LOCAL, tNode) {
        if (space === Space.LOCAL) {
          this._decompose();
          this._localRotation.copyFrom(quat);
          this._markAsDirtyAndCompose();
          return;
        }
        const rotMatInv = Bone._TmpMats[0];
        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
          return;
        }
        const rotMat = Bone._TmpMats[1];
        Matrix.FromQuaternionToRef(quat, rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat);
        this._rotateWithMatrix(rotMat, space, tNode);
      }
      setRotationMatrix(rotMat, space = Space.LOCAL, tNode) {
        if (space === Space.LOCAL) {
          const quat = Bone._TmpQuat;
          Quaternion.FromRotationMatrixToRef(rotMat, quat);
          this.setRotationQuaternion(quat, space, tNode);
          return;
        }
        const rotMatInv = Bone._TmpMats[0];
        if (!this._getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode)) {
          return;
        }
        const rotMat2 = Bone._TmpMats[1];
        rotMat2.copyFrom(rotMat);
        rotMatInv.multiplyToRef(rotMat, rotMat2);
        this._rotateWithMatrix(rotMat2, space, tNode);
      }
      _rotateWithMatrix(rmat, space = Space.LOCAL, tNode) {
        const lmat = this.getLocalMatrix();
        const lx = lmat.m[12];
        const ly = lmat.m[13];
        const lz = lmat.m[14];
        const parent = this.getParent();
        const parentScale = Bone._TmpMats[3];
        const parentScaleInv = Bone._TmpMats[4];
        if (parent && space == Space.WORLD) {
          if (tNode) {
            parentScale.copyFrom(tNode.getWorldMatrix());
            parent.getAbsoluteMatrix().multiplyToRef(parentScale, parentScale);
          } else {
            parentScale.copyFrom(parent.getAbsoluteMatrix());
          }
          parentScaleInv.copyFrom(parentScale);
          parentScaleInv.invert();
          lmat.multiplyToRef(parentScale, lmat);
          lmat.multiplyToRef(rmat, lmat);
          lmat.multiplyToRef(parentScaleInv, lmat);
        } else {
          if (space == Space.WORLD && tNode) {
            parentScale.copyFrom(tNode.getWorldMatrix());
            parentScaleInv.copyFrom(parentScale);
            parentScaleInv.invert();
            lmat.multiplyToRef(parentScale, lmat);
            lmat.multiplyToRef(rmat, lmat);
            lmat.multiplyToRef(parentScaleInv, lmat);
          } else {
            lmat.multiplyToRef(rmat, lmat);
          }
        }
        lmat.setTranslationFromFloats(lx, ly, lz);
        this.computeAbsoluteMatrices();
        this._markAsDirtyAndDecompose();
      }
      _getAbsoluteInverseMatrixUnscaledToRef(rotMatInv, tNode) {
        const scaleMatrix = Bone._TmpMats[2];
        rotMatInv.copyFrom(this.getAbsoluteMatrix());
        if (tNode) {
          rotMatInv.multiplyToRef(tNode.getWorldMatrix(), rotMatInv);
          Matrix.ScalingToRef(tNode.scaling.x, tNode.scaling.y, tNode.scaling.z, scaleMatrix);
        } else {
          Matrix.IdentityToRef(scaleMatrix);
        }
        rotMatInv.invert();
        if (isNaN(rotMatInv.m[0])) {
          return false;
        }
        scaleMatrix.multiplyAtIndex(0, this._scalingDeterminant);
        rotMatInv.multiplyToRef(scaleMatrix, rotMatInv);
        return true;
      }
      getPosition(space = Space.LOCAL, tNode = null) {
        const pos = Vector3.Zero();
        this.getPositionToRef(space, tNode, pos);
        return pos;
      }
      getPositionToRef(space = Space.LOCAL, tNode, result) {
        if (space == Space.LOCAL) {
          const lm = this.getLocalMatrix();
          result.x = lm.m[12];
          result.y = lm.m[13];
          result.z = lm.m[14];
        } else {
          let wm = null;
          if (tNode) {
            wm = tNode.getWorldMatrix();
          }
          this._skeleton.computeAbsoluteMatrices();
          let tmat = Bone._TmpMats[0];
          if (tNode && wm) {
            tmat.copyFrom(this.getAbsoluteMatrix());
            tmat.multiplyToRef(wm, tmat);
          } else {
            tmat = this.getAbsoluteMatrix();
          }
          result.x = tmat.m[12];
          result.y = tmat.m[13];
          result.z = tmat.m[14];
        }
      }
      getAbsolutePosition(tNode = null) {
        const pos = Vector3.Zero();
        this.getPositionToRef(Space.WORLD, tNode, pos);
        return pos;
      }
      getAbsolutePositionToRef(tNode, result) {
        this.getPositionToRef(Space.WORLD, tNode, result);
      }
      computeAbsoluteMatrices() {
        this._compose();
        if (this.parent) {
          this._localMatrix.multiplyToRef(this.parent._absoluteMatrix, this._absoluteMatrix);
        } else {
          this._absoluteMatrix.copyFrom(this._localMatrix);
          const poseMatrix = this._skeleton.getPoseMatrix();
          if (poseMatrix) {
            this._absoluteMatrix.multiplyToRef(poseMatrix, this._absoluteMatrix);
          }
        }
        const children = this.children;
        const len = children.length;
        for (let i = 0; i < len; i++) {
          children[i].computeAbsoluteMatrices();
        }
      }
      computeAbsoluteTransforms() {
        this.computeAbsoluteMatrices();
      }
      getDirection(localAxis, tNode = null) {
        const result = Vector3.Zero();
        this.getDirectionToRef(localAxis, tNode, result);
        return result;
      }
      getDirectionToRef(localAxis, tNode = null, result) {
        let wm = null;
        if (tNode) {
          wm = tNode.getWorldMatrix();
        }
        this._skeleton.computeAbsoluteMatrices();
        const mat = Bone._TmpMats[0];
        mat.copyFrom(this.getAbsoluteMatrix());
        if (tNode && wm) {
          mat.multiplyToRef(wm, mat);
        }
        Vector3.TransformNormalToRef(localAxis, mat, result);
        result.normalize();
      }
      getRotation(space = Space.LOCAL, tNode = null) {
        const result = Vector3.Zero();
        this.getRotationToRef(space, tNode, result);
        return result;
      }
      getRotationToRef(space = Space.LOCAL, tNode = null, result) {
        const quat = Bone._TmpQuat;
        this.getRotationQuaternionToRef(space, tNode, quat);
        quat.toEulerAnglesToRef(result);
      }
      getRotationQuaternion(space = Space.LOCAL, tNode = null) {
        const result = Quaternion.Identity();
        this.getRotationQuaternionToRef(space, tNode, result);
        return result;
      }
      getRotationQuaternionToRef(space = Space.LOCAL, tNode = null, result) {
        if (space == Space.LOCAL) {
          this._decompose();
          result.copyFrom(this._localRotation);
        } else {
          const mat = Bone._TmpMats[0];
          const amat = this.getAbsoluteMatrix();
          if (tNode) {
            amat.multiplyToRef(tNode.getWorldMatrix(), mat);
          } else {
            mat.copyFrom(amat);
          }
          mat.multiplyAtIndex(0, this._scalingDeterminant);
          mat.multiplyAtIndex(1, this._scalingDeterminant);
          mat.multiplyAtIndex(2, this._scalingDeterminant);
          mat.decompose(void 0, result, void 0);
        }
      }
      getRotationMatrix(space = Space.LOCAL, tNode) {
        const result = Matrix.Identity();
        this.getRotationMatrixToRef(space, tNode, result);
        return result;
      }
      getRotationMatrixToRef(space = Space.LOCAL, tNode, result) {
        if (space == Space.LOCAL) {
          this.getLocalMatrix().getRotationMatrixToRef(result);
        } else {
          const mat = Bone._TmpMats[0];
          const amat = this.getAbsoluteMatrix();
          if (tNode) {
            amat.multiplyToRef(tNode.getWorldMatrix(), mat);
          } else {
            mat.copyFrom(amat);
          }
          mat.multiplyAtIndex(0, this._scalingDeterminant);
          mat.multiplyAtIndex(1, this._scalingDeterminant);
          mat.multiplyAtIndex(2, this._scalingDeterminant);
          mat.getRotationMatrixToRef(result);
        }
      }
      getAbsolutePositionFromLocal(position, tNode = null) {
        const result = Vector3.Zero();
        this.getAbsolutePositionFromLocalToRef(position, tNode, result);
        return result;
      }
      getAbsolutePositionFromLocalToRef(position, tNode = null, result) {
        let wm = null;
        if (tNode) {
          wm = tNode.getWorldMatrix();
        }
        this._skeleton.computeAbsoluteMatrices();
        const tmat = Bone._TmpMats[0];
        tmat.copyFrom(this.getAbsoluteMatrix());
        if (tNode && wm) {
          tmat.multiplyToRef(wm, tmat);
        }
        Vector3.TransformCoordinatesToRef(position, tmat, result);
      }
      getLocalPositionFromAbsolute(position, tNode = null) {
        const result = Vector3.Zero();
        this.getLocalPositionFromAbsoluteToRef(position, tNode, result);
        return result;
      }
      getLocalPositionFromAbsoluteToRef(position, tNode = null, result) {
        let wm = null;
        if (tNode) {
          wm = tNode.getWorldMatrix();
        }
        this._skeleton.computeAbsoluteMatrices();
        const tmat = Bone._TmpMats[0];
        tmat.copyFrom(this.getAbsoluteMatrix());
        if (tNode && wm) {
          tmat.multiplyToRef(wm, tmat);
        }
        tmat.invert();
        Vector3.TransformCoordinatesToRef(position, tmat, result);
      }
      setCurrentPoseAsRest() {
        this.setRestMatrix(this.getLocalMatrix());
      }
    };
    Bone._TmpVecs = ArrayTools.BuildArray(2, Vector3.Zero);
    Bone._TmpQuat = Quaternion.Identity();
    Bone._TmpMats = ArrayTools.BuildArray(5, Matrix.Identity);
  }
});

// node_modules/@babylonjs/core/Maths/math.path.js
var Orientation, BezierCurve, Angle, Arc2, Path2, Path3D, Curve3;
var init_math_path = __esm({
  "node_modules/@babylonjs/core/Maths/math.path.js"() {
    init_math_scalar();
    init_math_vector();
    init_math_constants();
    (function(Orientation2) {
      Orientation2[Orientation2["CW"] = 0] = "CW";
      Orientation2[Orientation2["CCW"] = 1] = "CCW";
    })(Orientation || (Orientation = {}));
    BezierCurve = class {
      static Interpolate(t, x1, y1, x2, y2) {
        const f0 = 1 - 3 * x2 + 3 * x1;
        const f1 = 3 * x2 - 6 * x1;
        const f2 = 3 * x1;
        let refinedT = t;
        for (let i = 0; i < 5; i++) {
          const refinedT2 = refinedT * refinedT;
          const refinedT3 = refinedT2 * refinedT;
          const x = f0 * refinedT3 + f1 * refinedT2 + f2 * refinedT;
          const slope = 1 / (3 * f0 * refinedT2 + 2 * f1 * refinedT + f2);
          refinedT -= (x - t) * slope;
          refinedT = Math.min(1, Math.max(0, refinedT));
        }
        return 3 * Math.pow(1 - refinedT, 2) * refinedT * y1 + 3 * (1 - refinedT) * Math.pow(refinedT, 2) * y2 + Math.pow(refinedT, 3);
      }
    };
    Angle = class {
      constructor(radians) {
        this._radians = radians;
        if (this._radians < 0) {
          this._radians += 2 * Math.PI;
        }
      }
      degrees() {
        return this._radians * 180 / Math.PI;
      }
      radians() {
        return this._radians;
      }
      static BetweenTwoPoints(a, b) {
        const delta = b.subtract(a);
        const theta = Math.atan2(delta.y, delta.x);
        return new Angle(theta);
      }
      static FromRadians(radians) {
        return new Angle(radians);
      }
      static FromDegrees(degrees) {
        return new Angle(degrees * Math.PI / 180);
      }
    };
    Arc2 = class {
      constructor(startPoint, midPoint, endPoint) {
        this.startPoint = startPoint;
        this.midPoint = midPoint;
        this.endPoint = endPoint;
        const temp = Math.pow(midPoint.x, 2) + Math.pow(midPoint.y, 2);
        const startToMid = (Math.pow(startPoint.x, 2) + Math.pow(startPoint.y, 2) - temp) / 2;
        const midToEnd = (temp - Math.pow(endPoint.x, 2) - Math.pow(endPoint.y, 2)) / 2;
        const det = (startPoint.x - midPoint.x) * (midPoint.y - endPoint.y) - (midPoint.x - endPoint.x) * (startPoint.y - midPoint.y);
        this.centerPoint = new Vector2((startToMid * (midPoint.y - endPoint.y) - midToEnd * (startPoint.y - midPoint.y)) / det, ((startPoint.x - midPoint.x) * midToEnd - (midPoint.x - endPoint.x) * startToMid) / det);
        this.radius = this.centerPoint.subtract(this.startPoint).length();
        this.startAngle = Angle.BetweenTwoPoints(this.centerPoint, this.startPoint);
        const a1 = this.startAngle.degrees();
        let a2 = Angle.BetweenTwoPoints(this.centerPoint, this.midPoint).degrees();
        let a3 = Angle.BetweenTwoPoints(this.centerPoint, this.endPoint).degrees();
        if (a2 - a1 > 180) {
          a2 -= 360;
        }
        if (a2 - a1 < -180) {
          a2 += 360;
        }
        if (a3 - a2 > 180) {
          a3 -= 360;
        }
        if (a3 - a2 < -180) {
          a3 += 360;
        }
        this.orientation = a2 - a1 < 0 ? Orientation.CW : Orientation.CCW;
        this.angle = Angle.FromDegrees(this.orientation === Orientation.CW ? a1 - a3 : a3 - a1);
      }
    };
    Path2 = class {
      constructor(x, y) {
        this._points = new Array();
        this._length = 0;
        this.closed = false;
        this._points.push(new Vector2(x, y));
      }
      addLineTo(x, y) {
        if (this.closed) {
          return this;
        }
        const newPoint = new Vector2(x, y);
        const previousPoint = this._points[this._points.length - 1];
        this._points.push(newPoint);
        this._length += newPoint.subtract(previousPoint).length();
        return this;
      }
      addArcTo(midX, midY, endX, endY, numberOfSegments = 36) {
        if (this.closed) {
          return this;
        }
        const startPoint = this._points[this._points.length - 1];
        const midPoint = new Vector2(midX, midY);
        const endPoint = new Vector2(endX, endY);
        const arc = new Arc2(startPoint, midPoint, endPoint);
        let increment = arc.angle.radians() / numberOfSegments;
        if (arc.orientation === Orientation.CW) {
          increment *= -1;
        }
        let currentAngle = arc.startAngle.radians() + increment;
        for (let i = 0; i < numberOfSegments; i++) {
          const x = Math.cos(currentAngle) * arc.radius + arc.centerPoint.x;
          const y = Math.sin(currentAngle) * arc.radius + arc.centerPoint.y;
          this.addLineTo(x, y);
          currentAngle += increment;
        }
        return this;
      }
      addQuadraticCurveTo(controlX, controlY, endX, endY, numberOfSegments = 36) {
        if (this.closed) {
          return this;
        }
        const equation = (t, val0, val1, val2) => {
          const res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
          return res;
        };
        const startPoint = this._points[this._points.length - 1];
        for (let i = 0; i <= numberOfSegments; i++) {
          const step = i / numberOfSegments;
          const x = equation(step, startPoint.x, controlX, endX);
          const y = equation(step, startPoint.y, controlY, endY);
          this.addLineTo(x, y);
        }
        return this;
      }
      addBezierCurveTo(originTangentX, originTangentY, destinationTangentX, destinationTangentY, endX, endY, numberOfSegments = 36) {
        if (this.closed) {
          return this;
        }
        const equation = (t, val0, val1, val2, val3) => {
          const res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
          return res;
        };
        const startPoint = this._points[this._points.length - 1];
        for (let i = 0; i <= numberOfSegments; i++) {
          const step = i / numberOfSegments;
          const x = equation(step, startPoint.x, originTangentX, destinationTangentX, endX);
          const y = equation(step, startPoint.y, originTangentY, destinationTangentY, endY);
          this.addLineTo(x, y);
        }
        return this;
      }
      isPointInside(point) {
        let isInside = false;
        const count = this._points.length;
        for (let p = count - 1, q = 0; q < count; p = q++) {
          let edgeLow = this._points[p];
          let edgeHigh = this._points[q];
          let edgeDx = edgeHigh.x - edgeLow.x;
          let edgeDy = edgeHigh.y - edgeLow.y;
          if (Math.abs(edgeDy) > Number.EPSILON) {
            if (edgeDy < 0) {
              edgeLow = this._points[q];
              edgeDx = -edgeDx;
              edgeHigh = this._points[p];
              edgeDy = -edgeDy;
            }
            if (point.y < edgeLow.y || point.y > edgeHigh.y) {
              continue;
            }
            if (point.y === edgeLow.y && point.x === edgeLow.x) {
              return true;
            } else {
              const perpEdge = edgeDy * (point.x - edgeLow.x) - edgeDx * (point.y - edgeLow.y);
              if (perpEdge === 0) {
                return true;
              }
              if (perpEdge < 0) {
                continue;
              }
              isInside = !isInside;
            }
          } else {
            if (point.y !== edgeLow.y) {
              continue;
            }
            if (edgeHigh.x <= point.x && point.x <= edgeLow.x || edgeLow.x <= point.x && point.x <= edgeHigh.x) {
              return true;
            }
          }
        }
        return isInside;
      }
      close() {
        this.closed = true;
        return this;
      }
      length() {
        let result = this._length;
        if (this.closed) {
          const lastPoint = this._points[this._points.length - 1];
          const firstPoint = this._points[0];
          result += firstPoint.subtract(lastPoint).length();
        }
        return result;
      }
      area() {
        const n = this._points.length;
        let value = 0;
        for (let p = n - 1, q = 0; q < n; p = q++) {
          value += this._points[p].x * this._points[q].y - this._points[q].x * this._points[p].y;
        }
        return value * 0.5;
      }
      getPoints() {
        return this._points;
      }
      getPointAtLengthPosition(normalizedLengthPosition) {
        if (normalizedLengthPosition < 0 || normalizedLengthPosition > 1) {
          return Vector2.Zero();
        }
        const lengthPosition = normalizedLengthPosition * this.length();
        let previousOffset = 0;
        for (let i = 0; i < this._points.length; i++) {
          const j = (i + 1) % this._points.length;
          const a = this._points[i];
          const b = this._points[j];
          const bToA = b.subtract(a);
          const nextOffset = bToA.length() + previousOffset;
          if (lengthPosition >= previousOffset && lengthPosition <= nextOffset) {
            const dir = bToA.normalize();
            const localOffset = lengthPosition - previousOffset;
            return new Vector2(a.x + dir.x * localOffset, a.y + dir.y * localOffset);
          }
          previousOffset = nextOffset;
        }
        return Vector2.Zero();
      }
      static StartingAt(x, y) {
        return new Path2(x, y);
      }
    };
    Path3D = class {
      constructor(path, firstNormal = null, raw, alignTangentsWithPath = false) {
        this.path = path;
        this._curve = new Array();
        this._distances = new Array();
        this._tangents = new Array();
        this._normals = new Array();
        this._binormals = new Array();
        this._pointAtData = {
          id: 0,
          point: Vector3.Zero(),
          previousPointArrayIndex: 0,
          position: 0,
          subPosition: 0,
          interpolateReady: false,
          interpolationMatrix: Matrix.Identity()
        };
        for (let p = 0; p < path.length; p++) {
          this._curve[p] = path[p].clone();
        }
        this._raw = raw || false;
        this._alignTangentsWithPath = alignTangentsWithPath;
        this._compute(firstNormal, alignTangentsWithPath);
      }
      getCurve() {
        return this._curve;
      }
      getPoints() {
        return this._curve;
      }
      length() {
        return this._distances[this._distances.length - 1];
      }
      getTangents() {
        return this._tangents;
      }
      getNormals() {
        return this._normals;
      }
      getBinormals() {
        return this._binormals;
      }
      getDistances() {
        return this._distances;
      }
      getPointAt(position) {
        return this._updatePointAtData(position).point;
      }
      getTangentAt(position, interpolated = false) {
        this._updatePointAtData(position, interpolated);
        return interpolated ? Vector3.TransformCoordinates(Vector3.Forward(), this._pointAtData.interpolationMatrix) : this._tangents[this._pointAtData.previousPointArrayIndex];
      }
      getNormalAt(position, interpolated = false) {
        this._updatePointAtData(position, interpolated);
        return interpolated ? Vector3.TransformCoordinates(Vector3.Right(), this._pointAtData.interpolationMatrix) : this._normals[this._pointAtData.previousPointArrayIndex];
      }
      getBinormalAt(position, interpolated = false) {
        this._updatePointAtData(position, interpolated);
        return interpolated ? Vector3.TransformCoordinates(Vector3.UpReadOnly, this._pointAtData.interpolationMatrix) : this._binormals[this._pointAtData.previousPointArrayIndex];
      }
      getDistanceAt(position) {
        return this.length() * position;
      }
      getPreviousPointIndexAt(position) {
        this._updatePointAtData(position);
        return this._pointAtData.previousPointArrayIndex;
      }
      getSubPositionAt(position) {
        this._updatePointAtData(position);
        return this._pointAtData.subPosition;
      }
      getClosestPositionTo(target) {
        let smallestDistance = Number.MAX_VALUE;
        let closestPosition = 0;
        for (let i = 0; i < this._curve.length - 1; i++) {
          const point = this._curve[i + 0];
          const tangent = this._curve[i + 1].subtract(point).normalize();
          const subLength = this._distances[i + 1] - this._distances[i + 0];
          const subPosition = Math.min(Math.max(Vector3.Dot(tangent, target.subtract(point).normalize()), 0) * Vector3.Distance(point, target) / subLength, 1);
          const distance = Vector3.Distance(point.add(tangent.scale(subPosition * subLength)), target);
          if (distance < smallestDistance) {
            smallestDistance = distance;
            closestPosition = (this._distances[i + 0] + subLength * subPosition) / this.length();
          }
        }
        return closestPosition;
      }
      slice(start = 0, end = 1) {
        if (start < 0) {
          start = 1 - start * -1 % 1;
        }
        if (end < 0) {
          end = 1 - end * -1 % 1;
        }
        if (start > end) {
          const _start = start;
          start = end;
          end = _start;
        }
        const curvePoints = this.getCurve();
        const startPoint = this.getPointAt(start);
        let startIndex = this.getPreviousPointIndexAt(start);
        const endPoint = this.getPointAt(end);
        const endIndex = this.getPreviousPointIndexAt(end) + 1;
        const slicePoints = [];
        if (start !== 0) {
          startIndex++;
          slicePoints.push(startPoint);
        }
        slicePoints.push(...curvePoints.slice(startIndex, endIndex));
        if (end !== 1 || start === 1) {
          slicePoints.push(endPoint);
        }
        return new Path3D(slicePoints, this.getNormalAt(start), this._raw, this._alignTangentsWithPath);
      }
      update(path, firstNormal = null, alignTangentsWithPath = false) {
        for (let p = 0; p < path.length; p++) {
          this._curve[p].x = path[p].x;
          this._curve[p].y = path[p].y;
          this._curve[p].z = path[p].z;
        }
        this._compute(firstNormal, alignTangentsWithPath);
        return this;
      }
      _compute(firstNormal, alignTangentsWithPath = false) {
        const l = this._curve.length;
        if (l < 2) {
          return;
        }
        this._tangents[0] = this._getFirstNonNullVector(0);
        if (!this._raw) {
          this._tangents[0].normalize();
        }
        this._tangents[l - 1] = this._curve[l - 1].subtract(this._curve[l - 2]);
        if (!this._raw) {
          this._tangents[l - 1].normalize();
        }
        const tg0 = this._tangents[0];
        const pp0 = this._normalVector(tg0, firstNormal);
        this._normals[0] = pp0;
        if (!this._raw) {
          this._normals[0].normalize();
        }
        this._binormals[0] = Vector3.Cross(tg0, this._normals[0]);
        if (!this._raw) {
          this._binormals[0].normalize();
        }
        this._distances[0] = 0;
        let prev;
        let cur;
        let curTang;
        let prevNor;
        let prevBinor;
        for (let i = 1; i < l; i++) {
          prev = this._getLastNonNullVector(i);
          if (i < l - 1) {
            cur = this._getFirstNonNullVector(i);
            this._tangents[i] = alignTangentsWithPath ? cur : prev.add(cur);
            this._tangents[i].normalize();
          }
          this._distances[i] = this._distances[i - 1] + this._curve[i].subtract(this._curve[i - 1]).length();
          curTang = this._tangents[i];
          prevBinor = this._binormals[i - 1];
          this._normals[i] = Vector3.Cross(prevBinor, curTang);
          if (!this._raw) {
            if (this._normals[i].length() === 0) {
              prevNor = this._normals[i - 1];
              this._normals[i] = prevNor.clone();
            } else {
              this._normals[i].normalize();
            }
          }
          this._binormals[i] = Vector3.Cross(curTang, this._normals[i]);
          if (!this._raw) {
            this._binormals[i].normalize();
          }
        }
        this._pointAtData.id = NaN;
      }
      _getFirstNonNullVector(index) {
        let i = 1;
        let nNVector = this._curve[index + i].subtract(this._curve[index]);
        while (nNVector.length() === 0 && index + i + 1 < this._curve.length) {
          i++;
          nNVector = this._curve[index + i].subtract(this._curve[index]);
        }
        return nNVector;
      }
      _getLastNonNullVector(index) {
        let i = 1;
        let nLVector = this._curve[index].subtract(this._curve[index - i]);
        while (nLVector.length() === 0 && index > i + 1) {
          i++;
          nLVector = this._curve[index].subtract(this._curve[index - i]);
        }
        return nLVector;
      }
      _normalVector(vt, va) {
        let normal0;
        let tgl = vt.length();
        if (tgl === 0) {
          tgl = 1;
        }
        if (va === void 0 || va === null) {
          let point;
          if (!Scalar.WithinEpsilon(Math.abs(vt.y) / tgl, 1, Epsilon)) {
            point = new Vector3(0, -1, 0);
          } else if (!Scalar.WithinEpsilon(Math.abs(vt.x) / tgl, 1, Epsilon)) {
            point = new Vector3(1, 0, 0);
          } else if (!Scalar.WithinEpsilon(Math.abs(vt.z) / tgl, 1, Epsilon)) {
            point = new Vector3(0, 0, 1);
          } else {
            point = Vector3.Zero();
          }
          normal0 = Vector3.Cross(vt, point);
        } else {
          normal0 = Vector3.Cross(vt, va);
          Vector3.CrossToRef(normal0, vt, normal0);
        }
        normal0.normalize();
        return normal0;
      }
      _updatePointAtData(position, interpolateTNB = false) {
        if (this._pointAtData.id === position) {
          if (!this._pointAtData.interpolateReady) {
            this._updateInterpolationMatrix();
          }
          return this._pointAtData;
        } else {
          this._pointAtData.id = position;
        }
        const curvePoints = this.getPoints();
        if (position <= 0) {
          return this._setPointAtData(0, 0, curvePoints[0], 0, interpolateTNB);
        } else if (position >= 1) {
          return this._setPointAtData(1, 1, curvePoints[curvePoints.length - 1], curvePoints.length - 1, interpolateTNB);
        }
        let previousPoint = curvePoints[0];
        let currentPoint;
        let currentLength = 0;
        const targetLength = position * this.length();
        for (let i = 1; i < curvePoints.length; i++) {
          currentPoint = curvePoints[i];
          const distance = Vector3.Distance(previousPoint, currentPoint);
          currentLength += distance;
          if (currentLength === targetLength) {
            return this._setPointAtData(position, 1, currentPoint, i, interpolateTNB);
          } else if (currentLength > targetLength) {
            const toLength = currentLength - targetLength;
            const diff = toLength / distance;
            const dir = previousPoint.subtract(currentPoint);
            const point = currentPoint.add(dir.scaleInPlace(diff));
            return this._setPointAtData(position, 1 - diff, point, i - 1, interpolateTNB);
          }
          previousPoint = currentPoint;
        }
        return this._pointAtData;
      }
      _setPointAtData(position, subPosition, point, parentIndex, interpolateTNB) {
        this._pointAtData.point = point;
        this._pointAtData.position = position;
        this._pointAtData.subPosition = subPosition;
        this._pointAtData.previousPointArrayIndex = parentIndex;
        this._pointAtData.interpolateReady = interpolateTNB;
        if (interpolateTNB) {
          this._updateInterpolationMatrix();
        }
        return this._pointAtData;
      }
      _updateInterpolationMatrix() {
        this._pointAtData.interpolationMatrix = Matrix.Identity();
        const parentIndex = this._pointAtData.previousPointArrayIndex;
        if (parentIndex !== this._tangents.length - 1) {
          const index = parentIndex + 1;
          const tangentFrom = this._tangents[parentIndex].clone();
          const normalFrom = this._normals[parentIndex].clone();
          const binormalFrom = this._binormals[parentIndex].clone();
          const tangentTo = this._tangents[index].clone();
          const normalTo = this._normals[index].clone();
          const binormalTo = this._binormals[index].clone();
          const quatFrom = Quaternion.RotationQuaternionFromAxis(normalFrom, binormalFrom, tangentFrom);
          const quatTo = Quaternion.RotationQuaternionFromAxis(normalTo, binormalTo, tangentTo);
          const quatAt = Quaternion.Slerp(quatFrom, quatTo, this._pointAtData.subPosition);
          quatAt.toRotationMatrix(this._pointAtData.interpolationMatrix);
        }
      }
    };
    Curve3 = class {
      static CreateQuadraticBezier(v0, v1, v2, nbPoints) {
        nbPoints = nbPoints > 2 ? nbPoints : 3;
        const bez = new Array();
        const equation = (t, val0, val1, val2) => {
          const res = (1 - t) * (1 - t) * val0 + 2 * t * (1 - t) * val1 + t * t * val2;
          return res;
        };
        for (let i = 0; i <= nbPoints; i++) {
          bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x), equation(i / nbPoints, v0.y, v1.y, v2.y), equation(i / nbPoints, v0.z, v1.z, v2.z)));
        }
        return new Curve3(bez);
      }
      static CreateCubicBezier(v0, v1, v2, v3, nbPoints) {
        nbPoints = nbPoints > 3 ? nbPoints : 4;
        const bez = new Array();
        const equation = (t, val0, val1, val2, val3) => {
          const res = (1 - t) * (1 - t) * (1 - t) * val0 + 3 * t * (1 - t) * (1 - t) * val1 + 3 * t * t * (1 - t) * val2 + t * t * t * val3;
          return res;
        };
        for (let i = 0; i <= nbPoints; i++) {
          bez.push(new Vector3(equation(i / nbPoints, v0.x, v1.x, v2.x, v3.x), equation(i / nbPoints, v0.y, v1.y, v2.y, v3.y), equation(i / nbPoints, v0.z, v1.z, v2.z, v3.z)));
        }
        return new Curve3(bez);
      }
      static CreateHermiteSpline(p1, t1, p2, t2, nSeg) {
        const hermite = new Array();
        const step = 1 / nSeg;
        for (let i = 0; i <= nSeg; i++) {
          hermite.push(Vector3.Hermite(p1, t1, p2, t2, i * step));
        }
        return new Curve3(hermite);
      }
      static CreateCatmullRomSpline(points, nbPoints, closed) {
        const catmullRom = new Array();
        const step = 1 / nbPoints;
        let amount = 0;
        if (closed) {
          const pointsCount = points.length;
          for (let i = 0; i < pointsCount; i++) {
            amount = 0;
            for (let c = 0; c < nbPoints; c++) {
              catmullRom.push(Vector3.CatmullRom(points[i % pointsCount], points[(i + 1) % pointsCount], points[(i + 2) % pointsCount], points[(i + 3) % pointsCount], amount));
              amount += step;
            }
          }
          catmullRom.push(catmullRom[0]);
        } else {
          const totalPoints = new Array();
          totalPoints.push(points[0].clone());
          Array.prototype.push.apply(totalPoints, points);
          totalPoints.push(points[points.length - 1].clone());
          let i = 0;
          for (; i < totalPoints.length - 3; i++) {
            amount = 0;
            for (let c = 0; c < nbPoints; c++) {
              catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
              amount += step;
            }
          }
          i--;
          catmullRom.push(Vector3.CatmullRom(totalPoints[i], totalPoints[i + 1], totalPoints[i + 2], totalPoints[i + 3], amount));
        }
        return new Curve3(catmullRom);
      }
      static ArcThru3Points(first, second, third, steps = 32, closed = false, fullCircle = false) {
        const arc = new Array();
        const vec1 = second.subtract(first);
        const vec2 = third.subtract(second);
        const vec3 = first.subtract(third);
        const zAxis = Vector3.Cross(vec1, vec2);
        const len4 = zAxis.length();
        if (len4 < Math.pow(10, -8)) {
          return new Curve3(arc);
        }
        const len1_sq = vec1.lengthSquared();
        const len2_sq = vec2.lengthSquared();
        const len3_sq = vec3.lengthSquared();
        const len4_sq = zAxis.lengthSquared();
        const len1 = vec1.length();
        const len2 = vec2.length();
        const len3 = vec3.length();
        const radius = 0.5 * len1 * len2 * len3 / len4;
        const dot1 = Vector3.Dot(vec1, vec3);
        const dot2 = Vector3.Dot(vec1, vec2);
        const dot3 = Vector3.Dot(vec2, vec3);
        const a = -0.5 * len2_sq * dot1 / len4_sq;
        const b = -0.5 * len3_sq * dot2 / len4_sq;
        const c = -0.5 * len1_sq * dot3 / len4_sq;
        const center = first.scale(a).add(second.scale(b)).add(third.scale(c));
        const radiusVec = first.subtract(center);
        const xAxis = radiusVec.normalize();
        const yAxis = Vector3.Cross(zAxis, xAxis).normalize();
        if (fullCircle) {
          const dStep = 2 * Math.PI / steps;
          for (let theta = 0; theta <= 2 * Math.PI; theta += dStep) {
            arc.push(center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta)))));
          }
          arc.push(first);
        } else {
          const dStep = 1 / steps;
          let theta = 0;
          let point = Vector3.Zero();
          do {
            point = center.add(xAxis.scale(radius * Math.cos(theta)).add(yAxis.scale(radius * Math.sin(theta))));
            arc.push(point);
            theta += dStep;
          } while (!point.equalsWithEpsilon(third, radius * dStep * 1.1));
          arc.push(third);
          if (closed) {
            arc.push(first);
          }
        }
        return new Curve3(arc);
      }
      constructor(points) {
        this._length = 0;
        this._points = points;
        this._length = this._computeLength(points);
      }
      getPoints() {
        return this._points;
      }
      length() {
        return this._length;
      }
      continue(curve) {
        const lastPoint = this._points[this._points.length - 1];
        const continuedPoints = this._points.slice();
        const curvePoints = curve.getPoints();
        for (let i = 1; i < curvePoints.length; i++) {
          continuedPoints.push(curvePoints[i].subtract(curvePoints[0]).add(lastPoint));
        }
        const continuedCurve = new Curve3(continuedPoints);
        return continuedCurve;
      }
      _computeLength(path) {
        let l = 0;
        for (let i = 1; i < path.length; i++) {
          l += path[i].subtract(path[i - 1]).length();
        }
        return l;
      }
    };
  }
});

// node_modules/@babylonjs/core/Animations/animationEvent.js
var AnimationEvent;
var init_animationEvent = __esm({
  "node_modules/@babylonjs/core/Animations/animationEvent.js"() {
    AnimationEvent = class {
      constructor(frame, action, onlyOnce) {
        this.frame = frame;
        this.action = action;
        this.onlyOnce = onlyOnce;
        this.isDone = false;
      }
      _clone() {
        return new AnimationEvent(this.frame, this.action, this.onlyOnce);
      }
    };
  }
});

// node_modules/@babylonjs/core/Animations/animationGroup.js
var TargetedAnimation, AnimationGroup;
var init_animationGroup = __esm({
  "node_modules/@babylonjs/core/Animations/animationGroup.js"() {
    init_animation();
    init_observable();
    init_engineStore();
    init_tags();
    TargetedAnimation = class {
      getClassName() {
        return "TargetedAnimation";
      }
      serialize() {
        const serializationObject = {};
        serializationObject.animation = this.animation.serialize();
        serializationObject.targetId = this.target.id;
        return serializationObject;
      }
    };
    AnimationGroup = class {
      syncWithMask() {
        if (!this.mask) {
          return;
        }
        for (let i = 0; i < this._animatables.length; ++i) {
          const animatable = this._animatables[i];
          if (this.mask.retainsTarget(animatable.target.name)) {
            if (animatable.paused) {
              animatable.restart();
            }
          } else {
            if (!animatable.paused) {
              animatable.pause();
            }
          }
        }
      }
      removeUnmaskedAnimations() {
        if (!this.mask) {
          return;
        }
        for (let i = 0; i < this._animatables.length; ++i) {
          const animatable = this._animatables[i];
          if (!this.mask.retainsTarget(animatable.target.name)) {
            animatable.stop();
            this._animatables.splice(i, 1);
            --i;
          }
        }
        for (let index = 0; index < this._targetedAnimations.length; index++) {
          const targetedAnimation = this._targetedAnimations[index];
          if (!this.mask.retainsTarget(targetedAnimation.target.name)) {
            this._targetedAnimations.splice(index, 1);
            --index;
          }
        }
      }
      get from() {
        return this._from;
      }
      get to() {
        return this._to;
      }
      get isStarted() {
        return this._isStarted;
      }
      get isPlaying() {
        return this._isStarted && !this._isPaused;
      }
      get speedRatio() {
        return this._speedRatio;
      }
      set speedRatio(value) {
        if (this._speedRatio === value) {
          return;
        }
        this._speedRatio = value;
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.speedRatio = this._speedRatio;
        }
      }
      get loopAnimation() {
        return this._loopAnimation;
      }
      set loopAnimation(value) {
        if (this._loopAnimation === value) {
          return;
        }
        this._loopAnimation = value;
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.loopAnimation = this._loopAnimation;
        }
      }
      get isAdditive() {
        return this._isAdditive;
      }
      set isAdditive(value) {
        if (this._isAdditive === value) {
          return;
        }
        this._isAdditive = value;
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.isAdditive = this._isAdditive;
        }
      }
      get weight() {
        return this._weight;
      }
      set weight(value) {
        if (this._weight === value) {
          return;
        }
        this._weight = value;
        this.setWeightForAllAnimatables(this._weight);
      }
      get targetedAnimations() {
        return this._targetedAnimations;
      }
      get animatables() {
        return this._animatables;
      }
      get children() {
        return this._targetedAnimations;
      }
      get playOrder() {
        return this._playOrder;
      }
      set playOrder(value) {
        if (this._playOrder === value) {
          return;
        }
        this._playOrder = value;
        if (this._animatables.length > 0) {
          for (let i = 0; i < this._animatables.length; i++) {
            this._animatables[i].playOrder = this._playOrder;
          }
          this._scene.sortActiveAnimatables();
        }
      }
      get enableBlending() {
        return this._enableBlending;
      }
      set enableBlending(value) {
        if (this._enableBlending === value) {
          return;
        }
        this._enableBlending = value;
        if (value !== null) {
          for (let i = 0; i < this._targetedAnimations.length; ++i) {
            this._targetedAnimations[i].animation.enableBlending = value;
          }
        }
      }
      get blendingSpeed() {
        return this._blendingSpeed;
      }
      set blendingSpeed(value) {
        if (this._blendingSpeed === value) {
          return;
        }
        this._blendingSpeed = value;
        if (value !== null) {
          for (let i = 0; i < this._targetedAnimations.length; ++i) {
            this._targetedAnimations[i].animation.blendingSpeed = value;
          }
        }
      }
      static MergeAnimationGroups(animationGroups, disposeSource = true, normalize = false, weight) {
        if (animationGroups.length === 0) {
          return null;
        }
        weight = weight !== null && weight !== void 0 ? weight : animationGroups[0].weight;
        let beginFrame = Number.MAX_VALUE;
        let endFrame = -Number.MAX_VALUE;
        if (normalize) {
          for (const animationGroup of animationGroups) {
            if (animationGroup.from < beginFrame) {
              beginFrame = animationGroup.from;
            }
            if (animationGroup.to > endFrame) {
              endFrame = animationGroup.to;
            }
          }
        }
        const mergedAnimationGroup = new AnimationGroup(animationGroups[0].name + "_merged", animationGroups[0]._scene, weight);
        for (const animationGroup of animationGroups) {
          if (normalize) {
            animationGroup.normalize(beginFrame, endFrame);
          }
          for (const targetedAnimation of animationGroup.targetedAnimations) {
            mergedAnimationGroup.addTargetedAnimation(targetedAnimation.animation, targetedAnimation.target);
          }
          if (disposeSource) {
            animationGroup.dispose();
          }
        }
        return mergedAnimationGroup;
      }
      constructor(name109, scene = null, weight = -1, playOrder = 0) {
        this.name = name109;
        this._targetedAnimations = new Array();
        this._animatables = new Array();
        this._from = Number.MAX_VALUE;
        this._to = -Number.MAX_VALUE;
        this._speedRatio = 1;
        this._loopAnimation = false;
        this._isAdditive = false;
        this._weight = -1;
        this._playOrder = 0;
        this._enableBlending = null;
        this._blendingSpeed = null;
        this._parentContainer = null;
        this.onAnimationEndObservable = new Observable();
        this.onAnimationLoopObservable = new Observable();
        this.onAnimationGroupLoopObservable = new Observable();
        this.onAnimationGroupEndObservable = new Observable();
        this.onAnimationGroupPauseObservable = new Observable();
        this.onAnimationGroupPlayObservable = new Observable();
        this.metadata = null;
        this._animationLoopFlags = [];
        this._scene = scene || EngineStore.LastCreatedScene;
        this._weight = weight;
        this._playOrder = playOrder;
        this.uniqueId = this._scene.getUniqueId();
        this._scene.addAnimationGroup(this);
      }
      addTargetedAnimation(animation, target) {
        const targetedAnimation = new TargetedAnimation();
        targetedAnimation.animation = animation;
        targetedAnimation.target = target;
        const keys = animation.getKeys();
        if (this._from > keys[0].frame) {
          this._from = keys[0].frame;
        }
        if (this._to < keys[keys.length - 1].frame) {
          this._to = keys[keys.length - 1].frame;
        }
        if (this._enableBlending !== null) {
          animation.enableBlending = this._enableBlending;
        }
        if (this._blendingSpeed !== null) {
          animation.blendingSpeed = this._blendingSpeed;
        }
        this._targetedAnimations.push(targetedAnimation);
        return targetedAnimation;
      }
      removeTargetedAnimation(animation) {
        for (let index = this._targetedAnimations.length - 1; index > -1; index--) {
          const targetedAnimation = this._targetedAnimations[index];
          if (targetedAnimation.animation === animation) {
            this._targetedAnimations.splice(index, 1);
          }
        }
      }
      normalize(beginFrame = null, endFrame = null) {
        if (beginFrame == null) {
          beginFrame = this._from;
        }
        if (endFrame == null) {
          endFrame = this._to;
        }
        for (let index = 0; index < this._targetedAnimations.length; index++) {
          const targetedAnimation = this._targetedAnimations[index];
          const keys = targetedAnimation.animation.getKeys();
          const startKey = keys[0];
          const endKey = keys[keys.length - 1];
          if (startKey.frame > beginFrame) {
            const newKey = {
              frame: beginFrame,
              value: startKey.value,
              inTangent: startKey.inTangent,
              outTangent: startKey.outTangent,
              interpolation: startKey.interpolation
            };
            keys.splice(0, 0, newKey);
          }
          if (endKey.frame < endFrame) {
            const newKey = {
              frame: endFrame,
              value: endKey.value,
              inTangent: endKey.inTangent,
              outTangent: endKey.outTangent,
              interpolation: endKey.interpolation
            };
            keys.push(newKey);
          }
        }
        this._from = beginFrame;
        this._to = endFrame;
        return this;
      }
      _processLoop(animatable, targetedAnimation, index) {
        animatable.onAnimationLoop = () => {
          this.onAnimationLoopObservable.notifyObservers(targetedAnimation);
          if (this._animationLoopFlags[index]) {
            return;
          }
          this._animationLoopFlags[index] = true;
          this._animationLoopCount++;
          if (this._animationLoopCount === this._targetedAnimations.length) {
            this.onAnimationGroupLoopObservable.notifyObservers(this);
            this._animationLoopCount = 0;
            this._animationLoopFlags.length = 0;
          }
        };
      }
      start(loop = false, speedRatio = 1, from, to, isAdditive) {
        if (this._isStarted || this._targetedAnimations.length === 0) {
          return this;
        }
        this._loopAnimation = loop;
        this._animationLoopCount = 0;
        this._animationLoopFlags.length = 0;
        for (let index = 0; index < this._targetedAnimations.length; index++) {
          const targetedAnimation = this._targetedAnimations[index];
          const animatable = this._scene.beginDirectAnimation(targetedAnimation.target, [targetedAnimation.animation], from !== void 0 ? from : this._from, to !== void 0 ? to : this._to, loop, speedRatio, void 0, void 0, isAdditive !== void 0 ? isAdditive : this._isAdditive);
          animatable.weight = this._weight;
          animatable.playOrder = this._playOrder;
          animatable.onAnimationEnd = () => {
            this.onAnimationEndObservable.notifyObservers(targetedAnimation);
            this._checkAnimationGroupEnded(animatable);
          };
          this._processLoop(animatable, targetedAnimation, index);
          this._animatables.push(animatable);
        }
        this.syncWithMask();
        this._scene.sortActiveAnimatables();
        this._speedRatio = speedRatio;
        this._isStarted = true;
        this._isPaused = false;
        this.onAnimationGroupPlayObservable.notifyObservers(this);
        return this;
      }
      pause() {
        if (!this._isStarted) {
          return this;
        }
        this._isPaused = true;
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.pause();
        }
        this.onAnimationGroupPauseObservable.notifyObservers(this);
        return this;
      }
      play(loop) {
        if (this.isStarted && this._animatables.length === this._targetedAnimations.length) {
          if (loop !== void 0) {
            this.loopAnimation = loop;
          }
          this.restart();
        } else {
          this.stop();
          this.start(loop, this._speedRatio);
        }
        this._isPaused = false;
        return this;
      }
      reset() {
        if (!this._isStarted) {
          this.play();
          this.goToFrame(0);
          this.stop();
          return this;
        }
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.reset();
        }
        return this;
      }
      restart() {
        if (!this._isStarted) {
          return this;
        }
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.restart();
        }
        this.onAnimationGroupPlayObservable.notifyObservers(this);
        return this;
      }
      stop() {
        if (!this._isStarted) {
          return this;
        }
        const list = this._animatables.slice();
        for (let index = 0; index < list.length; index++) {
          list[index].stop(void 0, void 0, true);
        }
        let curIndex = 0;
        for (let index = 0; index < this._scene._activeAnimatables.length; index++) {
          const animatable = this._scene._activeAnimatables[index];
          if (animatable._runtimeAnimations.length > 0) {
            this._scene._activeAnimatables[curIndex++] = animatable;
          }
        }
        this._scene._activeAnimatables.length = curIndex;
        this._isStarted = false;
        return this;
      }
      setWeightForAllAnimatables(weight) {
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.weight = weight;
        }
        return this;
      }
      syncAllAnimationsWith(root) {
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.syncWith(root);
        }
        return this;
      }
      goToFrame(frame) {
        if (!this._isStarted) {
          return this;
        }
        for (let index = 0; index < this._animatables.length; index++) {
          const animatable = this._animatables[index];
          animatable.goToFrame(frame);
        }
        return this;
      }
      dispose() {
        this._targetedAnimations.length = 0;
        this._animatables.length = 0;
        const index = this._scene.animationGroups.indexOf(this);
        if (index > -1) {
          this._scene.animationGroups.splice(index, 1);
        }
        if (this._parentContainer) {
          const index2 = this._parentContainer.animationGroups.indexOf(this);
          if (index2 > -1) {
            this._parentContainer.animationGroups.splice(index2, 1);
          }
          this._parentContainer = null;
        }
        this.onAnimationEndObservable.clear();
        this.onAnimationGroupEndObservable.clear();
        this.onAnimationGroupPauseObservable.clear();
        this.onAnimationGroupPlayObservable.clear();
        this.onAnimationLoopObservable.clear();
        this.onAnimationGroupLoopObservable.clear();
      }
      _checkAnimationGroupEnded(animatable) {
        const idx = this._animatables.indexOf(animatable);
        if (idx > -1) {
          this._animatables.splice(idx, 1);
        }
        if (this._animatables.length === 0) {
          this._isStarted = false;
          this.onAnimationGroupEndObservable.notifyObservers(this);
        }
      }
      clone(newName, targetConverter, cloneAnimations = false) {
        const newGroup = new AnimationGroup(newName || this.name, this._scene, this._weight, this._playOrder);
        newGroup._from = this.from;
        newGroup._to = this.to;
        newGroup._speedRatio = this.speedRatio;
        newGroup._loopAnimation = this.loopAnimation;
        newGroup._isAdditive = this.isAdditive;
        newGroup._enableBlending = this.enableBlending;
        newGroup._blendingSpeed = this.blendingSpeed;
        newGroup.metadata = this.metadata;
        newGroup.mask = this.mask;
        for (const targetAnimation of this._targetedAnimations) {
          newGroup.addTargetedAnimation(cloneAnimations ? targetAnimation.animation.clone() : targetAnimation.animation, targetConverter ? targetConverter(targetAnimation.target) : targetAnimation.target);
        }
        return newGroup;
      }
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.from = this.from;
        serializationObject.to = this.to;
        serializationObject.speedRatio = this.speedRatio;
        serializationObject.loopAnimation = this.loopAnimation;
        serializationObject.isAdditive = this.isAdditive;
        serializationObject.weight = this.weight;
        serializationObject.playOrder = this.playOrder;
        serializationObject.enableBlending = this.enableBlending;
        serializationObject.blendingSpeed = this.blendingSpeed;
        serializationObject.targetedAnimations = [];
        for (let targetedAnimationIndex = 0; targetedAnimationIndex < this.targetedAnimations.length; targetedAnimationIndex++) {
          const targetedAnimation = this.targetedAnimations[targetedAnimationIndex];
          serializationObject.targetedAnimations[targetedAnimationIndex] = targetedAnimation.serialize();
        }
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        return serializationObject;
      }
      static Parse(parsedAnimationGroup, scene) {
        const animationGroup = new AnimationGroup(parsedAnimationGroup.name, scene, parsedAnimationGroup.weight, parsedAnimationGroup.playOrder);
        for (let i = 0; i < parsedAnimationGroup.targetedAnimations.length; i++) {
          const targetedAnimation = parsedAnimationGroup.targetedAnimations[i];
          const animation = Animation.Parse(targetedAnimation.animation);
          const id = targetedAnimation.targetId;
          if (targetedAnimation.animation.property === "influence") {
            const morphTarget = scene.getMorphTargetById(id);
            if (morphTarget) {
              animationGroup.addTargetedAnimation(animation, morphTarget);
            }
          } else {
            const targetNode = scene.getNodeById(id);
            if (targetNode != null) {
              animationGroup.addTargetedAnimation(animation, targetNode);
            }
          }
        }
        if (Tags) {
          Tags.AddTagsTo(animationGroup, parsedAnimationGroup.tags);
        }
        if (parsedAnimationGroup.from !== null && parsedAnimationGroup.to !== null) {
          animationGroup.normalize(parsedAnimationGroup.from, parsedAnimationGroup.to);
        }
        if (parsedAnimationGroup.speedRatio !== void 0) {
          animationGroup._speedRatio = parsedAnimationGroup.speedRatio;
        }
        if (parsedAnimationGroup.loopAnimation !== void 0) {
          animationGroup._loopAnimation = parsedAnimationGroup.loopAnimation;
        }
        if (parsedAnimationGroup.isAdditive !== void 0) {
          animationGroup._isAdditive = parsedAnimationGroup.isAdditive;
        }
        if (parsedAnimationGroup.weight !== void 0) {
          animationGroup._weight = parsedAnimationGroup.weight;
        }
        if (parsedAnimationGroup.playOrder !== void 0) {
          animationGroup._playOrder = parsedAnimationGroup.playOrder;
        }
        if (parsedAnimationGroup.enableBlending !== void 0) {
          animationGroup._enableBlending = parsedAnimationGroup.enableBlending;
        }
        if (parsedAnimationGroup.blendingSpeed !== void 0) {
          animationGroup._blendingSpeed = parsedAnimationGroup.blendingSpeed;
        }
        if (parsedAnimationGroup.metadata !== void 0) {
          animationGroup.metadata = parsedAnimationGroup.metadata;
        }
        return animationGroup;
      }
      static MakeAnimationAdditive(sourceAnimationGroup, referenceFrameOrOptions, range, cloneOriginal = false, clonedName) {
        let options;
        if (typeof referenceFrameOrOptions === "object") {
          options = referenceFrameOrOptions;
        } else {
          options = {
            referenceFrame: referenceFrameOrOptions,
            range,
            cloneOriginalAnimationGroup: cloneOriginal,
            clonedAnimationName: clonedName
          };
        }
        let animationGroup = sourceAnimationGroup;
        if (options.cloneOriginalAnimationGroup) {
          animationGroup = sourceAnimationGroup.clone(options.clonedAnimationGroupName || animationGroup.name);
        }
        const targetedAnimations = animationGroup.targetedAnimations;
        for (let index = 0; index < targetedAnimations.length; index++) {
          const targetedAnimation = targetedAnimations[index];
          targetedAnimation.animation = Animation.MakeAnimationAdditive(targetedAnimation.animation, options);
        }
        animationGroup.isAdditive = true;
        if (options.clipKeys) {
          let from = Number.MAX_VALUE;
          let to = -Number.MAX_VALUE;
          const targetedAnimations2 = animationGroup.targetedAnimations;
          for (let index = 0; index < targetedAnimations2.length; index++) {
            const targetedAnimation = targetedAnimations2[index];
            const animation = targetedAnimation.animation;
            const keys = animation.getKeys();
            if (from > keys[0].frame) {
              from = keys[0].frame;
            }
            if (to < keys[keys.length - 1].frame) {
              to = keys[keys.length - 1].frame;
            }
          }
          animationGroup._from = from;
          animationGroup._to = to;
        }
        return animationGroup;
      }
      static ClipKeys(sourceAnimationGroup, fromKey, toKey, name109, dontCloneAnimations) {
        const animationGroup = sourceAnimationGroup.clone(name109 || sourceAnimationGroup.name);
        return AnimationGroup.ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations);
      }
      static ClipKeysInPlace(animationGroup, fromKey, toKey, dontCloneAnimations) {
        return AnimationGroup.ClipInPlace(animationGroup, fromKey, toKey, dontCloneAnimations, false);
      }
      static ClipFrames(sourceAnimationGroup, fromFrame, toFrame, name109, dontCloneAnimations) {
        const animationGroup = sourceAnimationGroup.clone(name109 || sourceAnimationGroup.name);
        return AnimationGroup.ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations);
      }
      static ClipFramesInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations) {
        return AnimationGroup.ClipInPlace(animationGroup, fromFrame, toFrame, dontCloneAnimations, true);
      }
      static ClipInPlace(animationGroup, start, end, dontCloneAnimations, useFrame = false) {
        let from = Number.MAX_VALUE;
        let to = -Number.MAX_VALUE;
        const targetedAnimations = animationGroup.targetedAnimations;
        for (let index = 0; index < targetedAnimations.length; index++) {
          const targetedAnimation = targetedAnimations[index];
          const animation = dontCloneAnimations ? targetedAnimation.animation : targetedAnimation.animation.clone();
          if (useFrame) {
            animation.createKeyForFrame(start);
            animation.createKeyForFrame(end);
          }
          const keys = animation.getKeys();
          const newKeys = [];
          let startFrame = Number.MAX_VALUE;
          for (let k = 0; k < keys.length; k++) {
            const key = keys[k];
            if (!useFrame && k >= start && k <= end || useFrame && key.frame >= start && key.frame <= end) {
              const newKey = {
                frame: key.frame,
                value: key.value.clone ? key.value.clone() : key.value,
                inTangent: key.inTangent,
                outTangent: key.outTangent,
                interpolation: key.interpolation,
                lockedTangent: key.lockedTangent
              };
              if (startFrame === Number.MAX_VALUE) {
                startFrame = newKey.frame;
              }
              newKey.frame -= startFrame;
              newKeys.push(newKey);
            }
          }
          if (newKeys.length === 0) {
            targetedAnimations.splice(index, 1);
            index--;
            continue;
          }
          if (from > newKeys[0].frame) {
            from = newKeys[0].frame;
          }
          if (to < newKeys[newKeys.length - 1].frame) {
            to = newKeys[newKeys.length - 1].frame;
          }
          animation.setKeys(newKeys, true);
          targetedAnimation.animation = animation;
        }
        animationGroup._from = from;
        animationGroup._to = to;
        return animationGroup;
      }
      getClassName() {
        return "AnimationGroup";
      }
      toString(fullDetails) {
        let ret = "Name: " + this.name;
        ret += ", type: " + this.getClassName();
        if (fullDetails) {
          ret += ", from: " + this._from;
          ret += ", to: " + this._to;
          ret += ", isStarted: " + this._isStarted;
          ret += ", speedRatio: " + this._speedRatio;
          ret += ", targetedAnimations length: " + this._targetedAnimations.length;
          ret += ", animatables length: " + this._animatables;
        }
        return ret;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/coroutine.js
function inlineScheduler(coroutine, onStep, onError) {
  try {
    const step = coroutine.next();
    if (step.done) {
      onStep(step);
    } else if (!step.value) {
      onStep(step);
    } else {
      step.value.then(() => {
        step.value = void 0;
        onStep(step);
      }, onError);
    }
  } catch (error) {
    onError(error);
  }
}
function createYieldingScheduler(yieldAfterMS = 25) {
  let startTime;
  return (coroutine, onStep, onError) => {
    const currentTime = performance.now();
    if (startTime === void 0 || currentTime - startTime > yieldAfterMS) {
      startTime = currentTime;
      setTimeout(() => {
        inlineScheduler(coroutine, onStep, onError);
      }, 0);
    } else {
      inlineScheduler(coroutine, onStep, onError);
    }
  };
}
function runCoroutine(coroutine, scheduler, onSuccess, onError, abortSignal) {
  const resume = () => {
    let reschedule;
    const onStep = (stepResult) => {
      if (stepResult.done) {
        onSuccess(stepResult.value);
      } else {
        if (reschedule === void 0) {
          reschedule = true;
        } else {
          resume();
        }
      }
    };
    do {
      reschedule = void 0;
      if (!abortSignal || !abortSignal.aborted) {
        scheduler(coroutine, onStep, onError);
      } else {
        onError(new Error("Aborted"));
      }
      if (reschedule === void 0) {
        reschedule = false;
      }
    } while (reschedule);
  };
  resume();
}
function runCoroutineSync(coroutine, abortSignal) {
  let result;
  runCoroutine(coroutine, inlineScheduler, (r) => result = r, (e) => {
    throw e;
  }, abortSignal);
  return result;
}
function runCoroutineAsync(coroutine, scheduler, abortSignal) {
  return new Promise((resolve, reject) => {
    runCoroutine(coroutine, scheduler, resolve, reject, abortSignal);
  });
}
function makeSyncFunction(coroutineFactory, abortSignal) {
  return (...params) => {
    return runCoroutineSync(coroutineFactory(...params), abortSignal);
  };
}
function makeAsyncFunction(coroutineFactory, scheduler, abortSignal) {
  return (...params) => {
    return runCoroutineAsync(coroutineFactory(...params), scheduler, abortSignal);
  };
}
var init_coroutine = __esm({
  "node_modules/@babylonjs/core/Misc/coroutine.js"() {
  }
});

// node_modules/@babylonjs/core/Maths/math.viewport.js
var Viewport;
var init_math_viewport = __esm({
  "node_modules/@babylonjs/core/Maths/math.viewport.js"() {
    Viewport = class {
      constructor(x, y, width, height) {
        this.x = x;
        this.y = y;
        this.width = width;
        this.height = height;
      }
      toGlobal(renderWidth, renderHeight) {
        return new Viewport(this.x * renderWidth, this.y * renderHeight, this.width * renderWidth, this.height * renderHeight);
      }
      toGlobalToRef(renderWidth, renderHeight, ref) {
        ref.x = this.x * renderWidth;
        ref.y = this.y * renderHeight;
        ref.width = this.width * renderWidth;
        ref.height = this.height * renderHeight;
        return this;
      }
      clone() {
        return new Viewport(this.x, this.y, this.width, this.height);
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/camera.js
var Camera;
var init_camera = __esm({
  "node_modules/@babylonjs/core/Cameras/camera.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_tools();
    init_observable();
    init_math_vector();
    init_node();
    init_logger();
    init_typeStore();
    init_devTools();
    init_math_viewport();
    init_math_frustum();
    Camera = class extends Node {
      get position() {
        return this._position;
      }
      set position(newPosition) {
        this._position = newPosition;
      }
      set upVector(vec) {
        this._upVector = vec;
      }
      get upVector() {
        return this._upVector;
      }
      get screenArea() {
        var _a, _b, _c, _d;
        let x = 0;
        let y = 0;
        if (this.mode === Camera.PERSPECTIVE_CAMERA) {
          if (this.fovMode === Camera.FOVMODE_VERTICAL_FIXED) {
            y = this.minZ * 2 * Math.tan(this.fov / 2);
            x = this.getEngine().getAspectRatio(this) * y;
          } else {
            x = this.minZ * 2 * Math.tan(this.fov / 2);
            y = x / this.getEngine().getAspectRatio(this);
          }
        } else {
          const halfWidth = this.getEngine().getRenderWidth() / 2;
          const halfHeight = this.getEngine().getRenderHeight() / 2;
          x = ((_a = this.orthoRight) !== null && _a !== void 0 ? _a : halfWidth) - ((_b = this.orthoLeft) !== null && _b !== void 0 ? _b : -halfWidth);
          y = ((_c = this.orthoTop) !== null && _c !== void 0 ? _c : halfHeight) - ((_d = this.orthoBottom) !== null && _d !== void 0 ? _d : -halfHeight);
        }
        return x * y;
      }
      set orthoLeft(value) {
        this._orthoLeft = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoLeft = value;
        }
      }
      get orthoLeft() {
        return this._orthoLeft;
      }
      set orthoRight(value) {
        this._orthoRight = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoRight = value;
        }
      }
      get orthoRight() {
        return this._orthoRight;
      }
      set orthoBottom(value) {
        this._orthoBottom = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoBottom = value;
        }
      }
      get orthoBottom() {
        return this._orthoBottom;
      }
      set orthoTop(value) {
        this._orthoTop = value;
        for (const rigCamera of this._rigCameras) {
          rigCamera.orthoTop = value;
        }
      }
      get orthoTop() {
        return this._orthoTop;
      }
      set mode(mode) {
        this._mode = mode;
        for (const rigCamera of this._rigCameras) {
          rigCamera.mode = mode;
        }
      }
      get mode() {
        return this._mode;
      }
      constructor(name109, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name109, scene);
        this._position = Vector3.Zero();
        this._upVector = Vector3.Up();
        this._orthoLeft = null;
        this._orthoRight = null;
        this._orthoBottom = null;
        this._orthoTop = null;
        this.fov = 0.8;
        this.projectionPlaneTilt = 0;
        this.minZ = 1;
        this.maxZ = 1e4;
        this.inertia = 0.9;
        this._mode = Camera.PERSPECTIVE_CAMERA;
        this.isIntermediate = false;
        this.viewport = new Viewport(0, 0, 1, 1);
        this.layerMask = 268435455;
        this.fovMode = Camera.FOVMODE_VERTICAL_FIXED;
        this.cameraRigMode = Camera.RIG_MODE_NONE;
        this.customRenderTargets = new Array();
        this.outputRenderTarget = null;
        this.onViewMatrixChangedObservable = new Observable();
        this.onProjectionMatrixChangedObservable = new Observable();
        this.onAfterCheckInputsObservable = new Observable();
        this.onRestoreStateObservable = new Observable();
        this.isRigCamera = false;
        this._rigCameras = new Array();
        this._webvrViewMatrix = Matrix.Identity();
        this._skipRendering = false;
        this._projectionMatrix = new Matrix();
        this._postProcesses = new Array();
        this._activeMeshes = new SmartArray(256);
        this._globalPosition = Vector3.Zero();
        this._computedViewMatrix = Matrix.Identity();
        this._doNotComputeProjectionMatrix = false;
        this._transformMatrix = Matrix.Zero();
        this._refreshFrustumPlanes = true;
        this._absoluteRotation = Quaternion.Identity();
        this._isCamera = true;
        this._isLeftCamera = false;
        this._isRightCamera = false;
        this.getScene().addCamera(this);
        if (setActiveOnSceneIfNoneActive && !this.getScene().activeCamera) {
          this.getScene().activeCamera = this;
        }
        this.position = position;
        this.renderPassId = this.getScene().getEngine().createRenderPassId(`Camera ${name109}`);
      }
      storeState() {
        this._stateStored = true;
        this._storedFov = this.fov;
        return this;
      }
      _restoreStateValues() {
        if (!this._stateStored) {
          return false;
        }
        this.fov = this._storedFov;
        return true;
      }
      restoreState() {
        if (this._restoreStateValues()) {
          this.onRestoreStateObservable.notifyObservers(this);
          return true;
        }
        return false;
      }
      getClassName() {
        return "Camera";
      }
      toString(fullDetails) {
        let ret = "Name: " + this.name;
        ret += ", type: " + this.getClassName();
        if (this.animations) {
          for (let i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        return ret;
      }
      applyVerticalCorrection() {
        const rot = this.absoluteRotation.toEulerAngles();
        this.projectionPlaneTilt = this._scene.useRightHandedSystem ? -rot.x : rot.x;
      }
      get globalPosition() {
        return this._globalPosition;
      }
      getActiveMeshes() {
        return this._activeMeshes;
      }
      isActiveMesh(mesh) {
        return this._activeMeshes.indexOf(mesh) !== -1;
      }
      isReady(completeCheck = false) {
        if (completeCheck) {
          for (const pp of this._postProcesses) {
            if (pp && !pp.isReady()) {
              return false;
            }
          }
        }
        return super.isReady(completeCheck);
      }
      _initCache() {
        super._initCache();
        this._cache.position = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.upVector = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.mode = void 0;
        this._cache.minZ = void 0;
        this._cache.maxZ = void 0;
        this._cache.fov = void 0;
        this._cache.fovMode = void 0;
        this._cache.aspectRatio = void 0;
        this._cache.orthoLeft = void 0;
        this._cache.orthoRight = void 0;
        this._cache.orthoBottom = void 0;
        this._cache.orthoTop = void 0;
        this._cache.renderWidth = void 0;
        this._cache.renderHeight = void 0;
      }
      _updateCache(ignoreParentClass) {
        if (!ignoreParentClass) {
          super._updateCache();
        }
        this._cache.position.copyFrom(this.position);
        this._cache.upVector.copyFrom(this.upVector);
      }
      _isSynchronized() {
        return this._isSynchronizedViewMatrix() && this._isSynchronizedProjectionMatrix();
      }
      _isSynchronizedViewMatrix() {
        if (!super._isSynchronized()) {
          return false;
        }
        return this._cache.position.equals(this.position) && this._cache.upVector.equals(this.upVector) && this.isSynchronizedWithParent();
      }
      _isSynchronizedProjectionMatrix() {
        let check = this._cache.mode === this.mode && this._cache.minZ === this.minZ && this._cache.maxZ === this.maxZ;
        if (!check) {
          return false;
        }
        const engine = this.getEngine();
        if (this.mode === Camera.PERSPECTIVE_CAMERA) {
          check = this._cache.fov === this.fov && this._cache.fovMode === this.fovMode && this._cache.aspectRatio === engine.getAspectRatio(this) && this._cache.projectionPlaneTilt === this.projectionPlaneTilt;
        } else {
          check = this._cache.orthoLeft === this.orthoLeft && this._cache.orthoRight === this.orthoRight && this._cache.orthoBottom === this.orthoBottom && this._cache.orthoTop === this.orthoTop && this._cache.renderWidth === engine.getRenderWidth() && this._cache.renderHeight === engine.getRenderHeight();
        }
        return check;
      }
      attachControl(_ignored, _noPreventDefault) {
      }
      detachControl(_ignored) {
      }
      update() {
        this._checkInputs();
        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
          this._updateRigCameras();
        }
        this.getViewMatrix();
        this.getProjectionMatrix();
      }
      _checkInputs() {
        this.onAfterCheckInputsObservable.notifyObservers(this);
      }
      get rigCameras() {
        return this._rigCameras;
      }
      get rigPostProcess() {
        return this._rigPostProcess;
      }
      _getFirstPostProcess() {
        for (let ppIndex = 0; ppIndex < this._postProcesses.length; ppIndex++) {
          if (this._postProcesses[ppIndex] !== null) {
            return this._postProcesses[ppIndex];
          }
        }
        return null;
      }
      _cascadePostProcessesToRigCams() {
        const firstPostProcess = this._getFirstPostProcess();
        if (firstPostProcess) {
          firstPostProcess.markTextureDirty();
        }
        for (let i = 0, len = this._rigCameras.length; i < len; i++) {
          const cam = this._rigCameras[i];
          const rigPostProcess = cam._rigPostProcess;
          if (rigPostProcess) {
            const isPass = rigPostProcess.getEffectName() === "pass";
            if (isPass) {
              cam.isIntermediate = this._postProcesses.length === 0;
            }
            cam._postProcesses = this._postProcesses.slice(0).concat(rigPostProcess);
            rigPostProcess.markTextureDirty();
          } else {
            cam._postProcesses = this._postProcesses.slice(0);
          }
        }
      }
      attachPostProcess(postProcess, insertAt = null) {
        if (!postProcess.isReusable() && this._postProcesses.indexOf(postProcess) > -1) {
          Logger.Error("You're trying to reuse a post process not defined as reusable.");
          return 0;
        }
        if (insertAt == null || insertAt < 0) {
          this._postProcesses.push(postProcess);
        } else if (this._postProcesses[insertAt] === null) {
          this._postProcesses[insertAt] = postProcess;
        } else {
          this._postProcesses.splice(insertAt, 0, postProcess);
        }
        this._cascadePostProcessesToRigCams();
        if (this._scene.prePassRenderer) {
          this._scene.prePassRenderer.markAsDirty();
        }
        return this._postProcesses.indexOf(postProcess);
      }
      detachPostProcess(postProcess) {
        const idx = this._postProcesses.indexOf(postProcess);
        if (idx !== -1) {
          this._postProcesses[idx] = null;
        }
        if (this._scene.prePassRenderer) {
          this._scene.prePassRenderer.markAsDirty();
        }
        this._cascadePostProcessesToRigCams();
      }
      getWorldMatrix() {
        if (this._isSynchronizedViewMatrix()) {
          return this._worldMatrix;
        }
        this.getViewMatrix();
        return this._worldMatrix;
      }
      _getViewMatrix() {
        return Matrix.Identity();
      }
      getViewMatrix(force) {
        if (!force && this._isSynchronizedViewMatrix()) {
          return this._computedViewMatrix;
        }
        this.updateCache();
        this._computedViewMatrix = this._getViewMatrix();
        this._currentRenderId = this.getScene().getRenderId();
        this._childUpdateId++;
        this._refreshFrustumPlanes = true;
        if (this._cameraRigParams && this._cameraRigParams.vrPreViewMatrix) {
          this._computedViewMatrix.multiplyToRef(this._cameraRigParams.vrPreViewMatrix, this._computedViewMatrix);
        }
        if (this.parent && this.parent.onViewMatrixChangedObservable) {
          this.parent.onViewMatrixChangedObservable.notifyObservers(this.parent);
        }
        this.onViewMatrixChangedObservable.notifyObservers(this);
        this._computedViewMatrix.invertToRef(this._worldMatrix);
        return this._computedViewMatrix;
      }
      freezeProjectionMatrix(projection) {
        this._doNotComputeProjectionMatrix = true;
        if (projection !== void 0) {
          this._projectionMatrix = projection;
        }
      }
      unfreezeProjectionMatrix() {
        this._doNotComputeProjectionMatrix = false;
      }
      getProjectionMatrix(force) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (this._doNotComputeProjectionMatrix || !force && this._isSynchronizedProjectionMatrix()) {
          return this._projectionMatrix;
        }
        this._cache.mode = this.mode;
        this._cache.minZ = this.minZ;
        this._cache.maxZ = this.maxZ;
        this._refreshFrustumPlanes = true;
        const engine = this.getEngine();
        const scene = this.getScene();
        const reverseDepth = engine.useReverseDepthBuffer;
        if (this.mode === Camera.PERSPECTIVE_CAMERA) {
          this._cache.fov = this.fov;
          this._cache.fovMode = this.fovMode;
          this._cache.aspectRatio = engine.getAspectRatio(this);
          this._cache.projectionPlaneTilt = this.projectionPlaneTilt;
          if (this.minZ <= 0) {
            this.minZ = 0.1;
          }
          let getProjectionMatrix;
          if (scene.useRightHandedSystem) {
            getProjectionMatrix = Matrix.PerspectiveFovRHToRef;
          } else {
            getProjectionMatrix = Matrix.PerspectiveFovLHToRef;
          }
          getProjectionMatrix(this.fov, engine.getAspectRatio(this), reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, this.fovMode === Camera.FOVMODE_VERTICAL_FIXED, engine.isNDCHalfZRange, this.projectionPlaneTilt, reverseDepth);
        } else {
          const halfWidth = engine.getRenderWidth() / 2;
          const halfHeight = engine.getRenderHeight() / 2;
          if (scene.useRightHandedSystem) {
            Matrix.OrthoOffCenterRHToRef((_a = this.orthoLeft) !== null && _a !== void 0 ? _a : -halfWidth, (_b = this.orthoRight) !== null && _b !== void 0 ? _b : halfWidth, (_c = this.orthoBottom) !== null && _c !== void 0 ? _c : -halfHeight, (_d = this.orthoTop) !== null && _d !== void 0 ? _d : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
          } else {
            Matrix.OrthoOffCenterLHToRef((_e = this.orthoLeft) !== null && _e !== void 0 ? _e : -halfWidth, (_f = this.orthoRight) !== null && _f !== void 0 ? _f : halfWidth, (_g = this.orthoBottom) !== null && _g !== void 0 ? _g : -halfHeight, (_h = this.orthoTop) !== null && _h !== void 0 ? _h : halfHeight, reverseDepth ? this.maxZ : this.minZ, reverseDepth ? this.minZ : this.maxZ, this._projectionMatrix, engine.isNDCHalfZRange);
          }
          this._cache.orthoLeft = this.orthoLeft;
          this._cache.orthoRight = this.orthoRight;
          this._cache.orthoBottom = this.orthoBottom;
          this._cache.orthoTop = this.orthoTop;
          this._cache.renderWidth = engine.getRenderWidth();
          this._cache.renderHeight = engine.getRenderHeight();
        }
        this.onProjectionMatrixChangedObservable.notifyObservers(this);
        return this._projectionMatrix;
      }
      getTransformationMatrix() {
        this._computedViewMatrix.multiplyToRef(this._projectionMatrix, this._transformMatrix);
        return this._transformMatrix;
      }
      _updateFrustumPlanes() {
        if (!this._refreshFrustumPlanes) {
          return;
        }
        this.getTransformationMatrix();
        if (!this._frustumPlanes) {
          this._frustumPlanes = Frustum.GetPlanes(this._transformMatrix);
        } else {
          Frustum.GetPlanesToRef(this._transformMatrix, this._frustumPlanes);
        }
        this._refreshFrustumPlanes = false;
      }
      isInFrustum(target, checkRigCameras = false) {
        this._updateFrustumPlanes();
        if (checkRigCameras && this.rigCameras.length > 0) {
          let result = false;
          this.rigCameras.forEach((cam) => {
            cam._updateFrustumPlanes();
            result = result || target.isInFrustum(cam._frustumPlanes);
          });
          return result;
        } else {
          return target.isInFrustum(this._frustumPlanes);
        }
      }
      isCompletelyInFrustum(target) {
        this._updateFrustumPlanes();
        return target.isCompletelyInFrustum(this._frustumPlanes);
      }
      getForwardRay(length = 100, transform, origin) {
        throw _WarnImport("Ray");
      }
      getForwardRayToRef(refRay, length = 100, transform, origin) {
        throw _WarnImport("Ray");
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this.onViewMatrixChangedObservable.clear();
        this.onProjectionMatrixChangedObservable.clear();
        this.onAfterCheckInputsObservable.clear();
        this.onRestoreStateObservable.clear();
        if (this.inputs) {
          this.inputs.clear();
        }
        this.getScene().stopAnimation(this);
        this.getScene().removeCamera(this);
        while (this._rigCameras.length > 0) {
          const camera = this._rigCameras.pop();
          if (camera) {
            camera.dispose();
          }
        }
        if (this._parentContainer) {
          const index = this._parentContainer.cameras.indexOf(this);
          if (index > -1) {
            this._parentContainer.cameras.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._rigPostProcess) {
          this._rigPostProcess.dispose(this);
          this._rigPostProcess = null;
          this._postProcesses.length = 0;
        } else if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
          this._rigPostProcess = null;
          this._postProcesses.length = 0;
        } else {
          let i2 = this._postProcesses.length;
          while (--i2 >= 0) {
            const postProcess = this._postProcesses[i2];
            if (postProcess) {
              postProcess.dispose(this);
            }
          }
        }
        let i = this.customRenderTargets.length;
        while (--i >= 0) {
          this.customRenderTargets[i].dispose();
        }
        this.customRenderTargets.length = 0;
        this._activeMeshes.dispose();
        this.getScene().getEngine().releaseRenderPassId(this.renderPassId);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      get isLeftCamera() {
        return this._isLeftCamera;
      }
      get isRightCamera() {
        return this._isRightCamera;
      }
      get leftCamera() {
        if (this._rigCameras.length < 1) {
          return null;
        }
        return this._rigCameras[0];
      }
      get rightCamera() {
        if (this._rigCameras.length < 2) {
          return null;
        }
        return this._rigCameras[1];
      }
      getLeftTarget() {
        if (this._rigCameras.length < 1) {
          return null;
        }
        return this._rigCameras[0].getTarget();
      }
      getRightTarget() {
        if (this._rigCameras.length < 2) {
          return null;
        }
        return this._rigCameras[1].getTarget();
      }
      setCameraRigMode(mode, rigParams) {
        if (this.cameraRigMode === mode) {
          return;
        }
        while (this._rigCameras.length > 0) {
          const camera = this._rigCameras.pop();
          if (camera) {
            camera.dispose();
          }
        }
        this.cameraRigMode = mode;
        this._cameraRigParams = {};
        this._cameraRigParams.interaxialDistance = rigParams.interaxialDistance || 0.0637;
        this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(this._cameraRigParams.interaxialDistance / 0.0637);
        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
          const leftCamera = this.createRigCamera(this.name + "_L", 0);
          if (leftCamera) {
            leftCamera._isLeftCamera = true;
          }
          const rightCamera = this.createRigCamera(this.name + "_R", 1);
          if (rightCamera) {
            rightCamera._isRightCamera = true;
          }
          if (leftCamera && rightCamera) {
            this._rigCameras.push(leftCamera);
            this._rigCameras.push(rightCamera);
          }
        }
        this._setRigMode(rigParams);
        this._cascadePostProcessesToRigCams();
        this.update();
      }
      _setRigMode(rigParams) {
      }
      _getVRProjectionMatrix() {
        Matrix.PerspectiveFovLHToRef(this._cameraRigParams.vrMetrics.aspectRatioFov, this._cameraRigParams.vrMetrics.aspectRatio, this.minZ, this.maxZ, this._cameraRigParams.vrWorkMatrix, true, this.getEngine().isNDCHalfZRange);
        this._cameraRigParams.vrWorkMatrix.multiplyToRef(this._cameraRigParams.vrHMatrix, this._projectionMatrix);
        return this._projectionMatrix;
      }
      _updateCameraRotationMatrix() {
      }
      _updateWebVRCameraRotationMatrix() {
      }
      _getWebVRProjectionMatrix() {
        return Matrix.Identity();
      }
      _getWebVRViewMatrix() {
        return Matrix.Identity();
      }
      setCameraRigParameter(name109, value) {
        if (!this._cameraRigParams) {
          this._cameraRigParams = {};
        }
        this._cameraRigParams[name109] = value;
        if (name109 === "interaxialDistance") {
          this._cameraRigParams.stereoHalfAngle = Tools.ToRadians(value / 0.0637);
        }
      }
      createRigCamera(name109, cameraIndex) {
        return null;
      }
      _updateRigCameras() {
        for (let i = 0; i < this._rigCameras.length; i++) {
          this._rigCameras[i].minZ = this.minZ;
          this._rigCameras[i].maxZ = this.maxZ;
          this._rigCameras[i].fov = this.fov;
          this._rigCameras[i].upVector.copyFrom(this.upVector);
        }
        if (this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH) {
          this._rigCameras[0].viewport = this._rigCameras[1].viewport = this.viewport;
        }
      }
      _setupInputs() {
      }
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getClassName();
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        if (this.inputs) {
          this.inputs.serialize(serializationObject);
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      }
      clone(name109, newParent = null) {
        const camera = SerializationHelper.Clone(Camera.GetConstructorFromName(this.getClassName(), name109, this.getScene(), this.interaxialDistance, this.isStereoscopicSideBySide), this);
        camera.name = name109;
        camera.parent = newParent;
        this.onClonedObservable.notifyObservers(camera);
        return camera;
      }
      getDirection(localAxis) {
        const result = Vector3.Zero();
        this.getDirectionToRef(localAxis, result);
        return result;
      }
      get absoluteRotation() {
        this.getWorldMatrix().decompose(void 0, this._absoluteRotation);
        return this._absoluteRotation;
      }
      getDirectionToRef(localAxis, result) {
        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
      }
      static GetConstructorFromName(type, name109, scene, interaxial_distance = 0, isStereoscopicSideBySide = true) {
        const constructorFunc = Node.Construct(type, name109, scene, {
          interaxial_distance,
          isStereoscopicSideBySide
        });
        if (constructorFunc) {
          return constructorFunc;
        }
        return () => Camera._CreateDefaultParsedCamera(name109, scene);
      }
      computeWorldMatrix() {
        return this.getWorldMatrix();
      }
      static Parse(parsedCamera, scene) {
        const type = parsedCamera.type;
        const construct = Camera.GetConstructorFromName(type, parsedCamera.name, scene, parsedCamera.interaxial_distance, parsedCamera.isStereoscopicSideBySide);
        const camera = SerializationHelper.Parse(construct, parsedCamera, scene);
        if (parsedCamera.parentId !== void 0) {
          camera._waitingParentId = parsedCamera.parentId;
        }
        if (parsedCamera.parentInstanceIndex !== void 0) {
          camera._waitingParentInstanceIndex = parsedCamera.parentInstanceIndex;
        }
        if (camera.inputs) {
          camera.inputs.parse(parsedCamera);
          camera._setupInputs();
        }
        if (parsedCamera.upVector) {
          camera.upVector = Vector3.FromArray(parsedCamera.upVector);
        }
        if (camera.setPosition) {
          camera.position.copyFromFloats(0, 0, 0);
          camera.setPosition(Vector3.FromArray(parsedCamera.position));
        }
        if (parsedCamera.target) {
          if (camera.setTarget) {
            camera.setTarget(Vector3.FromArray(parsedCamera.target));
          }
        }
        if (parsedCamera.cameraRigMode) {
          const rigParams = parsedCamera.interaxial_distance ? { interaxialDistance: parsedCamera.interaxial_distance } : {};
          camera.setCameraRigMode(parsedCamera.cameraRigMode, rigParams);
        }
        if (parsedCamera.animations) {
          for (let animationIndex = 0; animationIndex < parsedCamera.animations.length; animationIndex++) {
            const parsedAnimation = parsedCamera.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              camera.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(camera, parsedCamera, scene);
        }
        if (parsedCamera.autoAnimate) {
          scene.beginAnimation(camera, parsedCamera.autoAnimateFrom, parsedCamera.autoAnimateTo, parsedCamera.autoAnimateLoop, parsedCamera.autoAnimateSpeed || 1);
        }
        if (parsedCamera.isEnabled !== void 0) {
          camera.setEnabled(parsedCamera.isEnabled);
        }
        return camera;
      }
      _calculateHandednessMultiplier() {
        let handednessMultiplier = this.getScene().useRightHandedSystem ? -1 : 1;
        if (this.parent && this.parent._getWorldMatrixDeterminant() < 0) {
          handednessMultiplier *= -1;
        }
        return handednessMultiplier;
      }
    };
    Camera._CreateDefaultParsedCamera = (name109, scene) => {
      throw _WarnImport("UniversalCamera");
    };
    Camera.PERSPECTIVE_CAMERA = 0;
    Camera.ORTHOGRAPHIC_CAMERA = 1;
    Camera.FOVMODE_VERTICAL_FIXED = 0;
    Camera.FOVMODE_HORIZONTAL_FIXED = 1;
    Camera.RIG_MODE_NONE = 0;
    Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
    Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
    Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
    Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
    Camera.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
    Camera.RIG_MODE_VR = 20;
    Camera.RIG_MODE_WEBVR = 21;
    Camera.RIG_MODE_CUSTOM = 22;
    Camera.ForceAttachControlToAlwaysPreventDefault = false;
    __decorate([
      serializeAsVector3("position")
    ], Camera.prototype, "_position", void 0);
    __decorate([
      serializeAsVector3("upVector")
    ], Camera.prototype, "_upVector", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoLeft", null);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoRight", null);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoBottom", null);
    __decorate([
      serialize()
    ], Camera.prototype, "orthoTop", null);
    __decorate([
      serialize()
    ], Camera.prototype, "fov", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "projectionPlaneTilt", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "minZ", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "maxZ", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "inertia", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "mode", null);
    __decorate([
      serialize()
    ], Camera.prototype, "layerMask", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "fovMode", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "cameraRigMode", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "interaxialDistance", void 0);
    __decorate([
      serialize()
    ], Camera.prototype, "isStereoscopicSideBySide", void 0);
  }
});

// node_modules/@babylonjs/core/Collisions/intersectionInfo.js
var IntersectionInfo;
var init_intersectionInfo = __esm({
  "node_modules/@babylonjs/core/Collisions/intersectionInfo.js"() {
    IntersectionInfo = class {
      constructor(bu, bv, distance) {
        this.bu = bu;
        this.bv = bv;
        this.distance = distance;
        this.faceId = 0;
        this.subMeshId = 0;
      }
    };
  }
});

// node_modules/@babylonjs/core/Culling/boundingBox.js
var BoundingBox;
var init_boundingBox = __esm({
  "node_modules/@babylonjs/core/Culling/boundingBox.js"() {
    init_arrayTools();
    init_math_vector();
    init_math_constants();
    BoundingBox = class {
      constructor(min, max, worldMatrix) {
        this.vectors = ArrayTools.BuildArray(8, Vector3.Zero);
        this.center = Vector3.Zero();
        this.centerWorld = Vector3.Zero();
        this.extendSize = Vector3.Zero();
        this.extendSizeWorld = Vector3.Zero();
        this.directions = ArrayTools.BuildArray(3, Vector3.Zero);
        this.vectorsWorld = ArrayTools.BuildArray(8, Vector3.Zero);
        this.minimumWorld = Vector3.Zero();
        this.maximumWorld = Vector3.Zero();
        this.minimum = Vector3.Zero();
        this.maximum = Vector3.Zero();
        this._drawWrapperFront = null;
        this._drawWrapperBack = null;
        this.reConstruct(min, max, worldMatrix);
      }
      reConstruct(min, max, worldMatrix) {
        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
        const vectors = this.vectors;
        this.minimum.copyFromFloats(minX, minY, minZ);
        this.maximum.copyFromFloats(maxX, maxY, maxZ);
        vectors[0].copyFromFloats(minX, minY, minZ);
        vectors[1].copyFromFloats(maxX, maxY, maxZ);
        vectors[2].copyFromFloats(maxX, minY, minZ);
        vectors[3].copyFromFloats(minX, maxY, minZ);
        vectors[4].copyFromFloats(minX, minY, maxZ);
        vectors[5].copyFromFloats(maxX, maxY, minZ);
        vectors[6].copyFromFloats(minX, maxY, maxZ);
        vectors[7].copyFromFloats(maxX, minY, maxZ);
        max.addToRef(min, this.center).scaleInPlace(0.5);
        max.subtractToRef(min, this.extendSize).scaleInPlace(0.5);
        this._worldMatrix = worldMatrix || Matrix.IdentityReadOnly;
        this._update(this._worldMatrix);
      }
      scale(factor) {
        const tmpVectors = BoundingBox._TmpVector3;
        const diff = this.maximum.subtractToRef(this.minimum, tmpVectors[0]);
        const len = diff.length();
        diff.normalizeFromLength(len);
        const distance = len * factor;
        const newRadius = diff.scaleInPlace(distance * 0.5);
        const min = this.center.subtractToRef(newRadius, tmpVectors[1]);
        const max = this.center.addToRef(newRadius, tmpVectors[2]);
        this.reConstruct(min, max, this._worldMatrix);
        return this;
      }
      getWorldMatrix() {
        return this._worldMatrix;
      }
      _update(world) {
        const minWorld = this.minimumWorld;
        const maxWorld = this.maximumWorld;
        const directions = this.directions;
        const vectorsWorld = this.vectorsWorld;
        const vectors = this.vectors;
        if (!world.isIdentity()) {
          minWorld.setAll(Number.MAX_VALUE);
          maxWorld.setAll(-Number.MAX_VALUE);
          for (let index = 0; index < 8; ++index) {
            const v = vectorsWorld[index];
            Vector3.TransformCoordinatesToRef(vectors[index], world, v);
            minWorld.minimizeInPlace(v);
            maxWorld.maximizeInPlace(v);
          }
          maxWorld.subtractToRef(minWorld, this.extendSizeWorld).scaleInPlace(0.5);
          maxWorld.addToRef(minWorld, this.centerWorld).scaleInPlace(0.5);
        } else {
          minWorld.copyFrom(this.minimum);
          maxWorld.copyFrom(this.maximum);
          for (let index = 0; index < 8; ++index) {
            vectorsWorld[index].copyFrom(vectors[index]);
          }
          this.extendSizeWorld.copyFrom(this.extendSize);
          this.centerWorld.copyFrom(this.center);
        }
        Vector3.FromArrayToRef(world.m, 0, directions[0]);
        Vector3.FromArrayToRef(world.m, 4, directions[1]);
        Vector3.FromArrayToRef(world.m, 8, directions[2]);
        this._worldMatrix = world;
      }
      isInFrustum(frustumPlanes) {
        return BoundingBox.IsInFrustum(this.vectorsWorld, frustumPlanes);
      }
      isCompletelyInFrustum(frustumPlanes) {
        return BoundingBox.IsCompletelyInFrustum(this.vectorsWorld, frustumPlanes);
      }
      intersectsPoint(point) {
        const min = this.minimumWorld;
        const max = this.maximumWorld;
        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
        const pointX = point.x, pointY = point.y, pointZ = point.z;
        const delta = -Epsilon;
        if (maxX - pointX < delta || delta > pointX - minX) {
          return false;
        }
        if (maxY - pointY < delta || delta > pointY - minY) {
          return false;
        }
        if (maxZ - pointZ < delta || delta > pointZ - minZ) {
          return false;
        }
        return true;
      }
      intersectsSphere(sphere) {
        return BoundingBox.IntersectsSphere(this.minimumWorld, this.maximumWorld, sphere.centerWorld, sphere.radiusWorld);
      }
      intersectsMinMax(min, max) {
        const myMin = this.minimumWorld;
        const myMax = this.maximumWorld;
        const myMinX = myMin.x, myMinY = myMin.y, myMinZ = myMin.z, myMaxX = myMax.x, myMaxY = myMax.y, myMaxZ = myMax.z;
        const minX = min.x, minY = min.y, minZ = min.z, maxX = max.x, maxY = max.y, maxZ = max.z;
        if (myMaxX < minX || myMinX > maxX) {
          return false;
        }
        if (myMaxY < minY || myMinY > maxY) {
          return false;
        }
        if (myMaxZ < minZ || myMinZ > maxZ) {
          return false;
        }
        return true;
      }
      dispose() {
        var _a, _b;
        (_a = this._drawWrapperFront) === null || _a === void 0 ? void 0 : _a.dispose();
        (_b = this._drawWrapperBack) === null || _b === void 0 ? void 0 : _b.dispose();
      }
      static Intersects(box0, box1) {
        return box0.intersectsMinMax(box1.minimumWorld, box1.maximumWorld);
      }
      static IntersectsSphere(minPoint, maxPoint, sphereCenter, sphereRadius) {
        const vector = BoundingBox._TmpVector3[0];
        Vector3.ClampToRef(sphereCenter, minPoint, maxPoint, vector);
        const num = Vector3.DistanceSquared(sphereCenter, vector);
        return num <= sphereRadius * sphereRadius;
      }
      static IsCompletelyInFrustum(boundingVectors, frustumPlanes) {
        for (let p = 0; p < 6; ++p) {
          const frustumPlane = frustumPlanes[p];
          for (let i = 0; i < 8; ++i) {
            if (frustumPlane.dotCoordinate(boundingVectors[i]) < 0) {
              return false;
            }
          }
        }
        return true;
      }
      static IsInFrustum(boundingVectors, frustumPlanes) {
        for (let p = 0; p < 6; ++p) {
          let canReturnFalse = true;
          const frustumPlane = frustumPlanes[p];
          for (let i = 0; i < 8; ++i) {
            if (frustumPlane.dotCoordinate(boundingVectors[i]) >= 0) {
              canReturnFalse = false;
              break;
            }
          }
          if (canReturnFalse) {
            return false;
          }
        }
        return true;
      }
    };
    BoundingBox._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  }
});

// node_modules/@babylonjs/core/Culling/boundingSphere.js
var BoundingSphere;
var init_boundingSphere = __esm({
  "node_modules/@babylonjs/core/Culling/boundingSphere.js"() {
    init_arrayTools();
    init_math_vector();
    BoundingSphere = class {
      constructor(min, max, worldMatrix) {
        this.center = Vector3.Zero();
        this.centerWorld = Vector3.Zero();
        this.minimum = Vector3.Zero();
        this.maximum = Vector3.Zero();
        this.reConstruct(min, max, worldMatrix);
      }
      reConstruct(min, max, worldMatrix) {
        this.minimum.copyFrom(min);
        this.maximum.copyFrom(max);
        const distance = Vector3.Distance(min, max);
        max.addToRef(min, this.center).scaleInPlace(0.5);
        this.radius = distance * 0.5;
        this._update(worldMatrix || Matrix.IdentityReadOnly);
      }
      scale(factor) {
        const newRadius = this.radius * factor;
        const tmpVectors = BoundingSphere._TmpVector3;
        const tempRadiusVector = tmpVectors[0].setAll(newRadius);
        const min = this.center.subtractToRef(tempRadiusVector, tmpVectors[1]);
        const max = this.center.addToRef(tempRadiusVector, tmpVectors[2]);
        this.reConstruct(min, max, this._worldMatrix);
        return this;
      }
      getWorldMatrix() {
        return this._worldMatrix;
      }
      _update(worldMatrix) {
        if (!worldMatrix.isIdentity()) {
          Vector3.TransformCoordinatesToRef(this.center, worldMatrix, this.centerWorld);
          const tempVector = BoundingSphere._TmpVector3[0];
          Vector3.TransformNormalFromFloatsToRef(1, 1, 1, worldMatrix, tempVector);
          this.radiusWorld = Math.max(Math.abs(tempVector.x), Math.abs(tempVector.y), Math.abs(tempVector.z)) * this.radius;
        } else {
          this.centerWorld.copyFrom(this.center);
          this.radiusWorld = this.radius;
        }
      }
      isInFrustum(frustumPlanes) {
        const center = this.centerWorld;
        const radius = this.radiusWorld;
        for (let i = 0; i < 6; i++) {
          if (frustumPlanes[i].dotCoordinate(center) <= -radius) {
            return false;
          }
        }
        return true;
      }
      isCenterInFrustum(frustumPlanes) {
        const center = this.centerWorld;
        for (let i = 0; i < 6; i++) {
          if (frustumPlanes[i].dotCoordinate(center) < 0) {
            return false;
          }
        }
        return true;
      }
      intersectsPoint(point) {
        const squareDistance = Vector3.DistanceSquared(this.centerWorld, point);
        if (this.radiusWorld * this.radiusWorld < squareDistance) {
          return false;
        }
        return true;
      }
      static Intersects(sphere0, sphere1) {
        const squareDistance = Vector3.DistanceSquared(sphere0.centerWorld, sphere1.centerWorld);
        const radiusSum = sphere0.radiusWorld + sphere1.radiusWorld;
        if (radiusSum * radiusSum < squareDistance) {
          return false;
        }
        return true;
      }
      static CreateFromCenterAndRadius(center, radius, matrix) {
        this._TmpVector3[0].copyFrom(center);
        this._TmpVector3[1].copyFromFloats(0, 0, radius);
        this._TmpVector3[2].copyFrom(center);
        this._TmpVector3[0].addInPlace(this._TmpVector3[1]);
        this._TmpVector3[2].subtractInPlace(this._TmpVector3[1]);
        const sphere = new BoundingSphere(this._TmpVector3[0], this._TmpVector3[2]);
        if (matrix) {
          sphere._worldMatrix = matrix;
        } else {
          sphere._worldMatrix = Matrix.Identity();
        }
        return sphere;
      }
    };
    BoundingSphere._TmpVector3 = ArrayTools.BuildArray(3, Vector3.Zero);
  }
});

// node_modules/@babylonjs/core/Culling/boundingInfo.js
var _result0, _result1, computeBoxExtents, axisOverlap, BoundingInfo;
var init_boundingInfo = __esm({
  "node_modules/@babylonjs/core/Culling/boundingInfo.js"() {
    init_arrayTools();
    init_math_vector();
    init_math_vector();
    init_boundingBox();
    init_boundingSphere();
    _result0 = { min: 0, max: 0 };
    _result1 = { min: 0, max: 0 };
    computeBoxExtents = (axis, box, result) => {
      const p = Vector3.Dot(box.centerWorld, axis);
      const r0 = Math.abs(Vector3.Dot(box.directions[0], axis)) * box.extendSize.x;
      const r1 = Math.abs(Vector3.Dot(box.directions[1], axis)) * box.extendSize.y;
      const r2 = Math.abs(Vector3.Dot(box.directions[2], axis)) * box.extendSize.z;
      const r = r0 + r1 + r2;
      result.min = p - r;
      result.max = p + r;
    };
    axisOverlap = (axis, box0, box1) => {
      computeBoxExtents(axis, box0, _result0);
      computeBoxExtents(axis, box1, _result1);
      return !(_result0.min > _result1.max || _result1.min > _result0.max);
    };
    BoundingInfo = class {
      constructor(minimum, maximum, worldMatrix) {
        this._isLocked = false;
        this.boundingBox = new BoundingBox(minimum, maximum, worldMatrix);
        this.boundingSphere = new BoundingSphere(minimum, maximum, worldMatrix);
      }
      reConstruct(min, max, worldMatrix) {
        this.boundingBox.reConstruct(min, max, worldMatrix);
        this.boundingSphere.reConstruct(min, max, worldMatrix);
      }
      get minimum() {
        return this.boundingBox.minimum;
      }
      get maximum() {
        return this.boundingBox.maximum;
      }
      get isLocked() {
        return this._isLocked;
      }
      set isLocked(value) {
        this._isLocked = value;
      }
      update(world) {
        if (this._isLocked) {
          return;
        }
        this.boundingBox._update(world);
        this.boundingSphere._update(world);
      }
      centerOn(center, extend) {
        const minimum = BoundingInfo._TmpVector3[0].copyFrom(center).subtractInPlace(extend);
        const maximum = BoundingInfo._TmpVector3[1].copyFrom(center).addInPlace(extend);
        this.boundingBox.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
        this.boundingSphere.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
        return this;
      }
      encapsulate(point) {
        const minimum = Vector3.Minimize(this.minimum, point);
        const maximum = Vector3.Maximize(this.maximum, point);
        this.reConstruct(minimum, maximum, this.boundingBox.getWorldMatrix());
        return this;
      }
      encapsulateBoundingInfo(toEncapsulate) {
        const invw = TmpVectors.Matrix[0];
        this.boundingBox.getWorldMatrix().invertToRef(invw);
        const v = TmpVectors.Vector3[0];
        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.minimumWorld, invw, v);
        this.encapsulate(v);
        Vector3.TransformCoordinatesToRef(toEncapsulate.boundingBox.maximumWorld, invw, v);
        this.encapsulate(v);
        return this;
      }
      scale(factor) {
        this.boundingBox.scale(factor);
        this.boundingSphere.scale(factor);
        return this;
      }
      isInFrustum(frustumPlanes, strategy = 0) {
        const inclusionTest = strategy === 2 || strategy === 3;
        if (inclusionTest) {
          if (this.boundingSphere.isCenterInFrustum(frustumPlanes)) {
            return true;
          }
        }
        if (!this.boundingSphere.isInFrustum(frustumPlanes)) {
          return false;
        }
        const bSphereOnlyTest = strategy === 1 || strategy === 3;
        if (bSphereOnlyTest) {
          return true;
        }
        return this.boundingBox.isInFrustum(frustumPlanes);
      }
      get diagonalLength() {
        const boundingBox = this.boundingBox;
        const diag = boundingBox.maximumWorld.subtractToRef(boundingBox.minimumWorld, BoundingInfo._TmpVector3[0]);
        return diag.length();
      }
      isCompletelyInFrustum(frustumPlanes) {
        return this.boundingBox.isCompletelyInFrustum(frustumPlanes);
      }
      _checkCollision(collider) {
        return collider._canDoCollision(this.boundingSphere.centerWorld, this.boundingSphere.radiusWorld, this.boundingBox.minimumWorld, this.boundingBox.maximumWorld);
      }
      intersectsPoint(point) {
        if (!this.boundingSphere.centerWorld) {
          return false;
        }
        if (!this.boundingSphere.intersectsPoint(point)) {
          return false;
        }
        if (!this.boundingBox.intersectsPoint(point)) {
          return false;
        }
        return true;
      }
      intersects(boundingInfo, precise) {
        if (!BoundingSphere.Intersects(this.boundingSphere, boundingInfo.boundingSphere)) {
          return false;
        }
        if (!BoundingBox.Intersects(this.boundingBox, boundingInfo.boundingBox)) {
          return false;
        }
        if (!precise) {
          return true;
        }
        const box0 = this.boundingBox;
        const box1 = boundingInfo.boundingBox;
        if (!axisOverlap(box0.directions[0], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box0.directions[1], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box0.directions[2], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box1.directions[0], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box1.directions[1], box0, box1)) {
          return false;
        }
        if (!axisOverlap(box1.directions[2], box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[0]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[1]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[0], box1.directions[2]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[0]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[1]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[1], box1.directions[2]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[0]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[1]), box0, box1)) {
          return false;
        }
        if (!axisOverlap(Vector3.Cross(box0.directions[2], box1.directions[2]), box0, box1)) {
          return false;
        }
        return true;
      }
    };
    BoundingInfo._TmpVector3 = ArrayTools.BuildArray(2, Vector3.Zero);
  }
});

// node_modules/@babylonjs/core/Maths/math.functions.js
function extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, bias = null) {
  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  MathHelpers.extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
function extractMinAndMax(positions, start, count, bias = null, stride) {
  const minimum = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
  const maximum = new Vector3(-Number.MAX_VALUE, -Number.MAX_VALUE, -Number.MAX_VALUE);
  if (!stride) {
    stride = 3;
  }
  MathHelpers.extractMinAndMax(positions, start, count, stride, minimum, maximum);
  if (bias) {
    minimum.x -= minimum.x * bias.x + bias.y;
    minimum.y -= minimum.y * bias.x + bias.y;
    minimum.z -= minimum.z * bias.x + bias.y;
    maximum.x += maximum.x * bias.x + bias.y;
    maximum.y += maximum.y * bias.x + bias.y;
    maximum.z += maximum.z * bias.x + bias.y;
  }
  return {
    minimum,
    maximum
  };
}
var MathHelpers;
var init_math_functions = __esm({
  "node_modules/@babylonjs/core/Maths/math.functions.js"() {
    init_tslib_es6();
    init_math_vector();
    init_decorators();
    MathHelpers = class {
      static extractMinAndMaxIndexed(positions, indices, indexStart, indexCount, minimum, maximum) {
        for (let index = indexStart; index < indexStart + indexCount; index++) {
          const offset = indices[index] * 3;
          const x = positions[offset];
          const y = positions[offset + 1];
          const z = positions[offset + 2];
          minimum.minimizeInPlaceFromFloats(x, y, z);
          maximum.maximizeInPlaceFromFloats(x, y, z);
        }
      }
      static extractMinAndMax(positions, start, count, stride, minimum, maximum) {
        for (let index = start, offset = start * stride; index < start + count; index++, offset += stride) {
          const x = positions[offset];
          const y = positions[offset + 1];
          const z = positions[offset + 2];
          minimum.minimizeInPlaceFromFloats(x, y, z);
          maximum.maximizeInPlaceFromFloats(x, y, z);
        }
      }
    };
    __decorate([
      nativeOverride.filter((...[positions, indices]) => !Array.isArray(positions) && !Array.isArray(indices))
    ], MathHelpers, "extractMinAndMaxIndexed", null);
    __decorate([
      nativeOverride.filter((...[positions]) => !Array.isArray(positions))
    ], MathHelpers, "extractMinAndMax", null);
  }
});

// node_modules/@babylonjs/core/Meshes/subMesh.js
var SubMesh;
var init_subMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/subMesh.js"() {
    init_buffer();
    init_intersectionInfo();
    init_boundingInfo();
    init_math_functions();
    init_drawWrapper();
    SubMesh = class {
      get materialDefines() {
        var _a;
        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.defines : (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.defines;
      }
      set materialDefines(defines) {
        var _a;
        const drawWrapper = (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
        drawWrapper.defines = defines;
      }
      _getDrawWrapper(passId, createIfNotExisting = false) {
        passId = passId !== null && passId !== void 0 ? passId : this._engine.currentRenderPassId;
        let drawWrapper = this._drawWrappers[passId];
        if (!drawWrapper && createIfNotExisting) {
          this._drawWrappers[passId] = drawWrapper = new DrawWrapper(this._mesh.getScene().getEngine());
        }
        return drawWrapper;
      }
      _removeDrawWrapper(passId, disposeWrapper = true) {
        var _a;
        if (disposeWrapper) {
          (_a = this._drawWrappers[passId]) === null || _a === void 0 ? void 0 : _a.dispose();
        }
        this._drawWrappers[passId] = void 0;
      }
      get effect() {
        var _a, _b;
        return this._mainDrawWrapperOverride ? this._mainDrawWrapperOverride.effect : (_b = (_a = this._getDrawWrapper()) === null || _a === void 0 ? void 0 : _a.effect) !== null && _b !== void 0 ? _b : null;
      }
      get _drawWrapper() {
        var _a;
        return (_a = this._mainDrawWrapperOverride) !== null && _a !== void 0 ? _a : this._getDrawWrapper(void 0, true);
      }
      get _drawWrapperOverride() {
        return this._mainDrawWrapperOverride;
      }
      _setMainDrawWrapperOverride(wrapper) {
        this._mainDrawWrapperOverride = wrapper;
      }
      setEffect(effect, defines = null, materialContext, resetContext = true) {
        const drawWrapper = this._drawWrapper;
        drawWrapper.setEffect(effect, defines, resetContext);
        if (materialContext !== void 0) {
          drawWrapper.materialContext = materialContext;
        }
        if (!effect) {
          drawWrapper.defines = null;
          drawWrapper.materialContext = void 0;
        }
      }
      resetDrawCache(passId) {
        if (this._drawWrappers) {
          if (passId !== void 0) {
            this._removeDrawWrapper(passId);
            return;
          } else {
            for (const drawWrapper of this._drawWrappers) {
              drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.dispose();
            }
          }
        }
        this._drawWrappers = [];
      }
      static AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true) {
        return new SubMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox);
      }
      constructor(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh, renderingMesh, createBoundingBox = true, addToMesh = true) {
        this.materialIndex = materialIndex;
        this.verticesStart = verticesStart;
        this.verticesCount = verticesCount;
        this.indexStart = indexStart;
        this.indexCount = indexCount;
        this._mainDrawWrapperOverride = null;
        this._linesIndexCount = 0;
        this._linesIndexBuffer = null;
        this._lastColliderWorldVertices = null;
        this._lastColliderTransformMatrix = null;
        this._wasDispatched = false;
        this._renderId = 0;
        this._alphaIndex = 0;
        this._distanceToCamera = 0;
        this._currentMaterial = null;
        this._mesh = mesh;
        this._renderingMesh = renderingMesh || mesh;
        if (addToMesh) {
          mesh.subMeshes.push(this);
        }
        this._engine = this._mesh.getScene().getEngine();
        this.resetDrawCache();
        this._trianglePlanes = [];
        this._id = mesh.subMeshes.length - 1;
        if (createBoundingBox) {
          this.refreshBoundingInfo();
          mesh.computeWorldMatrix(true);
        }
      }
      get IsGlobal() {
        return this.verticesStart === 0 && this.verticesCount === this._mesh.getTotalVertices() && this.indexStart === 0 && this.indexCount === this._mesh.getTotalIndices();
      }
      getBoundingInfo() {
        if (this.IsGlobal) {
          return this._mesh.getBoundingInfo();
        }
        return this._boundingInfo;
      }
      setBoundingInfo(boundingInfo) {
        this._boundingInfo = boundingInfo;
        return this;
      }
      getMesh() {
        return this._mesh;
      }
      getRenderingMesh() {
        return this._renderingMesh;
      }
      getReplacementMesh() {
        return this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
      }
      getEffectiveMesh() {
        const replacementMesh = this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : null;
        return replacementMesh ? replacementMesh : this._renderingMesh;
      }
      getMaterial(getDefaultMaterial = true) {
        var _a;
        const rootMaterial = (_a = this._renderingMesh.getMaterialForRenderPass(this._engine.currentRenderPassId)) !== null && _a !== void 0 ? _a : this._renderingMesh.material;
        if (!rootMaterial) {
          return getDefaultMaterial ? this._mesh.getScene().defaultMaterial : null;
        } else if (this._isMultiMaterial(rootMaterial)) {
          const effectiveMaterial = rootMaterial.getSubMaterial(this.materialIndex);
          if (this._currentMaterial !== effectiveMaterial) {
            this._currentMaterial = effectiveMaterial;
            this.resetDrawCache();
          }
          return effectiveMaterial;
        }
        return rootMaterial;
      }
      _isMultiMaterial(material) {
        return material.getSubMaterial !== void 0;
      }
      refreshBoundingInfo(data = null) {
        this._lastColliderWorldVertices = null;
        if (this.IsGlobal || !this._renderingMesh || !this._renderingMesh.geometry) {
          return this;
        }
        if (!data) {
          data = this._renderingMesh.getVerticesData(VertexBuffer.PositionKind);
        }
        if (!data) {
          this._boundingInfo = this._mesh.getBoundingInfo();
          return this;
        }
        const indices = this._renderingMesh.getIndices();
        let extend;
        if (this.indexStart === 0 && this.indexCount === indices.length) {
          const boundingInfo = this._renderingMesh.getBoundingInfo();
          extend = { minimum: boundingInfo.minimum.clone(), maximum: boundingInfo.maximum.clone() };
        } else {
          extend = extractMinAndMaxIndexed(data, indices, this.indexStart, this.indexCount, this._renderingMesh.geometry.boundingBias);
        }
        if (this._boundingInfo) {
          this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
        } else {
          this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
        }
        return this;
      }
      _checkCollision(collider) {
        const boundingInfo = this.getBoundingInfo();
        return boundingInfo._checkCollision(collider);
      }
      updateBoundingInfo(world) {
        let boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          this.refreshBoundingInfo();
          boundingInfo = this.getBoundingInfo();
        }
        if (boundingInfo) {
          boundingInfo.update(world);
        }
        return this;
      }
      isInFrustum(frustumPlanes) {
        const boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          return false;
        }
        return boundingInfo.isInFrustum(frustumPlanes, this._mesh.cullingStrategy);
      }
      isCompletelyInFrustum(frustumPlanes) {
        const boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          return false;
        }
        return boundingInfo.isCompletelyInFrustum(frustumPlanes);
      }
      render(enableAlphaMode) {
        this._renderingMesh.render(this, enableAlphaMode, this._mesh._internalAbstractMeshDataInfo._actAsRegularMesh ? this._mesh : void 0);
        return this;
      }
      _getLinesIndexBuffer(indices, engine) {
        if (!this._linesIndexBuffer) {
          const linesIndices = [];
          for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 3) {
            linesIndices.push(indices[index], indices[index + 1], indices[index + 1], indices[index + 2], indices[index + 2], indices[index]);
          }
          this._linesIndexBuffer = engine.createIndexBuffer(linesIndices);
          this._linesIndexCount = linesIndices.length;
        }
        return this._linesIndexBuffer;
      }
      canIntersects(ray) {
        const boundingInfo = this.getBoundingInfo();
        if (!boundingInfo) {
          return false;
        }
        return ray.intersectsBox(boundingInfo.boundingBox);
      }
      intersects(ray, positions, indices, fastCheck, trianglePredicate) {
        const material = this.getMaterial();
        if (!material) {
          return null;
        }
        let step = 3;
        let checkStopper = false;
        switch (material.fillMode) {
          case 3:
          case 5:
          case 6:
          case 8:
            return null;
          case 7:
            step = 1;
            checkStopper = true;
            break;
          default:
            break;
        }
        if (material.fillMode === 4) {
          if (!indices.length) {
            return this._intersectUnIndexedLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
          }
          return this._intersectLines(ray, positions, indices, this._mesh.intersectionThreshold, fastCheck);
        } else {
          if (!indices.length && this._mesh._unIndexed) {
            return this._intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate);
          }
          return this._intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate);
        }
      }
      _intersectLines(ray, positions, indices, intersectionThreshold, fastCheck) {
        let intersectInfo = null;
        for (let index = this.indexStart; index < this.indexStart + this.indexCount; index += 2) {
          const p0 = positions[indices[index]];
          const p1 = positions[indices[index + 1]];
          const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
          if (length < 0) {
            continue;
          }
          if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
            intersectInfo = new IntersectionInfo(null, null, length);
            intersectInfo.faceId = index / 2;
            if (fastCheck) {
              break;
            }
          }
        }
        return intersectInfo;
      }
      _intersectUnIndexedLines(ray, positions, indices, intersectionThreshold, fastCheck) {
        let intersectInfo = null;
        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 2) {
          const p0 = positions[index];
          const p1 = positions[index + 1];
          const length = ray.intersectionSegment(p0, p1, intersectionThreshold);
          if (length < 0) {
            continue;
          }
          if (fastCheck || !intersectInfo || length < intersectInfo.distance) {
            intersectInfo = new IntersectionInfo(null, null, length);
            intersectInfo.faceId = index / 2;
            if (fastCheck) {
              break;
            }
          }
        }
        return intersectInfo;
      }
      _intersectTriangles(ray, positions, indices, step, checkStopper, fastCheck, trianglePredicate) {
        let intersectInfo = null;
        let faceId = -1;
        for (let index = this.indexStart; index < this.indexStart + this.indexCount - (3 - step); index += step) {
          faceId++;
          const indexA = indices[index];
          const indexB = indices[index + 1];
          const indexC = indices[index + 2];
          if (checkStopper && indexC === 4294967295) {
            index += 2;
            continue;
          }
          const p0 = positions[indexA];
          const p1 = positions[indexB];
          const p2 = positions[indexC];
          if (!p0 || !p1 || !p2) {
            continue;
          }
          if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, indexA, indexB, indexC)) {
            continue;
          }
          const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
          if (currentIntersectInfo) {
            if (currentIntersectInfo.distance < 0) {
              continue;
            }
            if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
              intersectInfo = currentIntersectInfo;
              intersectInfo.faceId = faceId;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        return intersectInfo;
      }
      _intersectUnIndexedTriangles(ray, positions, indices, fastCheck, trianglePredicate) {
        let intersectInfo = null;
        for (let index = this.verticesStart; index < this.verticesStart + this.verticesCount; index += 3) {
          const p0 = positions[index];
          const p1 = positions[index + 1];
          const p2 = positions[index + 2];
          if (trianglePredicate && !trianglePredicate(p0, p1, p2, ray, -1, -1, -1)) {
            continue;
          }
          const currentIntersectInfo = ray.intersectsTriangle(p0, p1, p2);
          if (currentIntersectInfo) {
            if (currentIntersectInfo.distance < 0) {
              continue;
            }
            if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
              intersectInfo = currentIntersectInfo;
              intersectInfo.faceId = index / 3;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        return intersectInfo;
      }
      _rebuild() {
        if (this._linesIndexBuffer) {
          this._linesIndexBuffer = null;
        }
      }
      clone(newMesh, newRenderingMesh) {
        const result = new SubMesh(this.materialIndex, this.verticesStart, this.verticesCount, this.indexStart, this.indexCount, newMesh, newRenderingMesh, false);
        if (!this.IsGlobal) {
          const boundingInfo = this.getBoundingInfo();
          if (!boundingInfo) {
            return result;
          }
          result._boundingInfo = new BoundingInfo(boundingInfo.minimum, boundingInfo.maximum);
        }
        return result;
      }
      dispose() {
        if (this._linesIndexBuffer) {
          this._mesh.getScene().getEngine()._releaseBuffer(this._linesIndexBuffer);
          this._linesIndexBuffer = null;
        }
        const index = this._mesh.subMeshes.indexOf(this);
        this._mesh.subMeshes.splice(index, 1);
        this.resetDrawCache();
      }
      getClassName() {
        return "SubMesh";
      }
      static CreateFromIndices(materialIndex, startIndex, indexCount, mesh, renderingMesh, createBoundingBox = true) {
        let minVertexIndex = Number.MAX_VALUE;
        let maxVertexIndex = -Number.MAX_VALUE;
        const whatWillRender = renderingMesh || mesh;
        const indices = whatWillRender.getIndices();
        for (let index = startIndex; index < startIndex + indexCount; index++) {
          const vertexIndex = indices[index];
          if (vertexIndex < minVertexIndex) {
            minVertexIndex = vertexIndex;
          }
          if (vertexIndex > maxVertexIndex) {
            maxVertexIndex = vertexIndex;
          }
        }
        return new SubMesh(materialIndex, minVertexIndex, maxVertexIndex - minVertexIndex + 1, startIndex, indexCount, mesh, renderingMesh, createBoundingBox);
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/mesh.vertexData.js
var VertexDataMaterialInfo, VertexData;
var init_mesh_vertexData = __esm({
  "node_modules/@babylonjs/core/Meshes/mesh.vertexData.js"() {
    init_tslib_es6();
    init_math_vector();
    init_buffer();
    init_devTools();
    init_math_color();
    init_logger();
    init_decorators();
    init_coroutine();
    init_error();
    init_subMesh();
    VertexDataMaterialInfo = class {
    };
    VertexData = class {
      constructor() {
        this.uniqueId = 0;
        this.metadata = {};
        this._applyTo = makeSyncFunction(this._applyToCoroutine.bind(this));
        this.uniqueId = VertexData._UniqueIDGenerator;
        VertexData._UniqueIDGenerator++;
      }
      set(data, kind) {
        if (!data.length) {
          Logger.Warn(`Setting vertex data kind '${kind}' with an empty array`);
        }
        switch (kind) {
          case VertexBuffer.PositionKind:
            this.positions = data;
            break;
          case VertexBuffer.NormalKind:
            this.normals = data;
            break;
          case VertexBuffer.TangentKind:
            this.tangents = data;
            break;
          case VertexBuffer.UVKind:
            this.uvs = data;
            break;
          case VertexBuffer.UV2Kind:
            this.uvs2 = data;
            break;
          case VertexBuffer.UV3Kind:
            this.uvs3 = data;
            break;
          case VertexBuffer.UV4Kind:
            this.uvs4 = data;
            break;
          case VertexBuffer.UV5Kind:
            this.uvs5 = data;
            break;
          case VertexBuffer.UV6Kind:
            this.uvs6 = data;
            break;
          case VertexBuffer.ColorKind:
            this.colors = data;
            break;
          case VertexBuffer.MatricesIndicesKind:
            this.matricesIndices = data;
            break;
          case VertexBuffer.MatricesWeightsKind:
            this.matricesWeights = data;
            break;
          case VertexBuffer.MatricesIndicesExtraKind:
            this.matricesIndicesExtra = data;
            break;
          case VertexBuffer.MatricesWeightsExtraKind:
            this.matricesWeightsExtra = data;
            break;
        }
      }
      applyToMesh(mesh, updatable) {
        this._applyTo(mesh, updatable, false);
        return this;
      }
      applyToGeometry(geometry, updatable) {
        this._applyTo(geometry, updatable, false);
        return this;
      }
      updateMesh(mesh) {
        this._update(mesh);
        return this;
      }
      updateGeometry(geometry) {
        this._update(geometry);
        return this;
      }
      *_applyToCoroutine(meshOrGeometry, updatable = false, isAsync) {
        if (this.positions) {
          meshOrGeometry.setVerticesData(VertexBuffer.PositionKind, this.positions, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.normals) {
          meshOrGeometry.setVerticesData(VertexBuffer.NormalKind, this.normals, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.tangents) {
          meshOrGeometry.setVerticesData(VertexBuffer.TangentKind, this.tangents, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.uvs) {
          meshOrGeometry.setVerticesData(VertexBuffer.UVKind, this.uvs, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.uvs2) {
          meshOrGeometry.setVerticesData(VertexBuffer.UV2Kind, this.uvs2, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.uvs3) {
          meshOrGeometry.setVerticesData(VertexBuffer.UV3Kind, this.uvs3, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.uvs4) {
          meshOrGeometry.setVerticesData(VertexBuffer.UV4Kind, this.uvs4, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.uvs5) {
          meshOrGeometry.setVerticesData(VertexBuffer.UV5Kind, this.uvs5, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.uvs6) {
          meshOrGeometry.setVerticesData(VertexBuffer.UV6Kind, this.uvs6, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.colors) {
          meshOrGeometry.setVerticesData(VertexBuffer.ColorKind, this.colors, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.matricesIndices) {
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.matricesWeights) {
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.matricesIndicesExtra) {
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.matricesWeightsExtra) {
          meshOrGeometry.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updatable);
          if (isAsync) {
            yield;
          }
        }
        if (this.indices) {
          meshOrGeometry.setIndices(this.indices, null, updatable);
          if (isAsync) {
            yield;
          }
        } else {
          meshOrGeometry.setIndices([], null);
        }
        if (meshOrGeometry.subMeshes && this.materialInfos && this.materialInfos.length > 1) {
          const mesh = meshOrGeometry;
          mesh.subMeshes = [];
          for (const matInfo of this.materialInfos) {
            new SubMesh(matInfo.materialIndex, matInfo.verticesStart, matInfo.verticesCount, matInfo.indexStart, matInfo.indexCount, mesh);
          }
        }
        return this;
      }
      _update(meshOrGeometry, updateExtends, makeItUnique) {
        if (this.positions) {
          meshOrGeometry.updateVerticesData(VertexBuffer.PositionKind, this.positions, updateExtends, makeItUnique);
        }
        if (this.normals) {
          meshOrGeometry.updateVerticesData(VertexBuffer.NormalKind, this.normals, updateExtends, makeItUnique);
        }
        if (this.tangents) {
          meshOrGeometry.updateVerticesData(VertexBuffer.TangentKind, this.tangents, updateExtends, makeItUnique);
        }
        if (this.uvs) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UVKind, this.uvs, updateExtends, makeItUnique);
        }
        if (this.uvs2) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV2Kind, this.uvs2, updateExtends, makeItUnique);
        }
        if (this.uvs3) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV3Kind, this.uvs3, updateExtends, makeItUnique);
        }
        if (this.uvs4) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV4Kind, this.uvs4, updateExtends, makeItUnique);
        }
        if (this.uvs5) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV5Kind, this.uvs5, updateExtends, makeItUnique);
        }
        if (this.uvs6) {
          meshOrGeometry.updateVerticesData(VertexBuffer.UV6Kind, this.uvs6, updateExtends, makeItUnique);
        }
        if (this.colors) {
          meshOrGeometry.updateVerticesData(VertexBuffer.ColorKind, this.colors, updateExtends, makeItUnique);
        }
        if (this.matricesIndices) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesKind, this.matricesIndices, updateExtends, makeItUnique);
        }
        if (this.matricesWeights) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsKind, this.matricesWeights, updateExtends, makeItUnique);
        }
        if (this.matricesIndicesExtra) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra, updateExtends, makeItUnique);
        }
        if (this.matricesWeightsExtra) {
          meshOrGeometry.updateVerticesData(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra, updateExtends, makeItUnique);
        }
        if (this.indices) {
          meshOrGeometry.setIndices(this.indices, null);
        }
        return this;
      }
      static _TransformVector3Coordinates(coordinates, transformation, offset = 0, length = coordinates.length) {
        const coordinate = TmpVectors.Vector3[0];
        const transformedCoordinate = TmpVectors.Vector3[1];
        for (let index = offset; index < offset + length; index += 3) {
          Vector3.FromArrayToRef(coordinates, index, coordinate);
          Vector3.TransformCoordinatesToRef(coordinate, transformation, transformedCoordinate);
          coordinates[index] = transformedCoordinate.x;
          coordinates[index + 1] = transformedCoordinate.y;
          coordinates[index + 2] = transformedCoordinate.z;
        }
      }
      static _TransformVector3Normals(normals, transformation, offset = 0, length = normals.length) {
        const normal = TmpVectors.Vector3[0];
        const transformedNormal = TmpVectors.Vector3[1];
        for (let index = offset; index < offset + length; index += 3) {
          Vector3.FromArrayToRef(normals, index, normal);
          Vector3.TransformNormalToRef(normal, transformation, transformedNormal);
          normals[index] = transformedNormal.x;
          normals[index + 1] = transformedNormal.y;
          normals[index + 2] = transformedNormal.z;
        }
      }
      static _TransformVector4Normals(normals, transformation, offset = 0, length = normals.length) {
        const normal = TmpVectors.Vector4[0];
        const transformedNormal = TmpVectors.Vector4[1];
        for (let index = offset; index < offset + length; index += 4) {
          Vector4.FromArrayToRef(normals, index, normal);
          Vector4.TransformNormalToRef(normal, transformation, transformedNormal);
          normals[index] = transformedNormal.x;
          normals[index + 1] = transformedNormal.y;
          normals[index + 2] = transformedNormal.z;
          normals[index + 3] = transformedNormal.w;
        }
      }
      static _FlipFaces(indices, offset = 0, length = indices.length) {
        for (let index = offset; index < offset + length; index += 3) {
          const tmp = indices[index + 1];
          indices[index + 1] = indices[index + 2];
          indices[index + 2] = tmp;
        }
      }
      transform(matrix) {
        const flip = matrix.determinant() < 0;
        if (this.positions) {
          VertexData._TransformVector3Coordinates(this.positions, matrix);
        }
        if (this.normals) {
          VertexData._TransformVector3Normals(this.normals, matrix);
        }
        if (this.tangents) {
          VertexData._TransformVector4Normals(this.tangents, matrix);
        }
        if (flip && this.indices) {
          VertexData._FlipFaces(this.indices);
        }
        return this;
      }
      splitBasedOnMaterialID() {
        if (!this.materialInfos || this.materialInfos.length < 2) {
          return [this];
        }
        const result = new Array();
        for (const materialInfo of this.materialInfos) {
          const vertexData = new VertexData();
          if (this.positions) {
            vertexData.positions = this.positions.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);
          }
          if (this.normals) {
            vertexData.normals = this.normals.slice(materialInfo.verticesStart * 3, (materialInfo.verticesCount + materialInfo.verticesStart) * 3);
          }
          if (this.tangents) {
            vertexData.tangents = this.tangents.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
          }
          if (this.colors) {
            vertexData.colors = this.colors.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
          }
          if (this.uvs) {
            vertexData.uvs = this.uvs.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
          }
          if (this.uvs2) {
            vertexData.uvs2 = this.uvs2.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
          }
          if (this.uvs3) {
            vertexData.uvs3 = this.uvs3.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
          }
          if (this.uvs4) {
            vertexData.uvs4 = this.uvs4.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
          }
          if (this.uvs5) {
            vertexData.uvs5 = this.uvs5.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
          }
          if (this.uvs6) {
            vertexData.uvs6 = this.uvs6.slice(materialInfo.verticesStart * 2, (materialInfo.verticesCount + materialInfo.verticesStart) * 2);
          }
          if (this.matricesIndices) {
            vertexData.matricesIndices = this.matricesIndices.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
          }
          if (this.matricesIndicesExtra) {
            vertexData.matricesIndicesExtra = this.matricesIndicesExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
          }
          if (this.matricesWeights) {
            vertexData.matricesWeights = this.matricesWeights.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
          }
          if (this.matricesWeightsExtra) {
            vertexData.matricesWeightsExtra = this.matricesWeightsExtra.slice(materialInfo.verticesStart * 4, (materialInfo.verticesCount + materialInfo.verticesStart) * 4);
          }
          if (this.indices) {
            vertexData.indices = [];
            for (let index = materialInfo.indexStart; index < materialInfo.indexStart + materialInfo.indexCount; index++) {
              vertexData.indices.push(this.indices[index] - materialInfo.verticesStart);
            }
          }
          const newMaterialInfo = new VertexDataMaterialInfo();
          newMaterialInfo.indexStart = 0;
          newMaterialInfo.indexCount = vertexData.indices ? vertexData.indices.length : 0;
          newMaterialInfo.materialIndex = materialInfo.materialIndex;
          newMaterialInfo.verticesStart = 0;
          newMaterialInfo.verticesCount = (vertexData.positions ? vertexData.positions.length : 0) / 3;
          vertexData.materialInfos = [newMaterialInfo];
          result.push(vertexData);
        }
        return result;
      }
      merge(others, use32BitsIndices = false, forceCloneIndices = false, mergeMaterialIds = false, enableCompletion = false) {
        const vertexDatas = Array.isArray(others) ? others.map((other) => {
          return { vertexData: other };
        }) : [{ vertexData: others }];
        return runCoroutineSync(this._mergeCoroutine(void 0, vertexDatas, use32BitsIndices, false, forceCloneIndices, mergeMaterialIds, enableCompletion));
      }
      *_mergeCoroutine(transform, vertexDatas, use32BitsIndices = false, isAsync, forceCloneIndices, mergeMaterialIds = false, enableCompletion = false) {
        var _a, _b, _c, _d;
        this._validate();
        let others = vertexDatas.map((vertexData) => vertexData.vertexData);
        let root = this;
        for (const other of others) {
          if (!other) {
            continue;
          }
          other._validate();
          if (!enableCompletion) {
            if (!this.normals !== !other.normals || !this.tangents !== !other.tangents || !this.uvs !== !other.uvs || !this.uvs2 !== !other.uvs2 || !this.uvs3 !== !other.uvs3 || !this.uvs4 !== !other.uvs4 || !this.uvs5 !== !other.uvs5 || !this.uvs6 !== !other.uvs6 || !this.colors !== !other.colors || !this.matricesIndices !== !other.matricesIndices || !this.matricesWeights !== !other.matricesWeights || !this.matricesIndicesExtra !== !other.matricesIndicesExtra || !this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
              throw new Error("Cannot merge vertex data that do not have the same set of attributes");
            }
          } else {
            if (!this.normals !== !other.normals) {
              if (!this.normals) {
                this.normals = new Float32Array(this.positions.length);
              } else {
                other.normals = new Float32Array(other.positions.length);
              }
            }
            if (!this.tangents !== !other.tangents) {
              if (!this.tangents) {
                this.tangents = new Float32Array(this.positions.length / 3 * 4);
              } else {
                other.tangents = new Float32Array(other.positions.length / 3 * 4);
              }
            }
            if (!this.uvs !== !other.uvs) {
              if (!this.uvs) {
                this.uvs = new Float32Array(this.positions.length / 3 * 2);
              } else {
                other.uvs = new Float32Array(other.positions.length / 3 * 2);
              }
            }
            if (!this.uvs2 !== !other.uvs2) {
              if (!this.uvs2) {
                this.uvs2 = new Float32Array(this.positions.length / 3 * 2);
              } else {
                other.uvs2 = new Float32Array(other.positions.length / 3 * 2);
              }
            }
            if (!this.uvs3 !== !other.uvs3) {
              if (!this.uvs3) {
                this.uvs3 = new Float32Array(this.positions.length / 3 * 2);
              } else {
                other.uvs3 = new Float32Array(other.positions.length / 3 * 2);
              }
            }
            if (!this.uvs4 !== !other.uvs4) {
              if (!this.uvs4) {
                this.uvs4 = new Float32Array(this.positions.length / 3 * 2);
              } else {
                other.uvs4 = new Float32Array(other.positions.length / 3 * 2);
              }
            }
            if (!this.uvs5 !== !other.uvs5) {
              if (!this.uvs5) {
                this.uvs5 = new Float32Array(this.positions.length / 3 * 2);
              } else {
                other.uvs5 = new Float32Array(other.positions.length / 3 * 2);
              }
            }
            if (!this.uvs6 !== !other.uvs6) {
              if (!this.uvs6) {
                this.uvs6 = new Float32Array(this.positions.length / 3 * 2);
              } else {
                other.uvs6 = new Float32Array(other.positions.length / 3 * 2);
              }
            }
            if (!this.colors !== !other.colors) {
              if (!this.colors) {
                this.colors = new Float32Array(this.positions.length / 3 * 4);
                this.colors.fill(1);
              } else {
                other.colors = new Float32Array(other.positions.length / 3 * 4);
                other.colors.fill(1);
              }
            }
            if (!this.matricesIndices !== !other.matricesIndices) {
              if (!this.matricesIndices) {
                this.matricesIndices = new Float32Array(this.positions.length / 3 * 4);
              } else {
                other.matricesIndices = new Float32Array(other.positions.length / 3 * 4);
              }
            }
            if (!this.matricesWeights !== !other.matricesWeights) {
              if (!this.matricesWeights) {
                this.matricesWeights = new Float32Array(this.positions.length / 3 * 4);
              } else {
                other.matricesWeights = new Float32Array(other.positions.length / 3 * 4);
              }
            }
            if (!this.matricesIndicesExtra !== !other.matricesIndicesExtra) {
              if (!this.matricesIndicesExtra) {
                this.matricesIndicesExtra = new Float32Array(this.positions.length / 3 * 4);
              } else {
                other.matricesIndicesExtra = new Float32Array(other.positions.length / 3 * 4);
              }
            }
            if (!this.matricesWeightsExtra !== !other.matricesWeightsExtra) {
              if (!this.matricesWeightsExtra) {
                this.matricesWeightsExtra = new Float32Array(this.positions.length / 3 * 4);
              } else {
                other.matricesWeightsExtra = new Float32Array(other.positions.length / 3 * 4);
              }
            }
          }
        }
        if (mergeMaterialIds) {
          let materialIndex = 0;
          let indexOffset = 0;
          let vertexOffset = 0;
          const materialInfos = [];
          let currentMaterialInfo = null;
          const vertexDataList = [];
          for (const split of this.splitBasedOnMaterialID()) {
            vertexDataList.push({ vertexData: split, transform });
          }
          for (const data of vertexDatas) {
            if (!data.vertexData) {
              continue;
            }
            for (const split of data.vertexData.splitBasedOnMaterialID()) {
              vertexDataList.push({ vertexData: split, transform: data.transform });
            }
          }
          vertexDataList.sort((a, b) => {
            const matInfoA = a.vertexData.materialInfos ? a.vertexData.materialInfos[0].materialIndex : 0;
            const matInfoB = b.vertexData.materialInfos ? b.vertexData.materialInfos[0].materialIndex : 0;
            if (matInfoA > matInfoB) {
              return 1;
            }
            if (matInfoA === matInfoB) {
              return 0;
            }
            return -1;
          });
          for (const vertexDataSource of vertexDataList) {
            const vertexData = vertexDataSource.vertexData;
            if (vertexData.materialInfos) {
              materialIndex = vertexData.materialInfos[0].materialIndex;
            } else {
              materialIndex = 0;
            }
            if (currentMaterialInfo && currentMaterialInfo.materialIndex === materialIndex) {
              currentMaterialInfo.indexCount += vertexData.indices.length;
              currentMaterialInfo.verticesCount += vertexData.positions.length / 3;
            } else {
              const materialInfo = new VertexDataMaterialInfo();
              materialInfo.materialIndex = materialIndex;
              materialInfo.indexStart = indexOffset;
              materialInfo.indexCount = vertexData.indices.length;
              materialInfo.verticesStart = vertexOffset;
              materialInfo.verticesCount = vertexData.positions.length / 3;
              materialInfos.push(materialInfo);
              currentMaterialInfo = materialInfo;
            }
            indexOffset += vertexData.indices.length;
            vertexOffset += vertexData.positions.length / 3;
          }
          const first = vertexDataList.splice(0, 1)[0];
          root = first.vertexData;
          transform = first.transform;
          others = vertexDataList.map((v) => v.vertexData);
          vertexDatas = vertexDataList;
          this.materialInfos = materialInfos;
        }
        const totalIndices = others.reduce((indexSum, vertexData) => {
          var _a2, _b2;
          return indexSum + ((_b2 = (_a2 = vertexData.indices) === null || _a2 === void 0 ? void 0 : _a2.length) !== null && _b2 !== void 0 ? _b2 : 0);
        }, (_b = (_a = root.indices) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0);
        const sliceIndices = forceCloneIndices || others.some((vertexData) => vertexData.indices === root.indices);
        let indices = sliceIndices ? (_c = root.indices) === null || _c === void 0 ? void 0 : _c.slice() : root.indices;
        if (totalIndices > 0) {
          let indicesOffset = (_d = indices === null || indices === void 0 ? void 0 : indices.length) !== null && _d !== void 0 ? _d : 0;
          if (!indices) {
            indices = new Array(totalIndices);
          }
          if (indices.length !== totalIndices) {
            if (Array.isArray(indices)) {
              indices.length = totalIndices;
            } else {
              const temp = use32BitsIndices || indices instanceof Uint32Array ? new Uint32Array(totalIndices) : new Uint16Array(totalIndices);
              temp.set(indices);
              indices = temp;
            }
            if (transform && transform.determinant() < 0) {
              VertexData._FlipFaces(indices, 0, indicesOffset);
            }
          }
          let positionsOffset = root.positions ? root.positions.length / 3 : 0;
          for (const { vertexData: other, transform: transform2 } of vertexDatas) {
            if (other.indices) {
              for (let index = 0; index < other.indices.length; index++) {
                indices[indicesOffset + index] = other.indices[index] + positionsOffset;
              }
              if (transform2 && transform2.determinant() < 0) {
                VertexData._FlipFaces(indices, indicesOffset, other.indices.length);
              }
              positionsOffset += other.positions.length / 3;
              indicesOffset += other.indices.length;
              if (isAsync) {
                yield;
              }
            }
          }
        }
        this.indices = indices;
        this.positions = VertexData._MergeElement(VertexBuffer.PositionKind, root.positions, transform, vertexDatas.map((other) => [other.vertexData.positions, other.transform]));
        if (isAsync) {
          yield;
        }
        if (root.normals) {
          this.normals = VertexData._MergeElement(VertexBuffer.NormalKind, root.normals, transform, vertexDatas.map((other) => [other.vertexData.normals, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.tangents) {
          this.tangents = VertexData._MergeElement(VertexBuffer.TangentKind, root.tangents, transform, vertexDatas.map((other) => [other.vertexData.tangents, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.uvs) {
          this.uvs = VertexData._MergeElement(VertexBuffer.UVKind, root.uvs, transform, vertexDatas.map((other) => [other.vertexData.uvs, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.uvs2) {
          this.uvs2 = VertexData._MergeElement(VertexBuffer.UV2Kind, root.uvs2, transform, vertexDatas.map((other) => [other.vertexData.uvs2, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.uvs3) {
          this.uvs3 = VertexData._MergeElement(VertexBuffer.UV3Kind, root.uvs3, transform, vertexDatas.map((other) => [other.vertexData.uvs3, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.uvs4) {
          this.uvs4 = VertexData._MergeElement(VertexBuffer.UV4Kind, root.uvs4, transform, vertexDatas.map((other) => [other.vertexData.uvs4, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.uvs5) {
          this.uvs5 = VertexData._MergeElement(VertexBuffer.UV5Kind, root.uvs5, transform, vertexDatas.map((other) => [other.vertexData.uvs5, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.uvs6) {
          this.uvs6 = VertexData._MergeElement(VertexBuffer.UV6Kind, root.uvs6, transform, vertexDatas.map((other) => [other.vertexData.uvs6, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.colors) {
          this.colors = VertexData._MergeElement(VertexBuffer.ColorKind, root.colors, transform, vertexDatas.map((other) => [other.vertexData.colors, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.matricesIndices) {
          this.matricesIndices = VertexData._MergeElement(VertexBuffer.MatricesIndicesKind, root.matricesIndices, transform, vertexDatas.map((other) => [other.vertexData.matricesIndices, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.matricesWeights) {
          this.matricesWeights = VertexData._MergeElement(VertexBuffer.MatricesWeightsKind, root.matricesWeights, transform, vertexDatas.map((other) => [other.vertexData.matricesWeights, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.matricesIndicesExtra) {
          this.matricesIndicesExtra = VertexData._MergeElement(VertexBuffer.MatricesIndicesExtraKind, root.matricesIndicesExtra, transform, vertexDatas.map((other) => [other.vertexData.matricesIndicesExtra, other.transform]));
          if (isAsync) {
            yield;
          }
        }
        if (root.matricesWeightsExtra) {
          this.matricesWeightsExtra = VertexData._MergeElement(VertexBuffer.MatricesWeightsExtraKind, root.matricesWeightsExtra, transform, vertexDatas.map((other) => [other.vertexData.matricesWeightsExtra, other.transform]));
        }
        return this;
      }
      static _MergeElement(kind, source, transform, others) {
        const nonNullOthers = others.filter((other) => other[0] !== null && other[0] !== void 0);
        if (!source && nonNullOthers.length == 0) {
          return source;
        }
        if (!source) {
          return this._MergeElement(kind, nonNullOthers[0][0], nonNullOthers[0][1], nonNullOthers.slice(1));
        }
        const len = nonNullOthers.reduce((sumLen, elements) => sumLen + elements[0].length, source.length);
        const transformRange = kind === VertexBuffer.PositionKind ? VertexData._TransformVector3Coordinates : kind === VertexBuffer.NormalKind ? VertexData._TransformVector3Normals : kind === VertexBuffer.TangentKind ? VertexData._TransformVector4Normals : () => {
        };
        if (source instanceof Float32Array) {
          const ret32 = new Float32Array(len);
          ret32.set(source);
          transform && transformRange(ret32, transform, 0, source.length);
          let offset = source.length;
          for (const [vertexData, transform2] of nonNullOthers) {
            ret32.set(vertexData, offset);
            transform2 && transformRange(ret32, transform2, offset, vertexData.length);
            offset += vertexData.length;
          }
          return ret32;
        } else {
          const ret = new Array(len);
          for (let i = 0; i < source.length; i++) {
            ret[i] = source[i];
          }
          transform && transformRange(ret, transform, 0, source.length);
          let offset = source.length;
          for (const [vertexData, transform2] of nonNullOthers) {
            for (let i = 0; i < vertexData.length; i++) {
              ret[offset + i] = vertexData[i];
            }
            transform2 && transformRange(ret, transform2, offset, vertexData.length);
            offset += vertexData.length;
          }
          return ret;
        }
      }
      _validate() {
        if (!this.positions) {
          throw new RuntimeError("Positions are required", ErrorCodes.MeshInvalidPositionsError);
        }
        const getElementCount = (kind, values) => {
          const stride = VertexBuffer.DeduceStride(kind);
          if (values.length % stride !== 0) {
            throw new Error("The " + kind + "s array count must be a multiple of " + stride);
          }
          return values.length / stride;
        };
        const positionsElementCount = getElementCount(VertexBuffer.PositionKind, this.positions);
        const validateElementCount = (kind, values) => {
          const elementCount = getElementCount(kind, values);
          if (elementCount !== positionsElementCount) {
            throw new Error("The " + kind + "s element count (" + elementCount + ") does not match the positions count (" + positionsElementCount + ")");
          }
        };
        if (this.normals) {
          validateElementCount(VertexBuffer.NormalKind, this.normals);
        }
        if (this.tangents) {
          validateElementCount(VertexBuffer.TangentKind, this.tangents);
        }
        if (this.uvs) {
          validateElementCount(VertexBuffer.UVKind, this.uvs);
        }
        if (this.uvs2) {
          validateElementCount(VertexBuffer.UV2Kind, this.uvs2);
        }
        if (this.uvs3) {
          validateElementCount(VertexBuffer.UV3Kind, this.uvs3);
        }
        if (this.uvs4) {
          validateElementCount(VertexBuffer.UV4Kind, this.uvs4);
        }
        if (this.uvs5) {
          validateElementCount(VertexBuffer.UV5Kind, this.uvs5);
        }
        if (this.uvs6) {
          validateElementCount(VertexBuffer.UV6Kind, this.uvs6);
        }
        if (this.colors) {
          validateElementCount(VertexBuffer.ColorKind, this.colors);
        }
        if (this.matricesIndices) {
          validateElementCount(VertexBuffer.MatricesIndicesKind, this.matricesIndices);
        }
        if (this.matricesWeights) {
          validateElementCount(VertexBuffer.MatricesWeightsKind, this.matricesWeights);
        }
        if (this.matricesIndicesExtra) {
          validateElementCount(VertexBuffer.MatricesIndicesExtraKind, this.matricesIndicesExtra);
        }
        if (this.matricesWeightsExtra) {
          validateElementCount(VertexBuffer.MatricesWeightsExtraKind, this.matricesWeightsExtra);
        }
      }
      clone() {
        const serializationObject = this.serialize();
        return VertexData.Parse(serializationObject);
      }
      serialize() {
        const serializationObject = {};
        if (this.positions) {
          serializationObject.positions = Array.from(this.positions);
        }
        if (this.normals) {
          serializationObject.normals = Array.from(this.normals);
        }
        if (this.tangents) {
          serializationObject.tangents = Array.from(this.tangents);
        }
        if (this.uvs) {
          serializationObject.uvs = Array.from(this.uvs);
        }
        if (this.uvs2) {
          serializationObject.uvs2 = Array.from(this.uvs2);
        }
        if (this.uvs3) {
          serializationObject.uvs3 = Array.from(this.uvs3);
        }
        if (this.uvs4) {
          serializationObject.uvs4 = Array.from(this.uvs4);
        }
        if (this.uvs5) {
          serializationObject.uvs5 = Array.from(this.uvs5);
        }
        if (this.uvs6) {
          serializationObject.uvs6 = Array.from(this.uvs6);
        }
        if (this.colors) {
          serializationObject.colors = Array.from(this.colors);
        }
        if (this.matricesIndices) {
          serializationObject.matricesIndices = Array.from(this.matricesIndices);
          serializationObject.matricesIndices._isExpanded = true;
        }
        if (this.matricesWeights) {
          serializationObject.matricesWeights = Array.from(this.matricesWeights);
        }
        if (this.matricesIndicesExtra) {
          serializationObject.matricesIndicesExtra = Array.from(this.matricesIndicesExtra);
          serializationObject.matricesIndicesExtra._isExpanded = true;
        }
        if (this.matricesWeightsExtra) {
          serializationObject.matricesWeightsExtra = Array.from(this.matricesWeightsExtra);
        }
        serializationObject.indices = Array.from(this.indices);
        if (this.materialInfos) {
          serializationObject.materialInfos = [];
          for (const materialInfo of this.materialInfos) {
            const materialInfoSerializationObject = {
              indexStart: materialInfo.indexStart,
              indexCount: materialInfo.indexCount,
              materialIndex: materialInfo.materialIndex,
              verticesStart: materialInfo.verticesStart,
              verticesCount: materialInfo.verticesCount
            };
            serializationObject.materialInfos.push(materialInfoSerializationObject);
          }
        }
        return serializationObject;
      }
      static ExtractFromMesh(mesh, copyWhenShared, forceCopy) {
        return VertexData._ExtractFrom(mesh, copyWhenShared, forceCopy);
      }
      static ExtractFromGeometry(geometry, copyWhenShared, forceCopy) {
        return VertexData._ExtractFrom(geometry, copyWhenShared, forceCopy);
      }
      static _ExtractFrom(meshOrGeometry, copyWhenShared, forceCopy) {
        const result = new VertexData();
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          result.positions = meshOrGeometry.getVerticesData(VertexBuffer.PositionKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          result.normals = meshOrGeometry.getVerticesData(VertexBuffer.NormalKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          result.tangents = meshOrGeometry.getVerticesData(VertexBuffer.TangentKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UVKind)) {
          result.uvs = meshOrGeometry.getVerticesData(VertexBuffer.UVKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          result.uvs2 = meshOrGeometry.getVerticesData(VertexBuffer.UV2Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
          result.uvs3 = meshOrGeometry.getVerticesData(VertexBuffer.UV3Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
          result.uvs4 = meshOrGeometry.getVerticesData(VertexBuffer.UV4Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
          result.uvs5 = meshOrGeometry.getVerticesData(VertexBuffer.UV5Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
          result.uvs6 = meshOrGeometry.getVerticesData(VertexBuffer.UV6Kind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          result.colors = meshOrGeometry.getVerticesData(VertexBuffer.ColorKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          result.matricesIndices = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          result.matricesWeights = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesIndicesExtraKind)) {
          result.matricesIndicesExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesIndicesExtraKind, copyWhenShared, forceCopy);
        }
        if (meshOrGeometry.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
          result.matricesWeightsExtra = meshOrGeometry.getVerticesData(VertexBuffer.MatricesWeightsExtraKind, copyWhenShared, forceCopy);
        }
        result.indices = meshOrGeometry.getIndices(copyWhenShared, forceCopy);
        return result;
      }
      static CreateRibbon(options) {
        throw _WarnImport("ribbonBuilder");
      }
      static CreateBox(options) {
        throw _WarnImport("boxBuilder");
      }
      static CreateTiledBox(options) {
        throw _WarnImport("tiledBoxBuilder");
      }
      static CreateTiledPlane(options) {
        throw _WarnImport("tiledPlaneBuilder");
      }
      static CreateSphere(options) {
        throw _WarnImport("sphereBuilder");
      }
      static CreateCylinder(options) {
        throw _WarnImport("cylinderBuilder");
      }
      static CreateTorus(options) {
        throw _WarnImport("torusBuilder");
      }
      static CreateLineSystem(options) {
        throw _WarnImport("linesBuilder");
      }
      static CreateDashedLines(options) {
        throw _WarnImport("linesBuilder");
      }
      static CreateGround(options) {
        throw _WarnImport("groundBuilder");
      }
      static CreateTiledGround(options) {
        throw _WarnImport("groundBuilder");
      }
      static CreateGroundFromHeightMap(options) {
        throw _WarnImport("groundBuilder");
      }
      static CreatePlane(options) {
        throw _WarnImport("planeBuilder");
      }
      static CreateDisc(options) {
        throw _WarnImport("discBuilder");
      }
      static CreatePolygon(polygon, sideOrientation, fUV, fColors, frontUVs, backUVs, wrap) {
        throw _WarnImport("polygonBuilder");
      }
      static CreateIcoSphere(options) {
        throw _WarnImport("icoSphereBuilder");
      }
      static CreatePolyhedron(options) {
        throw _WarnImport("polyhedronBuilder");
      }
      static CreateCapsule(options = {
        orientation: Vector3.Up(),
        subdivisions: 2,
        tessellation: 16,
        height: 1,
        radius: 0.25,
        capSubdivisions: 6
      }) {
        throw _WarnImport("capsuleBuilder");
      }
      static CreateTorusKnot(options) {
        throw _WarnImport("torusKnotBuilder");
      }
      static ComputeNormals(positions, indices, normals, options) {
        let index = 0;
        let p1p2x = 0;
        let p1p2y = 0;
        let p1p2z = 0;
        let p3p2x = 0;
        let p3p2y = 0;
        let p3p2z = 0;
        let faceNormalx = 0;
        let faceNormaly = 0;
        let faceNormalz = 0;
        let length = 0;
        let v1x = 0;
        let v1y = 0;
        let v1z = 0;
        let v2x = 0;
        let v2y = 0;
        let v2z = 0;
        let v3x = 0;
        let v3y = 0;
        let v3z = 0;
        let computeFacetNormals = false;
        let computeFacetPositions = false;
        let computeFacetPartitioning = false;
        let computeDepthSort = false;
        let faceNormalSign = 1;
        let ratio = 0;
        let distanceTo = null;
        if (options) {
          computeFacetNormals = options.facetNormals ? true : false;
          computeFacetPositions = options.facetPositions ? true : false;
          computeFacetPartitioning = options.facetPartitioning ? true : false;
          faceNormalSign = options.useRightHandedSystem === true ? -1 : 1;
          ratio = options.ratio || 0;
          computeDepthSort = options.depthSort ? true : false;
          distanceTo = options.distanceTo;
          if (computeDepthSort) {
            if (distanceTo === void 0) {
              distanceTo = Vector3.Zero();
            }
          }
        }
        let xSubRatio = 0;
        let ySubRatio = 0;
        let zSubRatio = 0;
        let subSq = 0;
        if (computeFacetPartitioning && options && options.bbSize) {
          xSubRatio = options.subDiv.X * ratio / options.bbSize.x;
          ySubRatio = options.subDiv.Y * ratio / options.bbSize.y;
          zSubRatio = options.subDiv.Z * ratio / options.bbSize.z;
          subSq = options.subDiv.max * options.subDiv.max;
          options.facetPartitioning.length = 0;
        }
        for (index = 0; index < positions.length; index++) {
          normals[index] = 0;
        }
        const nbFaces = indices.length / 3 | 0;
        for (index = 0; index < nbFaces; index++) {
          v1x = indices[index * 3] * 3;
          v1y = v1x + 1;
          v1z = v1x + 2;
          v2x = indices[index * 3 + 1] * 3;
          v2y = v2x + 1;
          v2z = v2x + 2;
          v3x = indices[index * 3 + 2] * 3;
          v3y = v3x + 1;
          v3z = v3x + 2;
          p1p2x = positions[v1x] - positions[v2x];
          p1p2y = positions[v1y] - positions[v2y];
          p1p2z = positions[v1z] - positions[v2z];
          p3p2x = positions[v3x] - positions[v2x];
          p3p2y = positions[v3y] - positions[v2y];
          p3p2z = positions[v3z] - positions[v2z];
          faceNormalx = faceNormalSign * (p1p2y * p3p2z - p1p2z * p3p2y);
          faceNormaly = faceNormalSign * (p1p2z * p3p2x - p1p2x * p3p2z);
          faceNormalz = faceNormalSign * (p1p2x * p3p2y - p1p2y * p3p2x);
          length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
          length = length === 0 ? 1 : length;
          faceNormalx /= length;
          faceNormaly /= length;
          faceNormalz /= length;
          if (computeFacetNormals && options) {
            options.facetNormals[index].x = faceNormalx;
            options.facetNormals[index].y = faceNormaly;
            options.facetNormals[index].z = faceNormalz;
          }
          if (computeFacetPositions && options) {
            options.facetPositions[index].x = (positions[v1x] + positions[v2x] + positions[v3x]) / 3;
            options.facetPositions[index].y = (positions[v1y] + positions[v2y] + positions[v3y]) / 3;
            options.facetPositions[index].z = (positions[v1z] + positions[v2z] + positions[v3z]) / 3;
          }
          if (computeFacetPartitioning && options) {
            const ox = Math.floor((options.facetPositions[index].x - options.bInfo.minimum.x * ratio) * xSubRatio);
            const oy = Math.floor((options.facetPositions[index].y - options.bInfo.minimum.y * ratio) * ySubRatio);
            const oz = Math.floor((options.facetPositions[index].z - options.bInfo.minimum.z * ratio) * zSubRatio);
            const b1x = Math.floor((positions[v1x] - options.bInfo.minimum.x * ratio) * xSubRatio);
            const b1y = Math.floor((positions[v1y] - options.bInfo.minimum.y * ratio) * ySubRatio);
            const b1z = Math.floor((positions[v1z] - options.bInfo.minimum.z * ratio) * zSubRatio);
            const b2x = Math.floor((positions[v2x] - options.bInfo.minimum.x * ratio) * xSubRatio);
            const b2y = Math.floor((positions[v2y] - options.bInfo.minimum.y * ratio) * ySubRatio);
            const b2z = Math.floor((positions[v2z] - options.bInfo.minimum.z * ratio) * zSubRatio);
            const b3x = Math.floor((positions[v3x] - options.bInfo.minimum.x * ratio) * xSubRatio);
            const b3y = Math.floor((positions[v3y] - options.bInfo.minimum.y * ratio) * ySubRatio);
            const b3z = Math.floor((positions[v3z] - options.bInfo.minimum.z * ratio) * zSubRatio);
            const block_idx_v1 = b1x + options.subDiv.max * b1y + subSq * b1z;
            const block_idx_v2 = b2x + options.subDiv.max * b2y + subSq * b2z;
            const block_idx_v3 = b3x + options.subDiv.max * b3y + subSq * b3z;
            const block_idx_o = ox + options.subDiv.max * oy + subSq * oz;
            options.facetPartitioning[block_idx_o] = options.facetPartitioning[block_idx_o] ? options.facetPartitioning[block_idx_o] : new Array();
            options.facetPartitioning[block_idx_v1] = options.facetPartitioning[block_idx_v1] ? options.facetPartitioning[block_idx_v1] : new Array();
            options.facetPartitioning[block_idx_v2] = options.facetPartitioning[block_idx_v2] ? options.facetPartitioning[block_idx_v2] : new Array();
            options.facetPartitioning[block_idx_v3] = options.facetPartitioning[block_idx_v3] ? options.facetPartitioning[block_idx_v3] : new Array();
            options.facetPartitioning[block_idx_v1].push(index);
            if (block_idx_v2 != block_idx_v1) {
              options.facetPartitioning[block_idx_v2].push(index);
            }
            if (!(block_idx_v3 == block_idx_v2 || block_idx_v3 == block_idx_v1)) {
              options.facetPartitioning[block_idx_v3].push(index);
            }
            if (!(block_idx_o == block_idx_v1 || block_idx_o == block_idx_v2 || block_idx_o == block_idx_v3)) {
              options.facetPartitioning[block_idx_o].push(index);
            }
          }
          if (computeDepthSort && options && options.facetPositions) {
            const dsf = options.depthSortedFacets[index];
            dsf.ind = index * 3;
            dsf.sqDistance = Vector3.DistanceSquared(options.facetPositions[index], distanceTo);
          }
          normals[v1x] += faceNormalx;
          normals[v1y] += faceNormaly;
          normals[v1z] += faceNormalz;
          normals[v2x] += faceNormalx;
          normals[v2y] += faceNormaly;
          normals[v2z] += faceNormalz;
          normals[v3x] += faceNormalx;
          normals[v3y] += faceNormaly;
          normals[v3z] += faceNormalz;
        }
        for (index = 0; index < normals.length / 3; index++) {
          faceNormalx = normals[index * 3];
          faceNormaly = normals[index * 3 + 1];
          faceNormalz = normals[index * 3 + 2];
          length = Math.sqrt(faceNormalx * faceNormalx + faceNormaly * faceNormaly + faceNormalz * faceNormalz);
          length = length === 0 ? 1 : length;
          faceNormalx /= length;
          faceNormaly /= length;
          faceNormalz /= length;
          normals[index * 3] = faceNormalx;
          normals[index * 3 + 1] = faceNormaly;
          normals[index * 3 + 2] = faceNormalz;
        }
      }
      static _ComputeSides(sideOrientation, positions, indices, normals, uvs, frontUVs, backUVs) {
        const li = indices.length;
        const ln = normals.length;
        let i;
        let n;
        sideOrientation = sideOrientation || VertexData.DEFAULTSIDE;
        switch (sideOrientation) {
          case VertexData.FRONTSIDE:
            break;
          case VertexData.BACKSIDE:
            for (i = 0; i < li; i += 3) {
              const tmp = indices[i];
              indices[i] = indices[i + 2];
              indices[i + 2] = tmp;
            }
            for (n = 0; n < ln; n++) {
              normals[n] = -normals[n];
            }
            break;
          case VertexData.DOUBLESIDE: {
            const lp = positions.length;
            const l = lp / 3;
            for (let p = 0; p < lp; p++) {
              positions[lp + p] = positions[p];
            }
            for (i = 0; i < li; i += 3) {
              indices[i + li] = indices[i + 2] + l;
              indices[i + 1 + li] = indices[i + 1] + l;
              indices[i + 2 + li] = indices[i] + l;
            }
            for (n = 0; n < ln; n++) {
              normals[ln + n] = -normals[n];
            }
            const lu = uvs.length;
            let u = 0;
            for (u = 0; u < lu; u++) {
              uvs[u + lu] = uvs[u];
            }
            frontUVs = frontUVs ? frontUVs : new Vector4(0, 0, 1, 1);
            backUVs = backUVs ? backUVs : new Vector4(0, 0, 1, 1);
            u = 0;
            for (i = 0; i < lu / 2; i++) {
              uvs[u] = frontUVs.x + (frontUVs.z - frontUVs.x) * uvs[u];
              uvs[u + 1] = frontUVs.y + (frontUVs.w - frontUVs.y) * uvs[u + 1];
              uvs[u + lu] = backUVs.x + (backUVs.z - backUVs.x) * uvs[u + lu];
              uvs[u + lu + 1] = backUVs.y + (backUVs.w - backUVs.y) * uvs[u + lu + 1];
              u += 2;
            }
            break;
          }
        }
      }
      static Parse(parsedVertexData) {
        const vertexData = new VertexData();
        const positions = parsedVertexData.positions;
        if (positions) {
          vertexData.set(positions, VertexBuffer.PositionKind);
        }
        const normals = parsedVertexData.normals;
        if (normals) {
          vertexData.set(normals, VertexBuffer.NormalKind);
        }
        const tangents = parsedVertexData.tangents;
        if (tangents) {
          vertexData.set(tangents, VertexBuffer.TangentKind);
        }
        const uvs = parsedVertexData.uvs;
        if (uvs) {
          vertexData.set(uvs, VertexBuffer.UVKind);
        }
        const uvs2 = parsedVertexData.uvs2;
        if (uvs2) {
          vertexData.set(uvs2, VertexBuffer.UV2Kind);
        }
        const uvs3 = parsedVertexData.uvs3;
        if (uvs3) {
          vertexData.set(uvs3, VertexBuffer.UV3Kind);
        }
        const uvs4 = parsedVertexData.uvs4;
        if (uvs4) {
          vertexData.set(uvs4, VertexBuffer.UV4Kind);
        }
        const uvs5 = parsedVertexData.uvs5;
        if (uvs5) {
          vertexData.set(uvs5, VertexBuffer.UV5Kind);
        }
        const uvs6 = parsedVertexData.uvs6;
        if (uvs6) {
          vertexData.set(uvs6, VertexBuffer.UV6Kind);
        }
        const colors = parsedVertexData.colors;
        if (colors) {
          vertexData.set(Color4.CheckColors4(colors, positions.length / 3), VertexBuffer.ColorKind);
        }
        const matricesIndices = parsedVertexData.matricesIndices;
        if (matricesIndices) {
          vertexData.set(matricesIndices, VertexBuffer.MatricesIndicesKind);
        }
        const matricesWeights = parsedVertexData.matricesWeights;
        if (matricesWeights) {
          vertexData.set(matricesWeights, VertexBuffer.MatricesWeightsKind);
        }
        const indices = parsedVertexData.indices;
        if (indices) {
          vertexData.indices = indices;
        }
        const materialInfos = parsedVertexData.materialInfos;
        if (materialInfos) {
          vertexData.materialInfos = [];
          for (const materialInfoFromJSON of materialInfos) {
            const materialInfo = new VertexDataMaterialInfo();
            materialInfo.indexCount = materialInfoFromJSON.indexCount;
            materialInfo.indexStart = materialInfoFromJSON.indexStart;
            materialInfo.verticesCount = materialInfoFromJSON.verticesCount;
            materialInfo.verticesStart = materialInfoFromJSON.verticesStart;
            materialInfo.materialIndex = materialInfoFromJSON.materialIndex;
            vertexData.materialInfos.push(materialInfo);
          }
        }
        return vertexData;
      }
      static ImportVertexData(parsedVertexData, geometry) {
        const vertexData = VertexData.Parse(parsedVertexData);
        geometry.setAllVerticesData(vertexData, parsedVertexData.updatable);
      }
    };
    VertexData.FRONTSIDE = 0;
    VertexData.BACKSIDE = 1;
    VertexData.DOUBLESIDE = 2;
    VertexData.DEFAULTSIDE = 0;
    VertexData._UniqueIDGenerator = 0;
    __decorate([
      nativeOverride.filter((...[coordinates]) => !Array.isArray(coordinates))
    ], VertexData, "_TransformVector3Coordinates", null);
    __decorate([
      nativeOverride.filter((...[normals]) => !Array.isArray(normals))
    ], VertexData, "_TransformVector3Normals", null);
    __decorate([
      nativeOverride.filter((...[normals]) => !Array.isArray(normals))
    ], VertexData, "_TransformVector4Normals", null);
    __decorate([
      nativeOverride.filter((...[indices]) => !Array.isArray(indices))
    ], VertexData, "_FlipFaces", null);
  }
});

// node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js
var SceneLoaderFlags;
var init_sceneLoaderFlags = __esm({
  "node_modules/@babylonjs/core/Loading/sceneLoaderFlags.js"() {
    SceneLoaderFlags = class {
      static get ForceFullSceneLoadingForIncremental() {
        return SceneLoaderFlags._ForceFullSceneLoadingForIncremental;
      }
      static set ForceFullSceneLoadingForIncremental(value) {
        SceneLoaderFlags._ForceFullSceneLoadingForIncremental = value;
      }
      static get ShowLoadingScreen() {
        return SceneLoaderFlags._ShowLoadingScreen;
      }
      static set ShowLoadingScreen(value) {
        SceneLoaderFlags._ShowLoadingScreen = value;
      }
      static get loggingLevel() {
        return SceneLoaderFlags._LoggingLevel;
      }
      static set loggingLevel(value) {
        SceneLoaderFlags._LoggingLevel = value;
      }
      static get CleanBoneMatrixWeights() {
        return SceneLoaderFlags._CleanBoneMatrixWeights;
      }
      static set CleanBoneMatrixWeights(value) {
        SceneLoaderFlags._CleanBoneMatrixWeights = value;
      }
    };
    SceneLoaderFlags._ForceFullSceneLoadingForIncremental = false;
    SceneLoaderFlags._ShowLoadingScreen = true;
    SceneLoaderFlags._CleanBoneMatrixWeights = false;
    SceneLoaderFlags._LoggingLevel = 0;
  }
});

// node_modules/@babylonjs/core/Compat/compatibilityOptions.js
var CompatibilityOptions;
var init_compatibilityOptions = __esm({
  "node_modules/@babylonjs/core/Compat/compatibilityOptions.js"() {
    CompatibilityOptions = class {
    };
    CompatibilityOptions.UseOpenGLOrientationForUV = false;
  }
});

// node_modules/@babylonjs/core/Meshes/geometry.js
var Geometry;
var init_geometry = __esm({
  "node_modules/@babylonjs/core/Meshes/geometry.js"() {
    init_math_vector();
    init_math_color();
    init_mesh_vertexData();
    init_buffer();
    init_subMesh();
    init_sceneLoaderFlags();
    init_boundingInfo();
    init_tools();
    init_tags();
    init_math_functions();
    init_engineStore();
    init_compatibilityOptions();
    Geometry = class {
      get boundingBias() {
        return this._boundingBias;
      }
      set boundingBias(value) {
        if (this._boundingBias) {
          this._boundingBias.copyFrom(value);
        } else {
          this._boundingBias = value.clone();
        }
        this._updateBoundingInfo(true, null);
      }
      static CreateGeometryForMesh(mesh) {
        const geometry = new Geometry(Geometry.RandomId(), mesh.getScene());
        geometry.applyToMesh(mesh);
        return geometry;
      }
      get meshes() {
        return this._meshes;
      }
      constructor(id, scene, vertexData, updatable = false, mesh = null) {
        this.delayLoadState = 0;
        this._totalVertices = 0;
        this._isDisposed = false;
        this._indexBufferIsUpdatable = false;
        this._positionsCache = [];
        this._parentContainer = null;
        this.useBoundingInfoFromGeometry = false;
        this._scene = scene || EngineStore.LastCreatedScene;
        if (!this._scene) {
          return;
        }
        this.id = id;
        this.uniqueId = this._scene.getUniqueId();
        this._engine = this._scene.getEngine();
        this._meshes = [];
        this._vertexBuffers = {};
        this._indices = [];
        this._updatable = updatable;
        if (vertexData) {
          this.setAllVerticesData(vertexData, updatable);
        } else {
          this._totalVertices = 0;
        }
        if (this._engine.getCaps().vertexArrayObject) {
          this._vertexArrayObjects = {};
        }
        if (mesh) {
          this.applyToMesh(mesh);
          mesh.computeWorldMatrix(true);
        }
      }
      get extend() {
        return this._extend;
      }
      getScene() {
        return this._scene;
      }
      getEngine() {
        return this._engine;
      }
      isReady() {
        return this.delayLoadState === 1 || this.delayLoadState === 0;
      }
      get doNotSerialize() {
        for (let index = 0; index < this._meshes.length; index++) {
          if (!this._meshes[index].doNotSerialize) {
            return false;
          }
        }
        return true;
      }
      _rebuild() {
        if (this._vertexArrayObjects) {
          this._vertexArrayObjects = {};
        }
        if (this._meshes.length !== 0 && this._indices) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
        }
        for (const key in this._vertexBuffers) {
          const vertexBuffer = this._vertexBuffers[key];
          vertexBuffer._rebuild();
        }
      }
      setAllVerticesData(vertexData, updatable) {
        vertexData.applyToGeometry(this, updatable);
        this._notifyUpdate();
      }
      setVerticesData(kind, data, updatable = false, stride) {
        if (updatable && Array.isArray(data)) {
          data = new Float32Array(data);
        }
        const buffer = new VertexBuffer(this._engine, data, kind, updatable, this._meshes.length === 0, stride);
        this.setVerticesBuffer(buffer);
      }
      removeVerticesData(kind) {
        if (this._vertexBuffers[kind]) {
          this._vertexBuffers[kind].dispose();
          delete this._vertexBuffers[kind];
        }
        if (this._vertexArrayObjects) {
          this._disposeVertexArrayObjects();
        }
      }
      setVerticesBuffer(buffer, totalVertices = null, disposeExistingBuffer = true) {
        const kind = buffer.getKind();
        if (this._vertexBuffers[kind] && disposeExistingBuffer) {
          this._vertexBuffers[kind].dispose();
        }
        if (buffer._buffer) {
          buffer._buffer._increaseReferences();
        }
        this._vertexBuffers[kind] = buffer;
        const meshes = this._meshes;
        const numOfMeshes = meshes.length;
        if (kind === VertexBuffer.PositionKind) {
          const data = buffer.getData();
          if (totalVertices != null) {
            this._totalVertices = totalVertices;
          } else {
            if (data != null) {
              this._totalVertices = data.length / (buffer.type === VertexBuffer.BYTE ? buffer.byteStride : buffer.byteStride / 4);
            }
          }
          this._updateExtend(data);
          this._resetPointsArrayCache();
          for (let index = 0; index < numOfMeshes; index++) {
            const mesh = meshes[index];
            mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            mesh._createGlobalSubMesh(mesh.isUnIndexed);
            mesh.computeWorldMatrix(true);
            mesh.synchronizeInstances();
          }
        }
        this._notifyUpdate(kind);
      }
      updateVerticesDataDirectly(kind, data, offset, useBytes = false) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexBuffer.updateDirectly(data, offset, useBytes);
        this._notifyUpdate(kind);
      }
      updateVerticesData(kind, data, updateExtends = false) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return;
        }
        vertexBuffer.update(data);
        if (kind === VertexBuffer.PositionKind) {
          this._updateBoundingInfo(updateExtends, data);
        }
        this._notifyUpdate(kind);
      }
      _updateBoundingInfo(updateExtends, data) {
        if (updateExtends) {
          this._updateExtend(data);
        }
        this._resetPointsArrayCache();
        if (updateExtends) {
          const meshes = this._meshes;
          for (const mesh of meshes) {
            if (mesh.hasBoundingInfo) {
              mesh.getBoundingInfo().reConstruct(this._extend.minimum, this._extend.maximum);
            } else {
              mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            }
            const subMeshes = mesh.subMeshes;
            for (const subMesh of subMeshes) {
              subMesh.refreshBoundingInfo();
            }
          }
        }
      }
      _bind(effect, indexToBind, overrideVertexBuffers, overrideVertexArrayObjects) {
        if (!effect) {
          return;
        }
        if (indexToBind === void 0) {
          indexToBind = this._indexBuffer;
        }
        const vbs = this.getVertexBuffers();
        if (!vbs) {
          return;
        }
        if (indexToBind != this._indexBuffer || !this._vertexArrayObjects && !overrideVertexArrayObjects) {
          this._engine.bindBuffers(vbs, indexToBind, effect, overrideVertexBuffers);
          return;
        }
        const vaos = overrideVertexArrayObjects ? overrideVertexArrayObjects : this._vertexArrayObjects;
        if (!vaos[effect.key]) {
          vaos[effect.key] = this._engine.recordVertexArrayObject(vbs, indexToBind, effect, overrideVertexBuffers);
        }
        this._engine.bindVertexArrayObject(vaos[effect.key], indexToBind);
      }
      getTotalVertices() {
        if (!this.isReady()) {
          return 0;
        }
        return this._totalVertices;
      }
      getVerticesData(kind, copyWhenShared, forceCopy) {
        const vertexBuffer = this.getVertexBuffer(kind);
        if (!vertexBuffer) {
          return null;
        }
        return vertexBuffer.getFloatData(this._totalVertices, forceCopy || copyWhenShared && this._meshes.length !== 1);
      }
      isVertexBufferUpdatable(kind) {
        const vb = this._vertexBuffers[kind];
        if (!vb) {
          return false;
        }
        return vb.isUpdatable();
      }
      getVertexBuffer(kind) {
        if (!this.isReady()) {
          return null;
        }
        return this._vertexBuffers[kind];
      }
      getVertexBuffers() {
        if (!this.isReady()) {
          return null;
        }
        return this._vertexBuffers;
      }
      isVerticesDataPresent(kind) {
        if (!this._vertexBuffers) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return this._vertexBuffers[kind] !== void 0;
      }
      getVerticesDataKinds() {
        const result = [];
        let kind;
        if (!this._vertexBuffers && this._delayInfo) {
          for (kind in this._delayInfo) {
            result.push(kind);
          }
        } else {
          for (kind in this._vertexBuffers) {
            result.push(kind);
          }
        }
        return result;
      }
      updateIndices(indices, offset, gpuMemoryOnly = false) {
        if (!this._indexBuffer) {
          return;
        }
        if (!this._indexBufferIsUpdatable) {
          this.setIndices(indices, null, true);
        } else {
          const needToUpdateSubMeshes = indices.length !== this._indices.length;
          if (!gpuMemoryOnly) {
            this._indices = indices.slice();
          }
          this._engine.updateDynamicIndexBuffer(this._indexBuffer, indices, offset);
          if (needToUpdateSubMeshes) {
            for (const mesh of this._meshes) {
              mesh._createGlobalSubMesh(true);
            }
          }
        }
      }
      setIndices(indices, totalVertices = null, updatable = false) {
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indices = indices;
        this._indexBufferIsUpdatable = updatable;
        if (this._meshes.length !== 0 && this._indices) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, updatable);
        }
        if (totalVertices != void 0) {
          this._totalVertices = totalVertices;
        }
        for (const mesh of this._meshes) {
          mesh._createGlobalSubMesh(true);
          mesh.synchronizeInstances();
        }
        this._notifyUpdate();
      }
      getTotalIndices() {
        if (!this.isReady()) {
          return 0;
        }
        return this._indices.length;
      }
      getIndices(copyWhenShared, forceCopy) {
        if (!this.isReady()) {
          return null;
        }
        const orig = this._indices;
        if (!forceCopy && (!copyWhenShared || this._meshes.length === 1)) {
          return orig;
        } else {
          return orig.slice();
        }
      }
      getIndexBuffer() {
        if (!this.isReady()) {
          return null;
        }
        return this._indexBuffer;
      }
      _releaseVertexArrayObject(effect = null) {
        if (!effect || !this._vertexArrayObjects) {
          return;
        }
        if (this._vertexArrayObjects[effect.key]) {
          this._engine.releaseVertexArrayObject(this._vertexArrayObjects[effect.key]);
          delete this._vertexArrayObjects[effect.key];
        }
      }
      releaseForMesh(mesh, shouldDispose) {
        const meshes = this._meshes;
        const index = meshes.indexOf(mesh);
        if (index === -1) {
          return;
        }
        meshes.splice(index, 1);
        if (this._vertexArrayObjects) {
          mesh._invalidateInstanceVertexArrayObject();
        }
        mesh._geometry = null;
        if (meshes.length === 0 && shouldDispose) {
          this.dispose();
        }
      }
      applyToMesh(mesh) {
        if (mesh._geometry === this) {
          return;
        }
        const previousGeometry = mesh._geometry;
        if (previousGeometry) {
          previousGeometry.releaseForMesh(mesh);
        }
        if (this._vertexArrayObjects) {
          mesh._invalidateInstanceVertexArrayObject();
        }
        const meshes = this._meshes;
        mesh._geometry = this;
        mesh._internalAbstractMeshDataInfo._positions = null;
        this._scene.pushGeometry(this);
        meshes.push(mesh);
        if (this.isReady()) {
          this._applyToMesh(mesh);
        } else if (this._boundingInfo) {
          mesh.setBoundingInfo(this._boundingInfo);
        }
      }
      _updateExtend(data = null) {
        if (this.useBoundingInfoFromGeometry && this._boundingInfo) {
          this._extend = {
            minimum: this._boundingInfo.minimum.clone(),
            maximum: this._boundingInfo.maximum.clone()
          };
        } else {
          if (!data) {
            data = this.getVerticesData(VertexBuffer.PositionKind);
            if (!data) {
              return;
            }
          }
          this._extend = extractMinAndMax(data, 0, this._totalVertices, this.boundingBias, 3);
        }
      }
      _applyToMesh(mesh) {
        const numOfMeshes = this._meshes.length;
        for (const kind in this._vertexBuffers) {
          if (numOfMeshes === 1) {
            this._vertexBuffers[kind].create();
          }
          if (kind === VertexBuffer.PositionKind) {
            if (!this._extend) {
              this._updateExtend();
            }
            mesh.buildBoundingInfo(this._extend.minimum, this._extend.maximum);
            mesh._createGlobalSubMesh(mesh.isUnIndexed);
            mesh._updateBoundingInfo();
          }
        }
        if (numOfMeshes === 1 && this._indices && this._indices.length > 0) {
          this._indexBuffer = this._engine.createIndexBuffer(this._indices, this._updatable);
        }
        mesh._syncGeometryWithMorphTargetManager();
        mesh.synchronizeInstances();
      }
      _notifyUpdate(kind) {
        if (this.onGeometryUpdated) {
          this.onGeometryUpdated(this, kind);
        }
        if (this._vertexArrayObjects) {
          this._disposeVertexArrayObjects();
        }
        for (const mesh of this._meshes) {
          mesh._markSubMeshesAsAttributesDirty();
        }
      }
      load(scene, onLoaded) {
        if (this.delayLoadState === 2) {
          return;
        }
        if (this.isReady()) {
          if (onLoaded) {
            onLoaded();
          }
          return;
        }
        this.delayLoadState = 2;
        this._queueLoad(scene, onLoaded);
      }
      _queueLoad(scene, onLoaded) {
        if (!this.delayLoadingFile) {
          return;
        }
        scene.addPendingData(this);
        scene._loadFile(this.delayLoadingFile, (data) => {
          if (!this._delayLoadingFunction) {
            return;
          }
          this._delayLoadingFunction(JSON.parse(data), this);
          this.delayLoadState = 1;
          this._delayInfo = [];
          scene.removePendingData(this);
          const meshes = this._meshes;
          const numOfMeshes = meshes.length;
          for (let index = 0; index < numOfMeshes; index++) {
            this._applyToMesh(meshes[index]);
          }
          if (onLoaded) {
            onLoaded();
          }
        }, void 0, true);
      }
      toLeftHanded() {
        const tIndices = this.getIndices(false);
        if (tIndices != null && tIndices.length > 0) {
          for (let i = 0; i < tIndices.length; i += 3) {
            const tTemp = tIndices[i + 0];
            tIndices[i + 0] = tIndices[i + 2];
            tIndices[i + 2] = tTemp;
          }
          this.setIndices(tIndices);
        }
        const tPositions = this.getVerticesData(VertexBuffer.PositionKind, false);
        if (tPositions != null && tPositions.length > 0) {
          for (let i = 0; i < tPositions.length; i += 3) {
            tPositions[i + 2] = -tPositions[i + 2];
          }
          this.setVerticesData(VertexBuffer.PositionKind, tPositions, false);
        }
        const tNormals = this.getVerticesData(VertexBuffer.NormalKind, false);
        if (tNormals != null && tNormals.length > 0) {
          for (let i = 0; i < tNormals.length; i += 3) {
            tNormals[i + 2] = -tNormals[i + 2];
          }
          this.setVerticesData(VertexBuffer.NormalKind, tNormals, false);
        }
      }
      _resetPointsArrayCache() {
        this._positions = null;
      }
      _generatePointsArray() {
        if (this._positions) {
          return true;
        }
        const data = this.getVerticesData(VertexBuffer.PositionKind);
        if (!data || data.length === 0) {
          return false;
        }
        for (let index = this._positionsCache.length * 3, arrayIdx = this._positionsCache.length; index < data.length; index += 3, ++arrayIdx) {
          this._positionsCache[arrayIdx] = Vector3.FromArray(data, index);
        }
        for (let index = 0, arrayIdx = 0; index < data.length; index += 3, ++arrayIdx) {
          this._positionsCache[arrayIdx].set(data[0 + index], data[1 + index], data[2 + index]);
        }
        this._positionsCache.length = data.length / 3;
        this._positions = this._positionsCache;
        return true;
      }
      isDisposed() {
        return this._isDisposed;
      }
      _disposeVertexArrayObjects() {
        if (this._vertexArrayObjects) {
          for (const kind in this._vertexArrayObjects) {
            this._engine.releaseVertexArrayObject(this._vertexArrayObjects[kind]);
          }
          this._vertexArrayObjects = {};
          const meshes = this._meshes;
          const numOfMeshes = meshes.length;
          for (let index = 0; index < numOfMeshes; index++) {
            meshes[index]._invalidateInstanceVertexArrayObject();
          }
        }
      }
      dispose() {
        const meshes = this._meshes;
        const numOfMeshes = meshes.length;
        let index;
        for (index = 0; index < numOfMeshes; index++) {
          this.releaseForMesh(meshes[index]);
        }
        this._meshes.length = 0;
        this._disposeVertexArrayObjects();
        for (const kind in this._vertexBuffers) {
          this._vertexBuffers[kind].dispose();
        }
        this._vertexBuffers = {};
        this._totalVertices = 0;
        if (this._indexBuffer) {
          this._engine._releaseBuffer(this._indexBuffer);
        }
        this._indexBuffer = null;
        this._indices = [];
        this.delayLoadState = 0;
        this.delayLoadingFile = null;
        this._delayLoadingFunction = null;
        this._delayInfo = [];
        this._boundingInfo = null;
        this._scene.removeGeometry(this);
        if (this._parentContainer) {
          const index2 = this._parentContainer.geometries.indexOf(this);
          if (index2 > -1) {
            this._parentContainer.geometries.splice(index2, 1);
          }
          this._parentContainer = null;
        }
        this._isDisposed = true;
      }
      copy(id) {
        const vertexData = new VertexData();
        vertexData.indices = [];
        const indices = this.getIndices();
        if (indices) {
          for (let index = 0; index < indices.length; index++) {
            vertexData.indices.push(indices[index]);
          }
        }
        let updatable = false;
        let stopChecking = false;
        let kind;
        for (kind in this._vertexBuffers) {
          const data = this.getVerticesData(kind);
          if (data) {
            if (data instanceof Float32Array) {
              vertexData.set(new Float32Array(data), kind);
            } else {
              vertexData.set(data.slice(0), kind);
            }
            if (!stopChecking) {
              const vb = this.getVertexBuffer(kind);
              if (vb) {
                updatable = vb.isUpdatable();
                stopChecking = !updatable;
              }
            }
          }
        }
        const geometry = new Geometry(id, this._scene, vertexData, updatable);
        geometry.delayLoadState = this.delayLoadState;
        geometry.delayLoadingFile = this.delayLoadingFile;
        geometry._delayLoadingFunction = this._delayLoadingFunction;
        for (kind in this._delayInfo) {
          geometry._delayInfo = geometry._delayInfo || [];
          geometry._delayInfo.push(kind);
        }
        geometry._boundingInfo = new BoundingInfo(this._extend.minimum, this._extend.maximum);
        return geometry;
      }
      serialize() {
        const serializationObject = {};
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.updatable = this._updatable;
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        return serializationObject;
      }
      _toNumberArray(origin) {
        if (Array.isArray(origin)) {
          return origin;
        } else {
          return Array.prototype.slice.call(origin);
        }
      }
      clearCachedData() {
        this._indices = [];
        this._resetPointsArrayCache();
        for (const vbName in this._vertexBuffers) {
          if (!Object.prototype.hasOwnProperty.call(this._vertexBuffers, vbName)) {
            continue;
          }
          this._vertexBuffers[vbName]._buffer._data = null;
        }
      }
      serializeVerticeData() {
        const serializationObject = this.serialize();
        if (this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          serializationObject.positions = this._toNumberArray(this.getVerticesData(VertexBuffer.PositionKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
            serializationObject.positions._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          serializationObject.normals = this._toNumberArray(this.getVerticesData(VertexBuffer.NormalKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
            serializationObject.normals._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          serializationObject.tangents = this._toNumberArray(this.getVerticesData(VertexBuffer.TangentKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.TangentKind)) {
            serializationObject.tangents._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UVKind)) {
          serializationObject.uvs = this._toNumberArray(this.getVerticesData(VertexBuffer.UVKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UVKind)) {
            serializationObject.uvs._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV2Kind)) {
          serializationObject.uvs2 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV2Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV2Kind)) {
            serializationObject.uvs2._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV3Kind)) {
          serializationObject.uvs3 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV3Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV3Kind)) {
            serializationObject.uvs3._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV4Kind)) {
          serializationObject.uvs4 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV4Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV4Kind)) {
            serializationObject.uvs4._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV5Kind)) {
          serializationObject.uvs5 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV5Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV5Kind)) {
            serializationObject.uvs5._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.UV6Kind)) {
          serializationObject.uvs6 = this._toNumberArray(this.getVerticesData(VertexBuffer.UV6Kind));
          if (this.isVertexBufferUpdatable(VertexBuffer.UV6Kind)) {
            serializationObject.uvs6._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          serializationObject.colors = this._toNumberArray(this.getVerticesData(VertexBuffer.ColorKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.ColorKind)) {
            serializationObject.colors._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          serializationObject.matricesIndices = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesIndicesKind));
          serializationObject.matricesIndices._isExpanded = true;
          if (this.isVertexBufferUpdatable(VertexBuffer.MatricesIndicesKind)) {
            serializationObject.matricesIndices._updatable = true;
          }
        }
        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          serializationObject.matricesWeights = this._toNumberArray(this.getVerticesData(VertexBuffer.MatricesWeightsKind));
          if (this.isVertexBufferUpdatable(VertexBuffer.MatricesWeightsKind)) {
            serializationObject.matricesWeights._updatable = true;
          }
        }
        serializationObject.indices = this._toNumberArray(this.getIndices());
        return serializationObject;
      }
      static ExtractFromMesh(mesh, id) {
        const geometry = mesh._geometry;
        if (!geometry) {
          return null;
        }
        return geometry.copy(id);
      }
      static RandomId() {
        return Tools.RandomId();
      }
      static _GetGeometryByLoadedUniqueId(uniqueId, scene) {
        for (let index = 0; index < scene.geometries.length; index++) {
          if (scene.geometries[index]._loadedUniqueId === uniqueId) {
            return scene.geometries[index];
          }
        }
        return null;
      }
      static _ImportGeometry(parsedGeometry, mesh) {
        const scene = mesh.getScene();
        const geometryUniqueId = parsedGeometry.geometryUniqueId;
        const geometryId = parsedGeometry.geometryId;
        if (geometryUniqueId || geometryId) {
          const geometry = geometryUniqueId ? this._GetGeometryByLoadedUniqueId(geometryUniqueId, scene) : scene.getGeometryById(geometryId);
          if (geometry) {
            geometry.applyToMesh(mesh);
          }
        } else if (parsedGeometry instanceof ArrayBuffer) {
          const binaryInfo = mesh._binaryInfo;
          if (binaryInfo.positionsAttrDesc && binaryInfo.positionsAttrDesc.count > 0) {
            const positionsData = new Float32Array(parsedGeometry, binaryInfo.positionsAttrDesc.offset, binaryInfo.positionsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.PositionKind, positionsData, false);
          }
          if (binaryInfo.normalsAttrDesc && binaryInfo.normalsAttrDesc.count > 0) {
            const normalsData = new Float32Array(parsedGeometry, binaryInfo.normalsAttrDesc.offset, binaryInfo.normalsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.NormalKind, normalsData, false);
          }
          if (binaryInfo.tangetsAttrDesc && binaryInfo.tangetsAttrDesc.count > 0) {
            const tangentsData = new Float32Array(parsedGeometry, binaryInfo.tangetsAttrDesc.offset, binaryInfo.tangetsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.TangentKind, tangentsData, false);
          }
          if (binaryInfo.uvsAttrDesc && binaryInfo.uvsAttrDesc.count > 0) {
            const uvsData = new Float32Array(parsedGeometry, binaryInfo.uvsAttrDesc.offset, binaryInfo.uvsAttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (let index = 1; index < uvsData.length; index += 2) {
                uvsData[index] = 1 - uvsData[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UVKind, uvsData, false);
          }
          if (binaryInfo.uvs2AttrDesc && binaryInfo.uvs2AttrDesc.count > 0) {
            const uvs2Data = new Float32Array(parsedGeometry, binaryInfo.uvs2AttrDesc.offset, binaryInfo.uvs2AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (let index = 1; index < uvs2Data.length; index += 2) {
                uvs2Data[index] = 1 - uvs2Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV2Kind, uvs2Data, false);
          }
          if (binaryInfo.uvs3AttrDesc && binaryInfo.uvs3AttrDesc.count > 0) {
            const uvs3Data = new Float32Array(parsedGeometry, binaryInfo.uvs3AttrDesc.offset, binaryInfo.uvs3AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (let index = 1; index < uvs3Data.length; index += 2) {
                uvs3Data[index] = 1 - uvs3Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV3Kind, uvs3Data, false);
          }
          if (binaryInfo.uvs4AttrDesc && binaryInfo.uvs4AttrDesc.count > 0) {
            const uvs4Data = new Float32Array(parsedGeometry, binaryInfo.uvs4AttrDesc.offset, binaryInfo.uvs4AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (let index = 1; index < uvs4Data.length; index += 2) {
                uvs4Data[index] = 1 - uvs4Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV4Kind, uvs4Data, false);
          }
          if (binaryInfo.uvs5AttrDesc && binaryInfo.uvs5AttrDesc.count > 0) {
            const uvs5Data = new Float32Array(parsedGeometry, binaryInfo.uvs5AttrDesc.offset, binaryInfo.uvs5AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (let index = 1; index < uvs5Data.length; index += 2) {
                uvs5Data[index] = 1 - uvs5Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV5Kind, uvs5Data, false);
          }
          if (binaryInfo.uvs6AttrDesc && binaryInfo.uvs6AttrDesc.count > 0) {
            const uvs6Data = new Float32Array(parsedGeometry, binaryInfo.uvs6AttrDesc.offset, binaryInfo.uvs6AttrDesc.count);
            if (CompatibilityOptions.UseOpenGLOrientationForUV) {
              for (let index = 1; index < uvs6Data.length; index += 2) {
                uvs6Data[index] = 1 - uvs6Data[index];
              }
            }
            mesh.setVerticesData(VertexBuffer.UV6Kind, uvs6Data, false);
          }
          if (binaryInfo.colorsAttrDesc && binaryInfo.colorsAttrDesc.count > 0) {
            const colorsData = new Float32Array(parsedGeometry, binaryInfo.colorsAttrDesc.offset, binaryInfo.colorsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.ColorKind, colorsData, false, binaryInfo.colorsAttrDesc.stride);
          }
          if (binaryInfo.matricesIndicesAttrDesc && binaryInfo.matricesIndicesAttrDesc.count > 0) {
            const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesAttrDesc.offset, binaryInfo.matricesIndicesAttrDesc.count);
            const floatIndices = [];
            for (let i = 0; i < matricesIndicesData.length; i++) {
              const index = matricesIndicesData[i];
              floatIndices.push(index & 255);
              floatIndices.push((index & 65280) >> 8);
              floatIndices.push((index & 16711680) >> 16);
              floatIndices.push(index >> 24 & 255);
            }
            mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, false);
          }
          if (binaryInfo.matricesIndicesExtraAttrDesc && binaryInfo.matricesIndicesExtraAttrDesc.count > 0) {
            const matricesIndicesData = new Int32Array(parsedGeometry, binaryInfo.matricesIndicesExtraAttrDesc.offset, binaryInfo.matricesIndicesExtraAttrDesc.count);
            const floatIndices = [];
            for (let i = 0; i < matricesIndicesData.length; i++) {
              const index = matricesIndicesData[i];
              floatIndices.push(index & 255);
              floatIndices.push((index & 65280) >> 8);
              floatIndices.push((index & 16711680) >> 16);
              floatIndices.push(index >> 24 & 255);
            }
            mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, false);
          }
          if (binaryInfo.matricesWeightsAttrDesc && binaryInfo.matricesWeightsAttrDesc.count > 0) {
            const matricesWeightsData = new Float32Array(parsedGeometry, binaryInfo.matricesWeightsAttrDesc.offset, binaryInfo.matricesWeightsAttrDesc.count);
            mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsData, false);
          }
          if (binaryInfo.indicesAttrDesc && binaryInfo.indicesAttrDesc.count > 0) {
            const indicesData = new Int32Array(parsedGeometry, binaryInfo.indicesAttrDesc.offset, binaryInfo.indicesAttrDesc.count);
            mesh.setIndices(indicesData, null);
          }
          if (binaryInfo.subMeshesAttrDesc && binaryInfo.subMeshesAttrDesc.count > 0) {
            const subMeshesData = new Int32Array(parsedGeometry, binaryInfo.subMeshesAttrDesc.offset, binaryInfo.subMeshesAttrDesc.count * 5);
            mesh.subMeshes = [];
            for (let i = 0; i < binaryInfo.subMeshesAttrDesc.count; i++) {
              const materialIndex = subMeshesData[i * 5 + 0];
              const verticesStart = subMeshesData[i * 5 + 1];
              const verticesCount = subMeshesData[i * 5 + 2];
              const indexStart = subMeshesData[i * 5 + 3];
              const indexCount = subMeshesData[i * 5 + 4];
              SubMesh.AddToMesh(materialIndex, verticesStart, verticesCount, indexStart, indexCount, mesh);
            }
          }
        } else if (parsedGeometry.positions && parsedGeometry.normals && parsedGeometry.indices) {
          mesh.setVerticesData(VertexBuffer.PositionKind, parsedGeometry.positions, parsedGeometry.positions._updatable);
          mesh.setVerticesData(VertexBuffer.NormalKind, parsedGeometry.normals, parsedGeometry.normals._updatable);
          if (parsedGeometry.tangents) {
            mesh.setVerticesData(VertexBuffer.TangentKind, parsedGeometry.tangents, parsedGeometry.tangents._updatable);
          }
          if (parsedGeometry.uvs) {
            mesh.setVerticesData(VertexBuffer.UVKind, parsedGeometry.uvs, parsedGeometry.uvs._updatable);
          }
          if (parsedGeometry.uvs2) {
            mesh.setVerticesData(VertexBuffer.UV2Kind, parsedGeometry.uvs2, parsedGeometry.uvs2._updatable);
          }
          if (parsedGeometry.uvs3) {
            mesh.setVerticesData(VertexBuffer.UV3Kind, parsedGeometry.uvs3, parsedGeometry.uvs3._updatable);
          }
          if (parsedGeometry.uvs4) {
            mesh.setVerticesData(VertexBuffer.UV4Kind, parsedGeometry.uvs4, parsedGeometry.uvs4._updatable);
          }
          if (parsedGeometry.uvs5) {
            mesh.setVerticesData(VertexBuffer.UV5Kind, parsedGeometry.uvs5, parsedGeometry.uvs5._updatable);
          }
          if (parsedGeometry.uvs6) {
            mesh.setVerticesData(VertexBuffer.UV6Kind, parsedGeometry.uvs6, parsedGeometry.uvs6._updatable);
          }
          if (parsedGeometry.colors) {
            mesh.setVerticesData(VertexBuffer.ColorKind, Color4.CheckColors4(parsedGeometry.colors, parsedGeometry.positions.length / 3), parsedGeometry.colors._updatable);
          }
          if (parsedGeometry.matricesIndices) {
            if (!parsedGeometry.matricesIndices._isExpanded) {
              const floatIndices = [];
              for (let i = 0; i < parsedGeometry.matricesIndices.length; i++) {
                const matricesIndex = parsedGeometry.matricesIndices[i];
                floatIndices.push(matricesIndex & 255);
                floatIndices.push((matricesIndex & 65280) >> 8);
                floatIndices.push((matricesIndex & 16711680) >> 16);
                floatIndices.push(matricesIndex >> 24 & 255);
              }
              mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, floatIndices, parsedGeometry.matricesIndices._updatable);
            } else {
              delete parsedGeometry.matricesIndices._isExpanded;
              mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, parsedGeometry.matricesIndices, parsedGeometry.matricesIndices._updatable);
            }
          }
          if (parsedGeometry.matricesIndicesExtra) {
            if (!parsedGeometry.matricesIndicesExtra._isExpanded) {
              const floatIndices = [];
              for (let i = 0; i < parsedGeometry.matricesIndicesExtra.length; i++) {
                const matricesIndex = parsedGeometry.matricesIndicesExtra[i];
                floatIndices.push(matricesIndex & 255);
                floatIndices.push((matricesIndex & 65280) >> 8);
                floatIndices.push((matricesIndex & 16711680) >> 16);
                floatIndices.push(matricesIndex >> 24 & 255);
              }
              mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, floatIndices, parsedGeometry.matricesIndicesExtra._updatable);
            } else {
              delete parsedGeometry.matricesIndices._isExpanded;
              mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, parsedGeometry.matricesIndicesExtra, parsedGeometry.matricesIndicesExtra._updatable);
            }
          }
          if (parsedGeometry.matricesWeights) {
            Geometry._CleanMatricesWeights(parsedGeometry, mesh);
            mesh.setVerticesData(VertexBuffer.MatricesWeightsKind, parsedGeometry.matricesWeights, parsedGeometry.matricesWeights._updatable);
          }
          if (parsedGeometry.matricesWeightsExtra) {
            mesh.setVerticesData(VertexBuffer.MatricesWeightsExtraKind, parsedGeometry.matricesWeightsExtra, parsedGeometry.matricesWeights._updatable);
          }
          mesh.setIndices(parsedGeometry.indices, null);
        }
        if (parsedGeometry.subMeshes) {
          mesh.subMeshes = [];
          for (let subIndex = 0; subIndex < parsedGeometry.subMeshes.length; subIndex++) {
            const parsedSubMesh = parsedGeometry.subMeshes[subIndex];
            SubMesh.AddToMesh(parsedSubMesh.materialIndex, parsedSubMesh.verticesStart, parsedSubMesh.verticesCount, parsedSubMesh.indexStart, parsedSubMesh.indexCount, mesh);
          }
        }
        if (mesh._shouldGenerateFlatShading) {
          mesh.convertToFlatShadedMesh();
          mesh._shouldGenerateFlatShading = false;
        }
        mesh.computeWorldMatrix(true);
        scene.onMeshImportedObservable.notifyObservers(mesh);
      }
      static _CleanMatricesWeights(parsedGeometry, mesh) {
        const epsilon = 1e-3;
        if (!SceneLoaderFlags.CleanBoneMatrixWeights) {
          return;
        }
        let noInfluenceBoneIndex = 0;
        if (parsedGeometry.skeletonId > -1) {
          const skeleton = mesh.getScene().getLastSkeletonById(parsedGeometry.skeletonId);
          if (!skeleton) {
            return;
          }
          noInfluenceBoneIndex = skeleton.bones.length;
        } else {
          return;
        }
        const matricesIndices = mesh.getVerticesData(VertexBuffer.MatricesIndicesKind);
        const matricesIndicesExtra = mesh.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
        const matricesWeights = parsedGeometry.matricesWeights;
        const matricesWeightsExtra = parsedGeometry.matricesWeightsExtra;
        const influencers = parsedGeometry.numBoneInfluencer;
        const size = matricesWeights.length;
        for (let i = 0; i < size; i += 4) {
          let weight = 0;
          let firstZeroWeight = -1;
          for (let j = 0; j < 4; j++) {
            const w = matricesWeights[i + j];
            weight += w;
            if (w < epsilon && firstZeroWeight < 0) {
              firstZeroWeight = j;
            }
          }
          if (matricesWeightsExtra) {
            for (let j = 0; j < 4; j++) {
              const w = matricesWeightsExtra[i + j];
              weight += w;
              if (w < epsilon && firstZeroWeight < 0) {
                firstZeroWeight = j + 4;
              }
            }
          }
          if (firstZeroWeight < 0 || firstZeroWeight > influencers - 1) {
            firstZeroWeight = influencers - 1;
          }
          if (weight > epsilon) {
            const mweight = 1 / weight;
            for (let j = 0; j < 4; j++) {
              matricesWeights[i + j] *= mweight;
            }
            if (matricesWeightsExtra) {
              for (let j = 0; j < 4; j++) {
                matricesWeightsExtra[i + j] *= mweight;
              }
            }
          } else {
            if (firstZeroWeight >= 4) {
              matricesWeightsExtra[i + firstZeroWeight - 4] = 1 - weight;
              matricesIndicesExtra[i + firstZeroWeight - 4] = noInfluenceBoneIndex;
            } else {
              matricesWeights[i + firstZeroWeight] = 1 - weight;
              matricesIndices[i + firstZeroWeight] = noInfluenceBoneIndex;
            }
          }
        }
        mesh.setVerticesData(VertexBuffer.MatricesIndicesKind, matricesIndices);
        if (parsedGeometry.matricesWeightsExtra) {
          mesh.setVerticesData(VertexBuffer.MatricesIndicesExtraKind, matricesIndicesExtra);
        }
      }
      static Parse(parsedVertexData, scene, rootUrl) {
        const geometry = new Geometry(parsedVertexData.id, scene, void 0, parsedVertexData.updatable);
        geometry._loadedUniqueId = parsedVertexData.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(geometry, parsedVertexData.tags);
        }
        if (parsedVertexData.delayLoadingFile) {
          geometry.delayLoadState = 4;
          geometry.delayLoadingFile = rootUrl + parsedVertexData.delayLoadingFile;
          geometry._boundingInfo = new BoundingInfo(Vector3.FromArray(parsedVertexData.boundingBoxMinimum), Vector3.FromArray(parsedVertexData.boundingBoxMaximum));
          geometry._delayInfo = [];
          if (parsedVertexData.hasUVs) {
            geometry._delayInfo.push(VertexBuffer.UVKind);
          }
          if (parsedVertexData.hasUVs2) {
            geometry._delayInfo.push(VertexBuffer.UV2Kind);
          }
          if (parsedVertexData.hasUVs3) {
            geometry._delayInfo.push(VertexBuffer.UV3Kind);
          }
          if (parsedVertexData.hasUVs4) {
            geometry._delayInfo.push(VertexBuffer.UV4Kind);
          }
          if (parsedVertexData.hasUVs5) {
            geometry._delayInfo.push(VertexBuffer.UV5Kind);
          }
          if (parsedVertexData.hasUVs6) {
            geometry._delayInfo.push(VertexBuffer.UV6Kind);
          }
          if (parsedVertexData.hasColors) {
            geometry._delayInfo.push(VertexBuffer.ColorKind);
          }
          if (parsedVertexData.hasMatricesIndices) {
            geometry._delayInfo.push(VertexBuffer.MatricesIndicesKind);
          }
          if (parsedVertexData.hasMatricesWeights) {
            geometry._delayInfo.push(VertexBuffer.MatricesWeightsKind);
          }
          geometry._delayLoadingFunction = VertexData.ImportVertexData;
        } else {
          VertexData.ImportVertexData(parsedVertexData, geometry);
        }
        scene.pushGeometry(geometry, true);
        return geometry;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/transformNode.js
var convertRHSToLHS, TransformNode;
var init_transformNode = __esm({
  "node_modules/@babylonjs/core/Meshes/transformNode.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_node();
    init_math_axis();
    convertRHSToLHS = Matrix.Compose(Vector3.One(), Quaternion.FromEulerAngles(0, Math.PI, 0), Vector3.Zero());
    TransformNode = class extends Node {
      get billboardMode() {
        return this._billboardMode;
      }
      set billboardMode(value) {
        if (this._billboardMode === value) {
          return;
        }
        this._billboardMode = value;
        this._cache.useBillboardPosition = (this._billboardMode & TransformNode.BILLBOARDMODE_USE_POSITION) !== 0;
        this._computeUseBillboardPath();
      }
      get preserveParentRotationForBillboard() {
        return this._preserveParentRotationForBillboard;
      }
      set preserveParentRotationForBillboard(value) {
        if (value === this._preserveParentRotationForBillboard) {
          return;
        }
        this._preserveParentRotationForBillboard = value;
        this._computeUseBillboardPath();
      }
      _computeUseBillboardPath() {
        this._cache.useBillboardPath = this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
      }
      get infiniteDistance() {
        return this._infiniteDistance;
      }
      set infiniteDistance(value) {
        if (this._infiniteDistance === value) {
          return;
        }
        this._infiniteDistance = value;
      }
      constructor(name109, scene = null, isPure = true) {
        super(name109, scene);
        this._forward = new Vector3(0, 0, 1);
        this._up = new Vector3(0, 1, 0);
        this._right = new Vector3(1, 0, 0);
        this._position = Vector3.Zero();
        this._rotation = Vector3.Zero();
        this._rotationQuaternion = null;
        this._scaling = Vector3.One();
        this._transformToBoneReferal = null;
        this._isAbsoluteSynced = false;
        this._billboardMode = TransformNode.BILLBOARDMODE_NONE;
        this._preserveParentRotationForBillboard = false;
        this.scalingDeterminant = 1;
        this._infiniteDistance = false;
        this.ignoreNonUniformScaling = false;
        this.reIntegrateRotationIntoRotationQuaternion = false;
        this._poseMatrix = null;
        this._localMatrix = Matrix.Zero();
        this._usePivotMatrix = false;
        this._absolutePosition = Vector3.Zero();
        this._absoluteScaling = Vector3.Zero();
        this._absoluteRotationQuaternion = Quaternion.Identity();
        this._pivotMatrix = Matrix.Identity();
        this._postMultiplyPivotMatrix = false;
        this._isWorldMatrixFrozen = false;
        this._indexInSceneTransformNodesArray = -1;
        this.onAfterWorldMatrixUpdateObservable = new Observable();
        this._nonUniformScaling = false;
        if (isPure) {
          this.getScene().addTransformNode(this);
        }
      }
      getClassName() {
        return "TransformNode";
      }
      get position() {
        return this._position;
      }
      set position(newPosition) {
        this._position = newPosition;
        this._isDirty = true;
      }
      isUsingPivotMatrix() {
        return this._usePivotMatrix;
      }
      get rotation() {
        return this._rotation;
      }
      set rotation(newRotation) {
        this._rotation = newRotation;
        this._rotationQuaternion = null;
        this._isDirty = true;
      }
      get scaling() {
        return this._scaling;
      }
      set scaling(newScaling) {
        this._scaling = newScaling;
        this._isDirty = true;
      }
      get rotationQuaternion() {
        return this._rotationQuaternion;
      }
      set rotationQuaternion(quaternion) {
        this._rotationQuaternion = quaternion;
        if (quaternion) {
          this._rotation.setAll(0);
        }
        this._isDirty = true;
      }
      get forward() {
        Vector3.TransformNormalFromFloatsToRef(0, 0, this.getScene().useRightHandedSystem ? -1 : 1, this.getWorldMatrix(), this._forward);
        return this._forward.normalize();
      }
      get up() {
        Vector3.TransformNormalFromFloatsToRef(0, 1, 0, this.getWorldMatrix(), this._up);
        return this._up.normalize();
      }
      get right() {
        Vector3.TransformNormalFromFloatsToRef(this.getScene().useRightHandedSystem ? -1 : 1, 0, 0, this.getWorldMatrix(), this._right);
        return this._right.normalize();
      }
      updatePoseMatrix(matrix) {
        if (!this._poseMatrix) {
          this._poseMatrix = matrix.clone();
          return this;
        }
        this._poseMatrix.copyFrom(matrix);
        return this;
      }
      getPoseMatrix() {
        if (!this._poseMatrix) {
          this._poseMatrix = Matrix.Identity();
        }
        return this._poseMatrix;
      }
      _isSynchronized() {
        const cache = this._cache;
        if (this._billboardMode !== cache.billboardMode || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
          return false;
        }
        if (cache.pivotMatrixUpdated) {
          return false;
        }
        if (this._infiniteDistance) {
          return false;
        }
        if (this._position._isDirty) {
          return false;
        }
        if (this._scaling._isDirty) {
          return false;
        }
        if (this._rotationQuaternion && this._rotationQuaternion._isDirty || this._rotation._isDirty) {
          return false;
        }
        return true;
      }
      _initCache() {
        super._initCache();
        const cache = this._cache;
        cache.localMatrixUpdated = false;
        cache.billboardMode = -1;
        cache.infiniteDistance = false;
        cache.useBillboardPosition = false;
        cache.useBillboardPath = false;
      }
      get absolutePosition() {
        return this.getAbsolutePosition();
      }
      get absoluteScaling() {
        this._syncAbsoluteScalingAndRotation();
        return this._absoluteScaling;
      }
      get absoluteRotationQuaternion() {
        this._syncAbsoluteScalingAndRotation();
        return this._absoluteRotationQuaternion;
      }
      setPreTransformMatrix(matrix) {
        return this.setPivotMatrix(matrix, false);
      }
      setPivotMatrix(matrix, postMultiplyPivotMatrix = true) {
        this._pivotMatrix.copyFrom(matrix);
        this._usePivotMatrix = !this._pivotMatrix.isIdentity();
        this._cache.pivotMatrixUpdated = true;
        this._postMultiplyPivotMatrix = postMultiplyPivotMatrix;
        if (this._postMultiplyPivotMatrix) {
          if (!this._pivotMatrixInverse) {
            this._pivotMatrixInverse = Matrix.Invert(this._pivotMatrix);
          } else {
            this._pivotMatrix.invertToRef(this._pivotMatrixInverse);
          }
        }
        return this;
      }
      getPivotMatrix() {
        return this._pivotMatrix;
      }
      instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true);
        if (clone) {
          if (onNewNodeCreated) {
            onNewNodeCreated(this, clone);
          }
        }
        for (const child of this.getChildTransformNodes(true)) {
          child.instantiateHierarchy(clone, options, onNewNodeCreated);
        }
        return clone;
      }
      freezeWorldMatrix(newWorldMatrix = null, decompose = false) {
        if (newWorldMatrix) {
          if (decompose) {
            this._rotation.setAll(0);
            this._rotationQuaternion = this._rotationQuaternion || Quaternion.Identity();
            newWorldMatrix.decompose(this._scaling, this._rotationQuaternion, this._position);
            this.computeWorldMatrix(true);
          } else {
            this._worldMatrix = newWorldMatrix;
            this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
            this._afterComputeWorldMatrix();
          }
        } else {
          this._isWorldMatrixFrozen = false;
          this.computeWorldMatrix(true);
        }
        this._isDirty = false;
        this._isWorldMatrixFrozen = true;
        return this;
      }
      unfreezeWorldMatrix() {
        this._isWorldMatrixFrozen = false;
        this.computeWorldMatrix(true);
        return this;
      }
      get isWorldMatrixFrozen() {
        return this._isWorldMatrixFrozen;
      }
      getAbsolutePosition() {
        this.computeWorldMatrix();
        return this._absolutePosition;
      }
      setAbsolutePosition(absolutePosition) {
        if (!absolutePosition) {
          return this;
        }
        let absolutePositionX;
        let absolutePositionY;
        let absolutePositionZ;
        if (absolutePosition.x === void 0) {
          if (arguments.length < 3) {
            return this;
          }
          absolutePositionX = arguments[0];
          absolutePositionY = arguments[1];
          absolutePositionZ = arguments[2];
        } else {
          absolutePositionX = absolutePosition.x;
          absolutePositionY = absolutePosition.y;
          absolutePositionZ = absolutePosition.z;
        }
        if (this.parent) {
          const invertParentWorldMatrix = TmpVectors.Matrix[0];
          this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
          Vector3.TransformCoordinatesFromFloatsToRef(absolutePositionX, absolutePositionY, absolutePositionZ, invertParentWorldMatrix, this.position);
        } else {
          this.position.x = absolutePositionX;
          this.position.y = absolutePositionY;
          this.position.z = absolutePositionZ;
        }
        this._absolutePosition.copyFrom(absolutePosition);
        return this;
      }
      setPositionWithLocalVector(vector3) {
        this.computeWorldMatrix();
        this.position = Vector3.TransformNormal(vector3, this._localMatrix);
        return this;
      }
      getPositionExpressedInLocalSpace() {
        this.computeWorldMatrix();
        const invLocalWorldMatrix = TmpVectors.Matrix[0];
        this._localMatrix.invertToRef(invLocalWorldMatrix);
        return Vector3.TransformNormal(this.position, invLocalWorldMatrix);
      }
      locallyTranslate(vector3) {
        this.computeWorldMatrix(true);
        this.position = Vector3.TransformCoordinates(vector3, this._localMatrix);
        return this;
      }
      lookAt(targetPoint, yawCor = 0, pitchCor = 0, rollCor = 0, space = Space.LOCAL) {
        const dv = TransformNode._LookAtVectorCache;
        const pos = space === Space.LOCAL ? this.position : this.getAbsolutePosition();
        targetPoint.subtractToRef(pos, dv);
        this.setDirection(dv, yawCor, pitchCor, rollCor);
        if (space === Space.WORLD && this.parent) {
          if (this.rotationQuaternion) {
            const rotationMatrix = TmpVectors.Matrix[0];
            this.rotationQuaternion.toRotationMatrix(rotationMatrix);
            const parentRotationMatrix = TmpVectors.Matrix[1];
            this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
            parentRotationMatrix.invert();
            rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
            this.rotationQuaternion.fromRotationMatrix(rotationMatrix);
          } else {
            const quaternionRotation = TmpVectors.Quaternion[0];
            Quaternion.FromEulerVectorToRef(this.rotation, quaternionRotation);
            const rotationMatrix = TmpVectors.Matrix[0];
            quaternionRotation.toRotationMatrix(rotationMatrix);
            const parentRotationMatrix = TmpVectors.Matrix[1];
            this.parent.getWorldMatrix().getRotationMatrixToRef(parentRotationMatrix);
            parentRotationMatrix.invert();
            rotationMatrix.multiplyToRef(parentRotationMatrix, rotationMatrix);
            quaternionRotation.fromRotationMatrix(rotationMatrix);
            quaternionRotation.toEulerAnglesToRef(this.rotation);
          }
        }
        return this;
      }
      getDirection(localAxis) {
        const result = Vector3.Zero();
        this.getDirectionToRef(localAxis, result);
        return result;
      }
      getDirectionToRef(localAxis, result) {
        Vector3.TransformNormalToRef(localAxis, this.getWorldMatrix(), result);
        return this;
      }
      setDirection(localAxis, yawCor = 0, pitchCor = 0, rollCor = 0) {
        const yaw = -Math.atan2(localAxis.z, localAxis.x) + Math.PI / 2;
        const len = Math.sqrt(localAxis.x * localAxis.x + localAxis.z * localAxis.z);
        const pitch = -Math.atan2(localAxis.y, len);
        if (this.rotationQuaternion) {
          Quaternion.RotationYawPitchRollToRef(yaw + yawCor, pitch + pitchCor, rollCor, this.rotationQuaternion);
        } else {
          this.rotation.x = pitch + pitchCor;
          this.rotation.y = yaw + yawCor;
          this.rotation.z = rollCor;
        }
        return this;
      }
      setPivotPoint(point, space = Space.LOCAL) {
        if (this.getScene().getRenderId() == 0) {
          this.computeWorldMatrix(true);
        }
        const wm = this.getWorldMatrix();
        if (space == Space.WORLD) {
          const tmat = TmpVectors.Matrix[0];
          wm.invertToRef(tmat);
          point = Vector3.TransformCoordinates(point, tmat);
        }
        return this.setPivotMatrix(Matrix.Translation(-point.x, -point.y, -point.z), true);
      }
      getPivotPoint() {
        const point = Vector3.Zero();
        this.getPivotPointToRef(point);
        return point;
      }
      getPivotPointToRef(result) {
        result.x = -this._pivotMatrix.m[12];
        result.y = -this._pivotMatrix.m[13];
        result.z = -this._pivotMatrix.m[14];
        return this;
      }
      getAbsolutePivotPoint() {
        const point = Vector3.Zero();
        this.getAbsolutePivotPointToRef(point);
        return point;
      }
      getAbsolutePivotPointToRef(result) {
        this.getPivotPointToRef(result);
        Vector3.TransformCoordinatesToRef(result, this.getWorldMatrix(), result);
        return this;
      }
      markAsDirty(property) {
        if (this._isDirty) {
          return this;
        }
        if (this._children) {
          for (const child of this._children) {
            child.markAsDirty(property);
          }
        }
        return super.markAsDirty(property);
      }
      setParent(node, preserveScalingSign = false, updatePivot = false) {
        if (!node && !this.parent) {
          return this;
        }
        const quatRotation = TmpVectors.Quaternion[0];
        const position = TmpVectors.Vector3[0];
        const scale = TmpVectors.Vector3[1];
        const invParentMatrix = TmpVectors.Matrix[1];
        Matrix.IdentityToRef(invParentMatrix);
        const composedMatrix = TmpVectors.Matrix[0];
        this.computeWorldMatrix(true);
        let currentRotation = this.rotationQuaternion;
        if (!currentRotation) {
          currentRotation = TransformNode._TmpRotation;
          Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, currentRotation);
        }
        Matrix.ComposeToRef(this.scaling, currentRotation, this.position, composedMatrix);
        if (this.parent) {
          composedMatrix.multiplyToRef(this.parent.computeWorldMatrix(true), composedMatrix);
        }
        if (node) {
          node.computeWorldMatrix(true).invertToRef(invParentMatrix);
          composedMatrix.multiplyToRef(invParentMatrix, composedMatrix);
        }
        composedMatrix.decompose(scale, quatRotation, position, preserveScalingSign ? this : void 0);
        if (this.rotationQuaternion) {
          this.rotationQuaternion.copyFrom(quatRotation);
        } else {
          quatRotation.toEulerAnglesToRef(this.rotation);
        }
        this.scaling.copyFrom(scale);
        this.position.copyFrom(position);
        this.parent = node;
        if (updatePivot) {
          this.setPivotMatrix(Matrix.Identity());
        }
        return this;
      }
      get nonUniformScaling() {
        return this._nonUniformScaling;
      }
      _updateNonUniformScalingState(value) {
        if (this._nonUniformScaling === value) {
          return false;
        }
        this._nonUniformScaling = value;
        return true;
      }
      attachToBone(bone, affectedTransformNode) {
        this._currentParentWhenAttachingToBone = this.parent;
        this._transformToBoneReferal = affectedTransformNode;
        this.parent = bone;
        bone.getSkeleton().prepare(true);
        if (bone.getFinalMatrix().determinant() < 0) {
          this.scalingDeterminant *= -1;
        }
        return this;
      }
      detachFromBone(resetToPreviousParent = false) {
        if (!this.parent) {
          if (resetToPreviousParent) {
            this.parent = this._currentParentWhenAttachingToBone;
          }
          return this;
        }
        if (this.parent.getWorldMatrix().determinant() < 0) {
          this.scalingDeterminant *= -1;
        }
        this._transformToBoneReferal = null;
        if (resetToPreviousParent) {
          this.parent = this._currentParentWhenAttachingToBone;
        } else {
          this.parent = null;
        }
        return this;
      }
      rotate(axis, amount, space) {
        axis.normalize();
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = this.rotation.toQuaternion();
          this.rotation.setAll(0);
        }
        let rotationQuaternion;
        if (!space || space === Space.LOCAL) {
          rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);
          this.rotationQuaternion.multiplyToRef(rotationQuaternion, this.rotationQuaternion);
        } else {
          if (this.parent) {
            const invertParentWorldMatrix = TmpVectors.Matrix[0];
            this.parent.getWorldMatrix().invertToRef(invertParentWorldMatrix);
            axis = Vector3.TransformNormal(axis, invertParentWorldMatrix);
          }
          rotationQuaternion = Quaternion.RotationAxisToRef(axis, amount, TransformNode._RotationAxisCache);
          rotationQuaternion.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        }
        return this;
      }
      rotateAround(point, axis, amount) {
        axis.normalize();
        if (!this.rotationQuaternion) {
          this.rotationQuaternion = Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
          this.rotation.setAll(0);
        }
        const tmpVector = TmpVectors.Vector3[0];
        const finalScale = TmpVectors.Vector3[1];
        const finalTranslation = TmpVectors.Vector3[2];
        const finalRotation = TmpVectors.Quaternion[0];
        const translationMatrix = TmpVectors.Matrix[0];
        const translationMatrixInv = TmpVectors.Matrix[1];
        const rotationMatrix = TmpVectors.Matrix[2];
        const finalMatrix = TmpVectors.Matrix[3];
        point.subtractToRef(this.position, tmpVector);
        Matrix.TranslationToRef(tmpVector.x, tmpVector.y, tmpVector.z, translationMatrix);
        Matrix.TranslationToRef(-tmpVector.x, -tmpVector.y, -tmpVector.z, translationMatrixInv);
        Matrix.RotationAxisToRef(axis, amount, rotationMatrix);
        translationMatrixInv.multiplyToRef(rotationMatrix, finalMatrix);
        finalMatrix.multiplyToRef(translationMatrix, finalMatrix);
        finalMatrix.decompose(finalScale, finalRotation, finalTranslation);
        this.position.addInPlace(finalTranslation);
        finalRotation.multiplyToRef(this.rotationQuaternion, this.rotationQuaternion);
        return this;
      }
      translate(axis, distance, space) {
        const displacementVector = axis.scale(distance);
        if (!space || space === Space.LOCAL) {
          const tempV3 = this.getPositionExpressedInLocalSpace().add(displacementVector);
          this.setPositionWithLocalVector(tempV3);
        } else {
          this.setAbsolutePosition(this.getAbsolutePosition().add(displacementVector));
        }
        return this;
      }
      addRotation(x, y, z) {
        let rotationQuaternion;
        if (this.rotationQuaternion) {
          rotationQuaternion = this.rotationQuaternion;
        } else {
          rotationQuaternion = TmpVectors.Quaternion[1];
          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, rotationQuaternion);
        }
        const accumulation = TmpVectors.Quaternion[0];
        Quaternion.RotationYawPitchRollToRef(y, x, z, accumulation);
        rotationQuaternion.multiplyInPlace(accumulation);
        if (!this.rotationQuaternion) {
          rotationQuaternion.toEulerAnglesToRef(this.rotation);
        }
        return this;
      }
      _getEffectiveParent() {
        return this.parent;
      }
      isWorldMatrixCameraDependent() {
        return this._infiniteDistance && !this.parent || this._billboardMode !== TransformNode.BILLBOARDMODE_NONE && !this.preserveParentRotationForBillboard;
      }
      computeWorldMatrix(force = false, camera = null) {
        if (this._isWorldMatrixFrozen && !this._isDirty) {
          return this._worldMatrix;
        }
        const currentRenderId = this.getScene().getRenderId();
        if (!this._isDirty && !force && (this._currentRenderId === currentRenderId || this.isSynchronized())) {
          this._currentRenderId = currentRenderId;
          return this._worldMatrix;
        }
        camera = camera || this.getScene().activeCamera;
        this._updateCache();
        const cache = this._cache;
        cache.pivotMatrixUpdated = false;
        cache.billboardMode = this.billboardMode;
        cache.infiniteDistance = this.infiniteDistance;
        cache.parent = this._parentNode;
        this._currentRenderId = currentRenderId;
        this._childUpdateId += 1;
        this._isDirty = false;
        this._position._isDirty = false;
        this._rotation._isDirty = false;
        this._scaling._isDirty = false;
        const parent = this._getEffectiveParent();
        const scaling = TransformNode._TmpScaling;
        let translation = this._position;
        if (this._infiniteDistance) {
          if (!this.parent && camera) {
            const cameraWorldMatrix = camera.getWorldMatrix();
            const cameraGlobalPosition = new Vector3(cameraWorldMatrix.m[12], cameraWorldMatrix.m[13], cameraWorldMatrix.m[14]);
            translation = TransformNode._TmpTranslation;
            translation.copyFromFloats(this._position.x + cameraGlobalPosition.x, this._position.y + cameraGlobalPosition.y, this._position.z + cameraGlobalPosition.z);
          }
        }
        scaling.copyFromFloats(this._scaling.x * this.scalingDeterminant, this._scaling.y * this.scalingDeterminant, this._scaling.z * this.scalingDeterminant);
        let rotation;
        if (this._rotationQuaternion) {
          this._rotationQuaternion._isDirty = false;
          rotation = this._rotationQuaternion;
          if (this.reIntegrateRotationIntoRotationQuaternion) {
            const len = this.rotation.lengthSquared();
            if (len) {
              this._rotationQuaternion.multiplyInPlace(Quaternion.RotationYawPitchRoll(this._rotation.y, this._rotation.x, this._rotation.z));
              this._rotation.copyFromFloats(0, 0, 0);
            }
          }
        } else {
          rotation = TransformNode._TmpRotation;
          Quaternion.RotationYawPitchRollToRef(this._rotation.y, this._rotation.x, this._rotation.z, rotation);
        }
        if (this._usePivotMatrix) {
          const scaleMatrix = TmpVectors.Matrix[1];
          Matrix.ScalingToRef(scaling.x, scaling.y, scaling.z, scaleMatrix);
          const rotationMatrix = TmpVectors.Matrix[0];
          rotation.toRotationMatrix(rotationMatrix);
          this._pivotMatrix.multiplyToRef(scaleMatrix, TmpVectors.Matrix[4]);
          TmpVectors.Matrix[4].multiplyToRef(rotationMatrix, this._localMatrix);
          if (this._postMultiplyPivotMatrix) {
            this._localMatrix.multiplyToRef(this._pivotMatrixInverse, this._localMatrix);
          }
          this._localMatrix.addTranslationFromFloats(translation.x, translation.y, translation.z);
        } else {
          Matrix.ComposeToRef(scaling, rotation, translation, this._localMatrix);
        }
        if (parent && parent.getWorldMatrix) {
          if (force) {
            parent.computeWorldMatrix(force);
          }
          if (cache.useBillboardPath) {
            if (this._transformToBoneReferal) {
              const bone = this.parent;
              bone.getSkeleton().prepare();
              bone.getFinalMatrix().multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), TmpVectors.Matrix[7]);
            } else {
              TmpVectors.Matrix[7].copyFrom(parent.getWorldMatrix());
            }
            const translation2 = TmpVectors.Vector3[5];
            const scale = TmpVectors.Vector3[6];
            const orientation = TmpVectors.Quaternion[0];
            TmpVectors.Matrix[7].decompose(scale, orientation, translation2);
            Matrix.ScalingToRef(scale.x, scale.y, scale.z, TmpVectors.Matrix[7]);
            TmpVectors.Matrix[7].setTranslation(translation2);
            if (TransformNode.BillboardUseParentOrientation) {
              this._position.applyRotationQuaternionToRef(orientation, translation2);
              this._localMatrix.setTranslation(translation2);
            }
            this._localMatrix.multiplyToRef(TmpVectors.Matrix[7], this._worldMatrix);
          } else {
            if (this._transformToBoneReferal) {
              const bone = this.parent;
              bone.getSkeleton().prepare();
              this._localMatrix.multiplyToRef(bone.getFinalMatrix(), TmpVectors.Matrix[6]);
              TmpVectors.Matrix[6].multiplyToRef(this._transformToBoneReferal.getWorldMatrix(), this._worldMatrix);
            } else {
              this._localMatrix.multiplyToRef(parent.getWorldMatrix(), this._worldMatrix);
            }
          }
          this._markSyncedWithParent();
        } else {
          this._worldMatrix.copyFrom(this._localMatrix);
        }
        if (cache.useBillboardPath && camera && this.billboardMode && !cache.useBillboardPosition) {
          const storedTranslation = TmpVectors.Vector3[0];
          this._worldMatrix.getTranslationToRef(storedTranslation);
          TmpVectors.Matrix[1].copyFrom(camera.getViewMatrix());
          if (this._scene.useRightHandedSystem) {
            TmpVectors.Matrix[1].multiplyToRef(convertRHSToLHS, TmpVectors.Matrix[1]);
          }
          TmpVectors.Matrix[1].setTranslationFromFloats(0, 0, 0);
          TmpVectors.Matrix[1].invertToRef(TmpVectors.Matrix[0]);
          if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {
            TmpVectors.Matrix[0].decompose(void 0, TmpVectors.Quaternion[0], void 0);
            const eulerAngles = TmpVectors.Vector3[1];
            TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
            if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {
              eulerAngles.x = 0;
            }
            if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {
              eulerAngles.y = 0;
            }
            if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {
              eulerAngles.z = 0;
            }
            Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
          }
          this._worldMatrix.setTranslationFromFloats(0, 0, 0);
          this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
          this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
        } else if (cache.useBillboardPath && camera && cache.useBillboardPosition) {
          const storedTranslation = TmpVectors.Vector3[0];
          this._worldMatrix.getTranslationToRef(storedTranslation);
          const cameraPosition = camera.globalPosition;
          this._worldMatrix.invertToRef(TmpVectors.Matrix[1]);
          const camInObjSpace = TmpVectors.Vector3[1];
          Vector3.TransformCoordinatesToRef(cameraPosition, TmpVectors.Matrix[1], camInObjSpace);
          camInObjSpace.normalize();
          const yaw = -Math.atan2(camInObjSpace.z, camInObjSpace.x) + Math.PI / 2;
          const len = Math.sqrt(camInObjSpace.x * camInObjSpace.x + camInObjSpace.z * camInObjSpace.z);
          const pitch = -Math.atan2(camInObjSpace.y, len);
          Quaternion.RotationYawPitchRollToRef(yaw, pitch, 0, TmpVectors.Quaternion[0]);
          if ((this.billboardMode & TransformNode.BILLBOARDMODE_ALL) !== TransformNode.BILLBOARDMODE_ALL) {
            const eulerAngles = TmpVectors.Vector3[1];
            TmpVectors.Quaternion[0].toEulerAnglesToRef(eulerAngles);
            if ((this.billboardMode & TransformNode.BILLBOARDMODE_X) !== TransformNode.BILLBOARDMODE_X) {
              eulerAngles.x = 0;
            }
            if ((this.billboardMode & TransformNode.BILLBOARDMODE_Y) !== TransformNode.BILLBOARDMODE_Y) {
              eulerAngles.y = 0;
            }
            if ((this.billboardMode & TransformNode.BILLBOARDMODE_Z) !== TransformNode.BILLBOARDMODE_Z) {
              eulerAngles.z = 0;
            }
            Matrix.RotationYawPitchRollToRef(eulerAngles.y, eulerAngles.x, eulerAngles.z, TmpVectors.Matrix[0]);
          } else {
            Matrix.FromQuaternionToRef(TmpVectors.Quaternion[0], TmpVectors.Matrix[0]);
          }
          this._worldMatrix.setTranslationFromFloats(0, 0, 0);
          this._worldMatrix.multiplyToRef(TmpVectors.Matrix[0], this._worldMatrix);
          this._worldMatrix.setTranslation(TmpVectors.Vector3[0]);
        }
        if (!this.ignoreNonUniformScaling) {
          if (this._scaling.isNonUniformWithinEpsilon(1e-6)) {
            this._updateNonUniformScalingState(true);
          } else if (parent && parent._nonUniformScaling) {
            this._updateNonUniformScalingState(parent._nonUniformScaling);
          } else {
            this._updateNonUniformScalingState(false);
          }
        } else {
          this._updateNonUniformScalingState(false);
        }
        this._afterComputeWorldMatrix();
        this._absolutePosition.copyFromFloats(this._worldMatrix.m[12], this._worldMatrix.m[13], this._worldMatrix.m[14]);
        this._isAbsoluteSynced = false;
        this.onAfterWorldMatrixUpdateObservable.notifyObservers(this);
        if (!this._poseMatrix) {
          this._poseMatrix = Matrix.Invert(this._worldMatrix);
        }
        this._worldMatrixDeterminantIsDirty = true;
        return this._worldMatrix;
      }
      resetLocalMatrix(independentOfChildren = true) {
        this.computeWorldMatrix();
        if (independentOfChildren) {
          const children = this.getChildren();
          for (let i = 0; i < children.length; ++i) {
            const child = children[i];
            if (child) {
              child.computeWorldMatrix();
              const bakedMatrix = TmpVectors.Matrix[0];
              child._localMatrix.multiplyToRef(this._localMatrix, bakedMatrix);
              const tmpRotationQuaternion = TmpVectors.Quaternion[0];
              bakedMatrix.decompose(child.scaling, tmpRotationQuaternion, child.position);
              if (child.rotationQuaternion) {
                child.rotationQuaternion.copyFrom(tmpRotationQuaternion);
              } else {
                tmpRotationQuaternion.toEulerAnglesToRef(child.rotation);
              }
            }
          }
        }
        this.scaling.copyFromFloats(1, 1, 1);
        this.position.copyFromFloats(0, 0, 0);
        this.rotation.copyFromFloats(0, 0, 0);
        if (this.rotationQuaternion) {
          this.rotationQuaternion = Quaternion.Identity();
        }
        this._worldMatrix = Matrix.Identity();
      }
      _afterComputeWorldMatrix() {
      }
      registerAfterWorldMatrixUpdate(func) {
        this.onAfterWorldMatrixUpdateObservable.add(func);
        return this;
      }
      unregisterAfterWorldMatrixUpdate(func) {
        this.onAfterWorldMatrixUpdateObservable.removeCallback(func);
        return this;
      }
      getPositionInCameraSpace(camera = null) {
        if (!camera) {
          camera = this.getScene().activeCamera;
        }
        return Vector3.TransformCoordinates(this.getAbsolutePosition(), camera.getViewMatrix());
      }
      getDistanceToCamera(camera = null) {
        if (!camera) {
          camera = this.getScene().activeCamera;
        }
        return this.getAbsolutePosition().subtract(camera.globalPosition).length();
      }
      clone(name109, newParent, doNotCloneChildren) {
        const result = SerializationHelper.Clone(() => new TransformNode(name109, this.getScene()), this);
        result.name = name109;
        result.id = name109;
        if (newParent) {
          result.parent = newParent;
        }
        if (!doNotCloneChildren) {
          const directDescendants = this.getDescendants(true);
          for (let index = 0; index < directDescendants.length; index++) {
            const child = directDescendants[index];
            if (child.clone) {
              child.clone(name109 + "." + child.name, result);
            }
          }
        }
        return result;
      }
      serialize(currentSerializationObject) {
        const serializationObject = SerializationHelper.Serialize(this, currentSerializationObject);
        serializationObject.type = this.getClassName();
        serializationObject.uniqueId = this.uniqueId;
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        serializationObject.localMatrix = this.getPivotMatrix().asArray();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      }
      static Parse(parsedTransformNode, scene, rootUrl) {
        const transformNode = SerializationHelper.Parse(() => new TransformNode(parsedTransformNode.name, scene), parsedTransformNode, scene, rootUrl);
        if (parsedTransformNode.localMatrix) {
          transformNode.setPreTransformMatrix(Matrix.FromArray(parsedTransformNode.localMatrix));
        } else if (parsedTransformNode.pivotMatrix) {
          transformNode.setPivotMatrix(Matrix.FromArray(parsedTransformNode.pivotMatrix));
        }
        transformNode.setEnabled(parsedTransformNode.isEnabled);
        transformNode._waitingParsedUniqueId = parsedTransformNode.uniqueId;
        if (parsedTransformNode.parentId !== void 0) {
          transformNode._waitingParentId = parsedTransformNode.parentId;
        }
        if (parsedTransformNode.parentInstanceIndex !== void 0) {
          transformNode._waitingParentInstanceIndex = parsedTransformNode.parentInstanceIndex;
        }
        return transformNode;
      }
      getChildTransformNodes(directDescendantsOnly, predicate) {
        const results = [];
        this._getDescendants(results, directDescendantsOnly, (node) => {
          return (!predicate || predicate(node)) && node instanceof TransformNode;
        });
        return results;
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this.getScene().stopAnimation(this);
        this.getScene().removeTransformNode(this);
        if (this._parentContainer) {
          const index = this._parentContainer.transformNodes.indexOf(this);
          if (index > -1) {
            this._parentContainer.transformNodes.splice(index, 1);
          }
          this._parentContainer = null;
        }
        this.onAfterWorldMatrixUpdateObservable.clear();
        if (doNotRecurse) {
          const transformNodes = this.getChildTransformNodes(true);
          for (const transformNode of transformNodes) {
            transformNode.parent = null;
            transformNode.computeWorldMatrix(true);
          }
        }
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
        let storedRotation = null;
        let storedRotationQuaternion = null;
        if (ignoreRotation) {
          if (this.rotationQuaternion) {
            storedRotationQuaternion = this.rotationQuaternion.clone();
            this.rotationQuaternion.copyFromFloats(0, 0, 0, 1);
          } else if (this.rotation) {
            storedRotation = this.rotation.clone();
            this.rotation.copyFromFloats(0, 0, 0);
          }
        }
        const boundingVectors = this.getHierarchyBoundingVectors(includeDescendants, predicate);
        const sizeVec = boundingVectors.max.subtract(boundingVectors.min);
        const maxDimension = Math.max(sizeVec.x, sizeVec.y, sizeVec.z);
        if (maxDimension === 0) {
          return this;
        }
        const scale = 1 / maxDimension;
        this.scaling.scaleInPlace(scale);
        if (ignoreRotation) {
          if (this.rotationQuaternion && storedRotationQuaternion) {
            this.rotationQuaternion.copyFrom(storedRotationQuaternion);
          } else if (this.rotation && storedRotation) {
            this.rotation.copyFrom(storedRotation);
          }
        }
        return this;
      }
      _syncAbsoluteScalingAndRotation() {
        if (!this._isAbsoluteSynced) {
          this._worldMatrix.decompose(this._absoluteScaling, this._absoluteRotationQuaternion);
          this._isAbsoluteSynced = true;
        }
      }
    };
    TransformNode.BILLBOARDMODE_NONE = 0;
    TransformNode.BILLBOARDMODE_X = 1;
    TransformNode.BILLBOARDMODE_Y = 2;
    TransformNode.BILLBOARDMODE_Z = 4;
    TransformNode.BILLBOARDMODE_ALL = 7;
    TransformNode.BILLBOARDMODE_USE_POSITION = 128;
    TransformNode.BillboardUseParentOrientation = false;
    TransformNode._TmpRotation = Quaternion.Zero();
    TransformNode._TmpScaling = Vector3.Zero();
    TransformNode._TmpTranslation = Vector3.Zero();
    TransformNode._LookAtVectorCache = new Vector3(0, 0, 0);
    TransformNode._RotationAxisCache = new Quaternion();
    __decorate([
      serializeAsVector3("position")
    ], TransformNode.prototype, "_position", void 0);
    __decorate([
      serializeAsVector3("rotation")
    ], TransformNode.prototype, "_rotation", void 0);
    __decorate([
      serializeAsQuaternion("rotationQuaternion")
    ], TransformNode.prototype, "_rotationQuaternion", void 0);
    __decorate([
      serializeAsVector3("scaling")
    ], TransformNode.prototype, "_scaling", void 0);
    __decorate([
      serialize("billboardMode")
    ], TransformNode.prototype, "_billboardMode", void 0);
    __decorate([
      serialize()
    ], TransformNode.prototype, "scalingDeterminant", void 0);
    __decorate([
      serialize("infiniteDistance")
    ], TransformNode.prototype, "_infiniteDistance", void 0);
    __decorate([
      serialize()
    ], TransformNode.prototype, "ignoreNonUniformScaling", void 0);
    __decorate([
      serialize()
    ], TransformNode.prototype, "reIntegrateRotationIntoRotationQuaternion", void 0);
  }
});

// node_modules/@babylonjs/core/Collisions/meshCollisionData.js
var _MeshCollisionData;
var init_meshCollisionData = __esm({
  "node_modules/@babylonjs/core/Collisions/meshCollisionData.js"() {
    init_math_vector();
    _MeshCollisionData = class {
      constructor() {
        this._checkCollisions = false;
        this._collisionMask = -1;
        this._collisionGroup = -1;
        this._surroundingMeshes = null;
        this._collider = null;
        this._oldPositionForCollisions = new Vector3(0, 0, 0);
        this._diffPositionForCollisions = new Vector3(0, 0, 0);
        this._collisionResponse = true;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/abstractMesh.js
var _FacetDataStorage, _InternalAbstractMeshDataInfo, AbstractMesh;
var init_abstractMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/abstractMesh.js"() {
    init_observable();
    init_scene();
    init_math_vector();
    init_engine();
    init_buffer();
    init_mesh_vertexData();
    init_transformNode();
    init_pickingInfo();
    init_boundingInfo();
    init_uniformBuffer();
    init_meshCollisionData();
    init_devTools();
    init_math_functions();
    init_math_color();
    init_math_constants();
    init_math_axis();
    init_typeStore();
    _FacetDataStorage = class {
      constructor() {
        this.facetNb = 0;
        this.partitioningSubdivisions = 10;
        this.partitioningBBoxRatio = 1.01;
        this.facetDataEnabled = false;
        this.facetParameters = {};
        this.bbSize = Vector3.Zero();
        this.subDiv = {
          max: 1,
          X: 1,
          Y: 1,
          Z: 1
        };
        this.facetDepthSort = false;
        this.facetDepthSortEnabled = false;
      }
    };
    _InternalAbstractMeshDataInfo = class {
      constructor() {
        this._hasVertexAlpha = false;
        this._useVertexColors = true;
        this._numBoneInfluencers = 4;
        this._applyFog = true;
        this._receiveShadows = false;
        this._facetData = new _FacetDataStorage();
        this._visibility = 1;
        this._skeleton = null;
        this._layerMask = 268435455;
        this._computeBonesUsingShaders = true;
        this._isActive = false;
        this._onlyForInstances = false;
        this._isActiveIntermediate = false;
        this._onlyForInstancesIntermediate = false;
        this._actAsRegularMesh = false;
        this._currentLOD = null;
        this._currentLODIsUpToDate = false;
        this._collisionRetryCount = 3;
        this._morphTargetManager = null;
        this._renderingGroupId = 0;
        this._bakedVertexAnimationManager = null;
        this._material = null;
        this._positions = null;
        this._pointerOverDisableMeshTesting = false;
        this._meshCollisionData = new _MeshCollisionData();
        this._enableDistantPicking = false;
        this._rawBoundingInfo = null;
      }
    };
    AbstractMesh = class extends TransformNode {
      static get BILLBOARDMODE_NONE() {
        return TransformNode.BILLBOARDMODE_NONE;
      }
      static get BILLBOARDMODE_X() {
        return TransformNode.BILLBOARDMODE_X;
      }
      static get BILLBOARDMODE_Y() {
        return TransformNode.BILLBOARDMODE_Y;
      }
      static get BILLBOARDMODE_Z() {
        return TransformNode.BILLBOARDMODE_Z;
      }
      static get BILLBOARDMODE_ALL() {
        return TransformNode.BILLBOARDMODE_ALL;
      }
      static get BILLBOARDMODE_USE_POSITION() {
        return TransformNode.BILLBOARDMODE_USE_POSITION;
      }
      get facetNb() {
        return this._internalAbstractMeshDataInfo._facetData.facetNb;
      }
      get partitioningSubdivisions() {
        return this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions;
      }
      set partitioningSubdivisions(nb) {
        this._internalAbstractMeshDataInfo._facetData.partitioningSubdivisions = nb;
      }
      get partitioningBBoxRatio() {
        return this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio;
      }
      set partitioningBBoxRatio(ratio) {
        this._internalAbstractMeshDataInfo._facetData.partitioningBBoxRatio = ratio;
      }
      get mustDepthSortFacets() {
        return this._internalAbstractMeshDataInfo._facetData.facetDepthSort;
      }
      set mustDepthSortFacets(sort) {
        this._internalAbstractMeshDataInfo._facetData.facetDepthSort = sort;
      }
      get facetDepthSortFrom() {
        return this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom;
      }
      set facetDepthSortFrom(location) {
        this._internalAbstractMeshDataInfo._facetData.facetDepthSortFrom = location;
      }
      get collisionRetryCount() {
        return this._internalAbstractMeshDataInfo._collisionRetryCount;
      }
      set collisionRetryCount(retryCount) {
        this._internalAbstractMeshDataInfo._collisionRetryCount = retryCount;
      }
      get isFacetDataEnabled() {
        return this._internalAbstractMeshDataInfo._facetData.facetDataEnabled;
      }
      get morphTargetManager() {
        return this._internalAbstractMeshDataInfo._morphTargetManager;
      }
      set morphTargetManager(value) {
        if (this._internalAbstractMeshDataInfo._morphTargetManager === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._morphTargetManager = value;
        this._syncGeometryWithMorphTargetManager();
      }
      get bakedVertexAnimationManager() {
        return this._internalAbstractMeshDataInfo._bakedVertexAnimationManager;
      }
      set bakedVertexAnimationManager(value) {
        if (this._internalAbstractMeshDataInfo._bakedVertexAnimationManager === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._bakedVertexAnimationManager = value;
        this._markSubMeshesAsAttributesDirty();
      }
      _syncGeometryWithMorphTargetManager() {
      }
      _updateNonUniformScalingState(value) {
        if (!super._updateNonUniformScalingState(value)) {
          return false;
        }
        this._markSubMeshesAsMiscDirty();
        return true;
      }
      get rawBoundingInfo() {
        return this._internalAbstractMeshDataInfo._rawBoundingInfo;
      }
      set rawBoundingInfo(boundingInfo) {
        this._internalAbstractMeshDataInfo._rawBoundingInfo = boundingInfo;
      }
      set onCollide(callback) {
        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver) {
          this.onCollideObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver);
        }
        this._internalAbstractMeshDataInfo._meshCollisionData._onCollideObserver = this.onCollideObservable.add(callback);
      }
      set onCollisionPositionChange(callback) {
        if (this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver) {
          this.onCollisionPositionChangeObservable.remove(this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver);
        }
        this._internalAbstractMeshDataInfo._meshCollisionData._onCollisionPositionChangeObserver = this.onCollisionPositionChangeObservable.add(callback);
      }
      get visibility() {
        return this._internalAbstractMeshDataInfo._visibility;
      }
      set visibility(value) {
        if (this._internalAbstractMeshDataInfo._visibility === value) {
          return;
        }
        const oldValue = this._internalAbstractMeshDataInfo._visibility;
        this._internalAbstractMeshDataInfo._visibility = value;
        if (oldValue === 1 && value !== 1 || oldValue !== 1 && value === 1) {
          this._markSubMeshesAsDirty((defines) => {
            defines.markAsMiscDirty();
            defines.markAsPrePassDirty();
          });
        }
      }
      get pointerOverDisableMeshTesting() {
        return this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting;
      }
      set pointerOverDisableMeshTesting(disable) {
        this._internalAbstractMeshDataInfo._pointerOverDisableMeshTesting = disable;
      }
      get renderingGroupId() {
        return this._internalAbstractMeshDataInfo._renderingGroupId;
      }
      set renderingGroupId(value) {
        this._internalAbstractMeshDataInfo._renderingGroupId = value;
      }
      get material() {
        return this._internalAbstractMeshDataInfo._material;
      }
      set material(value) {
        if (this._internalAbstractMeshDataInfo._material === value) {
          return;
        }
        if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
          this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
        }
        this._internalAbstractMeshDataInfo._material = value;
        if (value && value.meshMap) {
          value.meshMap[this.uniqueId] = this;
        }
        if (this.onMaterialChangedObservable.hasObservers()) {
          this.onMaterialChangedObservable.notifyObservers(this);
        }
        if (!this.subMeshes) {
          return;
        }
        this.resetDrawCache();
        this._unBindEffect();
      }
      getMaterialForRenderPass(renderPassId) {
        var _a;
        return (_a = this._internalAbstractMeshDataInfo._materialForRenderPass) === null || _a === void 0 ? void 0 : _a[renderPassId];
      }
      setMaterialForRenderPass(renderPassId, material) {
        this.resetDrawCache(renderPassId);
        if (!this._internalAbstractMeshDataInfo._materialForRenderPass) {
          this._internalAbstractMeshDataInfo._materialForRenderPass = [];
        }
        this._internalAbstractMeshDataInfo._materialForRenderPass[renderPassId] = material;
      }
      get receiveShadows() {
        return this._internalAbstractMeshDataInfo._receiveShadows;
      }
      set receiveShadows(value) {
        if (this._internalAbstractMeshDataInfo._receiveShadows === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._receiveShadows = value;
        this._markSubMeshesAsLightDirty();
      }
      get hasVertexAlpha() {
        return this._internalAbstractMeshDataInfo._hasVertexAlpha;
      }
      set hasVertexAlpha(value) {
        if (this._internalAbstractMeshDataInfo._hasVertexAlpha === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._hasVertexAlpha = value;
        this._markSubMeshesAsAttributesDirty();
        this._markSubMeshesAsMiscDirty();
      }
      get useVertexColors() {
        return this._internalAbstractMeshDataInfo._useVertexColors;
      }
      set useVertexColors(value) {
        if (this._internalAbstractMeshDataInfo._useVertexColors === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._useVertexColors = value;
        this._markSubMeshesAsAttributesDirty();
      }
      get computeBonesUsingShaders() {
        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
      }
      set computeBonesUsingShaders(value) {
        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
        this._markSubMeshesAsAttributesDirty();
      }
      get numBoneInfluencers() {
        return this._internalAbstractMeshDataInfo._numBoneInfluencers;
      }
      set numBoneInfluencers(value) {
        if (this._internalAbstractMeshDataInfo._numBoneInfluencers === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._numBoneInfluencers = value;
        this._markSubMeshesAsAttributesDirty();
      }
      get applyFog() {
        return this._internalAbstractMeshDataInfo._applyFog;
      }
      set applyFog(value) {
        if (this._internalAbstractMeshDataInfo._applyFog === value) {
          return;
        }
        this._internalAbstractMeshDataInfo._applyFog = value;
        this._markSubMeshesAsMiscDirty();
      }
      get enableDistantPicking() {
        return this._internalAbstractMeshDataInfo._enableDistantPicking;
      }
      set enableDistantPicking(value) {
        this._internalAbstractMeshDataInfo._enableDistantPicking = value;
      }
      get layerMask() {
        return this._internalAbstractMeshDataInfo._layerMask;
      }
      set layerMask(value) {
        if (value === this._internalAbstractMeshDataInfo._layerMask) {
          return;
        }
        this._internalAbstractMeshDataInfo._layerMask = value;
        this._resyncLightSources();
      }
      get collisionMask() {
        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask;
      }
      set collisionMask(mask) {
        this._internalAbstractMeshDataInfo._meshCollisionData._collisionMask = !isNaN(mask) ? mask : -1;
      }
      get collisionResponse() {
        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse;
      }
      set collisionResponse(response) {
        this._internalAbstractMeshDataInfo._meshCollisionData._collisionResponse = response;
      }
      get collisionGroup() {
        return this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup;
      }
      set collisionGroup(mask) {
        this._internalAbstractMeshDataInfo._meshCollisionData._collisionGroup = !isNaN(mask) ? mask : -1;
      }
      get surroundingMeshes() {
        return this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes;
      }
      set surroundingMeshes(meshes) {
        this._internalAbstractMeshDataInfo._meshCollisionData._surroundingMeshes = meshes;
      }
      get lightSources() {
        return this._lightSources;
      }
      get _positions() {
        return null;
      }
      set skeleton(value) {
        const skeleton = this._internalAbstractMeshDataInfo._skeleton;
        if (skeleton && skeleton.needInitialSkinMatrix) {
          skeleton._unregisterMeshWithPoseMatrix(this);
        }
        if (value && value.needInitialSkinMatrix) {
          value._registerMeshWithPoseMatrix(this);
        }
        this._internalAbstractMeshDataInfo._skeleton = value;
        if (!this._internalAbstractMeshDataInfo._skeleton) {
          this._bonesTransformMatrices = null;
        }
        this._markSubMeshesAsAttributesDirty();
      }
      get skeleton() {
        return this._internalAbstractMeshDataInfo._skeleton;
      }
      constructor(name109, scene = null) {
        super(name109, scene, false);
        this._internalAbstractMeshDataInfo = new _InternalAbstractMeshDataInfo();
        this._waitingMaterialId = null;
        this.cullingStrategy = AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY;
        this.onCollideObservable = new Observable();
        this.onCollisionPositionChangeObservable = new Observable();
        this.onMaterialChangedObservable = new Observable();
        this.definedFacingForward = true;
        this._occlusionQuery = null;
        this._renderingGroup = null;
        this.alphaIndex = Number.MAX_VALUE;
        this.isVisible = true;
        this.isPickable = true;
        this.isNearPickable = false;
        this.isNearGrabbable = false;
        this.showSubMeshesBoundingBox = false;
        this.isBlocker = false;
        this.enablePointerMoveEvents = false;
        this.outlineColor = Color3.Red();
        this.outlineWidth = 0.02;
        this.overlayColor = Color3.Red();
        this.overlayAlpha = 0.5;
        this.useOctreeForRenderingSelection = true;
        this.useOctreeForPicking = true;
        this.useOctreeForCollisions = true;
        this.alwaysSelectAsActiveMesh = false;
        this.doNotSyncBoundingInfo = false;
        this.actionManager = null;
        this.ellipsoid = new Vector3(0.5, 1, 0.5);
        this.ellipsoidOffset = new Vector3(0, 0, 0);
        this.edgesWidth = 1;
        this.edgesColor = new Color4(1, 0, 0, 1);
        this._edgesRenderer = null;
        this._masterMesh = null;
        this._boundingInfo = null;
        this._boundingInfoIsDirty = true;
        this._renderId = 0;
        this._intersectionsInProgress = new Array();
        this._unIndexed = false;
        this._lightSources = new Array();
        this._waitingData = {
          lods: null,
          actions: null,
          freezeWorldMatrix: null
        };
        this._bonesTransformMatrices = null;
        this._transformMatrixTexture = null;
        this.onRebuildObservable = new Observable();
        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
          newPosition.subtractToRef(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
          if (this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions.length() > Engine.CollisionsEpsilon) {
            this.position.addInPlace(this._internalAbstractMeshDataInfo._meshCollisionData._diffPositionForCollisions);
          }
          if (collidedMesh) {
            this.onCollideObservable.notifyObservers(collidedMesh);
          }
          this.onCollisionPositionChangeObservable.notifyObservers(this.position);
        };
        scene = this.getScene();
        scene.addMesh(this);
        this._resyncLightSources();
        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name109, !this.getScene().getEngine().isWebGPU);
        this._buildUniformLayout();
        switch (scene.performancePriority) {
          case ScenePerformancePriority.Aggressive:
            this.doNotSyncBoundingInfo = true;
          case ScenePerformancePriority.Intermediate:
            this.alwaysSelectAsActiveMesh = true;
            this.isPickable = false;
            break;
        }
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("world", 16);
        this._uniformBuffer.addUniform("visibility", 1);
        this._uniformBuffer.create();
      }
      transferToEffect(world) {
        const ubo = this._uniformBuffer;
        ubo.updateMatrix("world", world);
        ubo.updateFloat("visibility", this._internalAbstractMeshDataInfo._visibility);
        ubo.update();
      }
      getMeshUniformBuffer() {
        return this._uniformBuffer;
      }
      getClassName() {
        return "AbstractMesh";
      }
      toString(fullDetails) {
        let ret = "Name: " + this.name + ", isInstance: " + (this.getClassName() !== "InstancedMesh" ? "YES" : "NO");
        ret += ", # of submeshes: " + (this.subMeshes ? this.subMeshes.length : 0);
        const skeleton = this._internalAbstractMeshDataInfo._skeleton;
        if (skeleton) {
          ret += ", skeleton: " + skeleton.name;
        }
        if (fullDetails) {
          ret += ", billboard mode: " + ["NONE", "X", "Y", null, "Z", null, null, "ALL"][this.billboardMode];
          ret += ", freeze wrld mat: " + (this._isWorldMatrixFrozen || this._waitingData.freezeWorldMatrix ? "YES" : "NO");
        }
        return ret;
      }
      _getEffectiveParent() {
        if (this._masterMesh && this.billboardMode !== TransformNode.BILLBOARDMODE_NONE) {
          return this._masterMesh;
        }
        return super._getEffectiveParent();
      }
      _getActionManagerForTrigger(trigger, initialCall = true) {
        if (this.actionManager && (initialCall || this.actionManager.isRecursive)) {
          if (trigger) {
            if (this.actionManager.hasSpecificTrigger(trigger)) {
              return this.actionManager;
            }
          } else {
            return this.actionManager;
          }
        }
        if (!this.parent) {
          return null;
        }
        return this.parent._getActionManagerForTrigger(trigger, false);
      }
      _rebuild(dispose = false) {
        this.onRebuildObservable.notifyObservers(this);
        if (this._occlusionQuery !== null) {
          this._occlusionQuery = null;
        }
        if (!this.subMeshes) {
          return;
        }
        for (const subMesh of this.subMeshes) {
          subMesh._rebuild();
        }
      }
      _resyncLightSources() {
        this._lightSources.length = 0;
        for (const light of this.getScene().lights) {
          if (!light.isEnabled()) {
            continue;
          }
          if (light.canAffectMesh(this)) {
            this._lightSources.push(light);
          }
        }
        this._markSubMeshesAsLightDirty();
      }
      _resyncLightSource(light) {
        const isIn = light.isEnabled() && light.canAffectMesh(this);
        const index = this._lightSources.indexOf(light);
        let removed = false;
        if (index === -1) {
          if (!isIn) {
            return;
          }
          this._lightSources.push(light);
        } else {
          if (isIn) {
            return;
          }
          removed = true;
          this._lightSources.splice(index, 1);
        }
        this._markSubMeshesAsLightDirty(removed);
      }
      _unBindEffect() {
        for (const subMesh of this.subMeshes) {
          subMesh.setEffect(null);
        }
      }
      _removeLightSource(light, dispose) {
        const index = this._lightSources.indexOf(light);
        if (index === -1) {
          return;
        }
        this._lightSources.splice(index, 1);
        this._markSubMeshesAsLightDirty(dispose);
      }
      _markSubMeshesAsDirty(func) {
        if (!this.subMeshes) {
          return;
        }
        for (const subMesh of this.subMeshes) {
          for (let i = 0; i < subMesh._drawWrappers.length; ++i) {
            const drawWrapper = subMesh._drawWrappers[i];
            if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
              continue;
            }
            func(drawWrapper.defines);
          }
        }
      }
      _markSubMeshesAsLightDirty(dispose = false) {
        this._markSubMeshesAsDirty((defines) => defines.markAsLightDirty(dispose));
      }
      _markSubMeshesAsAttributesDirty() {
        this._markSubMeshesAsDirty((defines) => defines.markAsAttributesDirty());
      }
      _markSubMeshesAsMiscDirty() {
        this._markSubMeshesAsDirty((defines) => defines.markAsMiscDirty());
      }
      markAsDirty(property) {
        this._currentRenderId = Number.MAX_VALUE;
        this._isDirty = true;
        return this;
      }
      resetDrawCache(passId) {
        if (!this.subMeshes) {
          return;
        }
        for (const subMesh of this.subMeshes) {
          subMesh.resetDrawCache(passId);
        }
      }
      get isBlocked() {
        return false;
      }
      getLOD(camera) {
        return this;
      }
      getTotalVertices() {
        return 0;
      }
      getTotalIndices() {
        return 0;
      }
      getIndices() {
        return null;
      }
      getVerticesData(kind) {
        return null;
      }
      setVerticesData(kind, data, updatable, stride) {
        return this;
      }
      updateVerticesData(kind, data, updateExtends, makeItUnique) {
        return this;
      }
      setIndices(indices, totalVertices) {
        return this;
      }
      isVerticesDataPresent(kind) {
        return false;
      }
      getBoundingInfo() {
        if (this._masterMesh) {
          return this._masterMesh.getBoundingInfo();
        }
        if (this._boundingInfoIsDirty) {
          this._boundingInfoIsDirty = false;
          this._updateBoundingInfo();
        }
        return this._boundingInfo;
      }
      getRawBoundingInfo() {
        var _a;
        return (_a = this.rawBoundingInfo) !== null && _a !== void 0 ? _a : this.getBoundingInfo();
      }
      setBoundingInfo(boundingInfo) {
        this._boundingInfo = boundingInfo;
        return this;
      }
      get hasBoundingInfo() {
        return this._boundingInfo !== null;
      }
      buildBoundingInfo(minimum, maximum, worldMatrix) {
        this._boundingInfo = new BoundingInfo(minimum, maximum, worldMatrix);
        return this._boundingInfo;
      }
      normalizeToUnitCube(includeDescendants = true, ignoreRotation = false, predicate) {
        return super.normalizeToUnitCube(includeDescendants, ignoreRotation, predicate);
      }
      get useBones() {
        return this.skeleton && this.getScene().skeletonsEnabled && this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind) && this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind);
      }
      _preActivate() {
      }
      _preActivateForIntermediateRendering(renderId) {
      }
      _activate(renderId, intermediateRendering) {
        this._renderId = renderId;
        return true;
      }
      _postActivate() {
      }
      _freeze() {
      }
      _unFreeze() {
      }
      getWorldMatrix() {
        if (this._masterMesh && this.billboardMode === TransformNode.BILLBOARDMODE_NONE) {
          return this._masterMesh.getWorldMatrix();
        }
        return super.getWorldMatrix();
      }
      _getWorldMatrixDeterminant() {
        if (this._masterMesh) {
          return this._masterMesh._getWorldMatrixDeterminant();
        }
        return super._getWorldMatrixDeterminant();
      }
      get isAnInstance() {
        return false;
      }
      get hasInstances() {
        return false;
      }
      get hasThinInstances() {
        return false;
      }
      movePOV(amountRight, amountUp, amountForward) {
        this.position.addInPlace(this.calcMovePOV(amountRight, amountUp, amountForward));
        return this;
      }
      calcMovePOV(amountRight, amountUp, amountForward) {
        const rotMatrix = new Matrix();
        const rotQuaternion = this.rotationQuaternion ? this.rotationQuaternion : Quaternion.RotationYawPitchRoll(this.rotation.y, this.rotation.x, this.rotation.z);
        rotQuaternion.toRotationMatrix(rotMatrix);
        const translationDelta = Vector3.Zero();
        const defForwardMult = this.definedFacingForward ? -1 : 1;
        Vector3.TransformCoordinatesFromFloatsToRef(amountRight * defForwardMult, amountUp, amountForward * defForwardMult, rotMatrix, translationDelta);
        return translationDelta;
      }
      rotatePOV(flipBack, twirlClockwise, tiltRight) {
        this.rotation.addInPlace(this.calcRotatePOV(flipBack, twirlClockwise, tiltRight));
        return this;
      }
      calcRotatePOV(flipBack, twirlClockwise, tiltRight) {
        const defForwardMult = this.definedFacingForward ? 1 : -1;
        return new Vector3(flipBack * defForwardMult, twirlClockwise, tiltRight * defForwardMult);
      }
      refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
        if (this._boundingInfo && this._boundingInfo.isLocked) {
          return this;
        }
        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), null);
        return this;
      }
      _refreshBoundingInfo(data, bias) {
        if (data) {
          const extend = extractMinAndMax(data, 0, this.getTotalVertices(), bias);
          if (this._boundingInfo) {
            this._boundingInfo.reConstruct(extend.minimum, extend.maximum);
          } else {
            this._boundingInfo = new BoundingInfo(extend.minimum, extend.maximum);
          }
        }
        if (this.subMeshes) {
          for (let index = 0; index < this.subMeshes.length; index++) {
            this.subMeshes[index].refreshBoundingInfo(data);
          }
        }
        this._updateBoundingInfo();
      }
      _getData(applySkeleton = false, applyMorph = false, data, kind = VertexBuffer.PositionKind) {
        data = data !== null && data !== void 0 ? data : this.getVerticesData(kind).slice();
        if (data && applyMorph && this.morphTargetManager) {
          let faceIndexCount = 0;
          let positionIndex = 0;
          for (let vertexCount = 0; vertexCount < data.length; vertexCount++) {
            for (let targetCount = 0; targetCount < this.morphTargetManager.numTargets; targetCount++) {
              const targetMorph = this.morphTargetManager.getTarget(targetCount);
              const influence = targetMorph.influence;
              if (influence > 0) {
                const morphTargetPositions = targetMorph.getPositions();
                if (morphTargetPositions) {
                  data[vertexCount] += (morphTargetPositions[vertexCount] - data[vertexCount]) * influence;
                }
              }
            }
            faceIndexCount++;
            if (kind === VertexBuffer.PositionKind) {
              if (this._positions && faceIndexCount === 3) {
                faceIndexCount = 0;
                const index = positionIndex * 3;
                this._positions[positionIndex++].copyFromFloats(data[index], data[index + 1], data[index + 2]);
              }
            }
          }
        }
        if (data && applySkeleton && this.skeleton) {
          const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
          const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
          if (matricesWeightsData && matricesIndicesData) {
            const needExtras = this.numBoneInfluencers > 4;
            const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
            const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
            const skeletonMatrices = this.skeleton.getTransformMatrices(this);
            const tempVector = TmpVectors.Vector3[0];
            const finalMatrix = TmpVectors.Matrix[0];
            const tempMatrix = TmpVectors.Matrix[1];
            let matWeightIdx = 0;
            for (let index = 0; index < data.length; index += 3, matWeightIdx += 4) {
              finalMatrix.reset();
              let inf;
              let weight;
              for (inf = 0; inf < 4; inf++) {
                weight = matricesWeightsData[matWeightIdx + inf];
                if (weight > 0) {
                  Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
                  finalMatrix.addToSelf(tempMatrix);
                }
              }
              if (needExtras) {
                for (inf = 0; inf < 4; inf++) {
                  weight = matricesWeightsExtraData[matWeightIdx + inf];
                  if (weight > 0) {
                    Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                    finalMatrix.addToSelf(tempMatrix);
                  }
                }
              }
              if (kind === VertexBuffer.NormalKind) {
                Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
              } else {
                Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], finalMatrix, tempVector);
              }
              tempVector.toArray(data, index);
              if (kind === VertexBuffer.PositionKind && this._positions) {
                this._positions[index / 3].copyFrom(tempVector);
              }
            }
          }
        }
        return data;
      }
      getNormalsData(applySkeleton = false, applyMorph = false) {
        return this._getData(applySkeleton, applyMorph, null, VertexBuffer.NormalKind);
      }
      getPositionData(applySkeleton = false, applyMorph = false, data) {
        return this._getData(applySkeleton, applyMorph, data, VertexBuffer.PositionKind);
      }
      _getPositionData(applySkeleton, applyMorph) {
        var _a;
        let data = this.getVerticesData(VertexBuffer.PositionKind);
        if (this._internalAbstractMeshDataInfo._positions) {
          this._internalAbstractMeshDataInfo._positions = null;
        }
        if (data && (applySkeleton && this.skeleton || applyMorph && this.morphTargetManager)) {
          data = data.slice();
          this._generatePointsArray();
          if (this._positions) {
            const pos = this._positions;
            this._internalAbstractMeshDataInfo._positions = new Array(pos.length);
            for (let i = 0; i < pos.length; i++) {
              this._internalAbstractMeshDataInfo._positions[i] = ((_a = pos[i]) === null || _a === void 0 ? void 0 : _a.clone()) || new Vector3();
            }
          }
          return this.getPositionData(applySkeleton, applyMorph, data);
        }
        return data;
      }
      _updateBoundingInfo() {
        if (this._boundingInfo) {
          this._boundingInfo.update(this.worldMatrixFromCache);
        } else {
          this._boundingInfo = new BoundingInfo(Vector3.Zero(), Vector3.Zero(), this.worldMatrixFromCache);
        }
        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        return this;
      }
      _updateSubMeshesBoundingInfo(matrix) {
        if (!this.subMeshes) {
          return this;
        }
        const count = this.subMeshes.length;
        for (let subIndex = 0; subIndex < count; subIndex++) {
          const subMesh = this.subMeshes[subIndex];
          if (count > 1 || !subMesh.IsGlobal) {
            subMesh.updateBoundingInfo(matrix);
          }
        }
        return this;
      }
      _afterComputeWorldMatrix() {
        if (this.doNotSyncBoundingInfo) {
          return;
        }
        this._boundingInfoIsDirty = true;
      }
      isInFrustum(frustumPlanes) {
        return this.getBoundingInfo().isInFrustum(frustumPlanes, this.cullingStrategy);
      }
      isCompletelyInFrustum(frustumPlanes) {
        return this.getBoundingInfo().isCompletelyInFrustum(frustumPlanes);
      }
      intersectsMesh(mesh, precise = false, includeDescendants) {
        const boundingInfo = this.getBoundingInfo();
        const otherBoundingInfo = mesh.getBoundingInfo();
        if (boundingInfo.intersects(otherBoundingInfo, precise)) {
          return true;
        }
        if (includeDescendants) {
          for (const child of this.getChildMeshes()) {
            if (child.intersectsMesh(mesh, precise, true)) {
              return true;
            }
          }
        }
        return false;
      }
      intersectsPoint(point) {
        return this.getBoundingInfo().intersectsPoint(point);
      }
      get checkCollisions() {
        return this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions;
      }
      set checkCollisions(collisionEnabled) {
        this._internalAbstractMeshDataInfo._meshCollisionData._checkCollisions = collisionEnabled;
      }
      get collider() {
        return this._internalAbstractMeshDataInfo._meshCollisionData._collider;
      }
      moveWithCollisions(displacement) {
        const globalPosition = this.getAbsolutePosition();
        globalPosition.addToRef(this.ellipsoidOffset, this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions);
        const coordinator = this.getScene().collisionCoordinator;
        if (!this._internalAbstractMeshDataInfo._meshCollisionData._collider) {
          this._internalAbstractMeshDataInfo._meshCollisionData._collider = coordinator.createCollider();
        }
        this._internalAbstractMeshDataInfo._meshCollisionData._collider._radius = this.ellipsoid;
        coordinator.getNewPosition(this._internalAbstractMeshDataInfo._meshCollisionData._oldPositionForCollisions, displacement, this._internalAbstractMeshDataInfo._meshCollisionData._collider, this.collisionRetryCount, this, this._onCollisionPositionChange, this.uniqueId);
        return this;
      }
      _collideForSubMesh(subMesh, transformMatrix, collider) {
        var _a;
        this._generatePointsArray();
        if (!this._positions) {
          return this;
        }
        if (!subMesh._lastColliderWorldVertices || !subMesh._lastColliderTransformMatrix.equals(transformMatrix)) {
          subMesh._lastColliderTransformMatrix = transformMatrix.clone();
          subMesh._lastColliderWorldVertices = [];
          subMesh._trianglePlanes = [];
          const start = subMesh.verticesStart;
          const end = subMesh.verticesStart + subMesh.verticesCount;
          for (let i = start; i < end; i++) {
            subMesh._lastColliderWorldVertices.push(Vector3.TransformCoordinates(this._positions[i], transformMatrix));
          }
        }
        collider._collide(subMesh._trianglePlanes, subMesh._lastColliderWorldVertices, this.getIndices(), subMesh.indexStart, subMesh.indexStart + subMesh.indexCount, subMesh.verticesStart, !!subMesh.getMaterial(), this, this._shouldConvertRHS(), ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.fillMode) === 7);
        return this;
      }
      _processCollisionsForSubMeshes(collider, transformMatrix) {
        const subMeshes = this._scene.getCollidingSubMeshCandidates(this, collider);
        const len = subMeshes.length;
        for (let index = 0; index < len; index++) {
          const subMesh = subMeshes.data[index];
          if (len > 1 && !subMesh._checkCollision(collider)) {
            continue;
          }
          this._collideForSubMesh(subMesh, transformMatrix, collider);
        }
        return this;
      }
      _shouldConvertRHS() {
        return false;
      }
      _checkCollision(collider) {
        if (!this.getBoundingInfo()._checkCollision(collider)) {
          return this;
        }
        const collisionsScalingMatrix = TmpVectors.Matrix[0];
        const collisionsTransformMatrix = TmpVectors.Matrix[1];
        Matrix.ScalingToRef(1 / collider._radius.x, 1 / collider._radius.y, 1 / collider._radius.z, collisionsScalingMatrix);
        this.worldMatrixFromCache.multiplyToRef(collisionsScalingMatrix, collisionsTransformMatrix);
        this._processCollisionsForSubMeshes(collider, collisionsTransformMatrix);
        return this;
      }
      _generatePointsArray() {
        return false;
      }
      intersects(ray, fastCheck, trianglePredicate, onlyBoundingInfo = false, worldToUse, skipBoundingInfo = false) {
        const pickingInfo = new PickingInfo();
        const className = this.getClassName();
        const intersectionThreshold = className === "InstancedLinesMesh" || className === "LinesMesh" || className === "GreasedLineMesh" ? this.intersectionThreshold : 0;
        const boundingInfo = this.getBoundingInfo();
        if (!this.subMeshes) {
          return pickingInfo;
        }
        if (!skipBoundingInfo && (!ray.intersectsSphere(boundingInfo.boundingSphere, intersectionThreshold) || !ray.intersectsBox(boundingInfo.boundingBox, intersectionThreshold))) {
          return pickingInfo;
        }
        if (onlyBoundingInfo) {
          pickingInfo.hit = skipBoundingInfo ? false : true;
          pickingInfo.pickedMesh = skipBoundingInfo ? null : this;
          pickingInfo.distance = skipBoundingInfo ? 0 : Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
          pickingInfo.subMeshId = 0;
          return pickingInfo;
        }
        if (!this._generatePointsArray()) {
          return pickingInfo;
        }
        let intersectInfo = null;
        const subMeshes = this._scene.getIntersectingSubMeshCandidates(this, ray);
        const len = subMeshes.length;
        let anySubmeshSupportIntersect = false;
        for (let index = 0; index < len; index++) {
          const subMesh = subMeshes.data[index];
          const material = subMesh.getMaterial();
          if (!material) {
            continue;
          }
          if (material.fillMode == 7 || material.fillMode == 0 || material.fillMode == 1 || material.fillMode == 2 || material.fillMode == 4) {
            anySubmeshSupportIntersect = true;
            break;
          }
        }
        if (!anySubmeshSupportIntersect) {
          pickingInfo.hit = true;
          pickingInfo.pickedMesh = this;
          pickingInfo.distance = Vector3.Distance(ray.origin, boundingInfo.boundingSphere.center);
          pickingInfo.subMeshId = -1;
          return pickingInfo;
        }
        for (let index = 0; index < len; index++) {
          const subMesh = subMeshes.data[index];
          if (len > 1 && !subMesh.canIntersects(ray)) {
            continue;
          }
          const currentIntersectInfo = subMesh.intersects(ray, this._positions, this.getIndices(), fastCheck, trianglePredicate);
          if (currentIntersectInfo) {
            if (fastCheck || !intersectInfo || currentIntersectInfo.distance < intersectInfo.distance) {
              intersectInfo = currentIntersectInfo;
              intersectInfo.subMeshId = index;
              if (fastCheck) {
                break;
              }
            }
          }
        }
        if (intersectInfo) {
          const world = worldToUse !== null && worldToUse !== void 0 ? worldToUse : this.getWorldMatrix();
          const worldOrigin = TmpVectors.Vector3[0];
          const direction = TmpVectors.Vector3[1];
          Vector3.TransformCoordinatesToRef(ray.origin, world, worldOrigin);
          ray.direction.scaleToRef(intersectInfo.distance, direction);
          const worldDirection = Vector3.TransformNormal(direction, world);
          const pickedPoint = worldDirection.addInPlace(worldOrigin);
          pickingInfo.hit = true;
          pickingInfo.distance = Vector3.Distance(worldOrigin, pickedPoint);
          pickingInfo.pickedPoint = pickedPoint;
          pickingInfo.pickedMesh = this;
          pickingInfo.bu = intersectInfo.bu || 0;
          pickingInfo.bv = intersectInfo.bv || 0;
          pickingInfo.subMeshFaceId = intersectInfo.faceId;
          pickingInfo.faceId = intersectInfo.faceId + subMeshes.data[intersectInfo.subMeshId].indexStart / (this.getClassName().indexOf("LinesMesh") !== -1 ? 2 : 3);
          pickingInfo.subMeshId = intersectInfo.subMeshId;
          return pickingInfo;
        }
        return pickingInfo;
      }
      clone(name109, newParent, doNotCloneChildren) {
        return null;
      }
      releaseSubMeshes() {
        if (this.subMeshes) {
          while (this.subMeshes.length) {
            this.subMeshes[0].dispose();
          }
        } else {
          this.subMeshes = new Array();
        }
        return this;
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        let index;
        if (this._scene.useMaterialMeshMap) {
          if (this._internalAbstractMeshDataInfo._material && this._internalAbstractMeshDataInfo._material.meshMap) {
            this._internalAbstractMeshDataInfo._material.meshMap[this.uniqueId] = void 0;
          }
        }
        this.getScene().freeActiveMeshes();
        this.getScene().freeRenderingGroups();
        if (this.actionManager !== void 0 && this.actionManager !== null) {
          if (!this._scene.meshes.some((m) => m !== this && m.actionManager === this.actionManager)) {
            this.actionManager.dispose();
          }
          this.actionManager = null;
        }
        this._internalAbstractMeshDataInfo._skeleton = null;
        if (this._transformMatrixTexture) {
          this._transformMatrixTexture.dispose();
          this._transformMatrixTexture = null;
        }
        for (index = 0; index < this._intersectionsInProgress.length; index++) {
          const other = this._intersectionsInProgress[index];
          const pos = other._intersectionsInProgress.indexOf(this);
          other._intersectionsInProgress.splice(pos, 1);
        }
        this._intersectionsInProgress.length = 0;
        const lights = this.getScene().lights;
        lights.forEach((light) => {
          let meshIndex = light.includedOnlyMeshes.indexOf(this);
          if (meshIndex !== -1) {
            light.includedOnlyMeshes.splice(meshIndex, 1);
          }
          meshIndex = light.excludedMeshes.indexOf(this);
          if (meshIndex !== -1) {
            light.excludedMeshes.splice(meshIndex, 1);
          }
          const generators = light.getShadowGenerators();
          if (generators) {
            const iterator = generators.values();
            for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
              const generator = key.value;
              const shadowMap = generator.getShadowMap();
              if (shadowMap && shadowMap.renderList) {
                meshIndex = shadowMap.renderList.indexOf(this);
                if (meshIndex !== -1) {
                  shadowMap.renderList.splice(meshIndex, 1);
                }
              }
            }
          }
        });
        if (this.getClassName() !== "InstancedMesh" || this.getClassName() !== "InstancedLinesMesh") {
          this.releaseSubMeshes();
        }
        const engine = this.getScene().getEngine();
        if (this._occlusionQuery !== null) {
          this.isOcclusionQueryInProgress = false;
          engine.deleteQuery(this._occlusionQuery);
          this._occlusionQuery = null;
        }
        engine.wipeCaches();
        this.getScene().removeMesh(this);
        if (this._parentContainer) {
          const index2 = this._parentContainer.meshes.indexOf(this);
          if (index2 > -1) {
            this._parentContainer.meshes.splice(index2, 1);
          }
          this._parentContainer = null;
        }
        if (disposeMaterialAndTextures) {
          if (this.material) {
            if (this.material.getClassName() === "MultiMaterial") {
              this.material.dispose(false, true, true);
            } else {
              this.material.dispose(false, true);
            }
          }
        }
        if (!doNotRecurse) {
          for (index = 0; index < this.getScene().particleSystems.length; index++) {
            if (this.getScene().particleSystems[index].emitter === this) {
              this.getScene().particleSystems[index].dispose();
              index--;
            }
          }
        }
        if (this._internalAbstractMeshDataInfo._facetData.facetDataEnabled) {
          this.disableFacetData();
        }
        this._uniformBuffer.dispose();
        this.onAfterWorldMatrixUpdateObservable.clear();
        this.onCollideObservable.clear();
        this.onCollisionPositionChangeObservable.clear();
        this.onRebuildObservable.clear();
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      addChild(mesh, preserveScalingSign = false) {
        mesh.setParent(this, preserveScalingSign);
        return this;
      }
      removeChild(mesh, preserveScalingSign = false) {
        mesh.setParent(null, preserveScalingSign);
        return this;
      }
      _initFacetData() {
        const data = this._internalAbstractMeshDataInfo._facetData;
        if (!data.facetNormals) {
          data.facetNormals = new Array();
        }
        if (!data.facetPositions) {
          data.facetPositions = new Array();
        }
        if (!data.facetPartitioning) {
          data.facetPartitioning = new Array();
        }
        data.facetNb = this.getIndices().length / 3 | 0;
        data.partitioningSubdivisions = data.partitioningSubdivisions ? data.partitioningSubdivisions : 10;
        data.partitioningBBoxRatio = data.partitioningBBoxRatio ? data.partitioningBBoxRatio : 1.01;
        for (let f = 0; f < data.facetNb; f++) {
          data.facetNormals[f] = Vector3.Zero();
          data.facetPositions[f] = Vector3.Zero();
        }
        data.facetDataEnabled = true;
        return this;
      }
      updateFacetData() {
        const data = this._internalAbstractMeshDataInfo._facetData;
        if (!data.facetDataEnabled) {
          this._initFacetData();
        }
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        const indices = this.getIndices();
        const normals = this.getVerticesData(VertexBuffer.NormalKind);
        const bInfo = this.getBoundingInfo();
        if (data.facetDepthSort && !data.facetDepthSortEnabled) {
          data.facetDepthSortEnabled = true;
          if (indices instanceof Uint16Array) {
            data.depthSortedIndices = new Uint16Array(indices);
          } else if (indices instanceof Uint32Array) {
            data.depthSortedIndices = new Uint32Array(indices);
          } else {
            let needs32bits = false;
            for (let i = 0; i < indices.length; i++) {
              if (indices[i] > 65535) {
                needs32bits = true;
                break;
              }
            }
            if (needs32bits) {
              data.depthSortedIndices = new Uint32Array(indices);
            } else {
              data.depthSortedIndices = new Uint16Array(indices);
            }
          }
          data.facetDepthSortFunction = function(f1, f2) {
            return f2.sqDistance - f1.sqDistance;
          };
          if (!data.facetDepthSortFrom) {
            const camera = this.getScene().activeCamera;
            data.facetDepthSortFrom = camera ? camera.position : Vector3.Zero();
          }
          data.depthSortedFacets = [];
          for (let f = 0; f < data.facetNb; f++) {
            const depthSortedFacet = { ind: f * 3, sqDistance: 0 };
            data.depthSortedFacets.push(depthSortedFacet);
          }
          data.invertedMatrix = Matrix.Identity();
          data.facetDepthSortOrigin = Vector3.Zero();
        }
        data.bbSize.x = bInfo.maximum.x - bInfo.minimum.x > Epsilon ? bInfo.maximum.x - bInfo.minimum.x : Epsilon;
        data.bbSize.y = bInfo.maximum.y - bInfo.minimum.y > Epsilon ? bInfo.maximum.y - bInfo.minimum.y : Epsilon;
        data.bbSize.z = bInfo.maximum.z - bInfo.minimum.z > Epsilon ? bInfo.maximum.z - bInfo.minimum.z : Epsilon;
        let bbSizeMax = data.bbSize.x > data.bbSize.y ? data.bbSize.x : data.bbSize.y;
        bbSizeMax = bbSizeMax > data.bbSize.z ? bbSizeMax : data.bbSize.z;
        data.subDiv.max = data.partitioningSubdivisions;
        data.subDiv.X = Math.floor(data.subDiv.max * data.bbSize.x / bbSizeMax);
        data.subDiv.Y = Math.floor(data.subDiv.max * data.bbSize.y / bbSizeMax);
        data.subDiv.Z = Math.floor(data.subDiv.max * data.bbSize.z / bbSizeMax);
        data.subDiv.X = data.subDiv.X < 1 ? 1 : data.subDiv.X;
        data.subDiv.Y = data.subDiv.Y < 1 ? 1 : data.subDiv.Y;
        data.subDiv.Z = data.subDiv.Z < 1 ? 1 : data.subDiv.Z;
        data.facetParameters.facetNormals = this.getFacetLocalNormals();
        data.facetParameters.facetPositions = this.getFacetLocalPositions();
        data.facetParameters.facetPartitioning = this.getFacetLocalPartitioning();
        data.facetParameters.bInfo = bInfo;
        data.facetParameters.bbSize = data.bbSize;
        data.facetParameters.subDiv = data.subDiv;
        data.facetParameters.ratio = this.partitioningBBoxRatio;
        data.facetParameters.depthSort = data.facetDepthSort;
        if (data.facetDepthSort && data.facetDepthSortEnabled) {
          this.computeWorldMatrix(true);
          this._worldMatrix.invertToRef(data.invertedMatrix);
          Vector3.TransformCoordinatesToRef(data.facetDepthSortFrom, data.invertedMatrix, data.facetDepthSortOrigin);
          data.facetParameters.distanceTo = data.facetDepthSortOrigin;
        }
        data.facetParameters.depthSortedFacets = data.depthSortedFacets;
        if (normals) {
          VertexData.ComputeNormals(positions, indices, normals, data.facetParameters);
        }
        if (data.facetDepthSort && data.facetDepthSortEnabled) {
          data.depthSortedFacets.sort(data.facetDepthSortFunction);
          const l = data.depthSortedIndices.length / 3 | 0;
          for (let f = 0; f < l; f++) {
            const sind = data.depthSortedFacets[f].ind;
            data.depthSortedIndices[f * 3] = indices[sind];
            data.depthSortedIndices[f * 3 + 1] = indices[sind + 1];
            data.depthSortedIndices[f * 3 + 2] = indices[sind + 2];
          }
          this.updateIndices(data.depthSortedIndices, void 0, true);
        }
        return this;
      }
      getFacetLocalNormals() {
        const facetData = this._internalAbstractMeshDataInfo._facetData;
        if (!facetData.facetNormals) {
          this.updateFacetData();
        }
        return facetData.facetNormals;
      }
      getFacetLocalPositions() {
        const facetData = this._internalAbstractMeshDataInfo._facetData;
        if (!facetData.facetPositions) {
          this.updateFacetData();
        }
        return facetData.facetPositions;
      }
      getFacetLocalPartitioning() {
        const facetData = this._internalAbstractMeshDataInfo._facetData;
        if (!facetData.facetPartitioning) {
          this.updateFacetData();
        }
        return facetData.facetPartitioning;
      }
      getFacetPosition(i) {
        const pos = Vector3.Zero();
        this.getFacetPositionToRef(i, pos);
        return pos;
      }
      getFacetPositionToRef(i, ref) {
        const localPos = this.getFacetLocalPositions()[i];
        const world = this.getWorldMatrix();
        Vector3.TransformCoordinatesToRef(localPos, world, ref);
        return this;
      }
      getFacetNormal(i) {
        const norm = Vector3.Zero();
        this.getFacetNormalToRef(i, norm);
        return norm;
      }
      getFacetNormalToRef(i, ref) {
        const localNorm = this.getFacetLocalNormals()[i];
        Vector3.TransformNormalToRef(localNorm, this.getWorldMatrix(), ref);
        return this;
      }
      getFacetsAtLocalCoordinates(x, y, z) {
        const bInfo = this.getBoundingInfo();
        const data = this._internalAbstractMeshDataInfo._facetData;
        const ox = Math.floor((x - bInfo.minimum.x * data.partitioningBBoxRatio) * data.subDiv.X * data.partitioningBBoxRatio / data.bbSize.x);
        const oy = Math.floor((y - bInfo.minimum.y * data.partitioningBBoxRatio) * data.subDiv.Y * data.partitioningBBoxRatio / data.bbSize.y);
        const oz = Math.floor((z - bInfo.minimum.z * data.partitioningBBoxRatio) * data.subDiv.Z * data.partitioningBBoxRatio / data.bbSize.z);
        if (ox < 0 || ox > data.subDiv.max || oy < 0 || oy > data.subDiv.max || oz < 0 || oz > data.subDiv.max) {
          return null;
        }
        return data.facetPartitioning[ox + data.subDiv.max * oy + data.subDiv.max * data.subDiv.max * oz];
      }
      getClosestFacetAtCoordinates(x, y, z, projected, checkFace = false, facing = true) {
        const world = this.getWorldMatrix();
        const invMat = TmpVectors.Matrix[5];
        world.invertToRef(invMat);
        const invVect = TmpVectors.Vector3[8];
        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, invMat, invVect);
        const closest = this.getClosestFacetAtLocalCoordinates(invVect.x, invVect.y, invVect.z, projected, checkFace, facing);
        if (projected) {
          Vector3.TransformCoordinatesFromFloatsToRef(projected.x, projected.y, projected.z, world, projected);
        }
        return closest;
      }
      getClosestFacetAtLocalCoordinates(x, y, z, projected, checkFace = false, facing = true) {
        let closest = null;
        let tmpx = 0;
        let tmpy = 0;
        let tmpz = 0;
        let d = 0;
        let t0 = 0;
        let projx = 0;
        let projy = 0;
        let projz = 0;
        const facetPositions = this.getFacetLocalPositions();
        const facetNormals = this.getFacetLocalNormals();
        const facetsInBlock = this.getFacetsAtLocalCoordinates(x, y, z);
        if (!facetsInBlock) {
          return null;
        }
        let shortest = Number.MAX_VALUE;
        let tmpDistance = shortest;
        let fib;
        let norm;
        let p0;
        for (let idx = 0; idx < facetsInBlock.length; idx++) {
          fib = facetsInBlock[idx];
          norm = facetNormals[fib];
          p0 = facetPositions[fib];
          d = (x - p0.x) * norm.x + (y - p0.y) * norm.y + (z - p0.z) * norm.z;
          if (!checkFace || checkFace && facing && d >= 0 || checkFace && !facing && d <= 0) {
            d = norm.x * p0.x + norm.y * p0.y + norm.z * p0.z;
            t0 = -(norm.x * x + norm.y * y + norm.z * z - d) / (norm.x * norm.x + norm.y * norm.y + norm.z * norm.z);
            projx = x + norm.x * t0;
            projy = y + norm.y * t0;
            projz = z + norm.z * t0;
            tmpx = projx - x;
            tmpy = projy - y;
            tmpz = projz - z;
            tmpDistance = tmpx * tmpx + tmpy * tmpy + tmpz * tmpz;
            if (tmpDistance < shortest) {
              shortest = tmpDistance;
              closest = fib;
              if (projected) {
                projected.x = projx;
                projected.y = projy;
                projected.z = projz;
              }
            }
          }
        }
        return closest;
      }
      getFacetDataParameters() {
        return this._internalAbstractMeshDataInfo._facetData.facetParameters;
      }
      disableFacetData() {
        const facetData = this._internalAbstractMeshDataInfo._facetData;
        if (facetData.facetDataEnabled) {
          facetData.facetDataEnabled = false;
          facetData.facetPositions = new Array();
          facetData.facetNormals = new Array();
          facetData.facetPartitioning = new Array();
          facetData.facetParameters = null;
          facetData.depthSortedIndices = new Uint32Array(0);
        }
        return this;
      }
      updateIndices(indices, offset, gpuMemoryOnly = false) {
        return this;
      }
      createNormals(updatable) {
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        const indices = this.getIndices();
        let normals;
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          normals = this.getVerticesData(VertexBuffer.NormalKind);
        } else {
          normals = [];
        }
        VertexData.ComputeNormals(positions, indices, normals, { useRightHandedSystem: this.getScene().useRightHandedSystem });
        this.setVerticesData(VertexBuffer.NormalKind, normals, updatable);
        return this;
      }
      alignWithNormal(normal, upDirection) {
        if (!upDirection) {
          upDirection = Axis.Y;
        }
        const axisX = TmpVectors.Vector3[0];
        const axisZ = TmpVectors.Vector3[1];
        Vector3.CrossToRef(upDirection, normal, axisZ);
        Vector3.CrossToRef(normal, axisZ, axisX);
        if (this.rotationQuaternion) {
          Quaternion.RotationQuaternionFromAxisToRef(axisX, normal, axisZ, this.rotationQuaternion);
        } else {
          Vector3.RotationFromAxisToRef(axisX, normal, axisZ, this.rotation);
        }
        return this;
      }
      _checkOcclusionQuery() {
        return false;
      }
      disableEdgesRendering() {
        throw _WarnImport("EdgesRenderer");
      }
      enableEdgesRendering(epsilon, checkVerticesInsteadOfIndices, options) {
        throw _WarnImport("EdgesRenderer");
      }
      getConnectedParticleSystems() {
        return this._scene.particleSystems.filter((particleSystem) => particleSystem.emitter === this);
      }
    };
    AbstractMesh.OCCLUSION_TYPE_NONE = 0;
    AbstractMesh.OCCLUSION_TYPE_OPTIMISTIC = 1;
    AbstractMesh.OCCLUSION_TYPE_STRICT = 2;
    AbstractMesh.OCCLUSION_ALGORITHM_TYPE_ACCURATE = 0;
    AbstractMesh.OCCLUSION_ALGORITHM_TYPE_CONSERVATIVE = 1;
    AbstractMesh.CULLINGSTRATEGY_STANDARD = 0;
    AbstractMesh.CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
    AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
    AbstractMesh.CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
    RegisterClass("BABYLON.AbstractMesh", AbstractMesh);
  }
});

// node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js
function addClipPlaneUniforms(uniforms) {
  if (uniforms.indexOf("vClipPlane") === -1) {
    uniforms.push("vClipPlane");
  }
  if (uniforms.indexOf("vClipPlane2") === -1) {
    uniforms.push("vClipPlane2");
  }
  if (uniforms.indexOf("vClipPlane3") === -1) {
    uniforms.push("vClipPlane3");
  }
  if (uniforms.indexOf("vClipPlane4") === -1) {
    uniforms.push("vClipPlane4");
  }
  if (uniforms.indexOf("vClipPlane5") === -1) {
    uniforms.push("vClipPlane5");
  }
  if (uniforms.indexOf("vClipPlane6") === -1) {
    uniforms.push("vClipPlane6");
  }
}
function prepareStringDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  var _a, _b, _c, _d, _e, _f;
  const clipPlane = !!((_a = primaryHolder.clipPlane) !== null && _a !== void 0 ? _a : secondaryHolder.clipPlane);
  const clipPlane2 = !!((_b = primaryHolder.clipPlane2) !== null && _b !== void 0 ? _b : secondaryHolder.clipPlane2);
  const clipPlane3 = !!((_c = primaryHolder.clipPlane3) !== null && _c !== void 0 ? _c : secondaryHolder.clipPlane3);
  const clipPlane4 = !!((_d = primaryHolder.clipPlane4) !== null && _d !== void 0 ? _d : secondaryHolder.clipPlane4);
  const clipPlane5 = !!((_e = primaryHolder.clipPlane5) !== null && _e !== void 0 ? _e : secondaryHolder.clipPlane5);
  const clipPlane6 = !!((_f = primaryHolder.clipPlane6) !== null && _f !== void 0 ? _f : secondaryHolder.clipPlane6);
  if (clipPlane)
    defines.push("#define CLIPPLANE");
  if (clipPlane2)
    defines.push("#define CLIPPLANE2");
  if (clipPlane3)
    defines.push("#define CLIPPLANE3");
  if (clipPlane4)
    defines.push("#define CLIPPLANE4");
  if (clipPlane5)
    defines.push("#define CLIPPLANE5");
  if (clipPlane6)
    defines.push("#define CLIPPLANE6");
}
function prepareDefinesForClipPlanes(primaryHolder, secondaryHolder, defines) {
  var _a, _b, _c, _d, _e, _f;
  let changed = false;
  const clipPlane = !!((_a = primaryHolder.clipPlane) !== null && _a !== void 0 ? _a : secondaryHolder.clipPlane);
  const clipPlane2 = !!((_b = primaryHolder.clipPlane2) !== null && _b !== void 0 ? _b : secondaryHolder.clipPlane2);
  const clipPlane3 = !!((_c = primaryHolder.clipPlane3) !== null && _c !== void 0 ? _c : secondaryHolder.clipPlane3);
  const clipPlane4 = !!((_d = primaryHolder.clipPlane4) !== null && _d !== void 0 ? _d : secondaryHolder.clipPlane4);
  const clipPlane5 = !!((_e = primaryHolder.clipPlane5) !== null && _e !== void 0 ? _e : secondaryHolder.clipPlane5);
  const clipPlane6 = !!((_f = primaryHolder.clipPlane6) !== null && _f !== void 0 ? _f : secondaryHolder.clipPlane6);
  if (defines["CLIPPLANE"] !== clipPlane) {
    defines["CLIPPLANE"] = clipPlane;
    changed = true;
  }
  if (defines["CLIPPLANE2"] !== clipPlane2) {
    defines["CLIPPLANE2"] = clipPlane2;
    changed = true;
  }
  if (defines["CLIPPLANE3"] !== clipPlane3) {
    defines["CLIPPLANE3"] = clipPlane3;
    changed = true;
  }
  if (defines["CLIPPLANE4"] !== clipPlane4) {
    defines["CLIPPLANE4"] = clipPlane4;
    changed = true;
  }
  if (defines["CLIPPLANE5"] !== clipPlane5) {
    defines["CLIPPLANE5"] = clipPlane5;
    changed = true;
  }
  if (defines["CLIPPLANE6"] !== clipPlane6) {
    defines["CLIPPLANE6"] = clipPlane6;
    changed = true;
  }
  return changed;
}
function bindClipPlane(effect, primaryHolder, secondaryHolder) {
  var _a, _b, _c, _d, _e, _f;
  let clipPlane = (_a = primaryHolder.clipPlane) !== null && _a !== void 0 ? _a : secondaryHolder.clipPlane;
  setClipPlane(effect, "vClipPlane", clipPlane);
  clipPlane = (_b = primaryHolder.clipPlane2) !== null && _b !== void 0 ? _b : secondaryHolder.clipPlane2;
  setClipPlane(effect, "vClipPlane2", clipPlane);
  clipPlane = (_c = primaryHolder.clipPlane3) !== null && _c !== void 0 ? _c : secondaryHolder.clipPlane3;
  setClipPlane(effect, "vClipPlane3", clipPlane);
  clipPlane = (_d = primaryHolder.clipPlane4) !== null && _d !== void 0 ? _d : secondaryHolder.clipPlane4;
  setClipPlane(effect, "vClipPlane4", clipPlane);
  clipPlane = (_e = primaryHolder.clipPlane5) !== null && _e !== void 0 ? _e : secondaryHolder.clipPlane5;
  setClipPlane(effect, "vClipPlane5", clipPlane);
  clipPlane = (_f = primaryHolder.clipPlane6) !== null && _f !== void 0 ? _f : secondaryHolder.clipPlane6;
  setClipPlane(effect, "vClipPlane6", clipPlane);
}
function setClipPlane(effect, uniformName, clipPlane) {
  if (clipPlane) {
    effect.setFloat4(uniformName, clipPlane.normal.x, clipPlane.normal.y, clipPlane.normal.z, clipPlane.d);
  }
}
var init_clipPlaneMaterialHelper = __esm({
  "node_modules/@babylonjs/core/Materials/clipPlaneMaterialHelper.js"() {
  }
});

// node_modules/@babylonjs/core/Materials/materialHelper.js
var MaterialHelper;
var init_materialHelper = __esm({
  "node_modules/@babylonjs/core/Materials/materialHelper.js"() {
    init_logger();
    init_camera();
    init_scene();
    init_engineStore();
    init_buffer();
    init_lightConstants();
    init_math_color();
    init_clipPlaneMaterialHelper();
    MaterialHelper = class {
      static BindSceneUniformBuffer(effect, sceneUbo) {
        sceneUbo.bindToEffect(effect, "Scene");
      }
      static PrepareDefinesForMergedUV(texture, defines, key) {
        defines._needUVs = true;
        defines[key] = true;
        if (texture.optimizeUVAllocation && texture.getTextureMatrix().isIdentityAs3x2()) {
          defines[key + "DIRECTUV"] = texture.coordinatesIndex + 1;
          defines["MAINUV" + (texture.coordinatesIndex + 1)] = true;
        } else {
          defines[key + "DIRECTUV"] = 0;
        }
      }
      static BindTextureMatrix(texture, uniformBuffer, key) {
        const matrix = texture.getTextureMatrix();
        uniformBuffer.updateMatrix(key + "Matrix", matrix);
      }
      static GetFogState(mesh, scene) {
        return scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE;
      }
      static PrepareDefinesForMisc(mesh, scene, useLogarithmicDepth, pointsCloud, fogEnabled, alphaTest, defines, applyDecalAfterDetail = false) {
        if (defines._areMiscDirty) {
          defines["LOGARITHMICDEPTH"] = useLogarithmicDepth;
          defines["POINTSIZE"] = pointsCloud;
          defines["FOG"] = fogEnabled && this.GetFogState(mesh, scene);
          defines["NONUNIFORMSCALING"] = mesh.nonUniformScaling;
          defines["ALPHATEST"] = alphaTest;
          defines["DECAL_AFTER_DETAIL"] = applyDecalAfterDetail;
        }
      }
      static PrepareDefinesForCamera(scene, defines) {
        let changed = false;
        if (scene.activeCamera) {
          const wasOrtho = defines["CAMERA_ORTHOGRAPHIC"] ? 1 : 0;
          const wasPersp = defines["CAMERA_PERSPECTIVE"] ? 1 : 0;
          const isOrtho = scene.activeCamera.mode === Camera.ORTHOGRAPHIC_CAMERA ? 1 : 0;
          const isPersp = scene.activeCamera.mode === Camera.PERSPECTIVE_CAMERA ? 1 : 0;
          if (wasOrtho ^ isOrtho || wasPersp ^ isPersp) {
            defines["CAMERA_ORTHOGRAPHIC"] = isOrtho === 1;
            defines["CAMERA_PERSPECTIVE"] = isPersp === 1;
            changed = true;
          }
        }
        return changed;
      }
      static PrepareDefinesForFrameBoundValues(scene, engine, material, defines, useInstances, useClipPlane = null, useThinInstances = false) {
        let changed = MaterialHelper.PrepareDefinesForCamera(scene, defines);
        if (useClipPlane !== false) {
          changed = prepareDefinesForClipPlanes(material, scene, defines);
        }
        if (defines["DEPTHPREPASS"] !== !engine.getColorWrite()) {
          defines["DEPTHPREPASS"] = !defines["DEPTHPREPASS"];
          changed = true;
        }
        if (defines["INSTANCES"] !== useInstances) {
          defines["INSTANCES"] = useInstances;
          changed = true;
        }
        if (defines["THIN_INSTANCES"] !== useThinInstances) {
          defines["THIN_INSTANCES"] = useThinInstances;
          changed = true;
        }
        if (changed) {
          defines.markAsUnprocessed();
        }
      }
      static PrepareDefinesForBones(mesh, defines) {
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          defines["NUM_BONE_INFLUENCERS"] = mesh.numBoneInfluencers;
          const materialSupportsBoneTexture = defines["BONETEXTURE"] !== void 0;
          if (mesh.skeleton.isUsingTextureForMatrices && materialSupportsBoneTexture) {
            defines["BONETEXTURE"] = true;
          } else {
            defines["BonesPerMesh"] = mesh.skeleton.bones.length + 1;
            defines["BONETEXTURE"] = materialSupportsBoneTexture ? false : void 0;
            const prePassRenderer = mesh.getScene().prePassRenderer;
            if (prePassRenderer && prePassRenderer.enabled) {
              const nonExcluded = prePassRenderer.excludedSkinnedMesh.indexOf(mesh) === -1;
              defines["BONES_VELOCITY_ENABLED"] = nonExcluded;
            }
          }
        } else {
          defines["NUM_BONE_INFLUENCERS"] = 0;
          defines["BonesPerMesh"] = 0;
          if (defines["BONETEXTURE"] !== void 0) {
            defines["BONETEXTURE"] = false;
          }
        }
      }
      static PrepareDefinesForMorphTargets(mesh, defines) {
        const manager = mesh.morphTargetManager;
        if (manager) {
          defines["MORPHTARGETS_UV"] = manager.supportsUVs && defines["UV1"];
          defines["MORPHTARGETS_TANGENT"] = manager.supportsTangents && defines["TANGENT"];
          defines["MORPHTARGETS_NORMAL"] = manager.supportsNormals && defines["NORMAL"];
          defines["MORPHTARGETS"] = manager.numInfluencers > 0;
          defines["NUM_MORPH_INFLUENCERS"] = manager.numInfluencers;
          defines["MORPHTARGETS_TEXTURE"] = manager.isUsingTextureForTargets;
        } else {
          defines["MORPHTARGETS_UV"] = false;
          defines["MORPHTARGETS_TANGENT"] = false;
          defines["MORPHTARGETS_NORMAL"] = false;
          defines["MORPHTARGETS"] = false;
          defines["NUM_MORPH_INFLUENCERS"] = 0;
        }
      }
      static PrepareDefinesForBakedVertexAnimation(mesh, defines) {
        const manager = mesh.bakedVertexAnimationManager;
        defines["BAKED_VERTEX_ANIMATION_TEXTURE"] = manager && manager.isEnabled ? true : false;
      }
      static PrepareDefinesForAttributes(mesh, defines, useVertexColor, useBones, useMorphTargets = false, useVertexAlpha = true, useBakedVertexAnimation = true) {
        if (!defines._areAttributesDirty && defines._needNormals === defines._normals && defines._needUVs === defines._uvs) {
          return false;
        }
        defines._normals = defines._needNormals;
        defines._uvs = defines._needUVs;
        defines["NORMAL"] = defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
        if (defines._needNormals && mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          defines["TANGENT"] = true;
        }
        for (let i = 1; i <= 6; ++i) {
          defines["UV" + i] = defines._needUVs ? mesh.isVerticesDataPresent(`uv${i === 1 ? "" : i}`) : false;
        }
        if (useVertexColor) {
          const hasVertexColors = mesh.useVertexColors && mesh.isVerticesDataPresent(VertexBuffer.ColorKind);
          defines["VERTEXCOLOR"] = hasVertexColors;
          defines["VERTEXALPHA"] = mesh.hasVertexAlpha && hasVertexColors && useVertexAlpha;
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind) && (mesh.hasInstances || mesh.hasThinInstances)) {
          defines["INSTANCESCOLOR"] = true;
        }
        if (useBones) {
          this.PrepareDefinesForBones(mesh, defines);
        }
        if (useMorphTargets) {
          this.PrepareDefinesForMorphTargets(mesh, defines);
        }
        if (useBakedVertexAnimation) {
          this.PrepareDefinesForBakedVertexAnimation(mesh, defines);
        }
        return true;
      }
      static PrepareDefinesForMultiview(scene, defines) {
        if (scene.activeCamera) {
          const previousMultiview = defines.MULTIVIEW;
          defines.MULTIVIEW = scene.activeCamera.outputRenderTarget !== null && scene.activeCamera.outputRenderTarget.getViewCount() > 1;
          if (defines.MULTIVIEW != previousMultiview) {
            defines.markAsUnprocessed();
          }
        }
      }
      static PrepareDefinesForOIT(scene, defines, needAlphaBlending) {
        const previousDefine = defines.ORDER_INDEPENDENT_TRANSPARENCY;
        const previousDefine16Bits = defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS;
        defines.ORDER_INDEPENDENT_TRANSPARENCY = scene.useOrderIndependentTransparency && needAlphaBlending;
        defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = !scene.getEngine().getCaps().textureFloatLinearFiltering;
        if (previousDefine !== defines.ORDER_INDEPENDENT_TRANSPARENCY || previousDefine16Bits !== defines.ORDER_INDEPENDENT_TRANSPARENCY_16BITS) {
          defines.markAsUnprocessed();
        }
      }
      static PrepareDefinesForPrePass(scene, defines, canRenderToMRT) {
        const previousPrePass = defines.PREPASS;
        if (!defines._arePrePassDirty) {
          return;
        }
        const texturesList = [
          {
            type: 1,
            define: "PREPASS_POSITION",
            index: "PREPASS_POSITION_INDEX"
          },
          {
            type: 2,
            define: "PREPASS_VELOCITY",
            index: "PREPASS_VELOCITY_INDEX"
          },
          {
            type: 3,
            define: "PREPASS_REFLECTIVITY",
            index: "PREPASS_REFLECTIVITY_INDEX"
          },
          {
            type: 0,
            define: "PREPASS_IRRADIANCE",
            index: "PREPASS_IRRADIANCE_INDEX"
          },
          {
            type: 7,
            define: "PREPASS_ALBEDO_SQRT",
            index: "PREPASS_ALBEDO_SQRT_INDEX"
          },
          {
            type: 5,
            define: "PREPASS_DEPTH",
            index: "PREPASS_DEPTH_INDEX"
          },
          {
            type: 6,
            define: "PREPASS_NORMAL",
            index: "PREPASS_NORMAL_INDEX"
          }
        ];
        if (scene.prePassRenderer && scene.prePassRenderer.enabled && canRenderToMRT) {
          defines.PREPASS = true;
          defines.SCENE_MRT_COUNT = scene.prePassRenderer.mrtCount;
          defines.PREPASS_NORMAL_WORLDSPACE = scene.prePassRenderer.generateNormalsInWorldSpace;
          for (let i = 0; i < texturesList.length; i++) {
            const index = scene.prePassRenderer.getIndex(texturesList[i].type);
            if (index !== -1) {
              defines[texturesList[i].define] = true;
              defines[texturesList[i].index] = index;
            } else {
              defines[texturesList[i].define] = false;
            }
          }
        } else {
          defines.PREPASS = false;
          for (let i = 0; i < texturesList.length; i++) {
            defines[texturesList[i].define] = false;
          }
        }
        if (defines.PREPASS != previousPrePass) {
          defines.markAsUnprocessed();
          defines.markAsImageProcessingDirty();
        }
      }
      static PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state) {
        var _a;
        state.needNormals = true;
        if (defines["LIGHT" + lightIndex] === void 0) {
          state.needRebuild = true;
        }
        defines["LIGHT" + lightIndex] = true;
        defines["SPOTLIGHT" + lightIndex] = false;
        defines["HEMILIGHT" + lightIndex] = false;
        defines["POINTLIGHT" + lightIndex] = false;
        defines["DIRLIGHT" + lightIndex] = false;
        light.prepareLightSpecificDefines(defines, lightIndex);
        defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = false;
        defines["LIGHT_FALLOFF_GLTF" + lightIndex] = false;
        defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = false;
        switch (light.falloffType) {
          case LightConstants.FALLOFF_GLTF:
            defines["LIGHT_FALLOFF_GLTF" + lightIndex] = true;
            break;
          case LightConstants.FALLOFF_PHYSICAL:
            defines["LIGHT_FALLOFF_PHYSICAL" + lightIndex] = true;
            break;
          case LightConstants.FALLOFF_STANDARD:
            defines["LIGHT_FALLOFF_STANDARD" + lightIndex] = true;
            break;
        }
        if (specularSupported && !light.specular.equalsFloats(0, 0, 0)) {
          state.specularEnabled = true;
        }
        defines["SHADOW" + lightIndex] = false;
        defines["SHADOWCSM" + lightIndex] = false;
        defines["SHADOWCSMDEBUG" + lightIndex] = false;
        defines["SHADOWCSMNUM_CASCADES" + lightIndex] = false;
        defines["SHADOWCSMUSESHADOWMAXZ" + lightIndex] = false;
        defines["SHADOWCSMNOBLEND" + lightIndex] = false;
        defines["SHADOWCSM_RIGHTHANDED" + lightIndex] = false;
        defines["SHADOWPCF" + lightIndex] = false;
        defines["SHADOWPCSS" + lightIndex] = false;
        defines["SHADOWPOISSON" + lightIndex] = false;
        defines["SHADOWESM" + lightIndex] = false;
        defines["SHADOWCLOSEESM" + lightIndex] = false;
        defines["SHADOWCUBE" + lightIndex] = false;
        defines["SHADOWLOWQUALITY" + lightIndex] = false;
        defines["SHADOWMEDIUMQUALITY" + lightIndex] = false;
        if (mesh && mesh.receiveShadows && scene.shadowsEnabled && light.shadowEnabled) {
          const shadowGenerator = (_a = light.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : light.getShadowGenerator();
          if (shadowGenerator) {
            const shadowMap = shadowGenerator.getShadowMap();
            if (shadowMap) {
              if (shadowMap.renderList && shadowMap.renderList.length > 0) {
                state.shadowEnabled = true;
                shadowGenerator.prepareDefines(defines, lightIndex);
              }
            }
          }
        }
        if (light.lightmapMode != LightConstants.LIGHTMAP_DEFAULT) {
          state.lightmapMode = true;
          defines["LIGHTMAPEXCLUDED" + lightIndex] = true;
          defines["LIGHTMAPNOSPECULAR" + lightIndex] = light.lightmapMode == LightConstants.LIGHTMAP_SHADOWSONLY;
        } else {
          defines["LIGHTMAPEXCLUDED" + lightIndex] = false;
          defines["LIGHTMAPNOSPECULAR" + lightIndex] = false;
        }
      }
      static PrepareDefinesForLights(scene, mesh, defines, specularSupported, maxSimultaneousLights = 4, disableLighting = false) {
        if (!defines._areLightsDirty) {
          return defines._needNormals;
        }
        let lightIndex = 0;
        const state = {
          needNormals: defines._needNormals,
          needRebuild: false,
          lightmapMode: false,
          shadowEnabled: false,
          specularEnabled: false
        };
        if (scene.lightsEnabled && !disableLighting) {
          for (const light of mesh.lightSources) {
            this.PrepareDefinesForLight(scene, mesh, light, lightIndex, defines, specularSupported, state);
            lightIndex++;
            if (lightIndex === maxSimultaneousLights) {
              break;
            }
          }
        }
        defines["SPECULARTERM"] = state.specularEnabled;
        defines["SHADOWS"] = state.shadowEnabled;
        for (let index = lightIndex; index < maxSimultaneousLights; index++) {
          if (defines["LIGHT" + index] !== void 0) {
            defines["LIGHT" + index] = false;
            defines["HEMILIGHT" + index] = false;
            defines["POINTLIGHT" + index] = false;
            defines["DIRLIGHT" + index] = false;
            defines["SPOTLIGHT" + index] = false;
            defines["SHADOW" + index] = false;
            defines["SHADOWCSM" + index] = false;
            defines["SHADOWCSMDEBUG" + index] = false;
            defines["SHADOWCSMNUM_CASCADES" + index] = false;
            defines["SHADOWCSMUSESHADOWMAXZ" + index] = false;
            defines["SHADOWCSMNOBLEND" + index] = false;
            defines["SHADOWCSM_RIGHTHANDED" + index] = false;
            defines["SHADOWPCF" + index] = false;
            defines["SHADOWPCSS" + index] = false;
            defines["SHADOWPOISSON" + index] = false;
            defines["SHADOWESM" + index] = false;
            defines["SHADOWCLOSEESM" + index] = false;
            defines["SHADOWCUBE" + index] = false;
            defines["SHADOWLOWQUALITY" + index] = false;
            defines["SHADOWMEDIUMQUALITY" + index] = false;
          }
        }
        const caps = scene.getEngine().getCaps();
        if (defines["SHADOWFLOAT"] === void 0) {
          state.needRebuild = true;
        }
        defines["SHADOWFLOAT"] = state.shadowEnabled && (caps.textureFloatRender && caps.textureFloatLinearFiltering || caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering);
        defines["LIGHTMAPEXCLUDED"] = state.lightmapMode;
        if (state.needRebuild) {
          defines.rebuild();
        }
        return state.needNormals;
      }
      static PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, projectedLightTexture, uniformBuffersList = null, updateOnlyBuffersList = false) {
        if (uniformBuffersList) {
          uniformBuffersList.push("Light" + lightIndex);
        }
        if (updateOnlyBuffersList) {
          return;
        }
        uniformsList.push("vLightData" + lightIndex, "vLightDiffuse" + lightIndex, "vLightSpecular" + lightIndex, "vLightDirection" + lightIndex, "vLightFalloff" + lightIndex, "vLightGround" + lightIndex, "lightMatrix" + lightIndex, "shadowsInfo" + lightIndex, "depthValues" + lightIndex);
        samplersList.push("shadowSampler" + lightIndex);
        samplersList.push("depthSampler" + lightIndex);
        uniformsList.push("viewFrustumZ" + lightIndex, "cascadeBlendFactor" + lightIndex, "lightSizeUVCorrection" + lightIndex, "depthCorrection" + lightIndex, "penumbraDarkness" + lightIndex, "frustumLengths" + lightIndex);
        if (projectedLightTexture) {
          samplersList.push("projectionLightSampler" + lightIndex);
          uniformsList.push("textureProjectionMatrix" + lightIndex);
        }
      }
      static PrepareUniformsAndSamplersList(uniformsListOrOptions, samplersList, defines, maxSimultaneousLights = 4) {
        let uniformsList;
        let uniformBuffersList = null;
        if (uniformsListOrOptions.uniformsNames) {
          const options = uniformsListOrOptions;
          uniformsList = options.uniformsNames;
          uniformBuffersList = options.uniformBuffersNames;
          samplersList = options.samplers;
          defines = options.defines;
          maxSimultaneousLights = options.maxSimultaneousLights || 0;
        } else {
          uniformsList = uniformsListOrOptions;
          if (!samplersList) {
            samplersList = [];
          }
        }
        for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
          if (!defines["LIGHT" + lightIndex]) {
            break;
          }
          this.PrepareUniformsAndSamplersForLight(lightIndex, uniformsList, samplersList, defines["PROJECTEDLIGHTTEXTURE" + lightIndex], uniformBuffersList);
        }
        if (defines["NUM_MORPH_INFLUENCERS"]) {
          uniformsList.push("morphTargetInfluences");
        }
        if (defines["BAKED_VERTEX_ANIMATION_TEXTURE"]) {
          uniformsList.push("bakedVertexAnimationSettings");
          uniformsList.push("bakedVertexAnimationTextureSizeInverted");
          uniformsList.push("bakedVertexAnimationTime");
          samplersList.push("bakedVertexAnimationTexture");
        }
      }
      static HandleFallbacksForShadows(defines, fallbacks, maxSimultaneousLights = 4, rank = 0) {
        let lightFallbackRank = 0;
        for (let lightIndex = 0; lightIndex < maxSimultaneousLights; lightIndex++) {
          if (!defines["LIGHT" + lightIndex]) {
            break;
          }
          if (lightIndex > 0) {
            lightFallbackRank = rank + lightIndex;
            fallbacks.addFallback(lightFallbackRank, "LIGHT" + lightIndex);
          }
          if (!defines["SHADOWS"]) {
            if (defines["SHADOW" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOW" + lightIndex);
            }
            if (defines["SHADOWPCF" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWPCF" + lightIndex);
            }
            if (defines["SHADOWPCSS" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWPCSS" + lightIndex);
            }
            if (defines["SHADOWPOISSON" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWPOISSON" + lightIndex);
            }
            if (defines["SHADOWESM" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWESM" + lightIndex);
            }
            if (defines["SHADOWCLOSEESM" + lightIndex]) {
              fallbacks.addFallback(rank, "SHADOWCLOSEESM" + lightIndex);
            }
          }
        }
        return lightFallbackRank++;
      }
      static PrepareAttributesForMorphTargetsInfluencers(attribs, mesh, influencers) {
        this._TmpMorphInfluencers.NUM_MORPH_INFLUENCERS = influencers;
        this.PrepareAttributesForMorphTargets(attribs, mesh, this._TmpMorphInfluencers);
      }
      static PrepareAttributesForMorphTargets(attribs, mesh, defines) {
        const influencers = defines["NUM_MORPH_INFLUENCERS"];
        if (influencers > 0 && EngineStore.LastCreatedEngine) {
          const maxAttributesCount = EngineStore.LastCreatedEngine.getCaps().maxVertexAttribs;
          const manager = mesh.morphTargetManager;
          if (manager === null || manager === void 0 ? void 0 : manager.isUsingTextureForTargets) {
            return;
          }
          const normal = manager && manager.supportsNormals && defines["NORMAL"];
          const tangent = manager && manager.supportsTangents && defines["TANGENT"];
          const uv = manager && manager.supportsUVs && defines["UV1"];
          for (let index = 0; index < influencers; index++) {
            attribs.push(VertexBuffer.PositionKind + index);
            if (normal) {
              attribs.push(VertexBuffer.NormalKind + index);
            }
            if (tangent) {
              attribs.push(VertexBuffer.TangentKind + index);
            }
            if (uv) {
              attribs.push(VertexBuffer.UVKind + "_" + index);
            }
            if (attribs.length > maxAttributesCount) {
              Logger.Error("Cannot add more vertex attributes for mesh " + mesh.name);
            }
          }
        }
      }
      static PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines) {
        const enabled = defines["BAKED_VERTEX_ANIMATION_TEXTURE"] && defines["INSTANCES"];
        if (enabled) {
          attribs.push("bakedVertexAnimationSettingsInstanced");
        }
      }
      static PrepareAttributesForBones(attribs, mesh, defines, fallbacks) {
        if (defines["NUM_BONE_INFLUENCERS"] > 0) {
          fallbacks.addCPUSkinningFallback(0, mesh);
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (defines["NUM_BONE_INFLUENCERS"] > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
        }
      }
      static PrepareAttributesForInstances(attribs, defines) {
        if (defines["INSTANCES"] || defines["THIN_INSTANCES"]) {
          this.PushAttributesForInstances(attribs, !!defines["PREPASS_VELOCITY"]);
        }
        if (defines.INSTANCESCOLOR) {
          attribs.push(VertexBuffer.ColorInstanceKind);
        }
      }
      static PushAttributesForInstances(attribs, needsPreviousMatrices = false) {
        attribs.push("world0");
        attribs.push("world1");
        attribs.push("world2");
        attribs.push("world3");
        if (needsPreviousMatrices) {
          attribs.push("previousWorld0");
          attribs.push("previousWorld1");
          attribs.push("previousWorld2");
          attribs.push("previousWorld3");
        }
      }
      static BindLightProperties(light, effect, lightIndex) {
        light.transferToEffect(effect, lightIndex + "");
      }
      static BindLight(light, lightIndex, scene, effect, useSpecular, receiveShadows = true) {
        light._bindLight(lightIndex, scene, effect, useSpecular, receiveShadows);
      }
      static BindLights(scene, mesh, effect, defines, maxSimultaneousLights = 4) {
        const len = Math.min(mesh.lightSources.length, maxSimultaneousLights);
        for (let i = 0; i < len; i++) {
          const light = mesh.lightSources[i];
          this.BindLight(light, i, scene, effect, typeof defines === "boolean" ? defines : defines["SPECULARTERM"], mesh.receiveShadows);
        }
      }
      static BindFogParameters(scene, mesh, effect, linearSpace = false) {
        if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE) {
          effect.setFloat4("vFogInfos", scene.fogMode, scene.fogStart, scene.fogEnd, scene.fogDensity);
          if (linearSpace) {
            scene.fogColor.toLinearSpaceToRef(this._TempFogColor, scene.getEngine().useExactSrgbConversions);
            effect.setColor3("vFogColor", this._TempFogColor);
          } else {
            effect.setColor3("vFogColor", scene.fogColor);
          }
        }
      }
      static BindBonesParameters(mesh, effect, prePassConfiguration) {
        if (!effect || !mesh) {
          return;
        }
        if (mesh.computeBonesUsingShaders && effect._bonesComputationForcedToCPU) {
          mesh.computeBonesUsingShaders = false;
        }
        if (mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          const skeleton = mesh.skeleton;
          if (skeleton.isUsingTextureForMatrices && effect.getUniformIndex("boneTextureWidth") > -1) {
            const boneTexture = skeleton.getTransformMatrixTexture(mesh);
            effect.setTexture("boneSampler", boneTexture);
            effect.setFloat("boneTextureWidth", 4 * (skeleton.bones.length + 1));
          } else {
            const matrices = skeleton.getTransformMatrices(mesh);
            if (matrices) {
              effect.setMatrices("mBones", matrices);
              if (prePassConfiguration && mesh.getScene().prePassRenderer && mesh.getScene().prePassRenderer.getIndex(2)) {
                if (!prePassConfiguration.previousBones[mesh.uniqueId]) {
                  prePassConfiguration.previousBones[mesh.uniqueId] = matrices.slice();
                }
                effect.setMatrices("mPreviousBones", prePassConfiguration.previousBones[mesh.uniqueId]);
                MaterialHelper._CopyBonesTransformationMatrices(matrices, prePassConfiguration.previousBones[mesh.uniqueId]);
              }
            }
          }
        }
      }
      static _CopyBonesTransformationMatrices(source, target) {
        target.set(source);
        return target;
      }
      static BindMorphTargetParameters(abstractMesh, effect) {
        const manager = abstractMesh.morphTargetManager;
        if (!abstractMesh || !manager) {
          return;
        }
        effect.setFloatArray("morphTargetInfluences", manager.influences);
      }
      static BindLogDepth(defines, effect, scene) {
        if (!defines || defines["LOGARITHMICDEPTH"] || defines.indexOf && defines.indexOf("LOGARITHMICDEPTH") >= 0) {
          const camera = scene.activeCamera;
          if (camera.mode === Camera.ORTHOGRAPHIC_CAMERA) {
            Logger.Error("Logarithmic depth is not compatible with orthographic cameras!", 20);
          }
          effect.setFloat("logarithmicDepthConstant", 2 / (Math.log(camera.maxZ + 1) / Math.LN2));
        }
      }
    };
    MaterialHelper._TmpMorphInfluencers = { NUM_MORPH_INFLUENCERS: 0 };
    MaterialHelper._TempFogColor = Color3.Black();
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginEvent.js
var MaterialPluginEvent;
var init_materialPluginEvent = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginEvent.js"() {
    (function(MaterialPluginEvent2) {
      MaterialPluginEvent2[MaterialPluginEvent2["Created"] = 1] = "Created";
      MaterialPluginEvent2[MaterialPluginEvent2["Disposed"] = 2] = "Disposed";
      MaterialPluginEvent2[MaterialPluginEvent2["GetDefineNames"] = 4] = "GetDefineNames";
      MaterialPluginEvent2[MaterialPluginEvent2["PrepareUniformBuffer"] = 8] = "PrepareUniformBuffer";
      MaterialPluginEvent2[MaterialPluginEvent2["IsReadyForSubMesh"] = 16] = "IsReadyForSubMesh";
      MaterialPluginEvent2[MaterialPluginEvent2["PrepareDefines"] = 32] = "PrepareDefines";
      MaterialPluginEvent2[MaterialPluginEvent2["BindForSubMesh"] = 64] = "BindForSubMesh";
      MaterialPluginEvent2[MaterialPluginEvent2["PrepareEffect"] = 128] = "PrepareEffect";
      MaterialPluginEvent2[MaterialPluginEvent2["GetAnimatables"] = 256] = "GetAnimatables";
      MaterialPluginEvent2[MaterialPluginEvent2["GetActiveTextures"] = 512] = "GetActiveTextures";
      MaterialPluginEvent2[MaterialPluginEvent2["HasTexture"] = 1024] = "HasTexture";
      MaterialPluginEvent2[MaterialPluginEvent2["FillRenderTargetTextures"] = 2048] = "FillRenderTargetTextures";
      MaterialPluginEvent2[MaterialPluginEvent2["HasRenderTargetTextures"] = 4096] = "HasRenderTargetTextures";
      MaterialPluginEvent2[MaterialPluginEvent2["HardBindForSubMesh"] = 8192] = "HardBindForSubMesh";
    })(MaterialPluginEvent || (MaterialPluginEvent = {}));
  }
});

// node_modules/@babylonjs/core/Materials/materialStencilState.js
var MaterialStencilState;
var init_materialStencilState = __esm({
  "node_modules/@babylonjs/core/Materials/materialStencilState.js"() {
    init_tslib_es6();
    init_decorators();
    MaterialStencilState = class {
      constructor() {
        this.reset();
      }
      reset() {
        this.enabled = false;
        this.mask = 255;
        this.func = 519;
        this.funcRef = 1;
        this.funcMask = 255;
        this.opStencilFail = 7680;
        this.opDepthFail = 7680;
        this.opStencilDepthPass = 7681;
      }
      get func() {
        return this._func;
      }
      set func(value) {
        this._func = value;
      }
      get funcRef() {
        return this._funcRef;
      }
      set funcRef(value) {
        this._funcRef = value;
      }
      get funcMask() {
        return this._funcMask;
      }
      set funcMask(value) {
        this._funcMask = value;
      }
      get opStencilFail() {
        return this._opStencilFail;
      }
      set opStencilFail(value) {
        this._opStencilFail = value;
      }
      get opDepthFail() {
        return this._opDepthFail;
      }
      set opDepthFail(value) {
        this._opDepthFail = value;
      }
      get opStencilDepthPass() {
        return this._opStencilDepthPass;
      }
      set opStencilDepthPass(value) {
        this._opStencilDepthPass = value;
      }
      get mask() {
        return this._mask;
      }
      set mask(value) {
        this._mask = value;
      }
      get enabled() {
        return this._enabled;
      }
      set enabled(value) {
        this._enabled = value;
      }
      getClassName() {
        return "MaterialStencilState";
      }
      copyTo(stencilState) {
        SerializationHelper.Clone(() => stencilState, this);
      }
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      parse(source, scene, rootUrl) {
        SerializationHelper.Parse(() => this, source, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "func", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "funcRef", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "funcMask", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "opStencilFail", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "opDepthFail", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "opStencilDepthPass", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "mask", null);
    __decorate([
      serialize()
    ], MaterialStencilState.prototype, "enabled", null);
  }
});

// node_modules/@babylonjs/core/Materials/material.js
var Material;
var init_material = __esm({
  "node_modules/@babylonjs/core/Materials/material.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_observable();
    init_engineStore();
    init_subMesh();
    init_uniformBuffer();
    init_logger();
    init_math_plane();
    init_materialHelper();
    init_drawWrapper();
    init_materialStencilState();
    init_scene();
    init_materialPluginEvent();
    Material = class {
      get canRenderToMRT() {
        return false;
      }
      set alpha(value) {
        if (this._alpha === value) {
          return;
        }
        const oldValue = this._alpha;
        this._alpha = value;
        if (oldValue === 1 || value === 1) {
          this.markAsDirty(Material.MiscDirtyFlag + Material.PrePassDirtyFlag);
        }
      }
      get alpha() {
        return this._alpha;
      }
      set backFaceCulling(value) {
        if (this._backFaceCulling === value) {
          return;
        }
        this._backFaceCulling = value;
        this.markAsDirty(Material.TextureDirtyFlag);
      }
      get backFaceCulling() {
        return this._backFaceCulling;
      }
      set cullBackFaces(value) {
        if (this._cullBackFaces === value) {
          return;
        }
        this._cullBackFaces = value;
        this.markAsDirty(Material.TextureDirtyFlag);
      }
      get cullBackFaces() {
        return this._cullBackFaces;
      }
      get blockDirtyMechanism() {
        return this._blockDirtyMechanism;
      }
      set blockDirtyMechanism(value) {
        if (this._blockDirtyMechanism === value) {
          return;
        }
        this._blockDirtyMechanism = value;
        if (!value) {
          this.markDirty();
        }
      }
      atomicMaterialsUpdate(callback) {
        this.blockDirtyMechanism = true;
        try {
          callback(this);
        } finally {
          this.blockDirtyMechanism = false;
        }
      }
      get hasRenderTargetTextures() {
        this._eventInfo.hasRenderTargetTextures = false;
        this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
        return this._eventInfo.hasRenderTargetTextures;
      }
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      get onBindObservable() {
        if (!this._onBindObservable) {
          this._onBindObservable = new Observable();
        }
        return this._onBindObservable;
      }
      set onBind(callback) {
        if (this._onBindObserver) {
          this.onBindObservable.remove(this._onBindObserver);
        }
        this._onBindObserver = this.onBindObservable.add(callback);
      }
      get onUnBindObservable() {
        if (!this._onUnBindObservable) {
          this._onUnBindObservable = new Observable();
        }
        return this._onUnBindObservable;
      }
      get onEffectCreatedObservable() {
        if (!this._onEffectCreatedObservable) {
          this._onEffectCreatedObservable = new Observable();
        }
        return this._onEffectCreatedObservable;
      }
      set alphaMode(value) {
        if (this._alphaMode === value) {
          return;
        }
        this._alphaMode = value;
        this.markAsDirty(Material.TextureDirtyFlag);
      }
      get alphaMode() {
        return this._alphaMode;
      }
      set needDepthPrePass(value) {
        if (this._needDepthPrePass === value) {
          return;
        }
        this._needDepthPrePass = value;
        if (this._needDepthPrePass) {
          this.checkReadyOnEveryCall = true;
        }
      }
      get needDepthPrePass() {
        return this._needDepthPrePass;
      }
      get isPrePassCapable() {
        return false;
      }
      set fogEnabled(value) {
        if (this._fogEnabled === value) {
          return;
        }
        this._fogEnabled = value;
        this.markAsDirty(Material.MiscDirtyFlag);
      }
      get fogEnabled() {
        return this._fogEnabled;
      }
      get wireframe() {
        switch (this._fillMode) {
          case Material.WireFrameFillMode:
          case Material.LineListDrawMode:
          case Material.LineLoopDrawMode:
          case Material.LineStripDrawMode:
            return true;
        }
        return this._scene.forceWireframe;
      }
      set wireframe(value) {
        this.fillMode = value ? Material.WireFrameFillMode : Material.TriangleFillMode;
      }
      get pointsCloud() {
        switch (this._fillMode) {
          case Material.PointFillMode:
          case Material.PointListDrawMode:
            return true;
        }
        return this._scene.forcePointsCloud;
      }
      set pointsCloud(value) {
        this.fillMode = value ? Material.PointFillMode : Material.TriangleFillMode;
      }
      get fillMode() {
        return this._fillMode;
      }
      set fillMode(value) {
        if (this._fillMode === value) {
          return;
        }
        this._fillMode = value;
        this.markAsDirty(Material.MiscDirtyFlag);
      }
      _getDrawWrapper() {
        return this._drawWrapper;
      }
      _setDrawWrapper(drawWrapper) {
        this._drawWrapper = drawWrapper;
      }
      constructor(name109, scene, doNotAdd) {
        this.shadowDepthWrapper = null;
        this.allowShaderHotSwapping = true;
        this.metadata = null;
        this.reservedDataStore = null;
        this.checkReadyOnEveryCall = false;
        this.checkReadyOnlyOnce = false;
        this.state = "";
        this._alpha = 1;
        this._backFaceCulling = true;
        this._cullBackFaces = true;
        this._blockDirtyMechanism = false;
        this.onCompiled = null;
        this.onError = null;
        this.getRenderTargetTextures = null;
        this.doNotSerialize = false;
        this._storeEffectOnSubMeshes = false;
        this.animations = null;
        this.onDisposeObservable = new Observable();
        this._onDisposeObserver = null;
        this._onUnBindObservable = null;
        this._onBindObserver = null;
        this._alphaMode = 2;
        this._needDepthPrePass = false;
        this.disableDepthWrite = false;
        this.disableColorWrite = false;
        this.forceDepthWrite = false;
        this.depthFunction = 0;
        this.separateCullingPass = false;
        this._fogEnabled = true;
        this.pointSize = 1;
        this.zOffset = 0;
        this.zOffsetUnits = 0;
        this.stencil = new MaterialStencilState();
        this._useUBO = false;
        this._fillMode = Material.TriangleFillMode;
        this._cachedDepthWriteState = false;
        this._cachedColorWriteState = false;
        this._cachedDepthFunctionState = 0;
        this._indexInSceneMaterialArray = -1;
        this.meshMap = null;
        this._parentContainer = null;
        this._uniformBufferLayoutBuilt = false;
        this._eventInfo = {};
        this._callbackPluginEventGeneric = () => void 0;
        this._callbackPluginEventIsReadyForSubMesh = () => void 0;
        this._callbackPluginEventPrepareDefines = () => void 0;
        this._callbackPluginEventPrepareDefinesBeforeAttributes = () => void 0;
        this._callbackPluginEventHardBindForSubMesh = () => void 0;
        this._callbackPluginEventBindForSubMesh = () => void 0;
        this._callbackPluginEventHasRenderTargetTextures = () => void 0;
        this._callbackPluginEventFillRenderTargetTextures = () => void 0;
        this._forceAlphaTest = false;
        this._transparencyMode = null;
        this.name = name109;
        const setScene = scene || EngineStore.LastCreatedScene;
        if (!setScene) {
          return;
        }
        this._scene = setScene;
        this._dirtyCallbacks = {};
        this._dirtyCallbacks[1] = this._markAllSubMeshesAsTexturesDirty.bind(this);
        this._dirtyCallbacks[2] = this._markAllSubMeshesAsLightsDirty.bind(this);
        this._dirtyCallbacks[4] = this._markAllSubMeshesAsFresnelDirty.bind(this);
        this._dirtyCallbacks[8] = this._markAllSubMeshesAsAttributesDirty.bind(this);
        this._dirtyCallbacks[16] = this._markAllSubMeshesAsMiscDirty.bind(this);
        this._dirtyCallbacks[32] = this._markAllSubMeshesAsPrePassDirty.bind(this);
        this._dirtyCallbacks[63] = this._markAllSubMeshesAsAllDirty.bind(this);
        this.id = name109 || Tools.RandomId();
        this.uniqueId = this._scene.getUniqueId();
        this._materialContext = this._scene.getEngine().createMaterialContext();
        this._drawWrapper = new DrawWrapper(this._scene.getEngine(), false);
        this._drawWrapper.materialContext = this._materialContext;
        if (this._scene.useRightHandedSystem) {
          this.sideOrientation = Material.ClockWiseSideOrientation;
        } else {
          this.sideOrientation = Material.CounterClockWiseSideOrientation;
        }
        this._uniformBuffer = new UniformBuffer(this._scene.getEngine(), void 0, void 0, name109);
        this._useUBO = this.getScene().getEngine().supportsUniformBuffers;
        if (!doNotAdd) {
          this._scene.addMaterial(this);
        }
        if (this._scene.useMaterialMeshMap) {
          this.meshMap = {};
        }
        Material.OnEventObservable.notifyObservers(this, MaterialPluginEvent.Created);
      }
      toString(fullDetails) {
        const ret = "Name: " + this.name;
        return ret;
      }
      getClassName() {
        return "Material";
      }
      get _isMaterial() {
        return true;
      }
      get isFrozen() {
        return this.checkReadyOnlyOnce;
      }
      freeze() {
        this.markDirty();
        this.checkReadyOnlyOnce = true;
      }
      unfreeze() {
        this.markDirty();
        this.checkReadyOnlyOnce = false;
      }
      isReady(mesh, useInstances) {
        return true;
      }
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        const defines = subMesh.materialDefines;
        if (!defines) {
          return false;
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        return this._eventInfo.isReadyForSubMesh;
      }
      getEffect() {
        return this._drawWrapper.effect;
      }
      getScene() {
        return this._scene;
      }
      get transparencyMode() {
        return this._transparencyMode;
      }
      set transparencyMode(value) {
        if (this._transparencyMode === value) {
          return;
        }
        this._transparencyMode = value;
        this._forceAlphaTest = value === Material.MATERIAL_ALPHATESTANDBLEND;
        this._markAllSubMeshesAsTexturesAndMiscDirty();
      }
      get _disableAlphaBlending() {
        return this._transparencyMode === Material.MATERIAL_OPAQUE || this._transparencyMode === Material.MATERIAL_ALPHATEST;
      }
      needAlphaBlending() {
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1;
      }
      needAlphaBlendingForMesh(mesh) {
        if (mesh.visibility < 1) {
          return true;
        }
        if (this._disableAlphaBlending) {
          return false;
        }
        return mesh.hasVertexAlpha || this.needAlphaBlending();
      }
      needAlphaTesting() {
        if (this._forceAlphaTest) {
          return true;
        }
        return false;
      }
      _shouldTurnAlphaTestOn(mesh) {
        return !this.needAlphaBlendingForMesh(mesh) && this.needAlphaTesting();
      }
      getAlphaTestTexture() {
        return null;
      }
      markDirty(forceMaterialDirty = false) {
        const meshes = this.getScene().meshes;
        for (const mesh of meshes) {
          if (!mesh.subMeshes) {
            continue;
          }
          for (const subMesh of mesh.subMeshes) {
            if (subMesh.getMaterial() !== this) {
              continue;
            }
            if (!subMesh.effect) {
              continue;
            }
            subMesh.effect._wasPreviouslyReady = false;
            subMesh.effect._wasPreviouslyUsingInstances = null;
            subMesh.effect._forceRebindOnNextCall = forceMaterialDirty;
          }
        }
        if (forceMaterialDirty) {
          this.markAsDirty(Material.AllDirtyFlag);
        }
      }
      _preBind(effect, overrideOrientation = null) {
        const engine = this._scene.getEngine();
        const orientation = overrideOrientation == null ? this.sideOrientation : overrideOrientation;
        const reverse = orientation === Material.ClockWiseSideOrientation;
        engine.enableEffect(effect ? effect : this._getDrawWrapper());
        engine.setState(this.backFaceCulling, this.zOffset, false, reverse, this._scene._mirroredCameraPosition ? !this.cullBackFaces : this.cullBackFaces, this.stencil, this.zOffsetUnits);
        return reverse;
      }
      bind(world, mesh) {
      }
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        this._eventInfo.ubo = ubo;
        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareUniformBuffer, this._eventInfo);
        ubo.create();
        this._uniformBufferLayoutBuilt = true;
      }
      bindForSubMesh(world, mesh, subMesh) {
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventBindForSubMesh(this._eventInfo);
        effect._forceRebindOnNextCall = false;
      }
      bindOnlyWorldMatrix(world) {
      }
      bindView(effect) {
        if (!this._useUBO) {
          effect.setMatrix("view", this.getScene().getViewMatrix());
        } else {
          this._needToBindSceneUbo = true;
        }
      }
      bindViewProjection(effect) {
        if (!this._useUBO) {
          effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
          effect.setMatrix("projection", this.getScene().getProjectionMatrix());
        } else {
          this._needToBindSceneUbo = true;
        }
      }
      bindEyePosition(effect, variableName) {
        if (!this._useUBO) {
          this._scene.bindEyePosition(effect, variableName);
        } else {
          this._needToBindSceneUbo = true;
        }
      }
      _afterBind(mesh, effect = null) {
        this._scene._cachedMaterial = this;
        if (this._needToBindSceneUbo) {
          if (effect) {
            this._needToBindSceneUbo = false;
            MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
            this._scene.finalizeSceneUbo();
          }
        }
        if (mesh) {
          this._scene._cachedVisibility = mesh.visibility;
        } else {
          this._scene._cachedVisibility = 1;
        }
        if (this._onBindObservable && mesh) {
          this._onBindObservable.notifyObservers(mesh);
        }
        if (this.disableDepthWrite) {
          const engine = this._scene.getEngine();
          this._cachedDepthWriteState = engine.getDepthWrite();
          engine.setDepthWrite(false);
        }
        if (this.disableColorWrite) {
          const engine = this._scene.getEngine();
          this._cachedColorWriteState = engine.getColorWrite();
          engine.setColorWrite(false);
        }
        if (this.depthFunction !== 0) {
          const engine = this._scene.getEngine();
          this._cachedDepthFunctionState = engine.getDepthFunction() || 0;
          engine.setDepthFunction(this.depthFunction);
        }
      }
      unbind() {
        if (this._onUnBindObservable) {
          this._onUnBindObservable.notifyObservers(this);
        }
        if (this.depthFunction !== 0) {
          const engine = this._scene.getEngine();
          engine.setDepthFunction(this._cachedDepthFunctionState);
        }
        if (this.disableDepthWrite) {
          const engine = this._scene.getEngine();
          engine.setDepthWrite(this._cachedDepthWriteState);
        }
        if (this.disableColorWrite) {
          const engine = this._scene.getEngine();
          engine.setColorWrite(this._cachedColorWriteState);
        }
      }
      getAnimatables() {
        this._eventInfo.animatables = [];
        this._callbackPluginEventGeneric(MaterialPluginEvent.GetAnimatables, this._eventInfo);
        return this._eventInfo.animatables;
      }
      getActiveTextures() {
        this._eventInfo.activeTextures = [];
        this._callbackPluginEventGeneric(MaterialPluginEvent.GetActiveTextures, this._eventInfo);
        return this._eventInfo.activeTextures;
      }
      hasTexture(texture) {
        this._eventInfo.hasTexture = false;
        this._eventInfo.texture = texture;
        this._callbackPluginEventGeneric(MaterialPluginEvent.HasTexture, this._eventInfo);
        return this._eventInfo.hasTexture;
      }
      clone(name109) {
        return null;
      }
      _clonePlugins(targetMaterial, rootUrl) {
        const serializationObject = {};
        this._serializePlugins(serializationObject);
        Material._parsePlugins(serializationObject, targetMaterial, this._scene, rootUrl);
        if (this.pluginManager) {
          for (const plugin of this.pluginManager._plugins) {
            const targetPlugin = targetMaterial.pluginManager.getPlugin(plugin.name);
            plugin.copyTo(targetPlugin);
          }
        }
      }
      getBindedMeshes() {
        if (this.meshMap) {
          const result = new Array();
          for (const meshId in this.meshMap) {
            const mesh = this.meshMap[meshId];
            if (mesh) {
              result.push(mesh);
            }
          }
          return result;
        } else {
          const meshes = this._scene.meshes;
          return meshes.filter((mesh) => mesh.material === this);
        }
      }
      forceCompilation(mesh, onCompiled, options, onError) {
        const localOptions = Object.assign({ clipPlane: false, useInstances: false }, options);
        const scene = this.getScene();
        const currentHotSwapingState = this.allowShaderHotSwapping;
        this.allowShaderHotSwapping = false;
        const checkReady = () => {
          if (!this._scene || !this._scene.getEngine()) {
            return;
          }
          const clipPlaneState = scene.clipPlane;
          if (localOptions.clipPlane) {
            scene.clipPlane = new Plane(0, 0, 0, 1);
          }
          if (this._storeEffectOnSubMeshes) {
            let allDone = true, lastError = null;
            if (mesh.subMeshes) {
              const tempSubMesh = new SubMesh(0, 0, 0, 0, 0, mesh, void 0, false, false);
              if (tempSubMesh.materialDefines) {
                tempSubMesh.materialDefines._renderId = -1;
              }
              if (!this.isReadyForSubMesh(mesh, tempSubMesh, localOptions.useInstances)) {
                if (tempSubMesh.effect && tempSubMesh.effect.getCompilationError() && tempSubMesh.effect.allFallbacksProcessed()) {
                  lastError = tempSubMesh.effect.getCompilationError();
                } else {
                  allDone = false;
                  setTimeout(checkReady, 16);
                }
              }
            }
            if (allDone) {
              this.allowShaderHotSwapping = currentHotSwapingState;
              if (lastError) {
                if (onError) {
                  onError(lastError);
                }
              }
              if (onCompiled) {
                onCompiled(this);
              }
            }
          } else {
            if (this.isReady()) {
              this.allowShaderHotSwapping = currentHotSwapingState;
              if (onCompiled) {
                onCompiled(this);
              }
            } else {
              setTimeout(checkReady, 16);
            }
          }
          if (localOptions.clipPlane) {
            scene.clipPlane = clipPlaneState;
          }
        };
        checkReady();
      }
      forceCompilationAsync(mesh, options) {
        return new Promise((resolve, reject) => {
          this.forceCompilation(mesh, () => {
            resolve();
          }, options, (reason) => {
            reject(reason);
          });
        });
      }
      markAsDirty(flag) {
        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
          return;
        }
        Material._DirtyCallbackArray.length = 0;
        if (flag & Material.TextureDirtyFlag) {
          Material._DirtyCallbackArray.push(Material._TextureDirtyCallBack);
        }
        if (flag & Material.LightDirtyFlag) {
          Material._DirtyCallbackArray.push(Material._LightsDirtyCallBack);
        }
        if (flag & Material.FresnelDirtyFlag) {
          Material._DirtyCallbackArray.push(Material._FresnelDirtyCallBack);
        }
        if (flag & Material.AttributesDirtyFlag) {
          Material._DirtyCallbackArray.push(Material._AttributeDirtyCallBack);
        }
        if (flag & Material.MiscDirtyFlag) {
          Material._DirtyCallbackArray.push(Material._MiscDirtyCallBack);
        }
        if (flag & Material.PrePassDirtyFlag) {
          Material._DirtyCallbackArray.push(Material._PrePassDirtyCallBack);
        }
        if (Material._DirtyCallbackArray.length) {
          this._markAllSubMeshesAsDirty(Material._RunDirtyCallBacks);
        }
        this.getScene().resetCachedMaterial();
      }
      resetDrawCache() {
        const meshes = this.getScene().meshes;
        for (const mesh of meshes) {
          if (!mesh.subMeshes) {
            continue;
          }
          for (const subMesh of mesh.subMeshes) {
            if (subMesh.getMaterial() !== this) {
              continue;
            }
            subMesh.resetDrawCache();
          }
        }
      }
      _markAllSubMeshesAsDirty(func) {
        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
          return;
        }
        const meshes = this.getScene().meshes;
        for (const mesh of meshes) {
          if (!mesh.subMeshes) {
            continue;
          }
          for (const subMesh of mesh.subMeshes) {
            if (subMesh.getMaterial(false) !== this) {
              continue;
            }
            for (const drawWrapper of subMesh._drawWrappers) {
              if (!drawWrapper || !drawWrapper.defines || !drawWrapper.defines.markAllAsDirty) {
                continue;
              }
              if (this._materialContext === drawWrapper.materialContext) {
                func(drawWrapper.defines);
              }
            }
          }
        }
      }
      _markScenePrePassDirty() {
        if (this.getScene().blockMaterialDirtyMechanism || this._blockDirtyMechanism) {
          return;
        }
        const prePassRenderer = this.getScene().enablePrePassRenderer();
        if (prePassRenderer) {
          prePassRenderer.markAsDirty();
        }
      }
      _markAllSubMeshesAsAllDirty() {
        this._markAllSubMeshesAsDirty(Material._AllDirtyCallBack);
      }
      _markAllSubMeshesAsImageProcessingDirty() {
        this._markAllSubMeshesAsDirty(Material._ImageProcessingDirtyCallBack);
      }
      _markAllSubMeshesAsTexturesDirty() {
        this._markAllSubMeshesAsDirty(Material._TextureDirtyCallBack);
      }
      _markAllSubMeshesAsFresnelDirty() {
        this._markAllSubMeshesAsDirty(Material._FresnelDirtyCallBack);
      }
      _markAllSubMeshesAsFresnelAndMiscDirty() {
        this._markAllSubMeshesAsDirty(Material._FresnelAndMiscDirtyCallBack);
      }
      _markAllSubMeshesAsLightsDirty() {
        this._markAllSubMeshesAsDirty(Material._LightsDirtyCallBack);
      }
      _markAllSubMeshesAsAttributesDirty() {
        this._markAllSubMeshesAsDirty(Material._AttributeDirtyCallBack);
      }
      _markAllSubMeshesAsMiscDirty() {
        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);
      }
      _markAllSubMeshesAsPrePassDirty() {
        this._markAllSubMeshesAsDirty(Material._MiscDirtyCallBack);
      }
      _markAllSubMeshesAsTexturesAndMiscDirty() {
        this._markAllSubMeshesAsDirty(Material._TextureAndMiscDirtyCallBack);
      }
      _checkScenePerformancePriority() {
        if (this._scene.performancePriority !== ScenePerformancePriority.BackwardCompatible) {
          this.checkReadyOnlyOnce = true;
          const observer2 = this._scene.onScenePerformancePriorityChangedObservable.addOnce(() => {
            this.checkReadyOnlyOnce = false;
          });
          this.onDisposeObservable.add(() => {
            this._scene.onScenePerformancePriorityChangedObservable.remove(observer2);
          });
        }
      }
      setPrePassRenderer(prePassRenderer) {
        return false;
      }
      dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        const scene = this.getScene();
        scene.stopAnimation(this);
        scene.freeProcessedMaterials();
        scene.removeMaterial(this);
        this._eventInfo.forceDisposeTextures = forceDisposeTextures;
        this._callbackPluginEventGeneric(MaterialPluginEvent.Disposed, this._eventInfo);
        if (this._parentContainer) {
          const index = this._parentContainer.materials.indexOf(this);
          if (index > -1) {
            this._parentContainer.materials.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (notBoundToMesh !== true) {
          if (this.meshMap) {
            for (const meshId in this.meshMap) {
              const mesh = this.meshMap[meshId];
              if (mesh) {
                mesh.material = null;
                this.releaseVertexArrayObject(mesh, forceDisposeEffect);
              }
            }
          } else {
            const meshes = scene.meshes;
            for (const mesh of meshes) {
              if (mesh.material === this && !mesh.sourceMesh) {
                mesh.material = null;
                this.releaseVertexArrayObject(mesh, forceDisposeEffect);
              }
            }
          }
        }
        this._uniformBuffer.dispose();
        if (forceDisposeEffect && this._drawWrapper.effect) {
          if (!this._storeEffectOnSubMeshes) {
            this._drawWrapper.effect.dispose();
          }
          this._drawWrapper.effect = null;
        }
        this.metadata = null;
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        if (this._onBindObservable) {
          this._onBindObservable.clear();
        }
        if (this._onUnBindObservable) {
          this._onUnBindObservable.clear();
        }
        if (this._onEffectCreatedObservable) {
          this._onEffectCreatedObservable.clear();
        }
        if (this._eventInfo) {
          this._eventInfo = {};
        }
      }
      releaseVertexArrayObject(mesh, forceDisposeEffect) {
        if (mesh.geometry) {
          const geometry = mesh.geometry;
          if (this._storeEffectOnSubMeshes) {
            for (const subMesh of mesh.subMeshes) {
              geometry._releaseVertexArrayObject(subMesh.effect);
              if (forceDisposeEffect && subMesh.effect) {
                subMesh.effect.dispose();
              }
            }
          } else {
            geometry._releaseVertexArrayObject(this._drawWrapper.effect);
          }
        }
      }
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.stencil = this.stencil.serialize();
        serializationObject.uniqueId = this.uniqueId;
        this._serializePlugins(serializationObject);
        return serializationObject;
      }
      _serializePlugins(serializationObject) {
        serializationObject.plugins = {};
        if (this.pluginManager) {
          for (const plugin of this.pluginManager._plugins) {
            serializationObject.plugins[plugin.getClassName()] = plugin.serialize();
          }
        }
      }
      static Parse(parsedMaterial, scene, rootUrl) {
        if (!parsedMaterial.customType) {
          parsedMaterial.customType = "BABYLON.StandardMaterial";
        } else if (parsedMaterial.customType === "BABYLON.PBRMaterial" && parsedMaterial.overloadedAlbedo) {
          parsedMaterial.customType = "BABYLON.LegacyPBRMaterial";
          if (!BABYLON.LegacyPBRMaterial) {
            Logger.Error("Your scene is trying to load a legacy version of the PBRMaterial, please, include it from the materials library.");
            return null;
          }
        }
        const materialType = Tools.Instantiate(parsedMaterial.customType);
        const material = materialType.Parse(parsedMaterial, scene, rootUrl);
        material._loadedUniqueId = parsedMaterial.uniqueId;
        return material;
      }
      static _parsePlugins(serializationObject, material, scene, rootUrl) {
        var _a;
        if (!serializationObject.plugins) {
          return;
        }
        for (const pluginClassName in serializationObject.plugins) {
          const pluginData = serializationObject.plugins[pluginClassName];
          let plugin = (_a = material.pluginManager) === null || _a === void 0 ? void 0 : _a.getPlugin(pluginData.name);
          if (!plugin) {
            const pluginClassType = Tools.Instantiate("BABYLON." + pluginClassName);
            if (pluginClassType) {
              plugin = new pluginClassType(material);
            }
          }
          plugin === null || plugin === void 0 ? void 0 : plugin.parse(pluginData, scene, rootUrl);
        }
      }
    };
    Material.TriangleFillMode = 0;
    Material.WireFrameFillMode = 1;
    Material.PointFillMode = 2;
    Material.PointListDrawMode = 3;
    Material.LineListDrawMode = 4;
    Material.LineLoopDrawMode = 5;
    Material.LineStripDrawMode = 6;
    Material.TriangleStripDrawMode = 7;
    Material.TriangleFanDrawMode = 8;
    Material.ClockWiseSideOrientation = 0;
    Material.CounterClockWiseSideOrientation = 1;
    Material.TextureDirtyFlag = 1;
    Material.LightDirtyFlag = 2;
    Material.FresnelDirtyFlag = 4;
    Material.AttributesDirtyFlag = 8;
    Material.MiscDirtyFlag = 16;
    Material.PrePassDirtyFlag = 32;
    Material.AllDirtyFlag = 63;
    Material.MATERIAL_OPAQUE = 0;
    Material.MATERIAL_ALPHATEST = 1;
    Material.MATERIAL_ALPHABLEND = 2;
    Material.MATERIAL_ALPHATESTANDBLEND = 3;
    Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT = 0;
    Material.MATERIAL_NORMALBLENDMETHOD_RNM = 1;
    Material.OnEventObservable = new Observable();
    Material._AllDirtyCallBack = (defines) => defines.markAllAsDirty();
    Material._ImageProcessingDirtyCallBack = (defines) => defines.markAsImageProcessingDirty();
    Material._TextureDirtyCallBack = (defines) => defines.markAsTexturesDirty();
    Material._FresnelDirtyCallBack = (defines) => defines.markAsFresnelDirty();
    Material._MiscDirtyCallBack = (defines) => defines.markAsMiscDirty();
    Material._PrePassDirtyCallBack = (defines) => defines.markAsPrePassDirty();
    Material._LightsDirtyCallBack = (defines) => defines.markAsLightDirty();
    Material._AttributeDirtyCallBack = (defines) => defines.markAsAttributesDirty();
    Material._FresnelAndMiscDirtyCallBack = (defines) => {
      Material._FresnelDirtyCallBack(defines);
      Material._MiscDirtyCallBack(defines);
    };
    Material._TextureAndMiscDirtyCallBack = (defines) => {
      Material._TextureDirtyCallBack(defines);
      Material._MiscDirtyCallBack(defines);
    };
    Material._DirtyCallbackArray = [];
    Material._RunDirtyCallBacks = (defines) => {
      for (const cb of Material._DirtyCallbackArray) {
        cb(defines);
      }
    };
    __decorate([
      serialize()
    ], Material.prototype, "id", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "uniqueId", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "name", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "metadata", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "checkReadyOnEveryCall", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "checkReadyOnlyOnce", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "state", void 0);
    __decorate([
      serialize("alpha")
    ], Material.prototype, "_alpha", void 0);
    __decorate([
      serialize("backFaceCulling")
    ], Material.prototype, "_backFaceCulling", void 0);
    __decorate([
      serialize("cullBackFaces")
    ], Material.prototype, "_cullBackFaces", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "sideOrientation", void 0);
    __decorate([
      serialize("alphaMode")
    ], Material.prototype, "_alphaMode", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "_needDepthPrePass", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "disableDepthWrite", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "disableColorWrite", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "forceDepthWrite", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "depthFunction", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "separateCullingPass", void 0);
    __decorate([
      serialize("fogEnabled")
    ], Material.prototype, "_fogEnabled", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "pointSize", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "zOffset", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "zOffsetUnits", void 0);
    __decorate([
      serialize()
    ], Material.prototype, "pointsCloud", null);
    __decorate([
      serialize()
    ], Material.prototype, "fillMode", null);
    __decorate([
      serialize()
    ], Material.prototype, "transparencyMode", null);
  }
});

// node_modules/@babylonjs/core/Materials/multiMaterial.js
var MultiMaterial;
var init_multiMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/multiMaterial.js"() {
    init_material();
    init_tags();
    init_typeStore();
    MultiMaterial = class extends Material {
      get subMaterials() {
        return this._subMaterials;
      }
      set subMaterials(value) {
        this._subMaterials = value;
        this._hookArray(value);
      }
      getChildren() {
        return this.subMaterials;
      }
      constructor(name109, scene) {
        super(name109, scene, true);
        this._waitingSubMaterialsUniqueIds = [];
        this.getScene().addMultiMaterial(this);
        this.subMaterials = new Array();
        this._storeEffectOnSubMeshes = true;
      }
      _hookArray(array) {
        const oldPush = array.push;
        array.push = (...items) => {
          const result = oldPush.apply(array, items);
          this._markAllSubMeshesAsTexturesDirty();
          return result;
        };
        const oldSplice = array.splice;
        array.splice = (index, deleteCount) => {
          const deleted = oldSplice.apply(array, [index, deleteCount]);
          this._markAllSubMeshesAsTexturesDirty();
          return deleted;
        };
      }
      getSubMaterial(index) {
        if (index < 0 || index >= this.subMaterials.length) {
          return this.getScene().defaultMaterial;
        }
        return this.subMaterials[index];
      }
      getActiveTextures() {
        return super.getActiveTextures().concat(...this.subMaterials.map((subMaterial) => {
          if (subMaterial) {
            return subMaterial.getActiveTextures();
          } else {
            return [];
          }
        }));
      }
      hasTexture(texture) {
        var _a;
        if (super.hasTexture(texture)) {
          return true;
        }
        for (let i = 0; i < this.subMaterials.length; i++) {
          if ((_a = this.subMaterials[i]) === null || _a === void 0 ? void 0 : _a.hasTexture(texture)) {
            return true;
          }
        }
        return false;
      }
      getClassName() {
        return "MultiMaterial";
      }
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        for (let index = 0; index < this.subMaterials.length; index++) {
          const subMaterial = this.subMaterials[index];
          if (subMaterial) {
            if (subMaterial._storeEffectOnSubMeshes) {
              if (!subMaterial.isReadyForSubMesh(mesh, subMesh, useInstances)) {
                return false;
              }
              continue;
            }
            if (!subMaterial.isReady(mesh)) {
              return false;
            }
          }
        }
        return true;
      }
      clone(name109, cloneChildren) {
        const newMultiMaterial = new MultiMaterial(name109, this.getScene());
        for (let index = 0; index < this.subMaterials.length; index++) {
          let subMaterial = null;
          const current = this.subMaterials[index];
          if (cloneChildren && current) {
            subMaterial = current.clone(name109 + "-" + current.name);
          } else {
            subMaterial = this.subMaterials[index];
          }
          newMultiMaterial.subMaterials.push(subMaterial);
        }
        return newMultiMaterial;
      }
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        if (Tags) {
          serializationObject.tags = Tags.GetTags(this);
        }
        serializationObject.materialsUniqueIds = [];
        serializationObject.materials = [];
        for (let matIndex = 0; matIndex < this.subMaterials.length; matIndex++) {
          const subMat = this.subMaterials[matIndex];
          if (subMat) {
            serializationObject.materialsUniqueIds.push(subMat.uniqueId);
            serializationObject.materials.push(subMat.id);
          } else {
            serializationObject.materialsUniqueIds.push(null);
            serializationObject.materials.push(null);
          }
        }
        return serializationObject;
      }
      dispose(forceDisposeEffect, forceDisposeTextures, forceDisposeChildren) {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        if (forceDisposeChildren) {
          for (let index2 = 0; index2 < this.subMaterials.length; index2++) {
            const subMaterial = this.subMaterials[index2];
            if (subMaterial) {
              subMaterial.dispose(forceDisposeEffect, forceDisposeTextures);
            }
          }
        }
        const index = scene.multiMaterials.indexOf(this);
        if (index >= 0) {
          scene.multiMaterials.splice(index, 1);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
      static ParseMultiMaterial(parsedMultiMaterial, scene) {
        const multiMaterial = new MultiMaterial(parsedMultiMaterial.name, scene);
        multiMaterial.id = parsedMultiMaterial.id;
        multiMaterial._loadedUniqueId = parsedMultiMaterial.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(multiMaterial, parsedMultiMaterial.tags);
        }
        if (parsedMultiMaterial.materialsUniqueIds) {
          multiMaterial._waitingSubMaterialsUniqueIds = parsedMultiMaterial.materialsUniqueIds;
        } else {
          parsedMultiMaterial.materials.forEach((subMatId) => multiMaterial.subMaterials.push(scene.getLastMaterialById(subMatId)));
        }
        return multiMaterial;
      }
    };
    RegisterClass("BABYLON.MultiMaterial", MultiMaterial);
  }
});

// node_modules/@babylonjs/core/Meshes/meshLODLevel.js
var MeshLODLevel;
var init_meshLODLevel = __esm({
  "node_modules/@babylonjs/core/Meshes/meshLODLevel.js"() {
    MeshLODLevel = class {
      constructor(distanceOrScreenCoverage, mesh) {
        this.distanceOrScreenCoverage = distanceOrScreenCoverage;
        this.mesh = mesh;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/mesh.js
var _CreationDataStorage, _InstanceDataStorage, _InstancesBatch, _ThinInstanceDataStorage, _InternalMeshDataInfo, Mesh;
var init_mesh = __esm({
  "node_modules/@babylonjs/core/Meshes/mesh.js"() {
    init_observable();
    init_tools();
    init_deepCopier();
    init_tags();
    init_coroutine();
    init_camera();
    init_scene();
    init_math_vector();
    init_math_color();
    init_node();
    init_buffer();
    init_mesh_vertexData();
    init_geometry();
    init_abstractMesh();
    init_subMesh();
    init_material();
    init_multiMaterial();
    init_sceneLoaderFlags();
    init_decorators();
    init_logger();
    init_typeStore();
    init_devTools();
    init_sceneComponent();
    init_meshLODLevel();
    _CreationDataStorage = class {
    };
    _InstanceDataStorage = class {
      constructor() {
        this.visibleInstances = {};
        this.batchCache = new _InstancesBatch();
        this.batchCacheReplacementModeInFrozenMode = new _InstancesBatch();
        this.instancesBufferSize = 32 * 16 * 4;
      }
    };
    _InstancesBatch = class {
      constructor() {
        this.mustReturn = false;
        this.visibleInstances = new Array();
        this.renderSelf = new Array();
        this.hardwareInstancedRendering = new Array();
      }
    };
    _ThinInstanceDataStorage = class {
      constructor() {
        this.instancesCount = 0;
        this.matrixBuffer = null;
        this.previousMatrixBuffer = null;
        this.matrixBufferSize = 32 * 16;
        this.matrixData = null;
        this.boundingVectors = [];
        this.worldMatrices = null;
      }
    };
    _InternalMeshDataInfo = class {
      constructor() {
        this._areNormalsFrozen = false;
        this._source = null;
        this.meshMap = null;
        this._preActivateId = -1;
        this._LODLevels = new Array();
        this._useLODScreenCoverage = false;
        this._effectiveMaterial = null;
        this._forcedInstanceCount = 0;
        this._overrideRenderingFillMode = null;
      }
    };
    Mesh = class extends AbstractMesh {
      static _GetDefaultSideOrientation(orientation) {
        return orientation || Mesh.FRONTSIDE;
      }
      get useLODScreenCoverage() {
        return this._internalMeshDataInfo._useLODScreenCoverage;
      }
      set useLODScreenCoverage(value) {
        this._internalMeshDataInfo._useLODScreenCoverage = value;
        this._sortLODLevels();
      }
      get computeBonesUsingShaders() {
        return this._internalAbstractMeshDataInfo._computeBonesUsingShaders;
      }
      set computeBonesUsingShaders(value) {
        if (this._internalAbstractMeshDataInfo._computeBonesUsingShaders === value) {
          return;
        }
        if (value && this._internalMeshDataInfo._sourcePositions) {
          this.setVerticesData(VertexBuffer.PositionKind, this._internalMeshDataInfo._sourcePositions, true);
          if (this._internalMeshDataInfo._sourceNormals) {
            this.setVerticesData(VertexBuffer.NormalKind, this._internalMeshDataInfo._sourceNormals, true);
          }
          this._internalMeshDataInfo._sourcePositions = null;
          this._internalMeshDataInfo._sourceNormals = null;
        }
        this._internalAbstractMeshDataInfo._computeBonesUsingShaders = value;
        this._markSubMeshesAsAttributesDirty();
      }
      get onBeforeRenderObservable() {
        if (!this._internalMeshDataInfo._onBeforeRenderObservable) {
          this._internalMeshDataInfo._onBeforeRenderObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBeforeRenderObservable;
      }
      get onBeforeBindObservable() {
        if (!this._internalMeshDataInfo._onBeforeBindObservable) {
          this._internalMeshDataInfo._onBeforeBindObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBeforeBindObservable;
      }
      get onAfterRenderObservable() {
        if (!this._internalMeshDataInfo._onAfterRenderObservable) {
          this._internalMeshDataInfo._onAfterRenderObservable = new Observable();
        }
        return this._internalMeshDataInfo._onAfterRenderObservable;
      }
      get onBetweenPassObservable() {
        if (!this._internalMeshDataInfo._onBetweenPassObservable) {
          this._internalMeshDataInfo._onBetweenPassObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBetweenPassObservable;
      }
      get onBeforeDrawObservable() {
        if (!this._internalMeshDataInfo._onBeforeDrawObservable) {
          this._internalMeshDataInfo._onBeforeDrawObservable = new Observable();
        }
        return this._internalMeshDataInfo._onBeforeDrawObservable;
      }
      set onBeforeDraw(callback) {
        if (this._onBeforeDrawObserver) {
          this.onBeforeDrawObservable.remove(this._onBeforeDrawObserver);
        }
        this._onBeforeDrawObserver = this.onBeforeDrawObservable.add(callback);
      }
      get hasInstances() {
        return this.instances.length > 0;
      }
      get hasThinInstances() {
        var _a;
        return ((_a = this._thinInstanceDataStorage.instancesCount) !== null && _a !== void 0 ? _a : 0) > 0;
      }
      get forcedInstanceCount() {
        return this._internalMeshDataInfo._forcedInstanceCount;
      }
      set forcedInstanceCount(count) {
        this._internalMeshDataInfo._forcedInstanceCount = count;
      }
      get overrideRenderingFillMode() {
        return this._internalMeshDataInfo._overrideRenderingFillMode;
      }
      set overrideRenderingFillMode(fillMode) {
        this._internalMeshDataInfo._overrideRenderingFillMode = fillMode;
      }
      get source() {
        return this._internalMeshDataInfo._source;
      }
      get cloneMeshMap() {
        return this._internalMeshDataInfo.meshMap;
      }
      get isUnIndexed() {
        return this._unIndexed;
      }
      set isUnIndexed(value) {
        if (this._unIndexed !== value) {
          this._unIndexed = value;
          this._markSubMeshesAsAttributesDirty();
        }
      }
      get worldMatrixInstancedBuffer() {
        return this._instanceDataStorage.instancesData;
      }
      get previousWorldMatrixInstancedBuffer() {
        return this._instanceDataStorage.instancesPreviousData;
      }
      get manualUpdateOfWorldMatrixInstancedBuffer() {
        return this._instanceDataStorage.manualUpdate;
      }
      set manualUpdateOfWorldMatrixInstancedBuffer(value) {
        this._instanceDataStorage.manualUpdate = value;
      }
      get manualUpdateOfPreviousWorldMatrixInstancedBuffer() {
        return this._instanceDataStorage.previousManualUpdate;
      }
      set manualUpdateOfPreviousWorldMatrixInstancedBuffer(value) {
        this._instanceDataStorage.previousManualUpdate = value;
      }
      get forceWorldMatrixInstancedBufferUpdate() {
        return this._instanceDataStorage.forceMatrixUpdates;
      }
      set forceWorldMatrixInstancedBufferUpdate(value) {
        this._instanceDataStorage.forceMatrixUpdates = value;
      }
      constructor(name109, scene = null, parent = null, source = null, doNotCloneChildren, clonePhysicsImpostor = true) {
        super(name109, scene);
        this._internalMeshDataInfo = new _InternalMeshDataInfo();
        this.delayLoadState = 0;
        this.instances = new Array();
        this._creationDataStorage = null;
        this._geometry = null;
        this._instanceDataStorage = new _InstanceDataStorage();
        this._thinInstanceDataStorage = new _ThinInstanceDataStorage();
        this._shouldGenerateFlatShading = false;
        this._originalBuilderSideOrientation = Mesh.DEFAULTSIDE;
        this.overrideMaterialSideOrientation = null;
        this.ignoreCameraMaxZ = false;
        scene = this.getScene();
        this._onBeforeDraw = (isInstance, world, effectiveMaterial) => {
          if (isInstance && effectiveMaterial) {
            if (this._uniformBuffer) {
              this.transferToEffect(world);
            } else {
              effectiveMaterial.bindOnlyWorldMatrix(world);
            }
          }
        };
        if (source) {
          if (source._geometry) {
            source._geometry.applyToMesh(this);
          }
          DeepCopier.DeepCopy(source, this, [
            "name",
            "material",
            "skeleton",
            "instances",
            "parent",
            "uniqueId",
            "source",
            "metadata",
            "morphTargetManager",
            "hasInstances",
            "worldMatrixInstancedBuffer",
            "previousWorldMatrixInstancedBuffer",
            "hasLODLevels",
            "geometry",
            "isBlocked",
            "areNormalsFrozen",
            "facetNb",
            "isFacetDataEnabled",
            "lightSources",
            "useBones",
            "isAnInstance",
            "collider",
            "edgesRenderer",
            "forward",
            "up",
            "right",
            "absolutePosition",
            "absoluteScaling",
            "absoluteRotationQuaternion",
            "isWorldMatrixFrozen",
            "nonUniformScaling",
            "behaviors",
            "worldMatrixFromCache",
            "hasThinInstances",
            "cloneMeshMap",
            "hasBoundingInfo",
            "physicsBody",
            "physicsImpostor"
          ], ["_poseMatrix"]);
          this._internalMeshDataInfo._source = source;
          if (scene.useClonedMeshMap) {
            if (!source._internalMeshDataInfo.meshMap) {
              source._internalMeshDataInfo.meshMap = {};
            }
            source._internalMeshDataInfo.meshMap[this.uniqueId] = this;
          }
          this._originalBuilderSideOrientation = source._originalBuilderSideOrientation;
          this._creationDataStorage = source._creationDataStorage;
          if (source._ranges) {
            const ranges = source._ranges;
            for (const name110 in ranges) {
              if (!Object.prototype.hasOwnProperty.call(ranges, name110)) {
                continue;
              }
              if (!ranges[name110]) {
                continue;
              }
              this.createAnimationRange(name110, ranges[name110].from, ranges[name110].to);
            }
          }
          if (source.metadata && source.metadata.clone) {
            this.metadata = source.metadata.clone();
          } else {
            this.metadata = source.metadata;
          }
          this._internalMetadata = source._internalMetadata;
          if (Tags && Tags.HasTags(source)) {
            Tags.AddTagsTo(this, Tags.GetTags(source, true));
          }
          this.setEnabled(source.isEnabled(false));
          this.parent = source.parent;
          this.setPivotMatrix(source.getPivotMatrix());
          this.id = name109 + "." + source.id;
          this.material = source.material;
          if (!doNotCloneChildren) {
            const directDescendants = source.getDescendants(true);
            for (let index = 0; index < directDescendants.length; index++) {
              const child = directDescendants[index];
              if (child.clone) {
                child.clone(name109 + "." + child.name, this);
              }
            }
          }
          if (source.morphTargetManager) {
            this.morphTargetManager = source.morphTargetManager;
          }
          if (scene.getPhysicsEngine) {
            const physicsEngine = scene.getPhysicsEngine();
            if (clonePhysicsImpostor && physicsEngine) {
              if (physicsEngine.getPluginVersion() === 1) {
                const impostor = physicsEngine.getImpostorForPhysicsObject(source);
                if (impostor) {
                  this.physicsImpostor = impostor.clone(this);
                }
              } else if (physicsEngine.getPluginVersion() === 2) {
                if (source.physicsBody) {
                  source.physicsBody.clone(this);
                }
              }
            }
          }
          for (let index = 0; index < scene.particleSystems.length; index++) {
            const system = scene.particleSystems[index];
            if (system.emitter === source) {
              system.clone(system.name, this);
            }
          }
          this.skeleton = source.skeleton;
          this.refreshBoundingInfo(true, true);
          this.computeWorldMatrix(true);
        }
        if (parent !== null) {
          this.parent = parent;
        }
        this._instanceDataStorage.hardwareInstancedRendering = this.getEngine().getCaps().instancedArrays;
        this._internalMeshDataInfo._onMeshReadyObserverAdded = (observer2) => {
          observer2.unregisterOnNextCall = true;
          if (this.isReady(true)) {
            this.onMeshReadyObservable.notifyObservers(this);
          } else {
            if (!this._internalMeshDataInfo._checkReadinessObserver) {
              this._internalMeshDataInfo._checkReadinessObserver = this._scene.onBeforeRenderObservable.add(() => {
                if (this.isReady(true)) {
                  this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
                  this._internalMeshDataInfo._checkReadinessObserver = null;
                  this.onMeshReadyObservable.notifyObservers(this);
                }
              });
            }
          }
        };
        this.onMeshReadyObservable = new Observable(this._internalMeshDataInfo._onMeshReadyObserverAdded);
        if (source) {
          source.onClonedObservable.notifyObservers(this);
        }
      }
      instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const instance = this.getTotalVertices() === 0 || options && options.doNotInstantiate && (options.doNotInstantiate === true || options.doNotInstantiate(this)) ? this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true) : this.createInstance("instance of " + (this.name || this.id));
        instance.parent = newParent || this.parent;
        instance.position = this.position.clone();
        instance.scaling = this.scaling.clone();
        if (this.rotationQuaternion) {
          instance.rotationQuaternion = this.rotationQuaternion.clone();
        } else {
          instance.rotation = this.rotation.clone();
        }
        if (onNewNodeCreated) {
          onNewNodeCreated(this, instance);
        }
        for (const child of this.getChildTransformNodes(true)) {
          if (child.getClassName() === "InstancedMesh" && instance.getClassName() === "Mesh" && child.sourceMesh === this) {
            child.instantiateHierarchy(instance, {
              doNotInstantiate: options && options.doNotInstantiate || false,
              newSourcedMesh: instance
            }, onNewNodeCreated);
          } else {
            child.instantiateHierarchy(instance, options, onNewNodeCreated);
          }
        }
        return instance;
      }
      getClassName() {
        return "Mesh";
      }
      get _isMesh() {
        return true;
      }
      toString(fullDetails) {
        let ret = super.toString(fullDetails);
        ret += ", n vertices: " + this.getTotalVertices();
        ret += ", parent: " + (this._waitingParentId ? this._waitingParentId : this.parent ? this.parent.name : "NONE");
        if (this.animations) {
          for (let i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        if (fullDetails) {
          if (this._geometry) {
            const ib = this.getIndices();
            const vb = this.getVerticesData(VertexBuffer.PositionKind);
            if (vb && ib) {
              ret += ", flat shading: " + (vb.length / 3 === ib.length ? "YES" : "NO");
            }
          } else {
            ret += ", flat shading: UNKNOWN";
          }
        }
        return ret;
      }
      _unBindEffect() {
        super._unBindEffect();
        for (const instance of this.instances) {
          instance._unBindEffect();
        }
      }
      get hasLODLevels() {
        return this._internalMeshDataInfo._LODLevels.length > 0;
      }
      getLODLevels() {
        return this._internalMeshDataInfo._LODLevels;
      }
      _sortLODLevels() {
        const sortingOrderFactor = this._internalMeshDataInfo._useLODScreenCoverage ? -1 : 1;
        this._internalMeshDataInfo._LODLevels.sort((a, b) => {
          if (a.distanceOrScreenCoverage < b.distanceOrScreenCoverage) {
            return sortingOrderFactor;
          }
          if (a.distanceOrScreenCoverage > b.distanceOrScreenCoverage) {
            return -sortingOrderFactor;
          }
          return 0;
        });
      }
      addLODLevel(distanceOrScreenCoverage, mesh) {
        if (mesh && mesh._masterMesh) {
          Logger.Warn("You cannot use a mesh as LOD level twice");
          return this;
        }
        const level = new MeshLODLevel(distanceOrScreenCoverage, mesh);
        this._internalMeshDataInfo._LODLevels.push(level);
        if (mesh) {
          mesh._masterMesh = this;
        }
        this._sortLODLevels();
        return this;
      }
      getLODLevelAtDistance(distance) {
        const internalDataInfo = this._internalMeshDataInfo;
        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
          const level = internalDataInfo._LODLevels[index];
          if (level.distanceOrScreenCoverage === distance) {
            return level.mesh;
          }
        }
        return null;
      }
      removeLODLevel(mesh) {
        const internalDataInfo = this._internalMeshDataInfo;
        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
          if (internalDataInfo._LODLevels[index].mesh === mesh) {
            internalDataInfo._LODLevels.splice(index, 1);
            if (mesh) {
              mesh._masterMesh = null;
            }
          }
        }
        this._sortLODLevels();
        return this;
      }
      getLOD(camera, boundingSphere) {
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._LODLevels || internalDataInfo._LODLevels.length === 0) {
          return this;
        }
        const bSphere = boundingSphere || this.getBoundingInfo().boundingSphere;
        const distanceToCamera = camera.mode === Camera.ORTHOGRAPHIC_CAMERA ? camera.minZ : bSphere.centerWorld.subtract(camera.globalPosition).length();
        let compareValue = distanceToCamera;
        let compareSign = 1;
        if (internalDataInfo._useLODScreenCoverage) {
          const screenArea = camera.screenArea;
          let meshArea = bSphere.radiusWorld * camera.minZ / distanceToCamera;
          meshArea = meshArea * meshArea * Math.PI;
          compareValue = meshArea / screenArea;
          compareSign = -1;
        }
        if (compareSign * internalDataInfo._LODLevels[internalDataInfo._LODLevels.length - 1].distanceOrScreenCoverage > compareSign * compareValue) {
          if (this.onLODLevelSelection) {
            this.onLODLevelSelection(compareValue, this, this);
          }
          return this;
        }
        for (let index = 0; index < internalDataInfo._LODLevels.length; index++) {
          const level = internalDataInfo._LODLevels[index];
          if (compareSign * level.distanceOrScreenCoverage < compareSign * compareValue) {
            if (level.mesh) {
              if (level.mesh.delayLoadState === 4) {
                level.mesh._checkDelayState();
                return this;
              }
              if (level.mesh.delayLoadState === 2) {
                return this;
              }
              level.mesh._preActivate();
              level.mesh._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
            }
            if (this.onLODLevelSelection) {
              this.onLODLevelSelection(compareValue, this, level.mesh);
            }
            return level.mesh;
          }
        }
        if (this.onLODLevelSelection) {
          this.onLODLevelSelection(compareValue, this, this);
        }
        return this;
      }
      get geometry() {
        return this._geometry;
      }
      getTotalVertices() {
        if (this._geometry === null || this._geometry === void 0) {
          return 0;
        }
        return this._geometry.getTotalVertices();
      }
      getVerticesData(kind, copyWhenShared, forceCopy, bypassInstanceData) {
        var _a, _b;
        if (!this._geometry) {
          return null;
        }
        let data = bypassInstanceData ? void 0 : (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.getFloatData(
          this.instances.length + 1,
          forceCopy || copyWhenShared && this._geometry.meshes.length !== 1
        );
        if (!data) {
          data = this._geometry.getVerticesData(kind, copyWhenShared, forceCopy);
        }
        return data;
      }
      getVertexBuffer(kind, bypassInstanceData) {
        var _a, _b;
        if (!this._geometry) {
          return null;
        }
        return (_b = bypassInstanceData ? void 0 : (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== null && _b !== void 0 ? _b : this._geometry.getVertexBuffer(kind);
      }
      isVerticesDataPresent(kind, bypassInstanceData) {
        var _a;
        if (!this._geometry) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        return !bypassInstanceData && ((_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) !== void 0 || this._geometry.isVerticesDataPresent(kind);
      }
      isVertexBufferUpdatable(kind, bypassInstanceData) {
        var _a;
        if (!this._geometry) {
          if (this._delayInfo) {
            return this._delayInfo.indexOf(kind) !== -1;
          }
          return false;
        }
        if (!bypassInstanceData) {
          const buffer = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind];
          if (buffer) {
            return buffer.isUpdatable();
          }
        }
        return this._geometry.isVertexBufferUpdatable(kind);
      }
      getVerticesDataKinds(bypassInstanceData) {
        if (!this._geometry) {
          const result = new Array();
          if (this._delayInfo) {
            this._delayInfo.forEach(function(kind) {
              result.push(kind);
            });
          }
          return result;
        }
        const kinds = this._geometry.getVerticesDataKinds();
        if (!bypassInstanceData && this._userInstancedBuffersStorage) {
          for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {
            if (kinds.indexOf(kind) === -1) {
              kinds.push(kind);
            }
          }
        }
        return kinds;
      }
      getTotalIndices() {
        if (!this._geometry) {
          return 0;
        }
        return this._geometry.getTotalIndices();
      }
      getIndices(copyWhenShared, forceCopy) {
        if (!this._geometry) {
          return [];
        }
        return this._geometry.getIndices(copyWhenShared, forceCopy);
      }
      get isBlocked() {
        return this._masterMesh !== null && this._masterMesh !== void 0;
      }
      isReady(completeCheck = false, forceInstanceSupport = false) {
        var _a, _b, _c, _d, _e, _f, _g;
        if (this.delayLoadState === 2) {
          return false;
        }
        if (!super.isReady(completeCheck)) {
          return false;
        }
        if (!this.subMeshes || this.subMeshes.length === 0) {
          return true;
        }
        if (!completeCheck) {
          return true;
        }
        const engine = this.getEngine();
        const scene = this.getScene();
        const hardwareInstancedRendering = forceInstanceSupport || engine.getCaps().instancedArrays && (this.instances.length > 0 || this.hasThinInstances);
        this.computeWorldMatrix();
        const mat = this.material || scene.defaultMaterial;
        if (mat) {
          if (mat._storeEffectOnSubMeshes) {
            for (const subMesh of this.subMeshes) {
              const effectiveMaterial = subMesh.getMaterial();
              if (effectiveMaterial) {
                if (effectiveMaterial._storeEffectOnSubMeshes) {
                  if (!effectiveMaterial.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
                    return false;
                  }
                } else {
                  if (!effectiveMaterial.isReady(this, hardwareInstancedRendering)) {
                    return false;
                  }
                }
              }
            }
          } else {
            if (!mat.isReady(this, hardwareInstancedRendering)) {
              return false;
            }
          }
        }
        const currentRenderPassId = engine.currentRenderPassId;
        for (const light of this.lightSources) {
          const generators = light.getShadowGenerators();
          if (!generators) {
            continue;
          }
          const iterator = generators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const generator = key.value;
            if (generator && (!((_a = generator.getShadowMap()) === null || _a === void 0 ? void 0 : _a.renderList) || ((_b = generator.getShadowMap()) === null || _b === void 0 ? void 0 : _b.renderList) && ((_d = (_c = generator.getShadowMap()) === null || _c === void 0 ? void 0 : _c.renderList) === null || _d === void 0 ? void 0 : _d.indexOf(this)) !== -1)) {
              const shadowMap = generator.getShadowMap();
              const renderPassIds = (_e = shadowMap.renderPassIds) !== null && _e !== void 0 ? _e : [engine.currentRenderPassId];
              for (let p = 0; p < renderPassIds.length; ++p) {
                engine.currentRenderPassId = renderPassIds[p];
                for (const subMesh of this.subMeshes) {
                  if (!generator.isReady(subMesh, hardwareInstancedRendering, (_g = (_f = subMesh.getMaterial()) === null || _f === void 0 ? void 0 : _f.needAlphaBlendingForMesh(this)) !== null && _g !== void 0 ? _g : false)) {
                    engine.currentRenderPassId = currentRenderPassId;
                    return false;
                  }
                }
              }
              engine.currentRenderPassId = currentRenderPassId;
            }
          }
        }
        for (const lod of this._internalMeshDataInfo._LODLevels) {
          if (lod.mesh && !lod.mesh.isReady(hardwareInstancedRendering)) {
            return false;
          }
        }
        return true;
      }
      get areNormalsFrozen() {
        return this._internalMeshDataInfo._areNormalsFrozen;
      }
      freezeNormals() {
        this._internalMeshDataInfo._areNormalsFrozen = true;
        return this;
      }
      unfreezeNormals() {
        this._internalMeshDataInfo._areNormalsFrozen = false;
        return this;
      }
      set overridenInstanceCount(count) {
        this._instanceDataStorage.overridenInstanceCount = count;
      }
      _preActivate() {
        const internalDataInfo = this._internalMeshDataInfo;
        const sceneRenderId = this.getScene().getRenderId();
        if (internalDataInfo._preActivateId === sceneRenderId) {
          return this;
        }
        internalDataInfo._preActivateId = sceneRenderId;
        this._instanceDataStorage.visibleInstances = null;
        return this;
      }
      _preActivateForIntermediateRendering(renderId) {
        if (this._instanceDataStorage.visibleInstances) {
          this._instanceDataStorage.visibleInstances.intermediateDefaultRenderId = renderId;
        }
        return this;
      }
      _registerInstanceForRenderId(instance, renderId) {
        if (!this._instanceDataStorage.visibleInstances) {
          this._instanceDataStorage.visibleInstances = {
            defaultRenderId: renderId,
            selfDefaultRenderId: this._renderId
          };
        }
        if (!this._instanceDataStorage.visibleInstances[renderId]) {
          if (this._instanceDataStorage.previousRenderId !== void 0 && this._instanceDataStorage.isFrozen) {
            this._instanceDataStorage.visibleInstances[this._instanceDataStorage.previousRenderId] = null;
          }
          this._instanceDataStorage.previousRenderId = renderId;
          this._instanceDataStorage.visibleInstances[renderId] = new Array();
        }
        this._instanceDataStorage.visibleInstances[renderId].push(instance);
        return this;
      }
      _afterComputeWorldMatrix() {
        super._afterComputeWorldMatrix();
        if (!this.hasThinInstances) {
          return;
        }
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      }
      _postActivate() {
        if (this.edgesShareWithInstances && this.edgesRenderer && this.edgesRenderer.isEnabled && this._renderingGroup) {
          this._renderingGroup._edgesRenderers.pushNoDuplicate(this.edgesRenderer);
          this.edgesRenderer.customInstances.push(this.getWorldMatrix());
        }
      }
      refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
          return this;
        }
        const bias = this.geometry ? this.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._getPositionData(applySkeleton, applyMorph), bias);
        return this;
      }
      _createGlobalSubMesh(force) {
        const totalVertices = this.getTotalVertices();
        if (!totalVertices || !this.getIndices()) {
          return null;
        }
        if (this.subMeshes && this.subMeshes.length > 0) {
          const ib = this.getIndices();
          if (!ib) {
            return null;
          }
          const totalIndices = ib.length;
          let needToRecreate = false;
          if (force) {
            needToRecreate = true;
          } else {
            for (const submesh of this.subMeshes) {
              if (submesh.indexStart + submesh.indexCount > totalIndices) {
                needToRecreate = true;
                break;
              }
              if (submesh.verticesStart + submesh.verticesCount > totalVertices) {
                needToRecreate = true;
                break;
              }
            }
          }
          if (!needToRecreate) {
            return this.subMeshes[0];
          }
        }
        this.releaseSubMeshes();
        return new SubMesh(0, 0, totalVertices, 0, this.getTotalIndices(), this);
      }
      subdivide(count) {
        if (count < 1) {
          return;
        }
        const totalIndices = this.getTotalIndices();
        let subdivisionSize = totalIndices / count | 0;
        let offset = 0;
        while (subdivisionSize % 3 !== 0) {
          subdivisionSize++;
        }
        this.releaseSubMeshes();
        for (let index = 0; index < count; index++) {
          if (offset >= totalIndices) {
            break;
          }
          SubMesh.CreateFromIndices(0, offset, index === count - 1 ? totalIndices - offset : subdivisionSize, this, void 0, false);
          offset += subdivisionSize;
        }
        this.refreshBoundingInfo();
        this.synchronizeInstances();
      }
      setVerticesData(kind, data, updatable = false, stride) {
        if (!this._geometry) {
          const vertexData = new VertexData();
          vertexData.set(data, kind);
          const scene = this.getScene();
          new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
        } else {
          this._geometry.setVerticesData(kind, data, updatable, stride);
        }
        return this;
      }
      removeVerticesData(kind) {
        if (!this._geometry) {
          return;
        }
        this._geometry.removeVerticesData(kind);
      }
      markVerticesDataAsUpdatable(kind, updatable = true) {
        const vb = this.getVertexBuffer(kind);
        if (!vb || vb.isUpdatable() === updatable) {
          return;
        }
        this.setVerticesData(kind, this.getVerticesData(kind), updatable);
      }
      setVerticesBuffer(buffer, disposeExistingBuffer = true) {
        if (!this._geometry) {
          this._geometry = Geometry.CreateGeometryForMesh(this);
        }
        this._geometry.setVerticesBuffer(buffer, null, disposeExistingBuffer);
        return this;
      }
      updateVerticesData(kind, data, updateExtends, makeItUnique) {
        if (!this._geometry) {
          return this;
        }
        if (!makeItUnique) {
          this._geometry.updateVerticesData(kind, data, updateExtends);
        } else {
          this.makeGeometryUnique();
          this.updateVerticesData(kind, data, updateExtends, false);
        }
        return this;
      }
      updateMeshPositions(positionFunction, computeNormals = true) {
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions) {
          return this;
        }
        positionFunction(positions);
        this.updateVerticesData(VertexBuffer.PositionKind, positions, false, false);
        if (computeNormals) {
          const indices = this.getIndices();
          const normals = this.getVerticesData(VertexBuffer.NormalKind);
          if (!normals) {
            return this;
          }
          VertexData.ComputeNormals(positions, indices, normals);
          this.updateVerticesData(VertexBuffer.NormalKind, normals, false, false);
        }
        return this;
      }
      makeGeometryUnique() {
        if (!this._geometry) {
          return this;
        }
        if (this._geometry.meshes.length === 1) {
          return this;
        }
        const oldGeometry = this._geometry;
        const geometry = this._geometry.copy(Geometry.RandomId());
        oldGeometry.releaseForMesh(this, true);
        geometry.applyToMesh(this);
        return this;
      }
      setIndices(indices, totalVertices = null, updatable = false) {
        if (!this._geometry) {
          const vertexData = new VertexData();
          vertexData.indices = indices;
          const scene = this.getScene();
          new Geometry(Geometry.RandomId(), scene, vertexData, updatable, this);
        } else {
          this._geometry.setIndices(indices, totalVertices, updatable);
        }
        return this;
      }
      updateIndices(indices, offset, gpuMemoryOnly = false) {
        if (!this._geometry) {
          return this;
        }
        this._geometry.updateIndices(indices, offset, gpuMemoryOnly);
        return this;
      }
      toLeftHanded() {
        if (!this._geometry) {
          return this;
        }
        this._geometry.toLeftHanded();
        return this;
      }
      _bind(subMesh, effect, fillMode, allowInstancedRendering = true) {
        if (!this._geometry) {
          return this;
        }
        const engine = this.getScene().getEngine();
        if (this.morphTargetManager && this.morphTargetManager.isUsingTextureForTargets) {
          this.morphTargetManager._bind(effect);
        }
        let indexToBind;
        if (this._unIndexed) {
          indexToBind = null;
        } else {
          switch (this._getRenderingFillMode(fillMode)) {
            case Material.PointFillMode:
              indexToBind = null;
              break;
            case Material.WireFrameFillMode:
              indexToBind = subMesh._getLinesIndexBuffer(this.getIndices(), engine);
              break;
            default:
            case Material.TriangleFillMode:
              indexToBind = this._geometry.getIndexBuffer();
              break;
          }
        }
        if (!allowInstancedRendering || !this._userInstancedBuffersStorage || this.hasThinInstances) {
          this._geometry._bind(effect, indexToBind);
        } else {
          this._geometry._bind(effect, indexToBind, this._userInstancedBuffersStorage.vertexBuffers, this._userInstancedBuffersStorage.vertexArrayObjects);
        }
        return this;
      }
      _draw(subMesh, fillMode, instancesCount) {
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        if (this._internalMeshDataInfo._onBeforeDrawObservable) {
          this._internalMeshDataInfo._onBeforeDrawObservable.notifyObservers(this);
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        if (this._unIndexed || fillMode == Material.PointFillMode) {
          engine.drawArraysType(fillMode, subMesh.verticesStart, subMesh.verticesCount, this.forcedInstanceCount || instancesCount);
        } else if (fillMode == Material.WireFrameFillMode) {
          engine.drawElementsType(fillMode, 0, subMesh._linesIndexCount, this.forcedInstanceCount || instancesCount);
        } else {
          engine.drawElementsType(fillMode, subMesh.indexStart, subMesh.indexCount, this.forcedInstanceCount || instancesCount);
        }
        return this;
      }
      registerBeforeRender(func) {
        this.onBeforeRenderObservable.add(func);
        return this;
      }
      unregisterBeforeRender(func) {
        this.onBeforeRenderObservable.removeCallback(func);
        return this;
      }
      registerAfterRender(func) {
        this.onAfterRenderObservable.add(func);
        return this;
      }
      unregisterAfterRender(func) {
        this.onAfterRenderObservable.removeCallback(func);
        return this;
      }
      _getInstancesRenderList(subMeshId, isReplacementMode = false) {
        if (this._instanceDataStorage.isFrozen) {
          if (isReplacementMode) {
            this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.hardwareInstancedRendering[subMeshId] = false;
            this._instanceDataStorage.batchCacheReplacementModeInFrozenMode.renderSelf[subMeshId] = true;
            return this._instanceDataStorage.batchCacheReplacementModeInFrozenMode;
          }
          if (this._instanceDataStorage.previousBatch) {
            return this._instanceDataStorage.previousBatch;
          }
        }
        const scene = this.getScene();
        const isInIntermediateRendering = scene._isInIntermediateRendering();
        const onlyForInstances = isInIntermediateRendering ? this._internalAbstractMeshDataInfo._onlyForInstancesIntermediate : this._internalAbstractMeshDataInfo._onlyForInstances;
        const batchCache = this._instanceDataStorage.batchCache;
        batchCache.mustReturn = false;
        batchCache.renderSelf[subMeshId] = isReplacementMode || !onlyForInstances && this.isEnabled() && this.isVisible;
        batchCache.visibleInstances[subMeshId] = null;
        if (this._instanceDataStorage.visibleInstances && !isReplacementMode) {
          const visibleInstances = this._instanceDataStorage.visibleInstances;
          const currentRenderId = scene.getRenderId();
          const defaultRenderId = isInIntermediateRendering ? visibleInstances.intermediateDefaultRenderId : visibleInstances.defaultRenderId;
          batchCache.visibleInstances[subMeshId] = visibleInstances[currentRenderId];
          if (!batchCache.visibleInstances[subMeshId] && defaultRenderId) {
            batchCache.visibleInstances[subMeshId] = visibleInstances[defaultRenderId];
          }
        }
        batchCache.hardwareInstancedRendering[subMeshId] = !isReplacementMode && this._instanceDataStorage.hardwareInstancedRendering && batchCache.visibleInstances[subMeshId] !== null && batchCache.visibleInstances[subMeshId] !== void 0;
        this._instanceDataStorage.previousBatch = batchCache;
        return batchCache;
      }
      _renderWithInstances(subMesh, fillMode, batch, effect, engine) {
        var _a;
        const visibleInstances = batch.visibleInstances[subMesh._id];
        const visibleInstanceCount = visibleInstances ? visibleInstances.length : 0;
        const instanceStorage = this._instanceDataStorage;
        const currentInstancesBufferSize = instanceStorage.instancesBufferSize;
        let instancesBuffer = instanceStorage.instancesBuffer;
        let instancesPreviousBuffer = instanceStorage.instancesPreviousBuffer;
        const matricesCount = visibleInstanceCount + 1;
        const bufferSize = matricesCount * 16 * 4;
        while (instanceStorage.instancesBufferSize < bufferSize) {
          instanceStorage.instancesBufferSize *= 2;
        }
        if (!instanceStorage.instancesData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
          instanceStorage.instancesData = new Float32Array(instanceStorage.instancesBufferSize / 4);
        }
        if (this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousData || currentInstancesBufferSize != instanceStorage.instancesBufferSize) {
          instanceStorage.instancesPreviousData = new Float32Array(instanceStorage.instancesBufferSize / 4);
        }
        let offset = 0;
        let instancesCount = 0;
        const renderSelf = batch.renderSelf[subMesh._id];
        const needUpdateBuffer = !instancesBuffer || currentInstancesBufferSize !== instanceStorage.instancesBufferSize || this._scene.needsPreviousWorldMatrices && !instanceStorage.instancesPreviousBuffer;
        if (!this._instanceDataStorage.manualUpdate && (!instanceStorage.isFrozen || needUpdateBuffer)) {
          const world = this.getWorldMatrix();
          if (renderSelf) {
            if (this._scene.needsPreviousWorldMatrices) {
              if (!instanceStorage.masterMeshPreviousWorldMatrix) {
                instanceStorage.masterMeshPreviousWorldMatrix = world.clone();
                instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
              } else {
                instanceStorage.masterMeshPreviousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                instanceStorage.masterMeshPreviousWorldMatrix.copyFrom(world);
              }
            }
            world.copyToArray(instanceStorage.instancesData, offset);
            offset += 16;
            instancesCount++;
          }
          if (visibleInstances) {
            if (Mesh.INSTANCEDMESH_SORT_TRANSPARENT && this._scene.activeCamera && ((_a = subMesh.getMaterial()) === null || _a === void 0 ? void 0 : _a.needAlphaBlendingForMesh(subMesh.getRenderingMesh()))) {
              const cameraPosition = this._scene.activeCamera.globalPosition;
              for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
                const instanceMesh = visibleInstances[instanceIndex];
                instanceMesh._distanceToCamera = Vector3.Distance(instanceMesh.getBoundingInfo().boundingSphere.centerWorld, cameraPosition);
              }
              visibleInstances.sort((m1, m2) => {
                return m1._distanceToCamera > m2._distanceToCamera ? -1 : m1._distanceToCamera < m2._distanceToCamera ? 1 : 0;
              });
            }
            for (let instanceIndex = 0; instanceIndex < visibleInstances.length; instanceIndex++) {
              const instance = visibleInstances[instanceIndex];
              const matrix = instance.getWorldMatrix();
              matrix.copyToArray(instanceStorage.instancesData, offset);
              if (this._scene.needsPreviousWorldMatrices) {
                if (!instance._previousWorldMatrix) {
                  instance._previousWorldMatrix = matrix.clone();
                  instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                } else {
                  instance._previousWorldMatrix.copyToArray(instanceStorage.instancesPreviousData, offset);
                  instance._previousWorldMatrix.copyFrom(matrix);
                }
              }
              offset += 16;
              instancesCount++;
            }
          }
        } else {
          instancesCount = (renderSelf ? 1 : 0) + visibleInstanceCount;
        }
        if (needUpdateBuffer) {
          if (instancesBuffer) {
            instancesBuffer.dispose();
          }
          if (instancesPreviousBuffer) {
            instancesPreviousBuffer.dispose();
          }
          instancesBuffer = new Buffer(engine, instanceStorage.instancesData, true, 16, false, true);
          instanceStorage.instancesBuffer = instancesBuffer;
          if (!this._userInstancedBuffersStorage) {
            this._userInstancedBuffersStorage = {
              data: {},
              vertexBuffers: {},
              strides: {},
              sizes: {},
              vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
            };
          }
          this._userInstancedBuffersStorage.vertexBuffers["world0"] = instancesBuffer.createVertexBuffer("world0", 0, 4);
          this._userInstancedBuffersStorage.vertexBuffers["world1"] = instancesBuffer.createVertexBuffer("world1", 4, 4);
          this._userInstancedBuffersStorage.vertexBuffers["world2"] = instancesBuffer.createVertexBuffer("world2", 8, 4);
          this._userInstancedBuffersStorage.vertexBuffers["world3"] = instancesBuffer.createVertexBuffer("world3", 12, 4);
          if (this._scene.needsPreviousWorldMatrices) {
            instancesPreviousBuffer = new Buffer(engine, instanceStorage.instancesPreviousData, true, 16, false, true);
            instanceStorage.instancesPreviousBuffer = instancesPreviousBuffer;
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld0"] = instancesPreviousBuffer.createVertexBuffer("previousWorld0", 0, 4);
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld1"] = instancesPreviousBuffer.createVertexBuffer("previousWorld1", 4, 4);
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld2"] = instancesPreviousBuffer.createVertexBuffer("previousWorld2", 8, 4);
            this._userInstancedBuffersStorage.vertexBuffers["previousWorld3"] = instancesPreviousBuffer.createVertexBuffer("previousWorld3", 12, 4);
          }
          this._invalidateInstanceVertexArrayObject();
        } else {
          if (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) {
            instancesBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
            if (this._scene.needsPreviousWorldMatrices && (!this._instanceDataStorage.manualUpdate || this._instanceDataStorage.previousManualUpdate)) {
              instancesPreviousBuffer.updateDirectly(instanceStorage.instancesPreviousData, 0, instancesCount);
            }
          }
        }
        this._processInstancedBuffers(visibleInstances, renderSelf);
        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
        if (engine._currentDrawContext) {
          engine._currentDrawContext.useInstancing = true;
        }
        this._bind(subMesh, effect, fillMode);
        this._draw(subMesh, fillMode, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && !needUpdateBuffer && this._instanceDataStorage.manualUpdate && (!this._instanceDataStorage.isFrozen || this._instanceDataStorage.forceMatrixUpdates) && !this._instanceDataStorage.previousManualUpdate) {
          instancesPreviousBuffer.updateDirectly(instanceStorage.instancesData, 0, instancesCount);
        }
        engine.unbindInstanceAttributes();
        return this;
      }
      _renderWithThinInstances(subMesh, fillMode, effect, engine) {
        var _a, _b;
        const instancesCount = (_b = (_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.instancesCount) !== null && _b !== void 0 ? _b : 0;
        this.getScene()._activeIndices.addCount(subMesh.indexCount * instancesCount, false);
        if (engine._currentDrawContext) {
          engine._currentDrawContext.useInstancing = true;
        }
        this._bind(subMesh, effect, fillMode);
        this._draw(subMesh, fillMode, instancesCount);
        if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData && this._thinInstanceDataStorage.matrixData) {
          if (!this._thinInstanceDataStorage.previousMatrixBuffer) {
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", this._thinInstanceDataStorage.matrixData, false);
          } else {
            this._thinInstanceDataStorage.previousMatrixBuffer.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, instancesCount);
          }
        }
        engine.unbindInstanceAttributes();
      }
      _processInstancedBuffers(visibleInstances, renderSelf) {
      }
      _processRendering(renderingMesh, subMesh, effect, fillMode, batch, hardwareInstancedRendering, onBeforeDraw, effectiveMaterial) {
        const scene = this.getScene();
        const engine = scene.getEngine();
        fillMode = this._getRenderingFillMode(fillMode);
        if (hardwareInstancedRendering && subMesh.getRenderingMesh().hasThinInstances) {
          this._renderWithThinInstances(subMesh, fillMode, effect, engine);
          return this;
        }
        if (hardwareInstancedRendering) {
          this._renderWithInstances(subMesh, fillMode, batch, effect, engine);
        } else {
          if (engine._currentDrawContext) {
            engine._currentDrawContext.useInstancing = false;
          }
          let instanceCount = 0;
          if (batch.renderSelf[subMesh._id]) {
            if (onBeforeDraw) {
              onBeforeDraw(false, renderingMesh.getWorldMatrix(), effectiveMaterial);
            }
            instanceCount++;
            this._draw(subMesh, fillMode, this._instanceDataStorage.overridenInstanceCount);
          }
          const visibleInstancesForSubMesh = batch.visibleInstances[subMesh._id];
          if (visibleInstancesForSubMesh) {
            const visibleInstanceCount = visibleInstancesForSubMesh.length;
            instanceCount += visibleInstanceCount;
            for (let instanceIndex = 0; instanceIndex < visibleInstanceCount; instanceIndex++) {
              const instance = visibleInstancesForSubMesh[instanceIndex];
              const world = instance.getWorldMatrix();
              if (onBeforeDraw) {
                onBeforeDraw(true, world, effectiveMaterial);
              }
              this._draw(subMesh, fillMode);
            }
          }
          scene._activeIndices.addCount(subMesh.indexCount * instanceCount, false);
        }
        return this;
      }
      _rebuild(dispose = false) {
        if (this._instanceDataStorage.instancesBuffer) {
          if (dispose) {
            this._instanceDataStorage.instancesBuffer.dispose();
          }
          this._instanceDataStorage.instancesBuffer = null;
        }
        if (this._userInstancedBuffersStorage) {
          for (const kind in this._userInstancedBuffersStorage.vertexBuffers) {
            const buffer = this._userInstancedBuffersStorage.vertexBuffers[kind];
            if (buffer) {
              if (dispose) {
                buffer.dispose();
              }
              this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
            }
          }
          if (this._userInstancedBuffersStorage.vertexArrayObjects) {
            this._userInstancedBuffersStorage.vertexArrayObjects = {};
          }
        }
        this._internalMeshDataInfo._effectiveMaterial = null;
        super._rebuild(dispose);
      }
      _freeze() {
        if (!this.subMeshes) {
          return;
        }
        for (let index = 0; index < this.subMeshes.length; index++) {
          this._getInstancesRenderList(index);
        }
        this._internalMeshDataInfo._effectiveMaterial = null;
        this._instanceDataStorage.isFrozen = true;
      }
      _unFreeze() {
        this._instanceDataStorage.isFrozen = false;
        this._instanceDataStorage.previousBatch = null;
      }
      render(subMesh, enableAlphaMode, effectiveMeshReplacement) {
        var _a, _b, _c, _d, _e;
        const scene = this.getScene();
        if (this._internalAbstractMeshDataInfo._isActiveIntermediate) {
          this._internalAbstractMeshDataInfo._isActiveIntermediate = false;
        } else {
          this._internalAbstractMeshDataInfo._isActive = false;
        }
        const numActiveCameras = (_b = (_a = scene.activeCameras) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : 0;
        const canCheckOcclusionQuery = numActiveCameras > 1 && scene.activeCamera === scene.activeCameras[0] || numActiveCameras <= 1;
        if (canCheckOcclusionQuery && this._checkOcclusionQuery() && !this._occlusionDataStorage.forceRenderingWhenOccluded) {
          return this;
        }
        const batch = this._getInstancesRenderList(subMesh._id, !!effectiveMeshReplacement);
        if (batch.mustReturn) {
          return this;
        }
        if (!this._geometry || !this._geometry.getVertexBuffers() || !this._unIndexed && !this._geometry.getIndexBuffer()) {
          return this;
        }
        const engine = scene.getEngine();
        let oldCameraMaxZ = 0;
        let oldCamera = null;
        if (this.ignoreCameraMaxZ && scene.activeCamera && !scene._isInIntermediateRendering()) {
          oldCameraMaxZ = scene.activeCamera.maxZ;
          oldCamera = scene.activeCamera;
          scene.activeCamera.maxZ = 0;
          scene.updateTransformMatrix(true);
        }
        if (this._internalMeshDataInfo._onBeforeRenderObservable) {
          this._internalMeshDataInfo._onBeforeRenderObservable.notifyObservers(this);
        }
        const renderingMesh = subMesh.getRenderingMesh();
        const hardwareInstancedRendering = batch.hardwareInstancedRendering[subMesh._id] || renderingMesh.hasThinInstances || !!this._userInstancedBuffersStorage && !subMesh.getMesh()._internalAbstractMeshDataInfo._actAsRegularMesh;
        const instanceDataStorage = this._instanceDataStorage;
        const material = subMesh.getMaterial();
        if (!material) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        if (!instanceDataStorage.isFrozen || !this._internalMeshDataInfo._effectiveMaterial || this._internalMeshDataInfo._effectiveMaterial !== material) {
          if (material._storeEffectOnSubMeshes) {
            if (!material.isReadyForSubMesh(this, subMesh, hardwareInstancedRendering)) {
              if (oldCamera) {
                oldCamera.maxZ = oldCameraMaxZ;
                scene.updateTransformMatrix(true);
              }
              return this;
            }
          } else if (!material.isReady(this, hardwareInstancedRendering)) {
            if (oldCamera) {
              oldCamera.maxZ = oldCameraMaxZ;
              scene.updateTransformMatrix(true);
            }
            return this;
          }
          this._internalMeshDataInfo._effectiveMaterial = material;
        } else if (material._storeEffectOnSubMeshes && !((_c = subMesh.effect) === null || _c === void 0 ? void 0 : _c._wasPreviouslyReady) || !material._storeEffectOnSubMeshes && !((_d = material.getEffect()) === null || _d === void 0 ? void 0 : _d._wasPreviouslyReady)) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        if (enableAlphaMode) {
          engine.setAlphaMode(this._internalMeshDataInfo._effectiveMaterial.alphaMode);
        }
        let drawWrapper;
        if (this._internalMeshDataInfo._effectiveMaterial._storeEffectOnSubMeshes) {
          drawWrapper = subMesh._drawWrapper;
        } else {
          drawWrapper = this._internalMeshDataInfo._effectiveMaterial._getDrawWrapper();
        }
        const effect = (_e = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _e !== void 0 ? _e : null;
        for (const step of scene._beforeRenderingMeshStage) {
          step.action(this, subMesh, batch, effect);
        }
        if (!drawWrapper || !effect) {
          if (oldCamera) {
            oldCamera.maxZ = oldCameraMaxZ;
            scene.updateTransformMatrix(true);
          }
          return this;
        }
        const effectiveMesh = effectiveMeshReplacement || this;
        let sideOrientation;
        if (!instanceDataStorage.isFrozen && (this._internalMeshDataInfo._effectiveMaterial.backFaceCulling || this.overrideMaterialSideOrientation !== null)) {
          const mainDeterminant = effectiveMesh._getWorldMatrixDeterminant();
          sideOrientation = this.overrideMaterialSideOrientation;
          if (sideOrientation == null) {
            sideOrientation = this._internalMeshDataInfo._effectiveMaterial.sideOrientation;
          }
          if (mainDeterminant < 0) {
            sideOrientation = sideOrientation === Material.ClockWiseSideOrientation ? Material.CounterClockWiseSideOrientation : Material.ClockWiseSideOrientation;
          }
          instanceDataStorage.sideOrientation = sideOrientation;
        } else {
          sideOrientation = instanceDataStorage.sideOrientation;
        }
        const reverse = this._internalMeshDataInfo._effectiveMaterial._preBind(drawWrapper, sideOrientation);
        if (this._internalMeshDataInfo._effectiveMaterial.forceDepthWrite) {
          engine.setDepthWrite(true);
        }
        const effectiveMaterial = this._internalMeshDataInfo._effectiveMaterial;
        const fillMode = effectiveMaterial.fillMode;
        if (this._internalMeshDataInfo._onBeforeBindObservable) {
          this._internalMeshDataInfo._onBeforeBindObservable.notifyObservers(this);
        }
        if (!hardwareInstancedRendering) {
          this._bind(subMesh, effect, fillMode, false);
        }
        const world = effectiveMesh.getWorldMatrix();
        if (effectiveMaterial._storeEffectOnSubMeshes) {
          effectiveMaterial.bindForSubMesh(world, this, subMesh);
        } else {
          effectiveMaterial.bind(world, this);
        }
        if (!effectiveMaterial.backFaceCulling && effectiveMaterial.separateCullingPass) {
          engine.setState(true, effectiveMaterial.zOffset, false, !reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
          this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
          engine.setState(true, effectiveMaterial.zOffset, false, reverse, effectiveMaterial.cullBackFaces, effectiveMaterial.stencil, effectiveMaterial.zOffsetUnits);
          if (this._internalMeshDataInfo._onBetweenPassObservable) {
            this._internalMeshDataInfo._onBetweenPassObservable.notifyObservers(subMesh);
          }
        }
        this._processRendering(this, subMesh, effect, fillMode, batch, hardwareInstancedRendering, this._onBeforeDraw, this._internalMeshDataInfo._effectiveMaterial);
        this._internalMeshDataInfo._effectiveMaterial.unbind();
        for (const step of scene._afterRenderingMeshStage) {
          step.action(this, subMesh, batch, effect);
        }
        if (this._internalMeshDataInfo._onAfterRenderObservable) {
          this._internalMeshDataInfo._onAfterRenderObservable.notifyObservers(this);
        }
        if (oldCamera) {
          oldCamera.maxZ = oldCameraMaxZ;
          scene.updateTransformMatrix(true);
        }
        if (scene.performancePriority === ScenePerformancePriority.Aggressive && !instanceDataStorage.isFrozen) {
          this._freeze();
        }
        return this;
      }
      cleanMatrixWeights() {
        if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          if (this.isVerticesDataPresent(VertexBuffer.MatricesWeightsExtraKind)) {
            this._normalizeSkinWeightsAndExtra();
          } else {
            this._normalizeSkinFourWeights();
          }
        }
      }
      _normalizeSkinFourWeights() {
        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        const numWeights = matricesWeights.length;
        for (let a = 0; a < numWeights; a += 4) {
          const t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
          if (t === 0) {
            matricesWeights[a] = 1;
          } else {
            const recip = 1 / t;
            matricesWeights[a] *= recip;
            matricesWeights[a + 1] *= recip;
            matricesWeights[a + 2] *= recip;
            matricesWeights[a + 3] *= recip;
          }
        }
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
      }
      _normalizeSkinWeightsAndExtra() {
        const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        const numWeights = matricesWeights.length;
        for (let a = 0; a < numWeights; a += 4) {
          let t = matricesWeights[a] + matricesWeights[a + 1] + matricesWeights[a + 2] + matricesWeights[a + 3];
          t += matricesWeightsExtra[a] + matricesWeightsExtra[a + 1] + matricesWeightsExtra[a + 2] + matricesWeightsExtra[a + 3];
          if (t === 0) {
            matricesWeights[a] = 1;
          } else {
            const recip = 1 / t;
            matricesWeights[a] *= recip;
            matricesWeights[a + 1] *= recip;
            matricesWeights[a + 2] *= recip;
            matricesWeights[a + 3] *= recip;
            matricesWeightsExtra[a] *= recip;
            matricesWeightsExtra[a + 1] *= recip;
            matricesWeightsExtra[a + 2] *= recip;
            matricesWeightsExtra[a + 3] *= recip;
          }
        }
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeights);
        this.setVerticesData(VertexBuffer.MatricesWeightsKind, matricesWeightsExtra);
      }
      validateSkinning() {
        const matricesWeightsExtra = this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind);
        const matricesWeights = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        if (matricesWeights === null || this.skeleton == null) {
          return { skinned: false, valid: true, report: "not skinned" };
        }
        const numWeights = matricesWeights.length;
        let numberNotSorted = 0;
        let missingWeights = 0;
        let maxUsedWeights = 0;
        let numberNotNormalized = 0;
        const numInfluences = matricesWeightsExtra === null ? 4 : 8;
        const usedWeightCounts = new Array();
        for (let a = 0; a <= numInfluences; a++) {
          usedWeightCounts[a] = 0;
        }
        const toleranceEpsilon = 1e-3;
        for (let a = 0; a < numWeights; a += 4) {
          let lastWeight = matricesWeights[a];
          let t = lastWeight;
          let usedWeights = t === 0 ? 0 : 1;
          for (let b = 1; b < numInfluences; b++) {
            const d = b < 4 ? matricesWeights[a + b] : matricesWeightsExtra[a + b - 4];
            if (d > lastWeight) {
              numberNotSorted++;
            }
            if (d !== 0) {
              usedWeights++;
            }
            t += d;
            lastWeight = d;
          }
          usedWeightCounts[usedWeights]++;
          if (usedWeights > maxUsedWeights) {
            maxUsedWeights = usedWeights;
          }
          if (t === 0) {
            missingWeights++;
          } else {
            const recip = 1 / t;
            let tolerance = 0;
            for (let b = 0; b < numInfluences; b++) {
              if (b < 4) {
                tolerance += Math.abs(matricesWeights[a + b] - matricesWeights[a + b] * recip);
              } else {
                tolerance += Math.abs(matricesWeightsExtra[a + b - 4] - matricesWeightsExtra[a + b - 4] * recip);
              }
            }
            if (tolerance > toleranceEpsilon) {
              numberNotNormalized++;
            }
          }
        }
        const numBones = this.skeleton.bones.length;
        const matricesIndices = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
        const matricesIndicesExtra = this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind);
        let numBadBoneIndices = 0;
        for (let a = 0; a < numWeights; a += 4) {
          for (let b = 0; b < numInfluences; b++) {
            const index = b < 4 ? matricesIndices[a + b] : matricesIndicesExtra[a + b - 4];
            if (index >= numBones || index < 0) {
              numBadBoneIndices++;
            }
          }
        }
        const output = "Number of Weights = " + numWeights / 4 + "\nMaximum influences = " + maxUsedWeights + "\nMissing Weights = " + missingWeights + "\nNot Sorted = " + numberNotSorted + "\nNot Normalized = " + numberNotNormalized + "\nWeightCounts = [" + usedWeightCounts + "]\nNumber of bones = " + numBones + "\nBad Bone Indices = " + numBadBoneIndices;
        return { skinned: true, valid: missingWeights === 0 && numberNotNormalized === 0 && numBadBoneIndices === 0, report: output };
      }
      _checkDelayState() {
        const scene = this.getScene();
        if (this._geometry) {
          this._geometry.load(scene);
        } else if (this.delayLoadState === 4) {
          this.delayLoadState = 2;
          this._queueLoad(scene);
        }
        return this;
      }
      _queueLoad(scene) {
        scene.addPendingData(this);
        const getBinaryData = this.delayLoadingFile.indexOf(".babylonbinarymeshdata") !== -1;
        Tools.LoadFile(this.delayLoadingFile, (data) => {
          if (data instanceof ArrayBuffer) {
            this._delayLoadingFunction(data, this);
          } else {
            this._delayLoadingFunction(JSON.parse(data), this);
          }
          this.instances.forEach((instance) => {
            instance.refreshBoundingInfo();
            instance._syncSubMeshes();
          });
          this.delayLoadState = 1;
          scene.removePendingData(this);
        }, () => {
        }, scene.offlineProvider, getBinaryData);
        return this;
      }
      isInFrustum(frustumPlanes) {
        if (this.delayLoadState === 2) {
          return false;
        }
        if (!super.isInFrustum(frustumPlanes)) {
          return false;
        }
        this._checkDelayState();
        return true;
      }
      setMaterialById(id) {
        const materials = this.getScene().materials;
        let index;
        for (index = materials.length - 1; index > -1; index--) {
          if (materials[index].id === id) {
            this.material = materials[index];
            return this;
          }
        }
        const multiMaterials = this.getScene().multiMaterials;
        for (index = multiMaterials.length - 1; index > -1; index--) {
          if (multiMaterials[index].id === id) {
            this.material = multiMaterials[index];
            return this;
          }
        }
        return this;
      }
      getAnimatables() {
        const results = new Array();
        if (this.material) {
          results.push(this.material);
        }
        if (this.skeleton) {
          results.push(this.skeleton);
        }
        return results;
      }
      bakeTransformIntoVertices(transform) {
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          return this;
        }
        const submeshes = this.subMeshes.splice(0);
        this._resetPointsArrayCache();
        let data = this.getVerticesData(VertexBuffer.PositionKind);
        const temp = Vector3.Zero();
        let index;
        for (index = 0; index < data.length; index += 3) {
          Vector3.TransformCoordinatesFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).toArray(data, index);
        }
        this.setVerticesData(VertexBuffer.PositionKind, data, this.getVertexBuffer(VertexBuffer.PositionKind).isUpdatable());
        if (this.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          data = this.getVerticesData(VertexBuffer.NormalKind);
          for (index = 0; index < data.length; index += 3) {
            Vector3.TransformNormalFromFloatsToRef(data[index], data[index + 1], data[index + 2], transform, temp).normalize().toArray(data, index);
          }
          this.setVerticesData(VertexBuffer.NormalKind, data, this.getVertexBuffer(VertexBuffer.NormalKind).isUpdatable());
        }
        if (transform.determinant() < 0) {
          this.flipFaces();
        }
        this.releaseSubMeshes();
        this.subMeshes = submeshes;
        return this;
      }
      bakeCurrentTransformIntoVertices(bakeIndependentlyOfChildren = true) {
        this.bakeTransformIntoVertices(this.computeWorldMatrix(true));
        this.resetLocalMatrix(bakeIndependentlyOfChildren);
        return this;
      }
      get _positions() {
        if (this._internalAbstractMeshDataInfo._positions) {
          return this._internalAbstractMeshDataInfo._positions;
        }
        if (this._geometry) {
          return this._geometry._positions;
        }
        return null;
      }
      _resetPointsArrayCache() {
        if (this._geometry) {
          this._geometry._resetPointsArrayCache();
        }
        return this;
      }
      _generatePointsArray() {
        if (this._geometry) {
          return this._geometry._generatePointsArray();
        }
        return false;
      }
      clone(name109 = "", newParent = null, doNotCloneChildren, clonePhysicsImpostor = true) {
        return new Mesh(name109, this.getScene(), newParent, this, doNotCloneChildren, clonePhysicsImpostor);
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this.morphTargetManager = null;
        if (this._geometry) {
          this._geometry.releaseForMesh(this, true);
        }
        const internalDataInfo = this._internalMeshDataInfo;
        if (internalDataInfo._onBeforeDrawObservable) {
          internalDataInfo._onBeforeDrawObservable.clear();
        }
        if (internalDataInfo._onBeforeBindObservable) {
          internalDataInfo._onBeforeBindObservable.clear();
        }
        if (internalDataInfo._onBeforeRenderObservable) {
          internalDataInfo._onBeforeRenderObservable.clear();
        }
        if (internalDataInfo._onAfterRenderObservable) {
          internalDataInfo._onAfterRenderObservable.clear();
        }
        if (internalDataInfo._onBetweenPassObservable) {
          internalDataInfo._onBetweenPassObservable.clear();
        }
        if (this._scene.useClonedMeshMap) {
          if (internalDataInfo.meshMap) {
            for (const uniqueId in internalDataInfo.meshMap) {
              const mesh = internalDataInfo.meshMap[uniqueId];
              if (mesh) {
                mesh._internalMeshDataInfo._source = null;
                internalDataInfo.meshMap[uniqueId] = void 0;
              }
            }
          }
          if (internalDataInfo._source && internalDataInfo._source._internalMeshDataInfo.meshMap) {
            internalDataInfo._source._internalMeshDataInfo.meshMap[this.uniqueId] = void 0;
          }
        } else {
          const meshes = this.getScene().meshes;
          for (const abstractMesh of meshes) {
            const mesh = abstractMesh;
            if (mesh._internalMeshDataInfo && mesh._internalMeshDataInfo._source && mesh._internalMeshDataInfo._source === this) {
              mesh._internalMeshDataInfo._source = null;
            }
          }
        }
        internalDataInfo._source = null;
        this._instanceDataStorage.visibleInstances = {};
        this._disposeInstanceSpecificData();
        this._disposeThinInstanceSpecificData();
        if (this._internalMeshDataInfo._checkReadinessObserver) {
          this._scene.onBeforeRenderObservable.remove(this._internalMeshDataInfo._checkReadinessObserver);
        }
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      _disposeInstanceSpecificData() {
      }
      _disposeThinInstanceSpecificData() {
      }
      _invalidateInstanceVertexArrayObject() {
      }
      applyDisplacementMap(url, minHeight, maxHeight, onSuccess, uvOffset, uvScale, forceUpdate = false) {
        const scene = this.getScene();
        const onload = (img) => {
          const heightMapWidth = img.width;
          const heightMapHeight = img.height;
          const canvas = this.getEngine().createCanvas(heightMapWidth, heightMapHeight);
          const context = canvas.getContext("2d");
          context.drawImage(img, 0, 0);
          const buffer = context.getImageData(0, 0, heightMapWidth, heightMapHeight).data;
          this.applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate);
          if (onSuccess) {
            onSuccess(this);
          }
        };
        Tools.LoadImage(url, onload, () => {
        }, scene.offlineProvider);
        return this;
      }
      applyDisplacementMapFromBuffer(buffer, heightMapWidth, heightMapHeight, minHeight, maxHeight, uvOffset, uvScale, forceUpdate = false) {
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind) || !this.isVerticesDataPresent(VertexBuffer.NormalKind) || !this.isVerticesDataPresent(VertexBuffer.UVKind)) {
          Logger.Warn("Cannot call applyDisplacementMap: Given mesh is not complete. Position, Normal or UV are missing");
          return this;
        }
        const positions = this.getVerticesData(VertexBuffer.PositionKind, true, true);
        const normals = this.getVerticesData(VertexBuffer.NormalKind);
        const uvs = this.getVerticesData(VertexBuffer.UVKind);
        let position = Vector3.Zero();
        const normal = Vector3.Zero();
        const uv = Vector2.Zero();
        uvOffset = uvOffset || Vector2.Zero();
        uvScale = uvScale || new Vector2(1, 1);
        for (let index = 0; index < positions.length; index += 3) {
          Vector3.FromArrayToRef(positions, index, position);
          Vector3.FromArrayToRef(normals, index, normal);
          Vector2.FromArrayToRef(uvs, index / 3 * 2, uv);
          const u = Math.abs(uv.x * uvScale.x + uvOffset.x % 1) * (heightMapWidth - 1) % heightMapWidth | 0;
          const v = Math.abs(uv.y * uvScale.y + uvOffset.y % 1) * (heightMapHeight - 1) % heightMapHeight | 0;
          const pos = (u + v * heightMapWidth) * 4;
          const r = buffer[pos] / 255;
          const g = buffer[pos + 1] / 255;
          const b = buffer[pos + 2] / 255;
          const gradient = r * 0.3 + g * 0.59 + b * 0.11;
          normal.normalize();
          normal.scaleInPlace(minHeight + (maxHeight - minHeight) * gradient);
          position = position.add(normal);
          position.toArray(positions, index);
        }
        VertexData.ComputeNormals(positions, this.getIndices(), normals);
        if (forceUpdate) {
          this.setVerticesData(VertexBuffer.PositionKind, positions);
          this.setVerticesData(VertexBuffer.NormalKind, normals);
          this.setVerticesData(VertexBuffer.UVKind, uvs);
        } else {
          this.updateVerticesData(VertexBuffer.PositionKind, positions);
          this.updateVerticesData(VertexBuffer.NormalKind, normals);
        }
        return this;
      }
      _getFlattenedNormals(indices, positions) {
        const normals = new Float32Array(indices.length * 3);
        let normalsCount = 0;
        const flipNormalGeneration = this.overrideMaterialSideOrientation === (this._scene.useRightHandedSystem ? 1 : 0);
        for (let index = 0; index < indices.length; index += 3) {
          const p1 = Vector3.FromArray(positions, indices[index] * 3);
          const p2 = Vector3.FromArray(positions, indices[index + 1] * 3);
          const p3 = Vector3.FromArray(positions, indices[index + 2] * 3);
          const p1p2 = p1.subtract(p2);
          const p3p2 = p3.subtract(p2);
          const normal = Vector3.Normalize(Vector3.Cross(p1p2, p3p2));
          if (flipNormalGeneration) {
            normal.scaleInPlace(-1);
          }
          for (let localIndex = 0; localIndex < 3; localIndex++) {
            normals[normalsCount++] = normal.x;
            normals[normalsCount++] = normal.y;
            normals[normalsCount++] = normal.z;
          }
        }
        return normals;
      }
      _convertToUnIndexedMesh(flattenNormals = false) {
        const kinds = this.getVerticesDataKinds();
        const indices = this.getIndices();
        const data = {};
        const separateVertices = (data2, stride) => {
          const newData = new Float32Array(indices.length * stride);
          let count = 0;
          for (let index = 0; index < indices.length; index++) {
            for (let offset = 0; offset < stride; offset++) {
              newData[count++] = data2[indices[index] * stride + offset];
            }
          }
          return newData;
        };
        const previousSubmeshes = this.geometry ? this.subMeshes.slice(0) : [];
        for (const kind of kinds) {
          data[kind] = this.getVerticesData(kind);
        }
        for (const kind of kinds) {
          const vertexBuffer = this.getVertexBuffer(kind);
          const stride = vertexBuffer.getStrideSize();
          if (flattenNormals && kind === VertexBuffer.NormalKind) {
            const normals = this._getFlattenedNormals(indices, data[VertexBuffer.PositionKind]);
            this.setVerticesData(VertexBuffer.NormalKind, normals, vertexBuffer.isUpdatable(), stride);
          } else {
            this.setVerticesData(kind, separateVertices(data[kind], stride), vertexBuffer.isUpdatable(), stride);
          }
        }
        if (this.morphTargetManager) {
          for (let targetIndex = 0; targetIndex < this.morphTargetManager.numTargets; targetIndex++) {
            const target = this.morphTargetManager.getTarget(targetIndex);
            const positions = target.getPositions();
            target.setPositions(separateVertices(positions, 3));
            const normals = target.getNormals();
            if (normals) {
              target.setNormals(flattenNormals ? this._getFlattenedNormals(indices, positions) : separateVertices(normals, 3));
            }
            const tangents = target.getTangents();
            if (tangents) {
              target.setTangents(separateVertices(tangents, 3));
            }
            const uvs = target.getUVs();
            if (uvs) {
              target.setUVs(separateVertices(uvs, 2));
            }
          }
          this.morphTargetManager.synchronize();
        }
        for (let index = 0; index < indices.length; index++) {
          indices[index] = index;
        }
        this.setIndices(indices);
        this._unIndexed = true;
        this.releaseSubMeshes();
        for (const previousOne of previousSubmeshes) {
          SubMesh.AddToMesh(previousOne.materialIndex, previousOne.indexStart, previousOne.indexCount, previousOne.indexStart, previousOne.indexCount, this);
        }
        this.synchronizeInstances();
        return this;
      }
      convertToFlatShadedMesh() {
        return this._convertToUnIndexedMesh(true);
      }
      convertToUnIndexedMesh() {
        return this._convertToUnIndexedMesh();
      }
      flipFaces(flipNormals = false) {
        const vertex_data = VertexData.ExtractFromMesh(this);
        let i;
        if (flipNormals && this.isVerticesDataPresent(VertexBuffer.NormalKind) && vertex_data.normals) {
          for (i = 0; i < vertex_data.normals.length; i++) {
            vertex_data.normals[i] *= -1;
          }
        }
        if (vertex_data.indices) {
          let temp;
          for (i = 0; i < vertex_data.indices.length; i += 3) {
            temp = vertex_data.indices[i + 1];
            vertex_data.indices[i + 1] = vertex_data.indices[i + 2];
            vertex_data.indices[i + 2] = temp;
          }
        }
        vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        return this;
      }
      increaseVertices(numberPerEdge = 1) {
        const vertex_data = VertexData.ExtractFromMesh(this);
        const currentIndices = vertex_data.indices && !Array.isArray(vertex_data.indices) && Array.from ? Array.from(vertex_data.indices) : vertex_data.indices;
        const positions = vertex_data.positions && !Array.isArray(vertex_data.positions) && Array.from ? Array.from(vertex_data.positions) : vertex_data.positions;
        const uvs = vertex_data.uvs && !Array.isArray(vertex_data.uvs) && Array.from ? Array.from(vertex_data.uvs) : vertex_data.uvs;
        const normals = vertex_data.normals && !Array.isArray(vertex_data.normals) && Array.from ? Array.from(vertex_data.normals) : vertex_data.normals;
        if (!currentIndices || !positions) {
          Logger.Warn("Couldn't increase number of vertices : VertexData must contain at least indices and positions");
        } else {
          vertex_data.indices = currentIndices;
          vertex_data.positions = positions;
          if (uvs) {
            vertex_data.uvs = uvs;
          }
          if (normals) {
            vertex_data.normals = normals;
          }
          const segments = numberPerEdge + 1;
          const tempIndices = new Array();
          for (let i = 0; i < segments + 1; i++) {
            tempIndices[i] = new Array();
          }
          let a;
          let b;
          const deltaPosition = new Vector3(0, 0, 0);
          const deltaNormal = new Vector3(0, 0, 0);
          const deltaUV = new Vector2(0, 0);
          const indices = new Array();
          const vertexIndex = new Array();
          const side = new Array();
          let len;
          let positionPtr = positions.length;
          let uvPtr;
          if (uvs) {
            uvPtr = uvs.length;
          }
          let normalsPtr;
          if (normals) {
            normalsPtr = normals.length;
          }
          for (let i = 0; i < currentIndices.length; i += 3) {
            vertexIndex[0] = currentIndices[i];
            vertexIndex[1] = currentIndices[i + 1];
            vertexIndex[2] = currentIndices[i + 2];
            for (let j = 0; j < 3; j++) {
              a = vertexIndex[j];
              b = vertexIndex[(j + 1) % 3];
              if (side[a] === void 0 && side[b] === void 0) {
                side[a] = new Array();
                side[b] = new Array();
              } else {
                if (side[a] === void 0) {
                  side[a] = new Array();
                }
                if (side[b] === void 0) {
                  side[b] = new Array();
                }
              }
              if (side[a][b] === void 0 && side[b][a] === void 0) {
                side[a][b] = [];
                deltaPosition.x = (positions[3 * b] - positions[3 * a]) / segments;
                deltaPosition.y = (positions[3 * b + 1] - positions[3 * a + 1]) / segments;
                deltaPosition.z = (positions[3 * b + 2] - positions[3 * a + 2]) / segments;
                if (normals) {
                  deltaNormal.x = (normals[3 * b] - normals[3 * a]) / segments;
                  deltaNormal.y = (normals[3 * b + 1] - normals[3 * a + 1]) / segments;
                  deltaNormal.z = (normals[3 * b + 2] - normals[3 * a + 2]) / segments;
                }
                if (uvs) {
                  deltaUV.x = (uvs[2 * b] - uvs[2 * a]) / segments;
                  deltaUV.y = (uvs[2 * b + 1] - uvs[2 * a + 1]) / segments;
                }
                side[a][b].push(a);
                for (let k = 1; k < segments; k++) {
                  side[a][b].push(positions.length / 3);
                  positions[positionPtr++] = positions[3 * a] + k * deltaPosition.x;
                  positions[positionPtr++] = positions[3 * a + 1] + k * deltaPosition.y;
                  positions[positionPtr++] = positions[3 * a + 2] + k * deltaPosition.z;
                  if (normals) {
                    normals[normalsPtr++] = normals[3 * a] + k * deltaNormal.x;
                    normals[normalsPtr++] = normals[3 * a + 1] + k * deltaNormal.y;
                    normals[normalsPtr++] = normals[3 * a + 2] + k * deltaNormal.z;
                  }
                  if (uvs) {
                    uvs[uvPtr++] = uvs[2 * a] + k * deltaUV.x;
                    uvs[uvPtr++] = uvs[2 * a + 1] + k * deltaUV.y;
                  }
                }
                side[a][b].push(b);
                side[b][a] = new Array();
                len = side[a][b].length;
                for (let idx = 0; idx < len; idx++) {
                  side[b][a][idx] = side[a][b][len - 1 - idx];
                }
              }
            }
            tempIndices[0][0] = currentIndices[i];
            tempIndices[1][0] = side[currentIndices[i]][currentIndices[i + 1]][1];
            tempIndices[1][1] = side[currentIndices[i]][currentIndices[i + 2]][1];
            for (let k = 2; k < segments; k++) {
              tempIndices[k][0] = side[currentIndices[i]][currentIndices[i + 1]][k];
              tempIndices[k][k] = side[currentIndices[i]][currentIndices[i + 2]][k];
              deltaPosition.x = (positions[3 * tempIndices[k][k]] - positions[3 * tempIndices[k][0]]) / k;
              deltaPosition.y = (positions[3 * tempIndices[k][k] + 1] - positions[3 * tempIndices[k][0] + 1]) / k;
              deltaPosition.z = (positions[3 * tempIndices[k][k] + 2] - positions[3 * tempIndices[k][0] + 2]) / k;
              if (normals) {
                deltaNormal.x = (normals[3 * tempIndices[k][k]] - normals[3 * tempIndices[k][0]]) / k;
                deltaNormal.y = (normals[3 * tempIndices[k][k] + 1] - normals[3 * tempIndices[k][0] + 1]) / k;
                deltaNormal.z = (normals[3 * tempIndices[k][k] + 2] - normals[3 * tempIndices[k][0] + 2]) / k;
              }
              if (uvs) {
                deltaUV.x = (uvs[2 * tempIndices[k][k]] - uvs[2 * tempIndices[k][0]]) / k;
                deltaUV.y = (uvs[2 * tempIndices[k][k] + 1] - uvs[2 * tempIndices[k][0] + 1]) / k;
              }
              for (let j = 1; j < k; j++) {
                tempIndices[k][j] = positions.length / 3;
                positions[positionPtr++] = positions[3 * tempIndices[k][0]] + j * deltaPosition.x;
                positions[positionPtr++] = positions[3 * tempIndices[k][0] + 1] + j * deltaPosition.y;
                positions[positionPtr++] = positions[3 * tempIndices[k][0] + 2] + j * deltaPosition.z;
                if (normals) {
                  normals[normalsPtr++] = normals[3 * tempIndices[k][0]] + j * deltaNormal.x;
                  normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 1] + j * deltaNormal.y;
                  normals[normalsPtr++] = normals[3 * tempIndices[k][0] + 2] + j * deltaNormal.z;
                }
                if (uvs) {
                  uvs[uvPtr++] = uvs[2 * tempIndices[k][0]] + j * deltaUV.x;
                  uvs[uvPtr++] = uvs[2 * tempIndices[k][0] + 1] + j * deltaUV.y;
                }
              }
            }
            tempIndices[segments] = side[currentIndices[i + 1]][currentIndices[i + 2]];
            indices.push(tempIndices[0][0], tempIndices[1][0], tempIndices[1][1]);
            for (let k = 1; k < segments; k++) {
              let j;
              for (j = 0; j < k; j++) {
                indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
                indices.push(tempIndices[k][j], tempIndices[k + 1][j + 1], tempIndices[k][j + 1]);
              }
              indices.push(tempIndices[k][j], tempIndices[k + 1][j], tempIndices[k + 1][j + 1]);
            }
          }
          vertex_data.indices = indices;
          vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        }
      }
      forceSharedVertices() {
        const vertex_data = VertexData.ExtractFromMesh(this);
        const currentUVs = vertex_data.uvs;
        const currentIndices = vertex_data.indices;
        const currentPositions = vertex_data.positions;
        const currentColors = vertex_data.colors;
        const currentMatrixIndices = vertex_data.matricesIndices;
        const currentMatrixWeights = vertex_data.matricesWeights;
        const currentMatrixIndicesExtra = vertex_data.matricesIndicesExtra;
        const currentMatrixWeightsExtra = vertex_data.matricesWeightsExtra;
        if (currentIndices === void 0 || currentPositions === void 0 || currentIndices === null || currentPositions === null) {
          Logger.Warn("VertexData contains empty entries");
        } else {
          const positions = new Array();
          const indices = new Array();
          const uvs = new Array();
          const colors = new Array();
          const matrixIndices = new Array();
          const matrixWeights = new Array();
          const matrixIndicesExtra = new Array();
          const matrixWeightsExtra = new Array();
          let pstring = new Array();
          let indexPtr = 0;
          const uniquePositions = {};
          let ptr;
          let facet;
          for (let i = 0; i < currentIndices.length; i += 3) {
            facet = [currentIndices[i], currentIndices[i + 1], currentIndices[i + 2]];
            pstring = new Array();
            for (let j = 0; j < 3; j++) {
              pstring[j] = "";
              for (let k = 0; k < 3; k++) {
                if (Math.abs(currentPositions[3 * facet[j] + k]) < 1e-8) {
                  currentPositions[3 * facet[j] + k] = 0;
                }
                pstring[j] += currentPositions[3 * facet[j] + k] + "|";
              }
            }
            if (!(pstring[0] == pstring[1] || pstring[0] == pstring[2] || pstring[1] == pstring[2])) {
              for (let j = 0; j < 3; j++) {
                ptr = uniquePositions[pstring[j]];
                if (ptr === void 0) {
                  uniquePositions[pstring[j]] = indexPtr;
                  ptr = indexPtr++;
                  for (let k = 0; k < 3; k++) {
                    positions.push(currentPositions[3 * facet[j] + k]);
                  }
                  if (currentColors !== null && currentColors !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      colors.push(currentColors[4 * facet[j] + k]);
                    }
                  }
                  if (currentUVs !== null && currentUVs !== void 0) {
                    for (let k = 0; k < 2; k++) {
                      uvs.push(currentUVs[2 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixIndices.push(currentMatrixIndices[4 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixWeights.push(currentMatrixWeights[4 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixIndicesExtra.push(currentMatrixIndicesExtra[4 * facet[j] + k]);
                    }
                  }
                  if (currentMatrixWeightsExtra !== null && currentMatrixWeightsExtra !== void 0) {
                    for (let k = 0; k < 4; k++) {
                      matrixWeightsExtra.push(currentMatrixWeightsExtra[4 * facet[j] + k]);
                    }
                  }
                }
                indices.push(ptr);
              }
            }
          }
          const normals = new Array();
          VertexData.ComputeNormals(positions, indices, normals);
          vertex_data.positions = positions;
          vertex_data.indices = indices;
          vertex_data.normals = normals;
          if (currentUVs !== null && currentUVs !== void 0) {
            vertex_data.uvs = uvs;
          }
          if (currentColors !== null && currentColors !== void 0) {
            vertex_data.colors = colors;
          }
          if (currentMatrixIndices !== null && currentMatrixIndices !== void 0) {
            vertex_data.matricesIndices = matrixIndices;
          }
          if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
            vertex_data.matricesWeights = matrixWeights;
          }
          if (currentMatrixIndicesExtra !== null && currentMatrixIndicesExtra !== void 0) {
            vertex_data.matricesIndicesExtra = matrixIndicesExtra;
          }
          if (currentMatrixWeights !== null && currentMatrixWeights !== void 0) {
            vertex_data.matricesWeightsExtra = matrixWeightsExtra;
          }
          vertex_data.applyToMesh(this, this.isVertexBufferUpdatable(VertexBuffer.PositionKind));
        }
      }
      static _instancedMeshFactory(name109, mesh) {
        throw _WarnImport("InstancedMesh");
      }
      static _PhysicsImpostorParser(scene, physicObject, jsonObject) {
        throw _WarnImport("PhysicsImpostor");
      }
      createInstance(name109) {
        return Mesh._instancedMeshFactory(name109, this);
      }
      synchronizeInstances() {
        for (let instanceIndex = 0; instanceIndex < this.instances.length; instanceIndex++) {
          const instance = this.instances[instanceIndex];
          instance._syncSubMeshes();
        }
        return this;
      }
      optimizeIndices(successCallback) {
        const indices = this.getIndices();
        const positions = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positions || !indices) {
          return this;
        }
        const vectorPositions = new Array();
        for (let pos = 0; pos < positions.length; pos = pos + 3) {
          vectorPositions.push(Vector3.FromArray(positions, pos));
        }
        const dupes = new Array();
        AsyncLoop.SyncAsyncForLoop(vectorPositions.length, 40, (iteration) => {
          const realPos = vectorPositions.length - 1 - iteration;
          const testedPosition = vectorPositions[realPos];
          for (let j = 0; j < realPos; ++j) {
            const againstPosition = vectorPositions[j];
            if (testedPosition.equals(againstPosition)) {
              dupes[realPos] = j;
              break;
            }
          }
        }, () => {
          for (let i = 0; i < indices.length; ++i) {
            indices[i] = dupes[indices[i]] || indices[i];
          }
          const originalSubMeshes = this.subMeshes.slice(0);
          this.setIndices(indices);
          this.subMeshes = originalSubMeshes;
          if (successCallback) {
            successCallback(this);
          }
        });
        return this;
      }
      serialize(serializationObject = {}) {
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getClassName();
        if (Tags && Tags.HasTags(this)) {
          serializationObject.tags = Tags.GetTags(this);
        }
        serializationObject.position = this.position.asArray();
        if (this.rotationQuaternion) {
          serializationObject.rotationQuaternion = this.rotationQuaternion.asArray();
        } else if (this.rotation) {
          serializationObject.rotation = this.rotation.asArray();
        }
        serializationObject.scaling = this.scaling.asArray();
        if (this._postMultiplyPivotMatrix) {
          serializationObject.pivotMatrix = this.getPivotMatrix().asArray();
        } else {
          serializationObject.localMatrix = this.getPivotMatrix().asArray();
        }
        serializationObject.isEnabled = this.isEnabled(false);
        serializationObject.isVisible = this.isVisible;
        serializationObject.infiniteDistance = this.infiniteDistance;
        serializationObject.pickable = this.isPickable;
        serializationObject.receiveShadows = this.receiveShadows;
        serializationObject.billboardMode = this.billboardMode;
        serializationObject.visibility = this.visibility;
        serializationObject.checkCollisions = this.checkCollisions;
        serializationObject.isBlocker = this.isBlocker;
        serializationObject.overrideMaterialSideOrientation = this.overrideMaterialSideOrientation;
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        serializationObject.isUnIndexed = this.isUnIndexed;
        const geometry = this._geometry;
        if (geometry && this.subMeshes) {
          serializationObject.geometryUniqueId = geometry.uniqueId;
          serializationObject.geometryId = geometry.id;
          serializationObject.subMeshes = [];
          for (let subIndex = 0; subIndex < this.subMeshes.length; subIndex++) {
            const subMesh = this.subMeshes[subIndex];
            serializationObject.subMeshes.push({
              materialIndex: subMesh.materialIndex,
              verticesStart: subMesh.verticesStart,
              verticesCount: subMesh.verticesCount,
              indexStart: subMesh.indexStart,
              indexCount: subMesh.indexCount
            });
          }
        }
        if (this.material) {
          if (!this.material.doNotSerialize) {
            serializationObject.materialUniqueId = this.material.uniqueId;
            serializationObject.materialId = this.material.id;
          }
        } else {
          this.material = null;
          serializationObject.materialUniqueId = this._scene.defaultMaterial.uniqueId;
          serializationObject.materialId = this._scene.defaultMaterial.id;
        }
        if (this.morphTargetManager) {
          serializationObject.morphTargetManagerId = this.morphTargetManager.uniqueId;
        }
        if (this.skeleton) {
          serializationObject.skeletonId = this.skeleton.id;
          serializationObject.numBoneInfluencers = this.numBoneInfluencers;
        }
        if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
          const impostor = this.getPhysicsImpostor();
          if (impostor) {
            serializationObject.physicsMass = impostor.getParam("mass");
            serializationObject.physicsFriction = impostor.getParam("friction");
            serializationObject.physicsRestitution = impostor.getParam("mass");
            serializationObject.physicsImpostor = impostor.type;
          }
        }
        if (this.metadata) {
          serializationObject.metadata = this.metadata;
        }
        serializationObject.instances = [];
        for (let index = 0; index < this.instances.length; index++) {
          const instance = this.instances[index];
          if (instance.doNotSerialize) {
            continue;
          }
          const serializationInstance = {
            name: instance.name,
            id: instance.id,
            isEnabled: instance.isEnabled(false),
            isVisible: instance.isVisible,
            isPickable: instance.isPickable,
            checkCollisions: instance.checkCollisions,
            position: instance.position.asArray(),
            scaling: instance.scaling.asArray()
          };
          if (instance.parent) {
            instance.parent._serializeAsParent(serializationInstance);
          }
          if (instance.rotationQuaternion) {
            serializationInstance.rotationQuaternion = instance.rotationQuaternion.asArray();
          } else if (instance.rotation) {
            serializationInstance.rotation = instance.rotation.asArray();
          }
          if (this.getScene()._getComponent(SceneComponentConstants.NAME_PHYSICSENGINE)) {
            const impostor = instance.getPhysicsImpostor();
            if (impostor) {
              serializationInstance.physicsMass = impostor.getParam("mass");
              serializationInstance.physicsFriction = impostor.getParam("friction");
              serializationInstance.physicsRestitution = impostor.getParam("mass");
              serializationInstance.physicsImpostor = impostor.type;
            }
          }
          if (instance.metadata) {
            serializationInstance.metadata = instance.metadata;
          }
          if (instance.actionManager) {
            serializationInstance.actions = instance.actionManager.serialize(instance.name);
          }
          serializationObject.instances.push(serializationInstance);
          SerializationHelper.AppendSerializedAnimations(instance, serializationInstance);
          serializationInstance.ranges = instance.serializeAnimationRanges();
        }
        if (this._thinInstanceDataStorage.instancesCount && this._thinInstanceDataStorage.matrixData) {
          serializationObject.thinInstances = {
            instancesCount: this._thinInstanceDataStorage.instancesCount,
            matrixData: Array.from(this._thinInstanceDataStorage.matrixData),
            matrixBufferSize: this._thinInstanceDataStorage.matrixBufferSize,
            enablePicking: this.thinInstanceEnablePicking
          };
          if (this._userThinInstanceBuffersStorage) {
            const userThinInstance = {
              data: {},
              sizes: {},
              strides: {}
            };
            for (const kind in this._userThinInstanceBuffersStorage.data) {
              userThinInstance.data[kind] = Array.from(this._userThinInstanceBuffersStorage.data[kind]);
              userThinInstance.sizes[kind] = this._userThinInstanceBuffersStorage.sizes[kind];
              userThinInstance.strides[kind] = this._userThinInstanceBuffersStorage.strides[kind];
            }
            serializationObject.thinInstances.userThinInstance = userThinInstance;
          }
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.layerMask = this.layerMask;
        serializationObject.alphaIndex = this.alphaIndex;
        serializationObject.hasVertexAlpha = this.hasVertexAlpha;
        serializationObject.overlayAlpha = this.overlayAlpha;
        serializationObject.overlayColor = this.overlayColor.asArray();
        serializationObject.renderOverlay = this.renderOverlay;
        serializationObject.applyFog = this.applyFog;
        if (this.actionManager) {
          serializationObject.actions = this.actionManager.serialize(this.name);
        }
        return serializationObject;
      }
      _syncGeometryWithMorphTargetManager() {
        if (!this.geometry) {
          return;
        }
        this._markSubMeshesAsAttributesDirty();
        const morphTargetManager = this._internalAbstractMeshDataInfo._morphTargetManager;
        if (morphTargetManager && morphTargetManager.vertexCount) {
          if (morphTargetManager.vertexCount !== this.getTotalVertices()) {
            Logger.Error("Mesh is incompatible with morph targets. Targets and mesh must all have the same vertices count.");
            this.morphTargetManager = null;
            return;
          }
          if (morphTargetManager.isUsingTextureForTargets) {
            return;
          }
          for (let index = 0; index < morphTargetManager.numInfluencers; index++) {
            const morphTarget = morphTargetManager.getActiveTarget(index);
            const positions = morphTarget.getPositions();
            if (!positions) {
              Logger.Error("Invalid morph target. Target must have positions.");
              return;
            }
            this.geometry.setVerticesData(VertexBuffer.PositionKind + index, positions, false, 3);
            const normals = morphTarget.getNormals();
            if (normals) {
              this.geometry.setVerticesData(VertexBuffer.NormalKind + index, normals, false, 3);
            }
            const tangents = morphTarget.getTangents();
            if (tangents) {
              this.geometry.setVerticesData(VertexBuffer.TangentKind + index, tangents, false, 3);
            }
            const uvs = morphTarget.getUVs();
            if (uvs) {
              this.geometry.setVerticesData(VertexBuffer.UVKind + "_" + index, uvs, false, 2);
            }
          }
        } else {
          let index = 0;
          while (this.geometry.isVerticesDataPresent(VertexBuffer.PositionKind + index)) {
            this.geometry.removeVerticesData(VertexBuffer.PositionKind + index);
            if (this.geometry.isVerticesDataPresent(VertexBuffer.NormalKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.NormalKind + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.TangentKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.TangentKind + index);
            }
            if (this.geometry.isVerticesDataPresent(VertexBuffer.UVKind + index)) {
              this.geometry.removeVerticesData(VertexBuffer.UVKind + "_" + index);
            }
            index++;
          }
        }
      }
      static Parse(parsedMesh, scene, rootUrl) {
        let mesh;
        if (parsedMesh.type && parsedMesh.type === "LinesMesh") {
          mesh = Mesh._LinesMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GroundMesh") {
          mesh = Mesh._GroundMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GoldbergMesh") {
          mesh = Mesh._GoldbergMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "GreasedLineMesh") {
          mesh = Mesh._GreasedLineMeshParser(parsedMesh, scene);
        } else if (parsedMesh.type && parsedMesh.type === "TrailMesh") {
          mesh = Mesh._TrailMeshParser(parsedMesh, scene);
        } else {
          mesh = new Mesh(parsedMesh.name, scene);
        }
        mesh.id = parsedMesh.id;
        mesh._waitingParsedUniqueId = parsedMesh.uniqueId;
        if (Tags) {
          Tags.AddTagsTo(mesh, parsedMesh.tags);
        }
        mesh.position = Vector3.FromArray(parsedMesh.position);
        if (parsedMesh.metadata !== void 0) {
          mesh.metadata = parsedMesh.metadata;
        }
        if (parsedMesh.rotationQuaternion) {
          mesh.rotationQuaternion = Quaternion.FromArray(parsedMesh.rotationQuaternion);
        } else if (parsedMesh.rotation) {
          mesh.rotation = Vector3.FromArray(parsedMesh.rotation);
        }
        mesh.scaling = Vector3.FromArray(parsedMesh.scaling);
        if (parsedMesh.localMatrix) {
          mesh.setPreTransformMatrix(Matrix.FromArray(parsedMesh.localMatrix));
        } else if (parsedMesh.pivotMatrix) {
          mesh.setPivotMatrix(Matrix.FromArray(parsedMesh.pivotMatrix));
        }
        mesh.setEnabled(parsedMesh.isEnabled);
        mesh.isVisible = parsedMesh.isVisible;
        mesh.infiniteDistance = parsedMesh.infiniteDistance;
        mesh.showBoundingBox = parsedMesh.showBoundingBox;
        mesh.showSubMeshesBoundingBox = parsedMesh.showSubMeshesBoundingBox;
        if (parsedMesh.applyFog !== void 0) {
          mesh.applyFog = parsedMesh.applyFog;
        }
        if (parsedMesh.pickable !== void 0) {
          mesh.isPickable = parsedMesh.pickable;
        }
        if (parsedMesh.alphaIndex !== void 0) {
          mesh.alphaIndex = parsedMesh.alphaIndex;
        }
        mesh.receiveShadows = parsedMesh.receiveShadows;
        if (parsedMesh.billboardMode !== void 0) {
          mesh.billboardMode = parsedMesh.billboardMode;
        }
        if (parsedMesh.visibility !== void 0) {
          mesh.visibility = parsedMesh.visibility;
        }
        mesh.checkCollisions = parsedMesh.checkCollisions;
        mesh.overrideMaterialSideOrientation = parsedMesh.overrideMaterialSideOrientation;
        if (parsedMesh.isBlocker !== void 0) {
          mesh.isBlocker = parsedMesh.isBlocker;
        }
        mesh._shouldGenerateFlatShading = parsedMesh.useFlatShading;
        if (parsedMesh.freezeWorldMatrix) {
          mesh._waitingData.freezeWorldMatrix = parsedMesh.freezeWorldMatrix;
        }
        if (parsedMesh.parentId !== void 0) {
          mesh._waitingParentId = parsedMesh.parentId;
        }
        if (parsedMesh.parentInstanceIndex !== void 0) {
          mesh._waitingParentInstanceIndex = parsedMesh.parentInstanceIndex;
        }
        if (parsedMesh.actions !== void 0) {
          mesh._waitingData.actions = parsedMesh.actions;
        }
        if (parsedMesh.overlayAlpha !== void 0) {
          mesh.overlayAlpha = parsedMesh.overlayAlpha;
        }
        if (parsedMesh.overlayColor !== void 0) {
          mesh.overlayColor = Color3.FromArray(parsedMesh.overlayColor);
        }
        if (parsedMesh.renderOverlay !== void 0) {
          mesh.renderOverlay = parsedMesh.renderOverlay;
        }
        mesh.isUnIndexed = !!parsedMesh.isUnIndexed;
        mesh.hasVertexAlpha = parsedMesh.hasVertexAlpha;
        if (parsedMesh.delayLoadingFile) {
          mesh.delayLoadState = 4;
          mesh.delayLoadingFile = rootUrl + parsedMesh.delayLoadingFile;
          mesh.buildBoundingInfo(Vector3.FromArray(parsedMesh.boundingBoxMinimum), Vector3.FromArray(parsedMesh.boundingBoxMaximum));
          if (parsedMesh._binaryInfo) {
            mesh._binaryInfo = parsedMesh._binaryInfo;
          }
          mesh._delayInfo = [];
          if (parsedMesh.hasUVs) {
            mesh._delayInfo.push(VertexBuffer.UVKind);
          }
          if (parsedMesh.hasUVs2) {
            mesh._delayInfo.push(VertexBuffer.UV2Kind);
          }
          if (parsedMesh.hasUVs3) {
            mesh._delayInfo.push(VertexBuffer.UV3Kind);
          }
          if (parsedMesh.hasUVs4) {
            mesh._delayInfo.push(VertexBuffer.UV4Kind);
          }
          if (parsedMesh.hasUVs5) {
            mesh._delayInfo.push(VertexBuffer.UV5Kind);
          }
          if (parsedMesh.hasUVs6) {
            mesh._delayInfo.push(VertexBuffer.UV6Kind);
          }
          if (parsedMesh.hasColors) {
            mesh._delayInfo.push(VertexBuffer.ColorKind);
          }
          if (parsedMesh.hasMatricesIndices) {
            mesh._delayInfo.push(VertexBuffer.MatricesIndicesKind);
          }
          if (parsedMesh.hasMatricesWeights) {
            mesh._delayInfo.push(VertexBuffer.MatricesWeightsKind);
          }
          mesh._delayLoadingFunction = Geometry._ImportGeometry;
          if (SceneLoaderFlags.ForceFullSceneLoadingForIncremental) {
            mesh._checkDelayState();
          }
        } else {
          Geometry._ImportGeometry(parsedMesh, mesh);
        }
        if (parsedMesh.materialUniqueId) {
          mesh._waitingMaterialId = parsedMesh.materialUniqueId;
        } else if (parsedMesh.materialId) {
          mesh._waitingMaterialId = parsedMesh.materialId;
        }
        if (parsedMesh.morphTargetManagerId > -1) {
          mesh.morphTargetManager = scene.getMorphTargetManagerById(parsedMesh.morphTargetManagerId);
        }
        if (parsedMesh.skeletonId !== void 0 && parsedMesh.skeletonId !== null) {
          mesh.skeleton = scene.getLastSkeletonById(parsedMesh.skeletonId);
          if (parsedMesh.numBoneInfluencers) {
            mesh.numBoneInfluencers = parsedMesh.numBoneInfluencers;
          }
        }
        if (parsedMesh.animations) {
          for (let animationIndex = 0; animationIndex < parsedMesh.animations.length; animationIndex++) {
            const parsedAnimation = parsedMesh.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              mesh.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(mesh, parsedMesh, scene);
        }
        if (parsedMesh.autoAnimate) {
          scene.beginAnimation(mesh, parsedMesh.autoAnimateFrom, parsedMesh.autoAnimateTo, parsedMesh.autoAnimateLoop, parsedMesh.autoAnimateSpeed || 1);
        }
        if (parsedMesh.layerMask && !isNaN(parsedMesh.layerMask)) {
          mesh.layerMask = Math.abs(parseInt(parsedMesh.layerMask));
        } else {
          mesh.layerMask = 268435455;
        }
        if (parsedMesh.physicsImpostor) {
          Mesh._PhysicsImpostorParser(scene, mesh, parsedMesh);
        }
        if (parsedMesh.lodMeshIds) {
          mesh._waitingData.lods = {
            ids: parsedMesh.lodMeshIds,
            distances: parsedMesh.lodDistances ? parsedMesh.lodDistances : null,
            coverages: parsedMesh.lodCoverages ? parsedMesh.lodCoverages : null
          };
        }
        if (parsedMesh.instances) {
          for (let index = 0; index < parsedMesh.instances.length; index++) {
            const parsedInstance = parsedMesh.instances[index];
            const instance = mesh.createInstance(parsedInstance.name);
            if (parsedInstance.id) {
              instance.id = parsedInstance.id;
            }
            if (Tags) {
              if (parsedInstance.tags) {
                Tags.AddTagsTo(instance, parsedInstance.tags);
              } else {
                Tags.AddTagsTo(instance, parsedMesh.tags);
              }
            }
            instance.position = Vector3.FromArray(parsedInstance.position);
            if (parsedInstance.metadata !== void 0) {
              instance.metadata = parsedInstance.metadata;
            }
            if (parsedInstance.parentId !== void 0) {
              instance._waitingParentId = parsedInstance.parentId;
            }
            if (parsedInstance.parentInstanceIndex !== void 0) {
              instance._waitingParentInstanceIndex = parsedInstance.parentInstanceIndex;
            }
            if (parsedInstance.isEnabled !== void 0 && parsedInstance.isEnabled !== null) {
              instance.setEnabled(parsedInstance.isEnabled);
            }
            if (parsedInstance.isVisible !== void 0 && parsedInstance.isVisible !== null) {
              instance.isVisible = parsedInstance.isVisible;
            }
            if (parsedInstance.isPickable !== void 0 && parsedInstance.isPickable !== null) {
              instance.isPickable = parsedInstance.isPickable;
            }
            if (parsedInstance.rotationQuaternion) {
              instance.rotationQuaternion = Quaternion.FromArray(parsedInstance.rotationQuaternion);
            } else if (parsedInstance.rotation) {
              instance.rotation = Vector3.FromArray(parsedInstance.rotation);
            }
            instance.scaling = Vector3.FromArray(parsedInstance.scaling);
            if (parsedInstance.checkCollisions != void 0 && parsedInstance.checkCollisions != null) {
              instance.checkCollisions = parsedInstance.checkCollisions;
            }
            if (parsedInstance.pickable != void 0 && parsedInstance.pickable != null) {
              instance.isPickable = parsedInstance.pickable;
            }
            if (parsedInstance.showBoundingBox != void 0 && parsedInstance.showBoundingBox != null) {
              instance.showBoundingBox = parsedInstance.showBoundingBox;
            }
            if (parsedInstance.showSubMeshesBoundingBox != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
              instance.showSubMeshesBoundingBox = parsedInstance.showSubMeshesBoundingBox;
            }
            if (parsedInstance.alphaIndex != void 0 && parsedInstance.showSubMeshesBoundingBox != null) {
              instance.alphaIndex = parsedInstance.alphaIndex;
            }
            if (parsedInstance.physicsImpostor) {
              Mesh._PhysicsImpostorParser(scene, instance, parsedInstance);
            }
            if (parsedInstance.actions !== void 0) {
              instance._waitingData.actions = parsedInstance.actions;
            }
            if (parsedInstance.animations) {
              for (let animationIndex = 0; animationIndex < parsedInstance.animations.length; animationIndex++) {
                const parsedAnimation = parsedInstance.animations[animationIndex];
                const internalClass = GetClass("BABYLON.Animation");
                if (internalClass) {
                  instance.animations.push(internalClass.Parse(parsedAnimation));
                }
              }
              Node.ParseAnimationRanges(instance, parsedInstance, scene);
              if (parsedInstance.autoAnimate) {
                scene.beginAnimation(instance, parsedInstance.autoAnimateFrom, parsedInstance.autoAnimateTo, parsedInstance.autoAnimateLoop, parsedInstance.autoAnimateSpeed || 1);
              }
            }
          }
        }
        if (parsedMesh.thinInstances) {
          const thinInstances = parsedMesh.thinInstances;
          mesh.thinInstanceEnablePicking = !!thinInstances.enablePicking;
          if (thinInstances.matrixData) {
            mesh.thinInstanceSetBuffer("matrix", new Float32Array(thinInstances.matrixData), 16, false);
            mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
            mesh._thinInstanceDataStorage.instancesCount = thinInstances.instancesCount;
          } else {
            mesh._thinInstanceDataStorage.matrixBufferSize = thinInstances.matrixBufferSize;
          }
          if (parsedMesh.thinInstances.userThinInstance) {
            const userThinInstance = parsedMesh.thinInstances.userThinInstance;
            for (const kind in userThinInstance.data) {
              mesh.thinInstanceSetBuffer(kind, new Float32Array(userThinInstance.data[kind]), userThinInstance.strides[kind], false);
              mesh._userThinInstanceBuffersStorage.sizes[kind] = userThinInstance.sizes[kind];
            }
          }
        }
        return mesh;
      }
      setPositionsForCPUSkinning() {
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourcePositions) {
          const source = this.getVerticesData(VertexBuffer.PositionKind);
          if (!source) {
            return internalDataInfo._sourcePositions;
          }
          internalDataInfo._sourcePositions = new Float32Array(source);
          if (!this.isVertexBufferUpdatable(VertexBuffer.PositionKind)) {
            this.setVerticesData(VertexBuffer.PositionKind, source, true);
          }
        }
        return internalDataInfo._sourcePositions;
      }
      setNormalsForCPUSkinning() {
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourceNormals) {
          const source = this.getVerticesData(VertexBuffer.NormalKind);
          if (!source) {
            return internalDataInfo._sourceNormals;
          }
          internalDataInfo._sourceNormals = new Float32Array(source);
          if (!this.isVertexBufferUpdatable(VertexBuffer.NormalKind)) {
            this.setVerticesData(VertexBuffer.NormalKind, source, true);
          }
        }
        return internalDataInfo._sourceNormals;
      }
      applySkeleton(skeleton) {
        if (!this.geometry) {
          return this;
        }
        if (this.geometry._softwareSkinningFrameId == this.getScene().getFrameId()) {
          return this;
        }
        this.geometry._softwareSkinningFrameId = this.getScene().getFrameId();
        if (!this.isVerticesDataPresent(VertexBuffer.PositionKind)) {
          return this;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.MatricesIndicesKind)) {
          return this;
        }
        if (!this.isVerticesDataPresent(VertexBuffer.MatricesWeightsKind)) {
          return this;
        }
        const hasNormals = this.isVerticesDataPresent(VertexBuffer.NormalKind);
        const internalDataInfo = this._internalMeshDataInfo;
        if (!internalDataInfo._sourcePositions) {
          const submeshes = this.subMeshes.slice();
          this.setPositionsForCPUSkinning();
          this.subMeshes = submeshes;
        }
        if (hasNormals && !internalDataInfo._sourceNormals) {
          this.setNormalsForCPUSkinning();
        }
        let positionsData = this.getVerticesData(VertexBuffer.PositionKind);
        if (!positionsData) {
          return this;
        }
        if (!(positionsData instanceof Float32Array)) {
          positionsData = new Float32Array(positionsData);
        }
        let normalsData = this.getVerticesData(VertexBuffer.NormalKind);
        if (hasNormals) {
          if (!normalsData) {
            return this;
          }
          if (!(normalsData instanceof Float32Array)) {
            normalsData = new Float32Array(normalsData);
          }
        }
        const matricesIndicesData = this.getVerticesData(VertexBuffer.MatricesIndicesKind);
        const matricesWeightsData = this.getVerticesData(VertexBuffer.MatricesWeightsKind);
        if (!matricesWeightsData || !matricesIndicesData) {
          return this;
        }
        const needExtras = this.numBoneInfluencers > 4;
        const matricesIndicesExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesIndicesExtraKind) : null;
        const matricesWeightsExtraData = needExtras ? this.getVerticesData(VertexBuffer.MatricesWeightsExtraKind) : null;
        const skeletonMatrices = skeleton.getTransformMatrices(this);
        const tempVector3 = Vector3.Zero();
        const finalMatrix = new Matrix();
        const tempMatrix = new Matrix();
        let matWeightIdx = 0;
        let inf;
        for (let index = 0; index < positionsData.length; index += 3, matWeightIdx += 4) {
          let weight;
          for (inf = 0; inf < 4; inf++) {
            weight = matricesWeightsData[matWeightIdx + inf];
            if (weight > 0) {
              Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesData[matWeightIdx + inf] * 16), weight, tempMatrix);
              finalMatrix.addToSelf(tempMatrix);
            }
          }
          if (needExtras) {
            for (inf = 0; inf < 4; inf++) {
              weight = matricesWeightsExtraData[matWeightIdx + inf];
              if (weight > 0) {
                Matrix.FromFloat32ArrayToRefScaled(skeletonMatrices, Math.floor(matricesIndicesExtraData[matWeightIdx + inf] * 16), weight, tempMatrix);
                finalMatrix.addToSelf(tempMatrix);
              }
            }
          }
          Vector3.TransformCoordinatesFromFloatsToRef(internalDataInfo._sourcePositions[index], internalDataInfo._sourcePositions[index + 1], internalDataInfo._sourcePositions[index + 2], finalMatrix, tempVector3);
          tempVector3.toArray(positionsData, index);
          if (hasNormals) {
            Vector3.TransformNormalFromFloatsToRef(internalDataInfo._sourceNormals[index], internalDataInfo._sourceNormals[index + 1], internalDataInfo._sourceNormals[index + 2], finalMatrix, tempVector3);
            tempVector3.toArray(normalsData, index);
          }
          finalMatrix.reset();
        }
        this.updateVerticesData(VertexBuffer.PositionKind, positionsData);
        if (hasNormals) {
          this.updateVerticesData(VertexBuffer.NormalKind, normalsData);
        }
        return this;
      }
      static MinMax(meshes) {
        let minVector = null;
        let maxVector = null;
        meshes.forEach(function(mesh) {
          const boundingInfo = mesh.getBoundingInfo();
          const boundingBox = boundingInfo.boundingBox;
          if (!minVector || !maxVector) {
            minVector = boundingBox.minimumWorld;
            maxVector = boundingBox.maximumWorld;
          } else {
            minVector.minimizeInPlace(boundingBox.minimumWorld);
            maxVector.maximizeInPlace(boundingBox.maximumWorld);
          }
        });
        if (!minVector || !maxVector) {
          return {
            min: Vector3.Zero(),
            max: Vector3.Zero()
          };
        }
        return {
          min: minVector,
          max: maxVector
        };
      }
      static Center(meshesOrMinMaxVector) {
        const minMaxVector = meshesOrMinMaxVector instanceof Array ? Mesh.MinMax(meshesOrMinMaxVector) : meshesOrMinMaxVector;
        return Vector3.Center(minMaxVector.min, minMaxVector.max);
      }
      static MergeMeshes(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
        return runCoroutineSync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, false));
      }
      static MergeMeshesAsync(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials) {
        return runCoroutineAsync(Mesh._MergeMeshesCoroutine(meshes, disposeSource, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, true), createYieldingScheduler());
      }
      static *_MergeMeshesCoroutine(meshes, disposeSource = true, allow32BitsIndices, meshSubclass, subdivideWithSubMeshes, multiMultiMaterials, isAsync) {
        meshes = meshes.filter(Boolean);
        if (meshes.length === 0) {
          return null;
        }
        let index;
        if (!allow32BitsIndices) {
          let totalVertices = 0;
          for (index = 0; index < meshes.length; index++) {
            totalVertices += meshes[index].getTotalVertices();
            if (totalVertices >= 65536) {
              Logger.Warn("Cannot merge meshes because resulting mesh will have more than 65536 vertices. Please use allow32BitsIndices = true to use 32 bits indices");
              return null;
            }
          }
        }
        if (multiMultiMaterials) {
          subdivideWithSubMeshes = false;
        }
        const materialArray = new Array();
        const materialIndexArray = new Array();
        const indiceArray = new Array();
        const currentOverrideMaterialSideOrientation = meshes[0].overrideMaterialSideOrientation;
        for (index = 0; index < meshes.length; index++) {
          const mesh = meshes[index];
          if (mesh.isAnInstance) {
            Logger.Warn("Cannot merge instance meshes.");
            return null;
          }
          if (currentOverrideMaterialSideOrientation !== mesh.overrideMaterialSideOrientation) {
            Logger.Warn("Cannot merge meshes with different overrideMaterialSideOrientation values.");
            return null;
          }
          if (subdivideWithSubMeshes) {
            indiceArray.push(mesh.getTotalIndices());
          }
          if (multiMultiMaterials) {
            if (mesh.material) {
              const material = mesh.material;
              if (material instanceof MultiMaterial) {
                for (let matIndex = 0; matIndex < material.subMaterials.length; matIndex++) {
                  if (materialArray.indexOf(material.subMaterials[matIndex]) < 0) {
                    materialArray.push(material.subMaterials[matIndex]);
                  }
                }
                for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                  materialIndexArray.push(materialArray.indexOf(material.subMaterials[mesh.subMeshes[subIndex].materialIndex]));
                  indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                }
              } else {
                if (materialArray.indexOf(material) < 0) {
                  materialArray.push(material);
                }
                for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                  materialIndexArray.push(materialArray.indexOf(material));
                  indiceArray.push(mesh.subMeshes[subIndex].indexCount);
                }
              }
            } else {
              for (let subIndex = 0; subIndex < mesh.subMeshes.length; subIndex++) {
                materialIndexArray.push(0);
                indiceArray.push(mesh.subMeshes[subIndex].indexCount);
              }
            }
          }
        }
        const source = meshes[0];
        const getVertexDataFromMesh = (mesh) => {
          const wm = mesh.computeWorldMatrix(true);
          const vertexData2 = VertexData.ExtractFromMesh(mesh, false, false);
          return { vertexData: vertexData2, transform: wm };
        };
        const { vertexData: sourceVertexData, transform: sourceTransform } = getVertexDataFromMesh(source);
        if (isAsync) {
          yield;
        }
        const meshVertexDatas = new Array(meshes.length - 1);
        for (let i = 1; i < meshes.length; i++) {
          meshVertexDatas[i - 1] = getVertexDataFromMesh(meshes[i]);
          if (isAsync) {
            yield;
          }
        }
        const mergeCoroutine = sourceVertexData._mergeCoroutine(sourceTransform, meshVertexDatas, allow32BitsIndices, isAsync, !disposeSource);
        let mergeCoroutineStep = mergeCoroutine.next();
        while (!mergeCoroutineStep.done) {
          if (isAsync) {
            yield;
          }
          mergeCoroutineStep = mergeCoroutine.next();
        }
        const vertexData = mergeCoroutineStep.value;
        if (!meshSubclass) {
          meshSubclass = new Mesh(source.name + "_merged", source.getScene());
        }
        const applyToCoroutine = vertexData._applyToCoroutine(meshSubclass, void 0, isAsync);
        let applyToCoroutineStep = applyToCoroutine.next();
        while (!applyToCoroutineStep.done) {
          if (isAsync) {
            yield;
          }
          applyToCoroutineStep = applyToCoroutine.next();
        }
        meshSubclass.checkCollisions = source.checkCollisions;
        meshSubclass.overrideMaterialSideOrientation = source.overrideMaterialSideOrientation;
        if (disposeSource) {
          for (index = 0; index < meshes.length; index++) {
            meshes[index].dispose();
          }
        }
        if (subdivideWithSubMeshes || multiMultiMaterials) {
          meshSubclass.releaseSubMeshes();
          index = 0;
          let offset = 0;
          while (index < indiceArray.length) {
            SubMesh.CreateFromIndices(0, offset, indiceArray[index], meshSubclass, void 0, false);
            offset += indiceArray[index];
            index++;
          }
          for (const subMesh of meshSubclass.subMeshes) {
            subMesh.refreshBoundingInfo();
          }
          meshSubclass.computeWorldMatrix(true);
        }
        if (multiMultiMaterials) {
          const newMultiMaterial = new MultiMaterial(source.name + "_merged", source.getScene());
          newMultiMaterial.subMaterials = materialArray;
          for (let subIndex = 0; subIndex < meshSubclass.subMeshes.length; subIndex++) {
            meshSubclass.subMeshes[subIndex].materialIndex = materialIndexArray[subIndex];
          }
          meshSubclass.material = newMultiMaterial;
        } else {
          meshSubclass.material = source.material;
        }
        return meshSubclass;
      }
      addInstance(instance) {
        instance._indexInSourceMeshInstanceArray = this.instances.length;
        this.instances.push(instance);
      }
      removeInstance(instance) {
        const index = instance._indexInSourceMeshInstanceArray;
        if (index != -1) {
          if (index !== this.instances.length - 1) {
            const last = this.instances[this.instances.length - 1];
            this.instances[index] = last;
            last._indexInSourceMeshInstanceArray = index;
          }
          instance._indexInSourceMeshInstanceArray = -1;
          this.instances.pop();
        }
      }
      _shouldConvertRHS() {
        return this.overrideMaterialSideOrientation === Material.CounterClockWiseSideOrientation;
      }
      _getRenderingFillMode(fillMode) {
        var _a;
        const scene = this.getScene();
        if (scene.forcePointsCloud)
          return Material.PointFillMode;
        if (scene.forceWireframe)
          return Material.WireFrameFillMode;
        return (_a = this.overrideRenderingFillMode) !== null && _a !== void 0 ? _a : fillMode;
      }
      setMaterialByID(id) {
        return this.setMaterialById(id);
      }
      static CreateRibbon(name109, pathArray, closeArray, closePath, offset, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateDisc(name109, radius, tessellation, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateBox(name109, size, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateSphere(name109, segments, diameter, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateHemisphere(name109, segments, diameter, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateCylinder(name109, height, diameterTop, diameterBottom, tessellation, subdivisions, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateTorus(name109, diameter, thickness, tessellation, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateTorusKnot(name109, radius, tube, radialSegments, tubularSegments, p, q, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateLines(name109, points, scene, updatable, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateDashedLines(name109, points, dashSize, gapSize, dashNb, scene, updatable, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreatePolygon(name109, shape, scene, holes, updatable, sideOrientation, earcutInjection) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static ExtrudePolygon(name109, shape, depth, scene, holes, updatable, sideOrientation, earcutInjection) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static ExtrudeShape(name109, shape, path, scale, rotation, cap, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static ExtrudeShapeCustom(name109, shape, path, scaleFunction, rotationFunction, ribbonCloseArray, ribbonClosePath, cap, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateLathe(name109, shape, radius, tessellation, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreatePlane(name109, size, scene, updatable, sideOrientation) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateGround(name109, width, height, subdivisions, scene, updatable) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateTiledGround(name109, xmin, zmin, xmax, zmax, subdivisions, precision, scene, updatable) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateGroundFromHeightMap(name109, url, width, height, subdivisions, minHeight, maxHeight, scene, updatable, onReady, alphaFilter) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateTube(name109, path, radius, tessellation, radiusFunction, cap, scene, updatable, sideOrientation, instance) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreatePolyhedron(name109, options, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateIcoSphere(name109, options, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateDecal(name109, sourceMesh, position, normal, size, angle) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static CreateCapsule(name109, options, scene) {
        throw new Error("Import MeshBuilder to populate this function");
      }
      static ExtendToGoldberg(mesh) {
        throw new Error("Import MeshBuilder to populate this function");
      }
    };
    Mesh.FRONTSIDE = VertexData.FRONTSIDE;
    Mesh.BACKSIDE = VertexData.BACKSIDE;
    Mesh.DOUBLESIDE = VertexData.DOUBLESIDE;
    Mesh.DEFAULTSIDE = VertexData.DEFAULTSIDE;
    Mesh.NO_CAP = 0;
    Mesh.CAP_START = 1;
    Mesh.CAP_END = 2;
    Mesh.CAP_ALL = 3;
    Mesh.NO_FLIP = 0;
    Mesh.FLIP_TILE = 1;
    Mesh.ROTATE_TILE = 2;
    Mesh.FLIP_ROW = 3;
    Mesh.ROTATE_ROW = 4;
    Mesh.FLIP_N_ROTATE_TILE = 5;
    Mesh.FLIP_N_ROTATE_ROW = 6;
    Mesh.CENTER = 0;
    Mesh.LEFT = 1;
    Mesh.RIGHT = 2;
    Mesh.TOP = 3;
    Mesh.BOTTOM = 4;
    Mesh.INSTANCEDMESH_SORT_TRANSPARENT = false;
    Mesh._GroundMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GroundMesh");
    };
    Mesh._GoldbergMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GoldbergMesh");
    };
    Mesh._LinesMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("LinesMesh");
    };
    Mesh._GreasedLineMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("GreasedLineMesh");
    };
    Mesh._TrailMeshParser = (parsedMesh, scene) => {
      throw _WarnImport("TrailMesh");
    };
    RegisterClass("BABYLON.Mesh", Mesh);
  }
});

// node_modules/@babylonjs/core/Meshes/instancedMesh.js
var InstancedMesh;
var init_instancedMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/instancedMesh.js"() {
    init_math_vector();
    init_logger();
    init_abstractMesh();
    init_mesh();
    init_deepCopier();
    init_transformNode();
    init_buffer();
    init_tools();
    Mesh._instancedMeshFactory = (name109, mesh) => {
      const instance = new InstancedMesh(name109, mesh);
      if (mesh.instancedBuffers) {
        instance.instancedBuffers = {};
        for (const key in mesh.instancedBuffers) {
          instance.instancedBuffers[key] = mesh.instancedBuffers[key];
        }
      }
      return instance;
    };
    InstancedMesh = class extends AbstractMesh {
      constructor(name109, source) {
        super(name109, source.getScene());
        this._indexInSourceMeshInstanceArray = -1;
        this._distanceToCamera = 0;
        source.addInstance(this);
        this._sourceMesh = source;
        this._unIndexed = source._unIndexed;
        this.position.copyFrom(source.position);
        this.rotation.copyFrom(source.rotation);
        this.scaling.copyFrom(source.scaling);
        if (source.rotationQuaternion) {
          this.rotationQuaternion = source.rotationQuaternion.clone();
        }
        this.animations = source.animations.slice();
        for (const range of source.getAnimationRanges()) {
          if (range != null) {
            this.createAnimationRange(range.name, range.from, range.to);
          }
        }
        this.infiniteDistance = source.infiniteDistance;
        this.setPivotMatrix(source.getPivotMatrix());
        this.refreshBoundingInfo(true, true);
        this._syncSubMeshes();
      }
      getClassName() {
        return "InstancedMesh";
      }
      get lightSources() {
        return this._sourceMesh._lightSources;
      }
      _resyncLightSources() {
      }
      _resyncLightSource() {
      }
      _removeLightSource() {
      }
      get receiveShadows() {
        return this._sourceMesh.receiveShadows;
      }
      set receiveShadows(_value) {
        var _a;
        if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.receiveShadows) !== _value) {
          Tools.Warn("Setting receiveShadows on an instanced mesh has no effect");
        }
      }
      get material() {
        return this._sourceMesh.material;
      }
      set material(_value) {
        var _a;
        if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.material) !== _value) {
          Tools.Warn("Setting material on an instanced mesh has no effect");
        }
      }
      get visibility() {
        return this._sourceMesh.visibility;
      }
      set visibility(_value) {
        var _a;
        if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.visibility) !== _value) {
          Tools.Warn("Setting visibility on an instanced mesh has no effect");
        }
      }
      get skeleton() {
        return this._sourceMesh.skeleton;
      }
      set skeleton(_value) {
        var _a;
        if (((_a = this._sourceMesh) === null || _a === void 0 ? void 0 : _a.skeleton) !== _value) {
          Tools.Warn("Setting skeleton on an instanced mesh has no effect");
        }
      }
      get renderingGroupId() {
        return this._sourceMesh.renderingGroupId;
      }
      set renderingGroupId(value) {
        if (!this._sourceMesh || value === this._sourceMesh.renderingGroupId) {
          return;
        }
        Logger.Warn("Note - setting renderingGroupId of an instanced mesh has no effect on the scene");
      }
      getTotalVertices() {
        return this._sourceMesh ? this._sourceMesh.getTotalVertices() : 0;
      }
      getTotalIndices() {
        return this._sourceMesh.getTotalIndices();
      }
      get sourceMesh() {
        return this._sourceMesh;
      }
      createInstance(name109) {
        return this._sourceMesh.createInstance(name109);
      }
      isReady(completeCheck = false) {
        return this._sourceMesh.isReady(completeCheck, true);
      }
      getVerticesData(kind, copyWhenShared, forceCopy) {
        return this._sourceMesh.getVerticesData(kind, copyWhenShared, forceCopy);
      }
      setVerticesData(kind, data, updatable, stride) {
        if (this.sourceMesh) {
          this.sourceMesh.setVerticesData(kind, data, updatable, stride);
        }
        return this.sourceMesh;
      }
      updateVerticesData(kind, data, updateExtends, makeItUnique) {
        if (this.sourceMesh) {
          this.sourceMesh.updateVerticesData(kind, data, updateExtends, makeItUnique);
        }
        return this.sourceMesh;
      }
      setIndices(indices, totalVertices = null) {
        if (this.sourceMesh) {
          this.sourceMesh.setIndices(indices, totalVertices);
        }
        return this.sourceMesh;
      }
      isVerticesDataPresent(kind) {
        return this._sourceMesh.isVerticesDataPresent(kind);
      }
      getIndices() {
        return this._sourceMesh.getIndices();
      }
      get _positions() {
        return this._sourceMesh._positions;
      }
      refreshBoundingInfo(applySkeleton = false, applyMorph = false) {
        if (this.hasBoundingInfo && this.getBoundingInfo().isLocked) {
          return this;
        }
        const bias = this._sourceMesh.geometry ? this._sourceMesh.geometry.boundingBias : null;
        this._refreshBoundingInfo(this._sourceMesh._getPositionData(applySkeleton, applyMorph), bias);
        return this;
      }
      _preActivate() {
        if (this._currentLOD) {
          this._currentLOD._preActivate();
        }
        return this;
      }
      _activate(renderId, intermediateRendering) {
        super._activate(renderId, intermediateRendering);
        if (!this._sourceMesh.subMeshes) {
          Logger.Warn("Instances should only be created for meshes with geometry.");
        }
        if (this._currentLOD) {
          const differentSign = this._currentLOD._getWorldMatrixDeterminant() >= 0 !== this._getWorldMatrixDeterminant() >= 0;
          if (differentSign) {
            this._internalAbstractMeshDataInfo._actAsRegularMesh = true;
            return true;
          }
          this._internalAbstractMeshDataInfo._actAsRegularMesh = false;
          this._currentLOD._registerInstanceForRenderId(this, renderId);
          if (intermediateRendering) {
            if (!this._currentLOD._internalAbstractMeshDataInfo._isActiveIntermediate) {
              this._currentLOD._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = true;
              return true;
            }
          } else {
            if (!this._currentLOD._internalAbstractMeshDataInfo._isActive) {
              this._currentLOD._internalAbstractMeshDataInfo._onlyForInstances = true;
              return true;
            }
          }
        }
        return false;
      }
      _postActivate() {
        if (this._sourceMesh.edgesShareWithInstances && this._sourceMesh._edgesRenderer && this._sourceMesh._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
          this._sourceMesh._renderingGroup._edgesRenderers.pushNoDuplicate(this._sourceMesh._edgesRenderer);
          this._sourceMesh._edgesRenderer.customInstances.push(this.getWorldMatrix());
        } else if (this._edgesRenderer && this._edgesRenderer.isEnabled && this._sourceMesh._renderingGroup) {
          this._sourceMesh._renderingGroup._edgesRenderers.push(this._edgesRenderer);
        }
      }
      getWorldMatrix() {
        if (this._currentLOD && this._currentLOD.billboardMode !== TransformNode.BILLBOARDMODE_NONE && this._currentLOD._masterMesh !== this) {
          if (!this._billboardWorldMatrix) {
            this._billboardWorldMatrix = new Matrix();
          }
          const tempMaster = this._currentLOD._masterMesh;
          this._currentLOD._masterMesh = this;
          TmpVectors.Vector3[7].copyFrom(this._currentLOD.position);
          this._currentLOD.position.set(0, 0, 0);
          this._billboardWorldMatrix.copyFrom(this._currentLOD.computeWorldMatrix(true));
          this._currentLOD.position.copyFrom(TmpVectors.Vector3[7]);
          this._currentLOD._masterMesh = tempMaster;
          return this._billboardWorldMatrix;
        }
        return super.getWorldMatrix();
      }
      get isAnInstance() {
        return true;
      }
      getLOD(camera) {
        if (!camera) {
          return this;
        }
        const sourceMeshLODLevels = this.sourceMesh.getLODLevels();
        if (!sourceMeshLODLevels || sourceMeshLODLevels.length === 0) {
          this._currentLOD = this.sourceMesh;
        } else {
          const boundingInfo = this.getBoundingInfo();
          this._currentLOD = this.sourceMesh.getLOD(camera, boundingInfo.boundingSphere);
        }
        return this._currentLOD;
      }
      _preActivateForIntermediateRendering(renderId) {
        return this.sourceMesh._preActivateForIntermediateRendering(renderId);
      }
      _syncSubMeshes() {
        this.releaseSubMeshes();
        if (this._sourceMesh.subMeshes) {
          for (let index = 0; index < this._sourceMesh.subMeshes.length; index++) {
            this._sourceMesh.subMeshes[index].clone(this, this._sourceMesh);
          }
        }
        return this;
      }
      _generatePointsArray() {
        return this._sourceMesh._generatePointsArray();
      }
      _updateBoundingInfo() {
        if (this.hasBoundingInfo) {
          this.getBoundingInfo().update(this.worldMatrixFromCache);
        } else {
          this.buildBoundingInfo(this.absolutePosition, this.absolutePosition, this.worldMatrixFromCache);
        }
        this._updateSubMeshesBoundingInfo(this.worldMatrixFromCache);
        return this;
      }
      clone(name109, newParent = null, doNotCloneChildren, newSourceMesh) {
        const result = (newSourceMesh || this._sourceMesh).createInstance(name109);
        DeepCopier.DeepCopy(this, result, [
          "name",
          "subMeshes",
          "uniqueId",
          "parent",
          "lightSources",
          "receiveShadows",
          "material",
          "visibility",
          "skeleton",
          "sourceMesh",
          "isAnInstance",
          "facetNb",
          "isFacetDataEnabled",
          "isBlocked",
          "useBones",
          "hasInstances",
          "collider",
          "edgesRenderer",
          "forward",
          "up",
          "right",
          "absolutePosition",
          "absoluteScaling",
          "absoluteRotationQuaternion",
          "isWorldMatrixFrozen",
          "nonUniformScaling",
          "behaviors",
          "worldMatrixFromCache",
          "hasThinInstances",
          "hasBoundingInfo"
        ], []);
        this.refreshBoundingInfo();
        if (newParent) {
          result.parent = newParent;
        }
        if (!doNotCloneChildren) {
          for (let index = 0; index < this.getScene().meshes.length; index++) {
            const mesh = this.getScene().meshes[index];
            if (mesh.parent === this) {
              mesh.clone(mesh.name, result);
            }
          }
        }
        result.computeWorldMatrix(true);
        this.onClonedObservable.notifyObservers(result);
        return result;
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        this._sourceMesh.removeInstance(this);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      _serializeAsParent(serializationObject) {
        super._serializeAsParent(serializationObject);
        serializationObject.parentId = this._sourceMesh.uniqueId;
        serializationObject.parentInstanceIndex = this._indexInSourceMeshInstanceArray;
      }
      instantiateHierarchy(newParent = null, options, onNewNodeCreated) {
        const clone = this.clone("Clone of " + (this.name || this.id), newParent || this.parent, true, options && options.newSourcedMesh);
        if (clone) {
          if (onNewNodeCreated) {
            onNewNodeCreated(this, clone);
          }
        }
        for (const child of this.getChildTransformNodes(true)) {
          child.instantiateHierarchy(clone, options, onNewNodeCreated);
        }
        return clone;
      }
    };
    Mesh.prototype.registerInstancedBuffer = function(kind, stride) {
      var _a, _b;
      (_b = (_a = this._userInstancedBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) === null || _b === void 0 ? void 0 : _b.dispose();
      if (!this.instancedBuffers) {
        this.instancedBuffers = {};
        for (const instance of this.instances) {
          instance.instancedBuffers = {};
        }
        if (!this._userInstancedBuffersStorage) {
          this._userInstancedBuffersStorage = {
            data: {},
            vertexBuffers: {},
            strides: {},
            sizes: {},
            vertexArrayObjects: this.getEngine().getCaps().vertexArrayObject ? {} : void 0
          };
        }
      }
      this.instancedBuffers[kind] = null;
      this._userInstancedBuffersStorage.strides[kind] = stride;
      this._userInstancedBuffersStorage.sizes[kind] = stride * 32;
      this._userInstancedBuffersStorage.data[kind] = new Float32Array(this._userInstancedBuffersStorage.sizes[kind]);
      this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
      for (const instance of this.instances) {
        instance.instancedBuffers[kind] = null;
      }
      this._invalidateInstanceVertexArrayObject();
      this._markSubMeshesAsAttributesDirty();
    };
    Mesh.prototype._processInstancedBuffers = function(visibleInstances, renderSelf) {
      const instanceCount = visibleInstances ? visibleInstances.length : 0;
      for (const kind in this.instancedBuffers) {
        let size = this._userInstancedBuffersStorage.sizes[kind];
        const stride = this._userInstancedBuffersStorage.strides[kind];
        const expectedSize = (instanceCount + 1) * stride;
        while (size < expectedSize) {
          size *= 2;
        }
        if (this._userInstancedBuffersStorage.data[kind].length != size) {
          this._userInstancedBuffersStorage.data[kind] = new Float32Array(size);
          this._userInstancedBuffersStorage.sizes[kind] = size;
          if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
            this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
            this._userInstancedBuffersStorage.vertexBuffers[kind] = null;
          }
        }
        const data = this._userInstancedBuffersStorage.data[kind];
        let offset = 0;
        if (renderSelf) {
          const value = this.instancedBuffers[kind];
          if (value.toArray) {
            value.toArray(data, offset);
          } else if (value.copyToArray) {
            value.copyToArray(data, offset);
          } else {
            data[offset] = value;
          }
          offset += stride;
        }
        for (let instanceIndex = 0; instanceIndex < instanceCount; instanceIndex++) {
          const instance = visibleInstances[instanceIndex];
          const value = instance.instancedBuffers[kind];
          if (value.toArray) {
            value.toArray(data, offset);
          } else if (value.copyToArray) {
            value.copyToArray(data, offset);
          } else {
            data[offset] = value;
          }
          offset += stride;
        }
        if (!this._userInstancedBuffersStorage.vertexBuffers[kind]) {
          this._userInstancedBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userInstancedBuffersStorage.data[kind], kind, true, false, stride, true);
          this._invalidateInstanceVertexArrayObject();
        } else {
          this._userInstancedBuffersStorage.vertexBuffers[kind].updateDirectly(data, 0);
        }
      }
    };
    Mesh.prototype._invalidateInstanceVertexArrayObject = function() {
      if (!this._userInstancedBuffersStorage || this._userInstancedBuffersStorage.vertexArrayObjects === void 0) {
        return;
      }
      for (const kind in this._userInstancedBuffersStorage.vertexArrayObjects) {
        this.getEngine().releaseVertexArrayObject(this._userInstancedBuffersStorage.vertexArrayObjects[kind]);
      }
      this._userInstancedBuffersStorage.vertexArrayObjects = {};
    };
    Mesh.prototype._disposeInstanceSpecificData = function() {
      if (this._instanceDataStorage.instancesBuffer) {
        this._instanceDataStorage.instancesBuffer.dispose();
        this._instanceDataStorage.instancesBuffer = null;
      }
      while (this.instances.length) {
        this.instances[0].dispose();
      }
      for (const kind in this.instancedBuffers) {
        if (this._userInstancedBuffersStorage.vertexBuffers[kind]) {
          this._userInstancedBuffersStorage.vertexBuffers[kind].dispose();
        }
      }
      this._invalidateInstanceVertexArrayObject();
      this.instancedBuffers = {};
    };
  }
});

// node_modules/@babylonjs/core/Lights/light.js
var Light;
var init_light = __esm({
  "node_modules/@babylonjs/core/Lights/light.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_math_color();
    init_node();
    init_uniformBuffer();
    init_typeStore();
    init_lightConstants();
    Light = class extends Node {
      get range() {
        return this._range;
      }
      set range(value) {
        this._range = value;
        this._inverseSquaredRange = 1 / (this.range * this.range);
      }
      get intensityMode() {
        return this._intensityMode;
      }
      set intensityMode(value) {
        this._intensityMode = value;
        this._computePhotometricScale();
      }
      get radius() {
        return this._radius;
      }
      set radius(value) {
        this._radius = value;
        this._computePhotometricScale();
      }
      get shadowEnabled() {
        return this._shadowEnabled;
      }
      set shadowEnabled(value) {
        if (this._shadowEnabled === value) {
          return;
        }
        this._shadowEnabled = value;
        this._markMeshesAsLightDirty();
      }
      get includedOnlyMeshes() {
        return this._includedOnlyMeshes;
      }
      set includedOnlyMeshes(value) {
        this._includedOnlyMeshes = value;
        this._hookArrayForIncludedOnly(value);
      }
      get excludedMeshes() {
        return this._excludedMeshes;
      }
      set excludedMeshes(value) {
        this._excludedMeshes = value;
        this._hookArrayForExcluded(value);
      }
      get excludeWithLayerMask() {
        return this._excludeWithLayerMask;
      }
      set excludeWithLayerMask(value) {
        this._excludeWithLayerMask = value;
        this._resyncMeshes();
      }
      get includeOnlyWithLayerMask() {
        return this._includeOnlyWithLayerMask;
      }
      set includeOnlyWithLayerMask(value) {
        this._includeOnlyWithLayerMask = value;
        this._resyncMeshes();
      }
      get lightmapMode() {
        return this._lightmapMode;
      }
      set lightmapMode(value) {
        if (this._lightmapMode === value) {
          return;
        }
        this._lightmapMode = value;
        this._markMeshesAsLightDirty();
      }
      constructor(name109, scene) {
        super(name109, scene);
        this.diffuse = new Color3(1, 1, 1);
        this.specular = new Color3(1, 1, 1);
        this.falloffType = Light.FALLOFF_DEFAULT;
        this.intensity = 1;
        this._range = Number.MAX_VALUE;
        this._inverseSquaredRange = 0;
        this._photometricScale = 1;
        this._intensityMode = Light.INTENSITYMODE_AUTOMATIC;
        this._radius = 1e-5;
        this.renderPriority = 0;
        this._shadowEnabled = true;
        this._excludeWithLayerMask = 0;
        this._includeOnlyWithLayerMask = 0;
        this._lightmapMode = 0;
        this._shadowGenerators = null;
        this._excludedMeshesIds = new Array();
        this._includedOnlyMeshesIds = new Array();
        this._isLight = true;
        this.getScene().addLight(this);
        this._uniformBuffer = new UniformBuffer(this.getScene().getEngine(), void 0, void 0, name109);
        this._buildUniformLayout();
        this.includedOnlyMeshes = new Array();
        this.excludedMeshes = new Array();
        this._resyncMeshes();
      }
      transferTexturesToEffect(effect, lightIndex) {
        return this;
      }
      _bindLight(lightIndex, scene, effect, useSpecular, receiveShadows = true) {
        var _a;
        const iAsString = lightIndex.toString();
        let needUpdate = false;
        this._uniformBuffer.bindToEffect(effect, "Light" + iAsString);
        if (this._renderId !== scene.getRenderId() || this._lastUseSpecular !== useSpecular || !this._uniformBuffer.useUbo) {
          this._renderId = scene.getRenderId();
          this._lastUseSpecular = useSpecular;
          const scaledIntensity = this.getScaledIntensity();
          this.transferToEffect(effect, iAsString);
          this.diffuse.scaleToRef(scaledIntensity, TmpColors.Color3[0]);
          this._uniformBuffer.updateColor4("vLightDiffuse", TmpColors.Color3[0], this.range, iAsString);
          if (useSpecular) {
            this.specular.scaleToRef(scaledIntensity, TmpColors.Color3[1]);
            this._uniformBuffer.updateColor4("vLightSpecular", TmpColors.Color3[1], this.radius, iAsString);
          }
          needUpdate = true;
        }
        this.transferTexturesToEffect(effect, iAsString);
        if (scene.shadowsEnabled && this.shadowEnabled && receiveShadows) {
          const shadowGenerator = (_a = this.getShadowGenerator(scene.activeCamera)) !== null && _a !== void 0 ? _a : this.getShadowGenerator();
          if (shadowGenerator) {
            shadowGenerator.bindShadowLight(iAsString, effect);
            needUpdate = true;
          }
        }
        if (needUpdate) {
          this._uniformBuffer.update();
        } else {
          this._uniformBuffer.bindUniformBuffer();
        }
      }
      getClassName() {
        return "Light";
      }
      toString(fullDetails) {
        let ret = "Name: " + this.name;
        ret += ", type: " + ["Point", "Directional", "Spot", "Hemispheric"][this.getTypeID()];
        if (this.animations) {
          for (let i = 0; i < this.animations.length; i++) {
            ret += ", animation[0]: " + this.animations[i].toString(fullDetails);
          }
        }
        return ret;
      }
      _syncParentEnabledState() {
        super._syncParentEnabledState();
        if (!this.isDisposed()) {
          this._resyncMeshes();
        }
      }
      setEnabled(value) {
        super.setEnabled(value);
        this._resyncMeshes();
      }
      getShadowGenerator(camera = null) {
        var _a;
        if (this._shadowGenerators === null) {
          return null;
        }
        return (_a = this._shadowGenerators.get(camera)) !== null && _a !== void 0 ? _a : null;
      }
      getShadowGenerators() {
        return this._shadowGenerators;
      }
      getAbsolutePosition() {
        return Vector3.Zero();
      }
      canAffectMesh(mesh) {
        if (!mesh) {
          return true;
        }
        if (this.includedOnlyMeshes && this.includedOnlyMeshes.length > 0 && this.includedOnlyMeshes.indexOf(mesh) === -1) {
          return false;
        }
        if (this.excludedMeshes && this.excludedMeshes.length > 0 && this.excludedMeshes.indexOf(mesh) !== -1) {
          return false;
        }
        if (this.includeOnlyWithLayerMask !== 0 && (this.includeOnlyWithLayerMask & mesh.layerMask) === 0) {
          return false;
        }
        if (this.excludeWithLayerMask !== 0 && this.excludeWithLayerMask & mesh.layerMask) {
          return false;
        }
        return true;
      }
      dispose(doNotRecurse, disposeMaterialAndTextures = false) {
        if (this._shadowGenerators) {
          const iterator = this._shadowGenerators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const shadowGenerator = key.value;
            shadowGenerator.dispose();
          }
          this._shadowGenerators = null;
        }
        this.getScene().stopAnimation(this);
        if (this._parentContainer) {
          const index = this._parentContainer.lights.indexOf(this);
          if (index > -1) {
            this._parentContainer.lights.splice(index, 1);
          }
          this._parentContainer = null;
        }
        for (const mesh of this.getScene().meshes) {
          mesh._removeLightSource(this, true);
        }
        this._uniformBuffer.dispose();
        this.getScene().removeLight(this);
        super.dispose(doNotRecurse, disposeMaterialAndTextures);
      }
      getTypeID() {
        return 0;
      }
      getScaledIntensity() {
        return this._photometricScale * this.intensity;
      }
      clone(name109, newParent = null) {
        const constructor = Light.GetConstructorFromName(this.getTypeID(), name109, this.getScene());
        if (!constructor) {
          return null;
        }
        const clonedLight = SerializationHelper.Clone(constructor, this);
        if (name109) {
          clonedLight.name = name109;
        }
        if (newParent) {
          clonedLight.parent = newParent;
        }
        clonedLight.setEnabled(this.isEnabled());
        this.onClonedObservable.notifyObservers(clonedLight);
        return clonedLight;
      }
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.type = this.getTypeID();
        if (this.parent) {
          this.parent._serializeAsParent(serializationObject);
        }
        if (this.excludedMeshes.length > 0) {
          serializationObject.excludedMeshesIds = [];
          this.excludedMeshes.forEach((mesh) => {
            serializationObject.excludedMeshesIds.push(mesh.id);
          });
        }
        if (this.includedOnlyMeshes.length > 0) {
          serializationObject.includedOnlyMeshesIds = [];
          this.includedOnlyMeshes.forEach((mesh) => {
            serializationObject.includedOnlyMeshesIds.push(mesh.id);
          });
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        serializationObject.ranges = this.serializeAnimationRanges();
        serializationObject.isEnabled = this.isEnabled();
        return serializationObject;
      }
      static GetConstructorFromName(type, name109, scene) {
        const constructorFunc = Node.Construct("Light_Type_" + type, name109, scene);
        if (constructorFunc) {
          return constructorFunc;
        }
        return null;
      }
      static Parse(parsedLight, scene) {
        const constructor = Light.GetConstructorFromName(parsedLight.type, parsedLight.name, scene);
        if (!constructor) {
          return null;
        }
        const light = SerializationHelper.Parse(constructor, parsedLight, scene);
        if (parsedLight.excludedMeshesIds) {
          light._excludedMeshesIds = parsedLight.excludedMeshesIds;
        }
        if (parsedLight.includedOnlyMeshesIds) {
          light._includedOnlyMeshesIds = parsedLight.includedOnlyMeshesIds;
        }
        if (parsedLight.parentId !== void 0) {
          light._waitingParentId = parsedLight.parentId;
        }
        if (parsedLight.parentInstanceIndex !== void 0) {
          light._waitingParentInstanceIndex = parsedLight.parentInstanceIndex;
        }
        if (parsedLight.falloffType !== void 0) {
          light.falloffType = parsedLight.falloffType;
        }
        if (parsedLight.lightmapMode !== void 0) {
          light.lightmapMode = parsedLight.lightmapMode;
        }
        if (parsedLight.animations) {
          for (let animationIndex = 0; animationIndex < parsedLight.animations.length; animationIndex++) {
            const parsedAnimation = parsedLight.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              light.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          Node.ParseAnimationRanges(light, parsedLight, scene);
        }
        if (parsedLight.autoAnimate) {
          scene.beginAnimation(light, parsedLight.autoAnimateFrom, parsedLight.autoAnimateTo, parsedLight.autoAnimateLoop, parsedLight.autoAnimateSpeed || 1);
        }
        if (parsedLight.isEnabled !== void 0) {
          light.setEnabled(parsedLight.isEnabled);
        }
        return light;
      }
      _hookArrayForExcluded(array) {
        const oldPush = array.push;
        array.push = (...items) => {
          const result = oldPush.apply(array, items);
          for (const item of items) {
            item._resyncLightSource(this);
          }
          return result;
        };
        const oldSplice = array.splice;
        array.splice = (index, deleteCount) => {
          const deleted = oldSplice.apply(array, [index, deleteCount]);
          for (const item of deleted) {
            item._resyncLightSource(this);
          }
          return deleted;
        };
        for (const item of array) {
          item._resyncLightSource(this);
        }
      }
      _hookArrayForIncludedOnly(array) {
        const oldPush = array.push;
        array.push = (...items) => {
          const result = oldPush.apply(array, items);
          this._resyncMeshes();
          return result;
        };
        const oldSplice = array.splice;
        array.splice = (index, deleteCount) => {
          const deleted = oldSplice.apply(array, [index, deleteCount]);
          this._resyncMeshes();
          return deleted;
        };
        this._resyncMeshes();
      }
      _resyncMeshes() {
        for (const mesh of this.getScene().meshes) {
          mesh._resyncLightSource(this);
        }
      }
      _markMeshesAsLightDirty() {
        for (const mesh of this.getScene().meshes) {
          if (mesh.lightSources.indexOf(this) !== -1) {
            mesh._markSubMeshesAsLightDirty();
          }
        }
      }
      _computePhotometricScale() {
        this._photometricScale = this._getPhotometricScale();
        this.getScene().resetCachedMaterial();
      }
      _getPhotometricScale() {
        let photometricScale = 0;
        const lightTypeID = this.getTypeID();
        let photometricMode = this.intensityMode;
        if (photometricMode === Light.INTENSITYMODE_AUTOMATIC) {
          if (lightTypeID === Light.LIGHTTYPEID_DIRECTIONALLIGHT) {
            photometricMode = Light.INTENSITYMODE_ILLUMINANCE;
          } else {
            photometricMode = Light.INTENSITYMODE_LUMINOUSINTENSITY;
          }
        }
        switch (lightTypeID) {
          case Light.LIGHTTYPEID_POINTLIGHT:
          case Light.LIGHTTYPEID_SPOTLIGHT:
            switch (photometricMode) {
              case Light.INTENSITYMODE_LUMINOUSPOWER:
                photometricScale = 1 / (4 * Math.PI);
                break;
              case Light.INTENSITYMODE_LUMINOUSINTENSITY:
                photometricScale = 1;
                break;
              case Light.INTENSITYMODE_LUMINANCE:
                photometricScale = this.radius * this.radius;
                break;
            }
            break;
          case Light.LIGHTTYPEID_DIRECTIONALLIGHT:
            switch (photometricMode) {
              case Light.INTENSITYMODE_ILLUMINANCE:
                photometricScale = 1;
                break;
              case Light.INTENSITYMODE_LUMINANCE: {
                let apexAngleRadians = this.radius;
                apexAngleRadians = Math.max(apexAngleRadians, 1e-3);
                const solidAngle = 2 * Math.PI * (1 - Math.cos(apexAngleRadians));
                photometricScale = solidAngle;
                break;
              }
            }
            break;
          case Light.LIGHTTYPEID_HEMISPHERICLIGHT:
            photometricScale = 1;
            break;
        }
        return photometricScale;
      }
      _reorderLightsInScene() {
        const scene = this.getScene();
        if (this._renderPriority != 0) {
          scene.requireLightSorting = true;
        }
        this.getScene().sortLightsByPriority();
      }
    };
    Light.FALLOFF_DEFAULT = LightConstants.FALLOFF_DEFAULT;
    Light.FALLOFF_PHYSICAL = LightConstants.FALLOFF_PHYSICAL;
    Light.FALLOFF_GLTF = LightConstants.FALLOFF_GLTF;
    Light.FALLOFF_STANDARD = LightConstants.FALLOFF_STANDARD;
    Light.LIGHTMAP_DEFAULT = LightConstants.LIGHTMAP_DEFAULT;
    Light.LIGHTMAP_SPECULAR = LightConstants.LIGHTMAP_SPECULAR;
    Light.LIGHTMAP_SHADOWSONLY = LightConstants.LIGHTMAP_SHADOWSONLY;
    Light.INTENSITYMODE_AUTOMATIC = LightConstants.INTENSITYMODE_AUTOMATIC;
    Light.INTENSITYMODE_LUMINOUSPOWER = LightConstants.INTENSITYMODE_LUMINOUSPOWER;
    Light.INTENSITYMODE_LUMINOUSINTENSITY = LightConstants.INTENSITYMODE_LUMINOUSINTENSITY;
    Light.INTENSITYMODE_ILLUMINANCE = LightConstants.INTENSITYMODE_ILLUMINANCE;
    Light.INTENSITYMODE_LUMINANCE = LightConstants.INTENSITYMODE_LUMINANCE;
    Light.LIGHTTYPEID_POINTLIGHT = LightConstants.LIGHTTYPEID_POINTLIGHT;
    Light.LIGHTTYPEID_DIRECTIONALLIGHT = LightConstants.LIGHTTYPEID_DIRECTIONALLIGHT;
    Light.LIGHTTYPEID_SPOTLIGHT = LightConstants.LIGHTTYPEID_SPOTLIGHT;
    Light.LIGHTTYPEID_HEMISPHERICLIGHT = LightConstants.LIGHTTYPEID_HEMISPHERICLIGHT;
    __decorate([
      serializeAsColor3()
    ], Light.prototype, "diffuse", void 0);
    __decorate([
      serializeAsColor3()
    ], Light.prototype, "specular", void 0);
    __decorate([
      serialize()
    ], Light.prototype, "falloffType", void 0);
    __decorate([
      serialize()
    ], Light.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], Light.prototype, "range", null);
    __decorate([
      serialize()
    ], Light.prototype, "intensityMode", null);
    __decorate([
      serialize()
    ], Light.prototype, "radius", null);
    __decorate([
      serialize()
    ], Light.prototype, "_renderPriority", void 0);
    __decorate([
      expandToProperty("_reorderLightsInScene")
    ], Light.prototype, "renderPriority", void 0);
    __decorate([
      serialize("shadowEnabled")
    ], Light.prototype, "_shadowEnabled", void 0);
    __decorate([
      serialize("excludeWithLayerMask")
    ], Light.prototype, "_excludeWithLayerMask", void 0);
    __decorate([
      serialize("includeOnlyWithLayerMask")
    ], Light.prototype, "_includeOnlyWithLayerMask", void 0);
    __decorate([
      serialize("lightmapMode")
    ], Light.prototype, "_lightmapMode", void 0);
  }
});

// node_modules/@babylonjs/core/assetContainer.js
var KeepAssets, InstantiatedEntries, AssetContainer;
var init_assetContainer = __esm({
  "node_modules/@babylonjs/core/assetContainer.js"() {
    init_abstractScene();
    init_mesh();
    init_transformNode();
    init_logger();
    init_engineStore();
    init_instancedMesh();
    init_light();
    init_camera();
    init_tools();
    KeepAssets = class extends AbstractScene {
    };
    InstantiatedEntries = class {
      constructor() {
        this.rootNodes = [];
        this.skeletons = [];
        this.animationGroups = [];
      }
      dispose() {
        this.rootNodes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.rootNodes.length = 0;
        this.skeletons.slice(0).forEach((o) => {
          o.dispose();
        });
        this.skeletons.length = 0;
        this.animationGroups.slice(0).forEach((o) => {
          o.dispose();
        });
        this.animationGroups.length = 0;
      }
    };
    AssetContainer = class extends AbstractScene {
      constructor(scene) {
        super();
        this._wasAddedToScene = false;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this.scene = scene;
        this["sounds"] = [];
        this["effectLayers"] = [];
        this["layers"] = [];
        this["lensFlareSystems"] = [];
        this["proceduralTextures"] = [];
        this["reflectionProbes"] = [];
        scene.onDisposeObservable.add(() => {
          if (!this._wasAddedToScene) {
            this.dispose();
          }
        });
        this._onContextRestoredObserver = scene.getEngine().onContextRestoredObservable.add(() => {
          for (const geometry of this.geometries) {
            geometry._rebuild();
          }
          for (const mesh of this.meshes) {
            mesh._rebuild();
          }
          for (const system of this.particleSystems) {
            system.rebuild();
          }
          for (const texture of this.textures) {
            texture._rebuild();
          }
        });
      }
      _topologicalSort(nodes) {
        const nodesUidMap = /* @__PURE__ */ new Map();
        for (const node of nodes) {
          nodesUidMap.set(node.uniqueId, node);
        }
        const dependencyGraph = {
          dependsOn: /* @__PURE__ */ new Map(),
          dependedBy: /* @__PURE__ */ new Map()
        };
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          dependencyGraph.dependsOn.set(nodeId, /* @__PURE__ */ new Set());
          dependencyGraph.dependedBy.set(nodeId, /* @__PURE__ */ new Set());
        }
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          const dependsOn = dependencyGraph.dependsOn.get(nodeId);
          if (node instanceof InstancedMesh) {
            const masterMesh = node.sourceMesh;
            if (nodesUidMap.has(masterMesh.uniqueId)) {
              dependsOn.add(masterMesh.uniqueId);
              dependencyGraph.dependedBy.get(masterMesh.uniqueId).add(nodeId);
            }
          }
          const dependedBy = dependencyGraph.dependedBy.get(nodeId);
          for (const child of node.getDescendants()) {
            const childId = child.uniqueId;
            if (nodesUidMap.has(childId)) {
              dependedBy.add(childId);
              const childDependsOn = dependencyGraph.dependsOn.get(childId);
              childDependsOn.add(nodeId);
            }
          }
        }
        const sortedNodes = [];
        const leaves = [];
        for (const node of nodes) {
          const nodeId = node.uniqueId;
          if (dependencyGraph.dependsOn.get(nodeId).size === 0) {
            leaves.push(node);
            nodesUidMap.delete(nodeId);
          }
        }
        const visitList = leaves;
        while (visitList.length > 0) {
          const nodeToVisit = visitList.shift();
          sortedNodes.push(nodeToVisit);
          const dependedByVisitedNode = dependencyGraph.dependedBy.get(nodeToVisit.uniqueId);
          for (const dependedByVisitedNodeId of Array.from(dependedByVisitedNode.values())) {
            const dependsOnDependedByVisitedNode = dependencyGraph.dependsOn.get(dependedByVisitedNodeId);
            dependsOnDependedByVisitedNode.delete(nodeToVisit.uniqueId);
            if (dependsOnDependedByVisitedNode.size === 0 && nodesUidMap.get(dependedByVisitedNodeId)) {
              visitList.push(nodesUidMap.get(dependedByVisitedNodeId));
              nodesUidMap.delete(dependedByVisitedNodeId);
            }
          }
        }
        if (nodesUidMap.size > 0) {
          console.error("SceneSerializer._topologicalSort: There were unvisited nodes:");
          nodesUidMap.forEach((node) => console.error(node.name));
        }
        return sortedNodes;
      }
      _addNodeAndDescendantsToList(list, addedIds, rootNode, predicate) {
        if (!rootNode || predicate && !predicate(rootNode) || addedIds.has(rootNode.uniqueId)) {
          return;
        }
        list.push(rootNode);
        addedIds.add(rootNode.uniqueId);
        for (const child of rootNode.getDescendants(true)) {
          this._addNodeAndDescendantsToList(list, addedIds, child, predicate);
        }
      }
      _isNodeInContainer(node) {
        if (node instanceof Mesh && this.meshes.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof TransformNode && this.transformNodes.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof Light && this.lights.indexOf(node) !== -1) {
          return true;
        }
        if (node instanceof Camera && this.cameras.indexOf(node) !== -1) {
          return true;
        }
        return false;
      }
      _isValidHierarchy() {
        for (const node of this.meshes) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.transformNodes) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.lights) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        for (const node of this.cameras) {
          if (node.parent && !this._isNodeInContainer(node.parent)) {
            Logger.Warn(`Node ${node.name} has a parent that is not in the container.`);
            return false;
          }
        }
        return true;
      }
      instantiateModelsToScene(nameFunction, cloneMaterials = false, options) {
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.InstantiateModelsToScene: The Asset Container hierarchy is not valid.");
        }
        const conversionMap = {};
        const storeMap = {};
        const result = new InstantiatedEntries();
        const alreadySwappedSkeletons = [];
        const alreadySwappedMaterials = [];
        const localOptions = Object.assign({ doNotInstantiate: true }, options);
        const onClone = (source, clone) => {
          conversionMap[source.uniqueId] = clone.uniqueId;
          storeMap[clone.uniqueId] = clone;
          if (nameFunction) {
            clone.name = nameFunction(source.name);
          }
          if (clone instanceof Mesh) {
            const clonedMesh = clone;
            if (clonedMesh.morphTargetManager) {
              const oldMorphTargetManager = source.morphTargetManager;
              clonedMesh.morphTargetManager = oldMorphTargetManager.clone();
              for (let index = 0; index < oldMorphTargetManager.numTargets; index++) {
                const oldTarget = oldMorphTargetManager.getTarget(index);
                const newTarget = clonedMesh.morphTargetManager.getTarget(index);
                conversionMap[oldTarget.uniqueId] = newTarget.uniqueId;
                storeMap[newTarget.uniqueId] = newTarget;
              }
            }
          }
        };
        const nodesToSort = [];
        const idsOnSortList = /* @__PURE__ */ new Set();
        for (const transformNode of this.transformNodes) {
          if (transformNode.parent === null) {
            this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, transformNode, localOptions.predicate);
          }
        }
        for (const mesh of this.meshes) {
          if (mesh.parent === null) {
            this._addNodeAndDescendantsToList(nodesToSort, idsOnSortList, mesh, localOptions.predicate);
          }
        }
        const sortedNodes = this._topologicalSort(nodesToSort);
        const onNewCreated = (source, clone) => {
          onClone(source, clone);
          if (source.parent) {
            const replicatedParentId = conversionMap[source.parent.uniqueId];
            const replicatedParent = storeMap[replicatedParentId];
            if (replicatedParent) {
              clone.parent = replicatedParent;
            } else {
              clone.parent = source.parent;
            }
          }
          if (clone.position && source.position) {
            clone.position.copyFrom(source.position);
          }
          if (clone.rotationQuaternion && source.rotationQuaternion) {
            clone.rotationQuaternion.copyFrom(source.rotationQuaternion);
          }
          if (clone.rotation && source.rotation) {
            clone.rotation.copyFrom(source.rotation);
          }
          if (clone.scaling && source.scaling) {
            clone.scaling.copyFrom(source.scaling);
          }
          if (clone.material) {
            const mesh = clone;
            if (mesh.material) {
              if (cloneMaterials) {
                const sourceMaterial = source.material;
                if (alreadySwappedMaterials.indexOf(sourceMaterial) === -1) {
                  let swap = sourceMaterial.clone(nameFunction ? nameFunction(sourceMaterial.name) : "Clone of " + sourceMaterial.name);
                  alreadySwappedMaterials.push(sourceMaterial);
                  conversionMap[sourceMaterial.uniqueId] = swap.uniqueId;
                  storeMap[swap.uniqueId] = swap;
                  if (sourceMaterial.getClassName() === "MultiMaterial") {
                    const multi = sourceMaterial;
                    for (const material of multi.subMaterials) {
                      if (!material) {
                        continue;
                      }
                      swap = material.clone(nameFunction ? nameFunction(material.name) : "Clone of " + material.name);
                      alreadySwappedMaterials.push(material);
                      conversionMap[material.uniqueId] = swap.uniqueId;
                      storeMap[swap.uniqueId] = swap;
                    }
                    multi.subMaterials = multi.subMaterials.map((m) => m && storeMap[conversionMap[m.uniqueId]]);
                  }
                }
                if (mesh.getClassName() !== "InstancedMesh") {
                  mesh.material = storeMap[conversionMap[sourceMaterial.uniqueId]];
                }
              } else {
                if (mesh.material.getClassName() === "MultiMaterial") {
                  if (this.scene.multiMaterials.indexOf(mesh.material) === -1) {
                    this.scene.addMultiMaterial(mesh.material);
                  }
                } else {
                  if (this.scene.materials.indexOf(mesh.material) === -1) {
                    this.scene.addMaterial(mesh.material);
                  }
                }
              }
            }
          }
          if (clone.parent === null) {
            result.rootNodes.push(clone);
          }
        };
        sortedNodes.forEach((node) => {
          if (node.getClassName() === "InstancedMesh") {
            const instancedNode = node;
            const sourceMesh = instancedNode.sourceMesh;
            const replicatedSourceId = conversionMap[sourceMesh.uniqueId];
            const replicatedSource = typeof replicatedSourceId === "number" ? storeMap[replicatedSourceId] : sourceMesh;
            const replicatedInstancedNode = replicatedSource.createInstance(instancedNode.name);
            onNewCreated(instancedNode, replicatedInstancedNode);
          } else {
            let canInstance = true;
            if (node.getClassName() === "TransformNode" || node.getClassName() === "Node" || node.skeleton || !node.getTotalVertices || node.getTotalVertices() === 0) {
              canInstance = false;
            } else if (localOptions.doNotInstantiate) {
              if (typeof localOptions.doNotInstantiate === "function") {
                canInstance = !localOptions.doNotInstantiate(node);
              } else {
                canInstance = !localOptions.doNotInstantiate;
              }
            }
            const replicatedNode = canInstance ? node.createInstance(`instance of ${node.name}`) : node.clone(`Clone of ${node.name}`, null, true);
            if (!replicatedNode) {
              throw new Error(`Could not clone or instantiate node on Asset Container ${node.name}`);
            }
            onNewCreated(node, replicatedNode);
          }
        });
        this.skeletons.forEach((s) => {
          if (localOptions.predicate && !localOptions.predicate(s)) {
            return;
          }
          const clone = s.clone(nameFunction ? nameFunction(s.name) : "Clone of " + s.name);
          for (const m of this.meshes) {
            if (m.skeleton === s && !m.isAnInstance) {
              const copy = storeMap[conversionMap[m.uniqueId]];
              if (!copy || copy.isAnInstance) {
                continue;
              }
              copy.skeleton = clone;
              if (alreadySwappedSkeletons.indexOf(clone) !== -1) {
                continue;
              }
              alreadySwappedSkeletons.push(clone);
              for (const bone of clone.bones) {
                if (bone._linkedTransformNode) {
                  bone._linkedTransformNode = storeMap[conversionMap[bone._linkedTransformNode.uniqueId]];
                }
              }
            }
          }
          result.skeletons.push(clone);
        });
        this.animationGroups.forEach((o) => {
          if (localOptions.predicate && !localOptions.predicate(o)) {
            return;
          }
          const clone = o.clone(nameFunction ? nameFunction(o.name) : "Clone of " + o.name, (oldTarget) => {
            const newTarget = storeMap[conversionMap[oldTarget.uniqueId]];
            return newTarget || oldTarget;
          });
          result.animationGroups.push(clone);
        });
        return result;
      }
      addAllToScene() {
        if (this._wasAddedToScene) {
          return;
        }
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.addAllToScene: The Asset Container hierarchy is not valid.");
        }
        this._wasAddedToScene = true;
        this.addToScene(null);
        if (this.environmentTexture) {
          this.scene.environmentTexture = this.environmentTexture;
        }
        for (const component of this.scene._serializableComponents) {
          component.addFromContainer(this);
        }
        this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
        this._onContextRestoredObserver = null;
      }
      addToScene(predicate = null) {
        const addedNodes = [];
        this.cameras.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addCamera(o);
          addedNodes.push(o);
        });
        this.lights.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addLight(o);
          addedNodes.push(o);
        });
        this.meshes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMesh(o);
          addedNodes.push(o);
        });
        this.skeletons.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addSkeleton(o);
        });
        this.animations.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addAnimation(o);
        });
        this.animationGroups.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addAnimationGroup(o);
        });
        this.multiMaterials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMultiMaterial(o);
        });
        this.materials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMaterial(o);
        });
        this.morphTargetManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addMorphTargetManager(o);
        });
        this.geometries.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addGeometry(o);
        });
        this.transformNodes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addTransformNode(o);
          addedNodes.push(o);
        });
        this.actionManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addActionManager(o);
        });
        this.textures.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addTexture(o);
        });
        this.reflectionProbes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.addReflectionProbe(o);
        });
        for (const addedNode of addedNodes) {
          if (addedNode.parent && this.scene.getNodes().indexOf(addedNode.parent) === -1) {
            if (addedNode.setParent) {
              addedNode.setParent(null);
            } else {
              addedNode.parent = null;
            }
          }
        }
      }
      removeAllFromScene() {
        if (!this._isValidHierarchy()) {
          Tools.Warn("SceneSerializer.removeAllFromScene: The Asset Container hierarchy is not valid.");
        }
        this._wasAddedToScene = false;
        this.removeFromScene(null);
        if (this.environmentTexture === this.scene.environmentTexture) {
          this.scene.environmentTexture = null;
        }
        for (const component of this.scene._serializableComponents) {
          component.removeFromContainer(this);
        }
      }
      removeFromScene(predicate = null) {
        this.cameras.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeCamera(o);
        });
        this.lights.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeLight(o);
        });
        this.meshes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMesh(o);
        });
        this.skeletons.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeSkeleton(o);
        });
        this.animations.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeAnimation(o);
        });
        this.animationGroups.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeAnimationGroup(o);
        });
        this.multiMaterials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMultiMaterial(o);
        });
        this.materials.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMaterial(o);
        });
        this.morphTargetManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeMorphTargetManager(o);
        });
        this.geometries.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeGeometry(o);
        });
        this.transformNodes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeTransformNode(o);
        });
        this.actionManagers.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeActionManager(o);
        });
        this.textures.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeTexture(o);
        });
        this.reflectionProbes.forEach((o) => {
          if (predicate && !predicate(o)) {
            return;
          }
          this.scene.removeReflectionProbe(o);
        });
      }
      dispose() {
        this.cameras.slice(0).forEach((o) => {
          o.dispose();
        });
        this.cameras.length = 0;
        this.lights.slice(0).forEach((o) => {
          o.dispose();
        });
        this.lights.length = 0;
        this.meshes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.meshes.length = 0;
        this.skeletons.slice(0).forEach((o) => {
          o.dispose();
        });
        this.skeletons.length = 0;
        this.animationGroups.slice(0).forEach((o) => {
          o.dispose();
        });
        this.animationGroups.length = 0;
        this.multiMaterials.slice(0).forEach((o) => {
          o.dispose();
        });
        this.multiMaterials.length = 0;
        this.materials.slice(0).forEach((o) => {
          o.dispose();
        });
        this.materials.length = 0;
        this.geometries.slice(0).forEach((o) => {
          o.dispose();
        });
        this.geometries.length = 0;
        this.transformNodes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.transformNodes.length = 0;
        this.actionManagers.slice(0).forEach((o) => {
          o.dispose();
        });
        this.actionManagers.length = 0;
        this.textures.slice(0).forEach((o) => {
          o.dispose();
        });
        this.textures.length = 0;
        this.reflectionProbes.slice(0).forEach((o) => {
          o.dispose();
        });
        this.reflectionProbes.length = 0;
        this.morphTargetManagers.slice(0).forEach((o) => {
          o.dispose();
        });
        this.morphTargetManagers.length = 0;
        if (this.environmentTexture) {
          this.environmentTexture.dispose();
          this.environmentTexture = null;
        }
        for (const component of this.scene._serializableComponents) {
          component.removeFromContainer(this, true);
        }
        if (this._onContextRestoredObserver) {
          this.scene.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
          this._onContextRestoredObserver = null;
        }
      }
      _moveAssets(sourceAssets, targetAssets, keepAssets) {
        if (!sourceAssets || !targetAssets) {
          return;
        }
        for (const asset of sourceAssets) {
          let move = true;
          if (keepAssets) {
            for (const keepAsset of keepAssets) {
              if (asset === keepAsset) {
                move = false;
                break;
              }
            }
          }
          if (move) {
            targetAssets.push(asset);
            asset._parentContainer = this;
          }
        }
      }
      moveAllFromScene(keepAssets) {
        this._wasAddedToScene = false;
        if (keepAssets === void 0) {
          keepAssets = new KeepAssets();
        }
        for (const key in this) {
          if (Object.prototype.hasOwnProperty.call(this, key)) {
            this[key] = this[key] || (key === "_environmentTexture" ? null : []);
            this._moveAssets(this.scene[key], this[key], keepAssets[key]);
          }
        }
        this.environmentTexture = this.scene.environmentTexture;
        this.removeAllFromScene();
      }
      createRootMesh() {
        const rootMesh = new Mesh("assetContainerRootMesh", this.scene);
        this.meshes.forEach((m) => {
          if (!m.parent) {
            rootMesh.addChild(m);
          }
        });
        this.meshes.unshift(rootMesh);
        return rootMesh;
      }
      mergeAnimationsTo(scene = EngineStore.LastCreatedScene, animatables, targetConverter = null) {
        if (!scene) {
          Logger.Error("No scene available to merge animations to");
          return [];
        }
        const _targetConverter = targetConverter ? targetConverter : (target) => {
          let node = null;
          const targetProperty = target.animations.length ? target.animations[0].targetProperty : "";
          const name109 = target.name.split(".").join("").split("_primitive")[0];
          switch (targetProperty) {
            case "position":
            case "rotationQuaternion":
              node = scene.getTransformNodeByName(target.name) || scene.getTransformNodeByName(name109);
              break;
            case "influence":
              node = scene.getMorphTargetByName(target.name) || scene.getMorphTargetByName(name109);
              break;
            default:
              node = scene.getNodeByName(target.name) || scene.getNodeByName(name109);
          }
          return node;
        };
        const nodesInAC = this.getNodes();
        nodesInAC.forEach((nodeInAC) => {
          const nodeInScene = _targetConverter(nodeInAC);
          if (nodeInScene !== null) {
            for (const animationInAC of nodeInAC.animations) {
              const animationsWithSameProperty = nodeInScene.animations.filter((animationInScene) => {
                return animationInScene.targetProperty === animationInAC.targetProperty;
              });
              for (const animationWithSameProperty of animationsWithSameProperty) {
                const index = nodeInScene.animations.indexOf(animationWithSameProperty, 0);
                if (index > -1) {
                  nodeInScene.animations.splice(index, 1);
                }
              }
            }
            nodeInScene.animations = nodeInScene.animations.concat(nodeInAC.animations);
          }
        });
        const newAnimationGroups = new Array();
        this.animationGroups.slice().forEach((animationGroupInAC) => {
          newAnimationGroups.push(animationGroupInAC.clone(animationGroupInAC.name, _targetConverter));
          animationGroupInAC.animatables.forEach((animatable) => {
            animatable.stop();
          });
        });
        animatables.forEach((animatable) => {
          const target = _targetConverter(animatable.target);
          if (target) {
            scene.beginAnimation(target, animatable.fromFrame, animatable.toFrame, animatable.loopAnimation, animatable.speedRatio, animatable.onAnimationEnd ? animatable.onAnimationEnd : void 0, void 0, true, void 0, animatable.onAnimationLoop ? animatable.onAnimationLoop : void 0);
            scene.stopAnimation(animatable.target);
          }
        });
        return newAnimationGroups;
      }
      populateRootNodes() {
        this.rootNodes.length = 0;
        this.meshes.forEach((m) => {
          if (!m.parent && this.rootNodes.indexOf(m) === -1) {
            this.rootNodes.push(m);
          }
        });
        this.transformNodes.forEach((t) => {
          if (!t.parent && this.rootNodes.indexOf(t) === -1) {
            this.rootNodes.push(t);
          }
        });
        this.lights.forEach((l) => {
          if (!l.parent && this.rootNodes.indexOf(l) === -1) {
            this.rootNodes.push(l);
          }
        });
        this.cameras.forEach((c) => {
          if (!c.parent && this.rootNodes.indexOf(c) === -1) {
            this.rootNodes.push(c);
          }
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Audio/sound.js
var Sound;
var init_sound = __esm({
  "node_modules/@babylonjs/core/Audio/sound.js"() {
    init_tools();
    init_observable();
    init_math_vector();
    init_engine();
    init_logger();
    init_devTools();
    init_engineStore();
    Sound = class {
      get loop() {
        return this._loop;
      }
      set loop(value) {
        if (value === this._loop) {
          return;
        }
        this._loop = value;
        this.updateOptions({ loop: value });
      }
      get currentTime() {
        var _a;
        if (this._htmlAudioElement) {
          return this._htmlAudioElement.currentTime;
        }
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && (this.isPlaying || this.isPaused)) {
          const timeSinceLastStart = this.isPaused ? 0 : Engine.audioEngine.audioContext.currentTime - this._startTime;
          return this._currentTime + timeSinceLastStart;
        }
        return 0;
      }
      get spatialSound() {
        return this._spatialSound;
      }
      set spatialSound(newValue) {
        if (newValue == this._spatialSound) {
          return;
        }
        const wasPlaying = this.isPlaying;
        this.pause();
        if (newValue) {
          this._spatialSound = newValue;
          this._updateSpatialParameters();
        } else {
          this._disableSpatialSound();
        }
        if (wasPlaying) {
          this.play();
        }
      }
      constructor(name109, urlOrArrayBuffer, scene, readyToPlayCallback = null, options) {
        var _a, _b, _c, _d, _e;
        this.autoplay = false;
        this._loop = false;
        this.useCustomAttenuation = false;
        this.isPlaying = false;
        this.isPaused = false;
        this.refDistance = 1;
        this.rolloffFactor = 1;
        this.maxDistance = 100;
        this.distanceModel = "linear";
        this.metadata = null;
        this.onEndedObservable = new Observable();
        this._spatialSound = false;
        this._panningModel = "equalpower";
        this._playbackRate = 1;
        this._streaming = false;
        this._startTime = 0;
        this._currentTime = 0;
        this._position = Vector3.Zero();
        this._localDirection = new Vector3(1, 0, 0);
        this._volume = 1;
        this._isReadyToPlay = false;
        this._isDirectional = false;
        this._coneInnerAngle = 360;
        this._coneOuterAngle = 360;
        this._coneOuterGain = 0;
        this._isOutputConnected = false;
        this._urlType = "Unknown";
        this.name = name109;
        scene = scene || EngineStore.LastCreatedScene;
        if (!scene) {
          return;
        }
        this._scene = scene;
        Sound._SceneComponentInitialization(scene);
        this._readyToPlayCallback = readyToPlayCallback;
        this._customAttenuationFunction = (currentVolume, currentDistance, maxDistance, refDistance, rolloffFactor) => {
          if (currentDistance < maxDistance) {
            return currentVolume * (1 - currentDistance / maxDistance);
          } else {
            return 0;
          }
        };
        if (options) {
          this.autoplay = options.autoplay || false;
          this._loop = options.loop || false;
          if (options.volume !== void 0) {
            this._volume = options.volume;
          }
          this._spatialSound = (_a = options.spatialSound) !== null && _a !== void 0 ? _a : false;
          this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : 100;
          this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : false;
          this.rolloffFactor = options.rolloffFactor || 1;
          this.refDistance = options.refDistance || 1;
          this.distanceModel = options.distanceModel || "linear";
          this._playbackRate = options.playbackRate || 1;
          this._streaming = (_d = options.streaming) !== null && _d !== void 0 ? _d : false;
          this._length = options.length;
          this._offset = options.offset;
        }
        if (((_e = Engine.audioEngine) === null || _e === void 0 ? void 0 : _e.canUseWebAudio) && Engine.audioEngine.audioContext) {
          this._soundGain = Engine.audioEngine.audioContext.createGain();
          this._soundGain.gain.value = this._volume;
          this._inputAudioNode = this._soundGain;
          this._outputAudioNode = this._soundGain;
          if (this._spatialSound) {
            this._createSpatialParameters();
          }
          this._scene.mainSoundTrack.addSound(this);
          let validParameter = true;
          if (urlOrArrayBuffer) {
            try {
              if (typeof urlOrArrayBuffer === "string") {
                this._urlType = "String";
                this._url = urlOrArrayBuffer;
              } else if (urlOrArrayBuffer instanceof ArrayBuffer) {
                this._urlType = "ArrayBuffer";
              } else if (urlOrArrayBuffer instanceof HTMLMediaElement) {
                this._urlType = "MediaElement";
              } else if (urlOrArrayBuffer instanceof MediaStream) {
                this._urlType = "MediaStream";
              } else if (urlOrArrayBuffer instanceof AudioBuffer) {
                this._urlType = "AudioBuffer";
              } else if (Array.isArray(urlOrArrayBuffer)) {
                this._urlType = "Array";
              }
              let urls = [];
              let codecSupportedFound = false;
              switch (this._urlType) {
                case "MediaElement":
                  this._streaming = true;
                  this._isReadyToPlay = true;
                  this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(urlOrArrayBuffer);
                  if (this.autoplay) {
                    this.play(0, this._offset, this._length);
                  }
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                  break;
                case "MediaStream":
                  this._streaming = true;
                  this._isReadyToPlay = true;
                  this._streamingSource = Engine.audioEngine.audioContext.createMediaStreamSource(urlOrArrayBuffer);
                  if (this.autoplay) {
                    this.play(0, this._offset, this._length);
                  }
                  if (this._readyToPlayCallback) {
                    this._readyToPlayCallback();
                  }
                  break;
                case "ArrayBuffer":
                  if (urlOrArrayBuffer.byteLength > 0) {
                    codecSupportedFound = true;
                    this._soundLoaded(urlOrArrayBuffer);
                  }
                  break;
                case "AudioBuffer":
                  this._audioBufferLoaded(urlOrArrayBuffer);
                  break;
                case "String":
                  urls.push(urlOrArrayBuffer);
                case "Array":
                  if (urls.length === 0) {
                    urls = urlOrArrayBuffer;
                  }
                  for (let i = 0; i < urls.length; i++) {
                    const url = urls[i];
                    codecSupportedFound = options && options.skipCodecCheck || url.indexOf(".mp3", url.length - 4) !== -1 && Engine.audioEngine.isMP3supported || url.indexOf(".ogg", url.length - 4) !== -1 && Engine.audioEngine.isOGGsupported || url.indexOf(".wav", url.length - 4) !== -1 || url.indexOf(".m4a", url.length - 4) !== -1 || url.indexOf(".mp4", url.length - 4) !== -1 || url.indexOf("blob:") !== -1;
                    if (codecSupportedFound) {
                      if (!this._streaming) {
                        this._scene._loadFile(url, (data) => {
                          this._soundLoaded(data);
                        }, void 0, true, true, (exception) => {
                          if (exception) {
                            Logger.Error("XHR " + exception.status + " error on: " + url + ".");
                          }
                          Logger.Error("Sound creation aborted.");
                          this._scene.mainSoundTrack.removeSound(this);
                        });
                      } else {
                        this._htmlAudioElement = new Audio(url);
                        this._htmlAudioElement.controls = false;
                        this._htmlAudioElement.loop = this.loop;
                        Tools.SetCorsBehavior(url, this._htmlAudioElement);
                        this._htmlAudioElement.preload = "auto";
                        this._htmlAudioElement.addEventListener("canplaythrough", () => {
                          this._isReadyToPlay = true;
                          if (this.autoplay) {
                            this.play(0, this._offset, this._length);
                          }
                          if (this._readyToPlayCallback) {
                            this._readyToPlayCallback();
                          }
                        });
                        document.body.appendChild(this._htmlAudioElement);
                        this._htmlAudioElement.load();
                      }
                      break;
                    }
                  }
                  break;
                default:
                  validParameter = false;
                  break;
              }
              if (!validParameter) {
                Logger.Error("Parameter must be a URL to the sound, an Array of URLs (.mp3 & .ogg) or an ArrayBuffer of the sound.");
              } else {
                if (!codecSupportedFound) {
                  this._isReadyToPlay = true;
                  if (this._readyToPlayCallback) {
                    setTimeout(() => {
                      if (this._readyToPlayCallback) {
                        this._readyToPlayCallback();
                      }
                    }, 1e3);
                  }
                }
              }
            } catch (ex) {
              Logger.Error("Unexpected error. Sound creation aborted.");
              this._scene.mainSoundTrack.removeSound(this);
            }
          }
        } else {
          this._scene.mainSoundTrack.addSound(this);
          if (Engine.audioEngine && !Engine.audioEngine.WarnedWebAudioUnsupported) {
            Logger.Error("Web Audio is not supported by your browser.");
            Engine.audioEngine.WarnedWebAudioUnsupported = true;
          }
          if (this._readyToPlayCallback) {
            setTimeout(() => {
              if (this._readyToPlayCallback) {
                this._readyToPlayCallback();
              }
            }, 1e3);
          }
        }
      }
      dispose() {
        var _a;
        if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
          if (this.isPlaying) {
            this.stop();
          }
          this._isReadyToPlay = false;
          if (this.soundTrackId === -1) {
            this._scene.mainSoundTrack.removeSound(this);
          } else if (this._scene.soundTracks) {
            this._scene.soundTracks[this.soundTrackId].removeSound(this);
          }
          if (this._soundGain) {
            this._soundGain.disconnect();
            this._soundGain = null;
          }
          if (this._soundPanner) {
            this._soundPanner.disconnect();
            this._soundPanner = null;
          }
          if (this._soundSource) {
            this._soundSource.disconnect();
            this._soundSource = null;
          }
          this._audioBuffer = null;
          if (this._htmlAudioElement) {
            this._htmlAudioElement.pause();
            this._htmlAudioElement.src = "";
            document.body.removeChild(this._htmlAudioElement);
          }
          if (this._streamingSource) {
            this._streamingSource.disconnect();
          }
          if (this._connectedTransformNode && this._registerFunc) {
            this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
            this._connectedTransformNode = null;
          }
          this._clearTimeoutsAndObservers();
        }
      }
      isReady() {
        return this._isReadyToPlay;
      }
      getClassName() {
        return "Sound";
      }
      _audioBufferLoaded(buffer) {
        var _a;
        if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {
          return;
        }
        this._audioBuffer = buffer;
        this._isReadyToPlay = true;
        if (this.autoplay) {
          this.play(0, this._offset, this._length);
        }
        if (this._readyToPlayCallback) {
          this._readyToPlayCallback();
        }
      }
      _soundLoaded(audioData) {
        var _a;
        if (!((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {
          return;
        }
        Engine.audioEngine.audioContext.decodeAudioData(audioData, (buffer) => {
          this._audioBufferLoaded(buffer);
        }, (err) => {
          Logger.Error("Error while decoding audio data for: " + this.name + " / Error: " + err);
        });
      }
      setAudioBuffer(audioBuffer) {
        var _a;
        if ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) {
          this._audioBuffer = audioBuffer;
          this._isReadyToPlay = true;
        }
      }
      updateOptions(options) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l;
        if (options) {
          this.loop = (_a = options.loop) !== null && _a !== void 0 ? _a : this.loop;
          this.maxDistance = (_b = options.maxDistance) !== null && _b !== void 0 ? _b : this.maxDistance;
          this.useCustomAttenuation = (_c = options.useCustomAttenuation) !== null && _c !== void 0 ? _c : this.useCustomAttenuation;
          this.rolloffFactor = (_d = options.rolloffFactor) !== null && _d !== void 0 ? _d : this.rolloffFactor;
          this.refDistance = (_e = options.refDistance) !== null && _e !== void 0 ? _e : this.refDistance;
          this.distanceModel = (_f = options.distanceModel) !== null && _f !== void 0 ? _f : this.distanceModel;
          this._playbackRate = (_g = options.playbackRate) !== null && _g !== void 0 ? _g : this._playbackRate;
          this._length = (_h = options.length) !== null && _h !== void 0 ? _h : void 0;
          this.spatialSound = (_j = options.spatialSound) !== null && _j !== void 0 ? _j : this._spatialSound;
          this._setOffset((_k = options.offset) !== null && _k !== void 0 ? _k : void 0);
          this.setVolume((_l = options.volume) !== null && _l !== void 0 ? _l : this._volume);
          this._updateSpatialParameters();
          if (this.isPlaying) {
            if (this._streaming && this._htmlAudioElement) {
              this._htmlAudioElement.playbackRate = this._playbackRate;
              if (this._htmlAudioElement.loop !== this.loop) {
                this._htmlAudioElement.loop = this.loop;
              }
            } else {
              if (this._soundSource) {
                this._soundSource.playbackRate.value = this._playbackRate;
                if (this._soundSource.loop !== this.loop) {
                  this._soundSource.loop = this.loop;
                }
                if (this._offset !== void 0 && this._soundSource.loopStart !== this._offset) {
                  this._soundSource.loopStart = this._offset;
                }
                if (this._length !== void 0 && this._length !== this._soundSource.loopEnd) {
                  this._soundSource.loopEnd = (this._offset | 0) + this._length;
                }
              }
            }
          }
        }
      }
      _createSpatialParameters() {
        var _a, _b;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && Engine.audioEngine.audioContext) {
          if (this._scene.headphone) {
            this._panningModel = "HRTF";
          }
          this._soundPanner = (_b = this._soundPanner) !== null && _b !== void 0 ? _b : Engine.audioEngine.audioContext.createPanner();
          if (this._soundPanner && this._outputAudioNode) {
            this._updateSpatialParameters();
            this._soundPanner.connect(this._outputAudioNode);
            this._inputAudioNode = this._soundPanner;
          }
        }
      }
      _disableSpatialSound() {
        var _a;
        if (!this._spatialSound) {
          return;
        }
        this._inputAudioNode = this._soundGain;
        (_a = this._soundPanner) === null || _a === void 0 ? void 0 : _a.disconnect();
        this._soundPanner = null;
        this._spatialSound = false;
      }
      _updateSpatialParameters() {
        if (!this._spatialSound) {
          return;
        }
        if (this._soundPanner) {
          if (this.useCustomAttenuation) {
            this._soundPanner.distanceModel = "linear";
            this._soundPanner.maxDistance = Number.MAX_VALUE;
            this._soundPanner.refDistance = 1;
            this._soundPanner.rolloffFactor = 1;
            this._soundPanner.panningModel = this._panningModel;
          } else {
            this._soundPanner.distanceModel = this.distanceModel;
            this._soundPanner.maxDistance = this.maxDistance;
            this._soundPanner.refDistance = this.refDistance;
            this._soundPanner.rolloffFactor = this.rolloffFactor;
            this._soundPanner.panningModel = this._panningModel;
          }
        } else {
          this._createSpatialParameters();
        }
      }
      switchPanningModelToHRTF() {
        this._panningModel = "HRTF";
        this._switchPanningModel();
      }
      switchPanningModelToEqualPower() {
        this._panningModel = "equalpower";
        this._switchPanningModel();
      }
      _switchPanningModel() {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
          this._soundPanner.panningModel = this._panningModel;
        }
      }
      connectToSoundTrackAudioNode(soundTrackAudioNode) {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._outputAudioNode) {
          if (this._isOutputConnected) {
            this._outputAudioNode.disconnect();
          }
          this._outputAudioNode.connect(soundTrackAudioNode);
          this._isOutputConnected = true;
        }
      }
      setDirectionalCone(coneInnerAngle, coneOuterAngle, coneOuterGain) {
        if (coneOuterAngle < coneInnerAngle) {
          Logger.Error("setDirectionalCone(): outer angle of the cone must be superior or equal to the inner angle.");
          return;
        }
        this._coneInnerAngle = coneInnerAngle;
        this._coneOuterAngle = coneOuterAngle;
        this._coneOuterGain = coneOuterGain;
        this._isDirectional = true;
        if (this.isPlaying && this.loop) {
          this.stop();
          this.play(0, this._offset, this._length);
        }
      }
      get directionalConeInnerAngle() {
        return this._coneInnerAngle;
      }
      set directionalConeInnerAngle(value) {
        var _a;
        if (value != this._coneInnerAngle) {
          if (this._coneOuterAngle < value) {
            Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneInnerAngle = value;
          if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
            this._soundPanner.coneInnerAngle = this._coneInnerAngle;
          }
        }
      }
      get directionalConeOuterAngle() {
        return this._coneOuterAngle;
      }
      set directionalConeOuterAngle(value) {
        var _a;
        if (value != this._coneOuterAngle) {
          if (value < this._coneInnerAngle) {
            Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneOuterAngle = value;
          if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner) {
            this._soundPanner.coneOuterAngle = this._coneOuterAngle;
          }
        }
      }
      setPosition(newPosition) {
        var _a;
        if (newPosition.equals(this._position)) {
          return;
        }
        this._position.copyFrom(newPosition);
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._spatialSound && this._soundPanner && !isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
          this._soundPanner.positionX.value = this._position.x;
          this._soundPanner.positionY.value = this._position.y;
          this._soundPanner.positionZ.value = this._position.z;
        }
      }
      setLocalDirectionToMesh(newLocalDirection) {
        var _a;
        this._localDirection = newLocalDirection;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.isPlaying) {
          this._updateDirection();
        }
      }
      _updateDirection() {
        if (!this._connectedTransformNode || !this._soundPanner) {
          return;
        }
        const mat = this._connectedTransformNode.getWorldMatrix();
        const direction = Vector3.TransformNormal(this._localDirection, mat);
        direction.normalize();
        this._soundPanner.orientationX.value = direction.x;
        this._soundPanner.orientationY.value = direction.y;
        this._soundPanner.orientationZ.value = direction.z;
      }
      updateDistanceFromListener() {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._connectedTransformNode && this.useCustomAttenuation && this._soundGain && this._scene.activeCamera) {
          const distance = this._scene.audioListenerPositionProvider ? this._connectedTransformNode.position.subtract(this._scene.audioListenerPositionProvider()).length() : this._connectedTransformNode.getDistanceToCamera(this._scene.activeCamera);
          this._soundGain.gain.value = this._customAttenuationFunction(this._volume, distance, this.maxDistance, this.refDistance, this.rolloffFactor);
        }
      }
      setAttenuationFunction(callback) {
        this._customAttenuationFunction = callback;
      }
      play(time, offset, length) {
        var _a, _b, _c, _d;
        if (this._isReadyToPlay && this._scene.audioEnabled && ((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext)) {
          try {
            this._clearTimeoutsAndObservers();
            let startTime = time ? ((_b = Engine.audioEngine) === null || _b === void 0 ? void 0 : _b.audioContext.currentTime) + time : (_c = Engine.audioEngine) === null || _c === void 0 ? void 0 : _c.audioContext.currentTime;
            if (!this._soundSource || !this._streamingSource) {
              if (this._spatialSound && this._soundPanner) {
                if (!isNaN(this._position.x) && !isNaN(this._position.y) && !isNaN(this._position.z)) {
                  this._soundPanner.positionX.value = this._position.x;
                  this._soundPanner.positionY.value = this._position.y;
                  this._soundPanner.positionZ.value = this._position.z;
                }
                if (this._isDirectional) {
                  this._soundPanner.coneInnerAngle = this._coneInnerAngle;
                  this._soundPanner.coneOuterAngle = this._coneOuterAngle;
                  this._soundPanner.coneOuterGain = this._coneOuterGain;
                  if (this._connectedTransformNode) {
                    this._updateDirection();
                  } else {
                    this._soundPanner.setOrientation(this._localDirection.x, this._localDirection.y, this._localDirection.z);
                  }
                }
              }
            }
            if (this._streaming) {
              if (!this._streamingSource) {
                this._streamingSource = Engine.audioEngine.audioContext.createMediaElementSource(this._htmlAudioElement);
                this._htmlAudioElement.onended = () => {
                  this._onended();
                };
                this._htmlAudioElement.playbackRate = this._playbackRate;
              }
              this._streamingSource.disconnect();
              if (this._inputAudioNode) {
                this._streamingSource.connect(this._inputAudioNode);
              }
              if (this._htmlAudioElement) {
                const tryToPlay = () => {
                  var _a2, _b2;
                  if ((_a2 = Engine.audioEngine) === null || _a2 === void 0 ? void 0 : _a2.unlocked) {
                    const playPromise = this._htmlAudioElement.play();
                    if (playPromise !== void 0) {
                      playPromise.catch(() => {
                        var _a3, _b3;
                        (_a3 = Engine.audioEngine) === null || _a3 === void 0 ? void 0 : _a3.lock();
                        if (this.loop || this.autoplay) {
                          this._audioUnlockedObserver = (_b3 = Engine.audioEngine) === null || _b3 === void 0 ? void 0 : _b3.onAudioUnlockedObservable.addOnce(() => {
                            tryToPlay();
                          });
                        }
                      });
                    }
                  } else {
                    if (this.loop || this.autoplay) {
                      this._audioUnlockedObserver = (_b2 = Engine.audioEngine) === null || _b2 === void 0 ? void 0 : _b2.onAudioUnlockedObservable.addOnce(() => {
                        tryToPlay();
                      });
                    }
                  }
                };
                tryToPlay();
              }
            } else {
              const tryToPlay = () => {
                var _a2, _b2, _c2, _d2;
                if ((_a2 = Engine.audioEngine) === null || _a2 === void 0 ? void 0 : _a2.audioContext) {
                  length = length || this._length;
                  if (offset !== void 0) {
                    this._setOffset(offset);
                  }
                  if (this._soundSource) {
                    const oldSource = this._soundSource;
                    oldSource.onended = () => {
                      oldSource.disconnect();
                    };
                  }
                  this._soundSource = (_b2 = Engine.audioEngine) === null || _b2 === void 0 ? void 0 : _b2.audioContext.createBufferSource();
                  if (this._soundSource && this._inputAudioNode) {
                    this._soundSource.buffer = this._audioBuffer;
                    this._soundSource.connect(this._inputAudioNode);
                    this._soundSource.loop = this.loop;
                    if (offset !== void 0) {
                      this._soundSource.loopStart = offset;
                    }
                    if (length !== void 0) {
                      this._soundSource.loopEnd = (offset | 0) + length;
                    }
                    this._soundSource.playbackRate.value = this._playbackRate;
                    this._soundSource.onended = () => {
                      this._onended();
                    };
                    startTime = time ? ((_c2 = Engine.audioEngine) === null || _c2 === void 0 ? void 0 : _c2.audioContext.currentTime) + time : Engine.audioEngine.audioContext.currentTime;
                    const actualOffset = ((this.isPaused ? this.currentTime : 0) + ((_d2 = this._offset) !== null && _d2 !== void 0 ? _d2 : 0)) % this._soundSource.buffer.duration;
                    this._soundSource.start(startTime, actualOffset, this.loop ? void 0 : length);
                  }
                }
              };
              if (((_d = Engine.audioEngine) === null || _d === void 0 ? void 0 : _d.audioContext.state) === "suspended") {
                this._tryToPlayTimeout = setTimeout(() => {
                  var _a2;
                  if (((_a2 = Engine.audioEngine) === null || _a2 === void 0 ? void 0 : _a2.audioContext.state) === "suspended") {
                    Engine.audioEngine.lock();
                    if (this.loop || this.autoplay) {
                      this._audioUnlockedObserver = Engine.audioEngine.onAudioUnlockedObservable.addOnce(() => {
                        tryToPlay();
                      });
                    }
                  } else {
                    tryToPlay();
                  }
                }, 500);
              } else {
                tryToPlay();
              }
            }
            this._startTime = startTime;
            this.isPlaying = true;
            this.isPaused = false;
          } catch (ex) {
            Logger.Error("Error while trying to play audio: " + this.name + ", " + ex.message);
          }
        }
      }
      _onended() {
        this.isPlaying = false;
        this._startTime = 0;
        this._currentTime = 0;
        if (this.onended) {
          this.onended();
        }
        this.onEndedObservable.notifyObservers(this);
      }
      stop(time) {
        var _a;
        if (this.isPlaying) {
          this._clearTimeoutsAndObservers();
          if (this._streaming) {
            if (this._htmlAudioElement) {
              this._htmlAudioElement.pause();
              if (this._htmlAudioElement.currentTime > 0) {
                this._htmlAudioElement.currentTime = 0;
              }
            } else {
              this._streamingSource.disconnect();
            }
            this.isPlaying = false;
          } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {
            const stopTime = time ? Engine.audioEngine.audioContext.currentTime + time : void 0;
            this._soundSource.onended = () => {
              this.isPlaying = false;
              this.isPaused = false;
              this._startTime = 0;
              this._currentTime = 0;
              if (this._soundSource) {
                this._soundSource.onended = () => void 0;
              }
              this._onended();
            };
            this._soundSource.stop(stopTime);
          } else {
            this.isPlaying = false;
          }
        } else if (this.isPaused) {
          this.isPaused = false;
          this._startTime = 0;
          this._currentTime = 0;
        }
      }
      pause() {
        var _a;
        if (this.isPlaying) {
          this._clearTimeoutsAndObservers();
          if (this._streaming) {
            if (this._htmlAudioElement) {
              this._htmlAudioElement.pause();
            } else {
              this._streamingSource.disconnect();
            }
            this.isPlaying = false;
            this.isPaused = true;
          } else if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.audioContext) && this._soundSource) {
            this._soundSource.onended = () => void 0;
            this._soundSource.stop();
            this.isPlaying = false;
            this.isPaused = true;
            this._currentTime += Engine.audioEngine.audioContext.currentTime - this._startTime;
          }
        }
      }
      setVolume(newVolume, time) {
        var _a;
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._soundGain) {
          if (time && Engine.audioEngine.audioContext) {
            this._soundGain.gain.cancelScheduledValues(Engine.audioEngine.audioContext.currentTime);
            this._soundGain.gain.setValueAtTime(this._soundGain.gain.value, Engine.audioEngine.audioContext.currentTime);
            this._soundGain.gain.linearRampToValueAtTime(newVolume, Engine.audioEngine.audioContext.currentTime + time);
          } else {
            this._soundGain.gain.value = newVolume;
          }
        }
        this._volume = newVolume;
      }
      setPlaybackRate(newPlaybackRate) {
        this._playbackRate = newPlaybackRate;
        if (this.isPlaying) {
          if (this._streaming && this._htmlAudioElement) {
            this._htmlAudioElement.playbackRate = this._playbackRate;
          } else if (this._soundSource) {
            this._soundSource.playbackRate.value = this._playbackRate;
          }
        }
      }
      getPlaybackRate() {
        return this._playbackRate;
      }
      getVolume() {
        return this._volume;
      }
      attachToMesh(transformNode) {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
        }
        this._connectedTransformNode = transformNode;
        if (!this._spatialSound) {
          this._spatialSound = true;
          this._createSpatialParameters();
          if (this.isPlaying && this.loop) {
            this.stop();
            this.play(0, this._offset, this._length);
          }
        }
        this._onRegisterAfterWorldMatrixUpdate(this._connectedTransformNode);
        this._registerFunc = (transformNode2) => this._onRegisterAfterWorldMatrixUpdate(transformNode2);
        this._connectedTransformNode.registerAfterWorldMatrixUpdate(this._registerFunc);
      }
      detachFromMesh() {
        if (this._connectedTransformNode && this._registerFunc) {
          this._connectedTransformNode.unregisterAfterWorldMatrixUpdate(this._registerFunc);
          this._registerFunc = null;
          this._connectedTransformNode = null;
        }
      }
      _onRegisterAfterWorldMatrixUpdate(node) {
        var _a;
        if (!node.getBoundingInfo) {
          this.setPosition(node.absolutePosition);
        } else {
          const mesh = node;
          const boundingInfo = mesh.getBoundingInfo();
          this.setPosition(boundingInfo.boundingSphere.centerWorld);
        }
        if (((_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.canUseWebAudio) && this._isDirectional && this.isPlaying) {
          this._updateDirection();
        }
      }
      clone() {
        if (!this._streaming) {
          const setBufferAndRun = () => {
            if (this._isReadyToPlay) {
              clonedSound._audioBuffer = this.getAudioBuffer();
              clonedSound._isReadyToPlay = true;
              if (clonedSound.autoplay) {
                clonedSound.play(0, this._offset, this._length);
              }
            } else {
              setTimeout(setBufferAndRun, 300);
            }
          };
          const currentOptions = {
            autoplay: this.autoplay,
            loop: this.loop,
            volume: this._volume,
            spatialSound: this._spatialSound,
            maxDistance: this.maxDistance,
            useCustomAttenuation: this.useCustomAttenuation,
            rolloffFactor: this.rolloffFactor,
            refDistance: this.refDistance,
            distanceModel: this.distanceModel
          };
          const clonedSound = new Sound(this.name + "_cloned", new ArrayBuffer(0), this._scene, null, currentOptions);
          if (this.useCustomAttenuation) {
            clonedSound.setAttenuationFunction(this._customAttenuationFunction);
          }
          clonedSound.setPosition(this._position);
          clonedSound.setPlaybackRate(this._playbackRate);
          setBufferAndRun();
          return clonedSound;
        } else {
          return null;
        }
      }
      getAudioBuffer() {
        return this._audioBuffer;
      }
      getSoundSource() {
        return this._soundSource;
      }
      getSoundGain() {
        return this._soundGain;
      }
      serialize() {
        const serializationObject = {
          name: this.name,
          url: this._url,
          autoplay: this.autoplay,
          loop: this.loop,
          volume: this._volume,
          spatialSound: this._spatialSound,
          maxDistance: this.maxDistance,
          rolloffFactor: this.rolloffFactor,
          refDistance: this.refDistance,
          distanceModel: this.distanceModel,
          playbackRate: this._playbackRate,
          panningModel: this._panningModel,
          soundTrackId: this.soundTrackId,
          metadata: this.metadata
        };
        if (this._spatialSound) {
          if (this._connectedTransformNode) {
            serializationObject.connectedMeshId = this._connectedTransformNode.id;
          }
          serializationObject.position = this._position.asArray();
          serializationObject.refDistance = this.refDistance;
          serializationObject.distanceModel = this.distanceModel;
          serializationObject.isDirectional = this._isDirectional;
          serializationObject.localDirectionToMesh = this._localDirection.asArray();
          serializationObject.coneInnerAngle = this._coneInnerAngle;
          serializationObject.coneOuterAngle = this._coneOuterAngle;
          serializationObject.coneOuterGain = this._coneOuterGain;
        }
        return serializationObject;
      }
      static Parse(parsedSound, scene, rootUrl, sourceSound) {
        const soundName = parsedSound.name;
        let soundUrl;
        if (parsedSound.url) {
          soundUrl = rootUrl + parsedSound.url;
        } else {
          soundUrl = rootUrl + soundName;
        }
        const options = {
          autoplay: parsedSound.autoplay,
          loop: parsedSound.loop,
          volume: parsedSound.volume,
          spatialSound: parsedSound.spatialSound,
          maxDistance: parsedSound.maxDistance,
          rolloffFactor: parsedSound.rolloffFactor,
          refDistance: parsedSound.refDistance,
          distanceModel: parsedSound.distanceModel,
          playbackRate: parsedSound.playbackRate
        };
        let newSound;
        if (!sourceSound) {
          newSound = new Sound(soundName, soundUrl, scene, () => {
            scene.removePendingData(newSound);
          }, options);
          scene.addPendingData(newSound);
        } else {
          const setBufferAndRun = () => {
            if (sourceSound._isReadyToPlay) {
              newSound._audioBuffer = sourceSound.getAudioBuffer();
              newSound._isReadyToPlay = true;
              if (newSound.autoplay) {
                newSound.play(0, newSound._offset, newSound._length);
              }
            } else {
              setTimeout(setBufferAndRun, 300);
            }
          };
          newSound = new Sound(soundName, new ArrayBuffer(0), scene, null, options);
          setBufferAndRun();
        }
        if (parsedSound.position) {
          const soundPosition = Vector3.FromArray(parsedSound.position);
          newSound.setPosition(soundPosition);
        }
        if (parsedSound.isDirectional) {
          newSound.setDirectionalCone(parsedSound.coneInnerAngle || 360, parsedSound.coneOuterAngle || 360, parsedSound.coneOuterGain || 0);
          if (parsedSound.localDirectionToMesh) {
            const localDirectionToMesh = Vector3.FromArray(parsedSound.localDirectionToMesh);
            newSound.setLocalDirectionToMesh(localDirectionToMesh);
          }
        }
        if (parsedSound.connectedMeshId) {
          const connectedMesh = scene.getMeshById(parsedSound.connectedMeshId);
          if (connectedMesh) {
            newSound.attachToMesh(connectedMesh);
          }
        }
        if (parsedSound.metadata) {
          newSound.metadata = parsedSound.metadata;
        }
        return newSound;
      }
      _setOffset(value) {
        if (this._offset === value) {
          return;
        }
        if (this.isPaused) {
          this.stop();
          this.isPaused = false;
        }
        this._offset = value;
      }
      _clearTimeoutsAndObservers() {
        var _a;
        if (this._tryToPlayTimeout) {
          clearTimeout(this._tryToPlayTimeout);
          this._tryToPlayTimeout = null;
        }
        if (this._audioUnlockedObserver) {
          (_a = Engine.audioEngine) === null || _a === void 0 ? void 0 : _a.onAudioUnlockedObservable.remove(this._audioUnlockedObserver);
          this._audioUnlockedObserver = null;
        }
      }
    };
    Sound._SceneComponentInitialization = (_) => {
      throw _WarnImport("AudioSceneComponent");
    };
  }
});

// node_modules/@babylonjs/core/Audio/weightedsound.js
var WeightedSound;
var init_weightedsound = __esm({
  "node_modules/@babylonjs/core/Audio/weightedsound.js"() {
    init_logger();
    WeightedSound = class {
      constructor(loop, sounds, weights) {
        this.loop = false;
        this._coneInnerAngle = 360;
        this._coneOuterAngle = 360;
        this._volume = 1;
        this.isPlaying = false;
        this.isPaused = false;
        this._sounds = [];
        this._weights = [];
        if (sounds.length !== weights.length) {
          throw new Error("Sounds length does not equal weights length");
        }
        this.loop = loop;
        this._weights = weights;
        let weightSum = 0;
        for (const weight of weights) {
          weightSum += weight;
        }
        const invWeightSum = weightSum > 0 ? 1 / weightSum : 0;
        for (let i = 0; i < this._weights.length; i++) {
          this._weights[i] *= invWeightSum;
        }
        this._sounds = sounds;
        for (const sound of this._sounds) {
          sound.onEndedObservable.add(() => {
            this._onended();
          });
        }
      }
      get directionalConeInnerAngle() {
        return this._coneInnerAngle;
      }
      set directionalConeInnerAngle(value) {
        if (value !== this._coneInnerAngle) {
          if (this._coneOuterAngle < value) {
            Logger.Error("directionalConeInnerAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneInnerAngle = value;
          for (const sound of this._sounds) {
            sound.directionalConeInnerAngle = value;
          }
        }
      }
      get directionalConeOuterAngle() {
        return this._coneOuterAngle;
      }
      set directionalConeOuterAngle(value) {
        if (value !== this._coneOuterAngle) {
          if (value < this._coneInnerAngle) {
            Logger.Error("directionalConeOuterAngle: outer angle of the cone must be superior or equal to the inner angle.");
            return;
          }
          this._coneOuterAngle = value;
          for (const sound of this._sounds) {
            sound.directionalConeOuterAngle = value;
          }
        }
      }
      get volume() {
        return this._volume;
      }
      set volume(value) {
        if (value !== this._volume) {
          for (const sound of this._sounds) {
            sound.setVolume(value);
          }
        }
      }
      _onended() {
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].autoplay = false;
        }
        if (this.loop && this.isPlaying) {
          this.play();
        } else {
          this.isPlaying = false;
        }
      }
      pause() {
        this.isPaused = true;
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].pause();
        }
      }
      stop() {
        this.isPlaying = false;
        if (this._currentIndex !== void 0) {
          this._sounds[this._currentIndex].stop();
        }
      }
      play(startOffset) {
        if (!this.isPaused) {
          this.stop();
          const randomValue = Math.random();
          let total = 0;
          for (let i = 0; i < this._weights.length; i++) {
            total += this._weights[i];
            if (randomValue <= total) {
              this._currentIndex = i;
              break;
            }
          }
        }
        const sound = this._sounds[this._currentIndex];
        if (sound.isReady()) {
          sound.play(0, this.isPaused ? void 0 : startOffset);
        } else {
          sound.autoplay = true;
        }
        this.isPlaying = true;
        this.isPaused = false;
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/thinTexture.js
var ThinTexture;
var init_thinTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/thinTexture.js"() {
    init_math_size();
    ThinTexture = class {
      get wrapU() {
        return this._wrapU;
      }
      set wrapU(value) {
        this._wrapU = value;
      }
      get wrapV() {
        return this._wrapV;
      }
      set wrapV(value) {
        this._wrapV = value;
      }
      get coordinatesMode() {
        return 0;
      }
      get isCube() {
        if (!this._texture) {
          return false;
        }
        return this._texture.isCube;
      }
      set isCube(value) {
        if (!this._texture) {
          return;
        }
        this._texture.isCube = value;
      }
      get is3D() {
        if (!this._texture) {
          return false;
        }
        return this._texture.is3D;
      }
      set is3D(value) {
        if (!this._texture) {
          return;
        }
        this._texture.is3D = value;
      }
      get is2DArray() {
        if (!this._texture) {
          return false;
        }
        return this._texture.is2DArray;
      }
      set is2DArray(value) {
        if (!this._texture) {
          return;
        }
        this._texture.is2DArray = value;
      }
      getClassName() {
        return "ThinTexture";
      }
      static _IsRenderTargetWrapper(texture) {
        return (texture === null || texture === void 0 ? void 0 : texture._shareDepth) !== void 0;
      }
      constructor(internalTexture) {
        this._wrapU = 1;
        this._wrapV = 1;
        this.wrapR = 1;
        this.anisotropicFilteringLevel = 4;
        this.delayLoadState = 0;
        this._texture = null;
        this._engine = null;
        this._cachedSize = Size.Zero();
        this._cachedBaseSize = Size.Zero();
        this._initialSamplingMode = 2;
        this._texture = ThinTexture._IsRenderTargetWrapper(internalTexture) ? internalTexture.texture : internalTexture;
        if (this._texture) {
          this._engine = this._texture.getEngine();
        }
      }
      isReady() {
        if (this.delayLoadState === 4) {
          this.delayLoad();
          return false;
        }
        if (this._texture) {
          return this._texture.isReady;
        }
        return false;
      }
      delayLoad() {
      }
      getInternalTexture() {
        return this._texture;
      }
      getSize() {
        if (this._texture) {
          if (this._texture.width) {
            this._cachedSize.width = this._texture.width;
            this._cachedSize.height = this._texture.height;
            return this._cachedSize;
          }
          if (this._texture._size) {
            this._cachedSize.width = this._texture._size;
            this._cachedSize.height = this._texture._size;
            return this._cachedSize;
          }
        }
        return this._cachedSize;
      }
      getBaseSize() {
        if (!this.isReady() || !this._texture) {
          this._cachedBaseSize.width = 0;
          this._cachedBaseSize.height = 0;
          return this._cachedBaseSize;
        }
        if (this._texture._size) {
          this._cachedBaseSize.width = this._texture._size;
          this._cachedBaseSize.height = this._texture._size;
          return this._cachedBaseSize;
        }
        this._cachedBaseSize.width = this._texture.baseWidth;
        this._cachedBaseSize.height = this._texture.baseHeight;
        return this._cachedBaseSize;
      }
      get samplingMode() {
        if (!this._texture) {
          return this._initialSamplingMode;
        }
        return this._texture.samplingMode;
      }
      updateSamplingMode(samplingMode) {
        if (this._texture && this._engine) {
          this._engine.updateTextureSamplingMode(samplingMode, this._texture);
        }
      }
      releaseInternalTexture() {
        if (this._texture) {
          this._texture.dispose();
          this._texture = null;
        }
      }
      dispose() {
        if (this._texture) {
          this.releaseInternalTexture();
          this._engine = null;
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.js
var BaseTexture;
var init_baseTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/baseTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_engineStore();
    init_guid();
    init_fileTools();
    init_thinTexture();
    BaseTexture = class extends ThinTexture {
      set hasAlpha(value) {
        if (this._hasAlpha === value) {
          return;
        }
        this._hasAlpha = value;
        if (this._scene) {
          this._scene.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
          });
        }
      }
      get hasAlpha() {
        return this._hasAlpha;
      }
      set getAlphaFromRGB(value) {
        if (this._getAlphaFromRGB === value) {
          return;
        }
        this._getAlphaFromRGB = value;
        if (this._scene) {
          this._scene.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
          });
        }
      }
      get getAlphaFromRGB() {
        return this._getAlphaFromRGB;
      }
      set coordinatesIndex(value) {
        if (this._coordinatesIndex === value) {
          return;
        }
        this._coordinatesIndex = value;
        if (this._scene) {
          this._scene.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
          });
        }
      }
      get coordinatesIndex() {
        return this._coordinatesIndex;
      }
      set coordinatesMode(value) {
        if (this._coordinatesMode === value) {
          return;
        }
        this._coordinatesMode = value;
        if (this._scene) {
          this._scene.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
          });
        }
      }
      get coordinatesMode() {
        return this._coordinatesMode;
      }
      get wrapU() {
        return this._wrapU;
      }
      set wrapU(value) {
        this._wrapU = value;
      }
      get wrapV() {
        return this._wrapV;
      }
      set wrapV(value) {
        this._wrapV = value;
      }
      get isCube() {
        if (!this._texture) {
          return this._isCube;
        }
        return this._texture.isCube;
      }
      set isCube(value) {
        if (!this._texture) {
          this._isCube = value;
        } else {
          this._texture.isCube = value;
        }
      }
      get is3D() {
        if (!this._texture) {
          return false;
        }
        return this._texture.is3D;
      }
      set is3D(value) {
        if (!this._texture) {
          return;
        }
        this._texture.is3D = value;
      }
      get is2DArray() {
        if (!this._texture) {
          return false;
        }
        return this._texture.is2DArray;
      }
      set is2DArray(value) {
        if (!this._texture) {
          return;
        }
        this._texture.is2DArray = value;
      }
      get gammaSpace() {
        if (!this._texture) {
          return this._gammaSpace;
        } else {
          if (this._texture._gammaSpace === null) {
            this._texture._gammaSpace = this._gammaSpace;
          }
        }
        return this._texture._gammaSpace && !this._texture._useSRGBBuffer;
      }
      set gammaSpace(gamma) {
        if (!this._texture) {
          if (this._gammaSpace === gamma) {
            return;
          }
          this._gammaSpace = gamma;
        } else {
          if (this._texture._gammaSpace === gamma) {
            return;
          }
          this._texture._gammaSpace = gamma;
        }
        this._markAllSubMeshesAsTexturesDirty();
      }
      get isRGBD() {
        return this._texture != null && this._texture._isRGBD;
      }
      set isRGBD(value) {
        if (this._texture) {
          this._texture._isRGBD = value;
        }
      }
      get noMipmap() {
        return false;
      }
      get lodGenerationOffset() {
        if (this._texture) {
          return this._texture._lodGenerationOffset;
        }
        return 0;
      }
      set lodGenerationOffset(value) {
        if (this._texture) {
          this._texture._lodGenerationOffset = value;
        }
      }
      get lodGenerationScale() {
        if (this._texture) {
          return this._texture._lodGenerationScale;
        }
        return 0;
      }
      set lodGenerationScale(value) {
        if (this._texture) {
          this._texture._lodGenerationScale = value;
        }
      }
      get linearSpecularLOD() {
        if (this._texture) {
          return this._texture._linearSpecularLOD;
        }
        return false;
      }
      set linearSpecularLOD(value) {
        if (this._texture) {
          this._texture._linearSpecularLOD = value;
        }
      }
      get irradianceTexture() {
        if (this._texture) {
          return this._texture._irradianceTexture;
        }
        return null;
      }
      set irradianceTexture(value) {
        if (this._texture) {
          this._texture._irradianceTexture = value;
        }
      }
      get uid() {
        if (!this._uid) {
          this._uid = RandomGUID();
        }
        return this._uid;
      }
      toString() {
        return this.name;
      }
      getClassName() {
        return "BaseTexture";
      }
      set onDispose(callback) {
        if (this._onDisposeObserver) {
          this.onDisposeObservable.remove(this._onDisposeObserver);
        }
        this._onDisposeObserver = this.onDisposeObservable.add(callback);
      }
      get isBlocking() {
        return true;
      }
      get loadingError() {
        return this._loadingError;
      }
      get errorObject() {
        return this._errorObject;
      }
      constructor(sceneOrEngine, internalTexture = null) {
        super(null);
        this.metadata = null;
        this.reservedDataStore = null;
        this._hasAlpha = false;
        this._getAlphaFromRGB = false;
        this.level = 1;
        this._coordinatesIndex = 0;
        this.optimizeUVAllocation = true;
        this._coordinatesMode = 0;
        this.wrapR = 1;
        this.anisotropicFilteringLevel = BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL;
        this._isCube = false;
        this._gammaSpace = true;
        this.invertZ = false;
        this.lodLevelInAlpha = false;
        this.isRenderTarget = false;
        this._prefiltered = false;
        this._forceSerialize = false;
        this.animations = new Array();
        this.onDisposeObservable = new Observable();
        this._onDisposeObserver = null;
        this._scene = null;
        this._uid = null;
        this._parentContainer = null;
        this._loadingError = false;
        if (sceneOrEngine) {
          if (BaseTexture._IsScene(sceneOrEngine)) {
            this._scene = sceneOrEngine;
          } else {
            this._engine = sceneOrEngine;
          }
        } else {
          this._scene = EngineStore.LastCreatedScene;
        }
        if (this._scene) {
          this.uniqueId = this._scene.getUniqueId();
          this._scene.addTexture(this);
          this._engine = this._scene.getEngine();
        }
        this._texture = internalTexture;
        this._uid = null;
      }
      getScene() {
        return this._scene;
      }
      _getEngine() {
        return this._engine;
      }
      checkTransformsAreIdentical(texture) {
        return texture !== null;
      }
      getTextureMatrix() {
        return Matrix.IdentityReadOnly;
      }
      getReflectionTextureMatrix() {
        return Matrix.IdentityReadOnly;
      }
      getRefractionTextureMatrix() {
        return this.getReflectionTextureMatrix();
      }
      isReadyOrNotBlocking() {
        return !this.isBlocking || this.isReady() || this.loadingError;
      }
      scale(ratio) {
      }
      get canRescale() {
        return false;
      }
      _getFromCache(url, noMipmap, sampling, invertY, useSRGBBuffer, isCube) {
        const engine = this._getEngine();
        if (!engine) {
          return null;
        }
        const correctedUseSRGBBuffer = engine._getUseSRGBBuffer(!!useSRGBBuffer, noMipmap);
        const texturesCache = engine.getLoadedTexturesCache();
        for (let index = 0; index < texturesCache.length; index++) {
          const texturesCacheEntry = texturesCache[index];
          if (useSRGBBuffer === void 0 || correctedUseSRGBBuffer === texturesCacheEntry._useSRGBBuffer) {
            if (invertY === void 0 || invertY === texturesCacheEntry.invertY) {
              if (texturesCacheEntry.url === url && texturesCacheEntry.generateMipMaps === !noMipmap) {
                if (!sampling || sampling === texturesCacheEntry.samplingMode) {
                  if (isCube === void 0 || isCube === texturesCacheEntry.isCube) {
                    texturesCacheEntry.incrementReferences();
                    return texturesCacheEntry;
                  }
                }
              }
            }
          }
        }
        return null;
      }
      _rebuild() {
      }
      clone() {
        return null;
      }
      get textureType() {
        if (!this._texture) {
          return 0;
        }
        return this._texture.type !== void 0 ? this._texture.type : 0;
      }
      get textureFormat() {
        if (!this._texture) {
          return 5;
        }
        return this._texture.format !== void 0 ? this._texture.format : 5;
      }
      _markAllSubMeshesAsTexturesDirty() {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        scene.markAllMaterialsAsDirty(1);
      }
      readPixels(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false, x = 0, y = 0, width = Number.MAX_VALUE, height = Number.MAX_VALUE) {
        if (!this._texture) {
          return null;
        }
        const engine = this._getEngine();
        if (!engine) {
          return null;
        }
        const size = this.getSize();
        let maxWidth = size.width;
        let maxHeight = size.height;
        if (level !== 0) {
          maxWidth = maxWidth / Math.pow(2, level);
          maxHeight = maxHeight / Math.pow(2, level);
          maxWidth = Math.round(maxWidth);
          maxHeight = Math.round(maxHeight);
        }
        width = Math.min(maxWidth, width);
        height = Math.min(maxHeight, height);
        try {
          if (this._texture.isCube) {
            return engine._readTexturePixels(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion, x, y);
          }
          return engine._readTexturePixels(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion, x, y);
        } catch (e) {
          return null;
        }
      }
      _readPixelsSync(faceIndex = 0, level = 0, buffer = null, flushRenderer = true, noDataConversion = false) {
        if (!this._texture) {
          return null;
        }
        const size = this.getSize();
        let width = size.width;
        let height = size.height;
        const engine = this._getEngine();
        if (!engine) {
          return null;
        }
        if (level != 0) {
          width = width / Math.pow(2, level);
          height = height / Math.pow(2, level);
          width = Math.round(width);
          height = Math.round(height);
        }
        try {
          if (this._texture.isCube) {
            return engine._readTexturePixelsSync(this._texture, width, height, faceIndex, level, buffer, flushRenderer, noDataConversion);
          }
          return engine._readTexturePixelsSync(this._texture, width, height, -1, level, buffer, flushRenderer, noDataConversion);
        } catch (e) {
          return null;
        }
      }
      get _lodTextureHigh() {
        if (this._texture) {
          return this._texture._lodTextureHigh;
        }
        return null;
      }
      get _lodTextureMid() {
        if (this._texture) {
          return this._texture._lodTextureMid;
        }
        return null;
      }
      get _lodTextureLow() {
        if (this._texture) {
          return this._texture._lodTextureLow;
        }
        return null;
      }
      dispose() {
        if (this._scene) {
          if (this._scene.stopAnimation) {
            this._scene.stopAnimation(this);
          }
          this._scene.removePendingData(this);
          const index = this._scene.textures.indexOf(this);
          if (index >= 0) {
            this._scene.textures.splice(index, 1);
          }
          this._scene.onTextureRemovedObservable.notifyObservers(this);
          this._scene = null;
          if (this._parentContainer) {
            const index2 = this._parentContainer.textures.indexOf(this);
            if (index2 > -1) {
              this._parentContainer.textures.splice(index2, 1);
            }
            this._parentContainer = null;
          }
        }
        this.onDisposeObservable.notifyObservers(this);
        this.onDisposeObservable.clear();
        this.metadata = null;
        super.dispose();
      }
      serialize(allowEmptyName = false) {
        if (!this.name && !allowEmptyName) {
          return null;
        }
        const serializationObject = SerializationHelper.Serialize(this);
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
      }
      static WhenAllReady(textures, callback) {
        let numRemaining = textures.length;
        if (numRemaining === 0) {
          callback();
          return;
        }
        for (let i = 0; i < textures.length; i++) {
          const texture = textures[i];
          if (texture.isReady()) {
            if (--numRemaining === 0) {
              callback();
            }
          } else {
            const onLoadObservable = texture.onLoadObservable;
            if (onLoadObservable) {
              onLoadObservable.addOnce(() => {
                if (--numRemaining === 0) {
                  callback();
                }
              });
            } else {
              if (--numRemaining === 0) {
                callback();
              }
            }
          }
        }
      }
      static _IsScene(sceneOrEngine) {
        return sceneOrEngine.getClassName() === "Scene";
      }
    };
    BaseTexture.DEFAULT_ANISOTROPIC_FILTERING_LEVEL = 4;
    __decorate([
      serialize()
    ], BaseTexture.prototype, "uniqueId", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "name", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "metadata", void 0);
    __decorate([
      serialize("hasAlpha")
    ], BaseTexture.prototype, "_hasAlpha", void 0);
    __decorate([
      serialize("getAlphaFromRGB")
    ], BaseTexture.prototype, "_getAlphaFromRGB", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "level", void 0);
    __decorate([
      serialize("coordinatesIndex")
    ], BaseTexture.prototype, "_coordinatesIndex", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "optimizeUVAllocation", void 0);
    __decorate([
      serialize("coordinatesMode")
    ], BaseTexture.prototype, "_coordinatesMode", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "wrapU", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "wrapV", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "wrapR", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "anisotropicFilteringLevel", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "isCube", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "is3D", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "is2DArray", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "gammaSpace", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "invertZ", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "lodLevelInAlpha", void 0);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "lodGenerationOffset", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "lodGenerationScale", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "linearSpecularLOD", null);
    __decorate([
      serializeAsTexture()
    ], BaseTexture.prototype, "irradianceTexture", null);
    __decorate([
      serialize()
    ], BaseTexture.prototype, "isRenderTarget", void 0);
  }
});

// node_modules/@babylonjs/core/Misc/copyTools.js
function GenerateBase64StringFromPixelData(pixels, size, invertY = false) {
  const width = size.width;
  const height = size.height;
  if (pixels instanceof Float32Array) {
    let len = pixels.byteLength / pixels.BYTES_PER_ELEMENT;
    const npixels = new Uint8Array(len);
    while (--len >= 0) {
      let val = pixels[len];
      if (val < 0) {
        val = 0;
      } else if (val > 1) {
        val = 1;
      }
      npixels[len] = val * 255;
    }
    pixels = npixels;
  }
  const canvas = document.createElement("canvas");
  canvas.width = width;
  canvas.height = height;
  const ctx = canvas.getContext("2d");
  if (!ctx) {
    return null;
  }
  const imageData = ctx.createImageData(width, height);
  const castData = imageData.data;
  castData.set(pixels);
  ctx.putImageData(imageData, 0, 0);
  if (invertY) {
    const canvas2 = document.createElement("canvas");
    canvas2.width = width;
    canvas2.height = height;
    const ctx2 = canvas2.getContext("2d");
    if (!ctx2) {
      return null;
    }
    ctx2.translate(0, height);
    ctx2.scale(1, -1);
    ctx2.drawImage(canvas, 0, 0);
    return canvas2.toDataURL("image/png");
  }
  return canvas.toDataURL("image/png");
}
function GenerateBase64StringFromTexture(texture, faceIndex = 0, level = 0) {
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  const pixels = texture._readPixelsSync(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
async function GenerateBase64StringFromTextureAsync(texture, faceIndex = 0, level = 0) {
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return null;
  }
  const pixels = await texture.readPixels(faceIndex, level);
  if (!pixels) {
    return null;
  }
  return GenerateBase64StringFromPixelData(pixels, texture.getSize(), internalTexture.invertY);
}
var CopyTools;
var init_copyTools = __esm({
  "node_modules/@babylonjs/core/Misc/copyTools.js"() {
    CopyTools = {
      GenerateBase64StringFromPixelData,
      GenerateBase64StringFromTexture,
      GenerateBase64StringFromTextureAsync
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/texture.js
var Texture;
var init_texture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/texture.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_math_vector();
    init_baseTexture();
    init_typeStore();
    init_devTools();
    init_timingTools();
    init_instantiationTools();
    init_math_plane();
    init_stringTools();
    init_copyTools();
    init_compatibilityOptions();
    Texture = class extends BaseTexture {
      get noMipmap() {
        return this._noMipmap;
      }
      get mimeType() {
        return this._mimeType;
      }
      set isBlocking(value) {
        this._isBlocking = value;
      }
      get isBlocking() {
        return this._isBlocking;
      }
      get invertY() {
        return this._invertY;
      }
      constructor(url, sceneOrEngine, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, buffer = null, deleteBuffer = false, format, mimeType, loaderOptions, creationFlags, forcedExtension) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        super(sceneOrEngine);
        this.url = null;
        this.uOffset = 0;
        this.vOffset = 0;
        this.uScale = 1;
        this.vScale = 1;
        this.uAng = 0;
        this.vAng = 0;
        this.wAng = 0;
        this.uRotationCenter = 0.5;
        this.vRotationCenter = 0.5;
        this.wRotationCenter = 0.5;
        this.homogeneousRotationInUVTransform = false;
        this.inspectableCustomProperties = null;
        this._noMipmap = false;
        this._invertY = false;
        this._rowGenerationMatrix = null;
        this._cachedTextureMatrix = null;
        this._projectionModeMatrix = null;
        this._t0 = null;
        this._t1 = null;
        this._t2 = null;
        this._cachedUOffset = -1;
        this._cachedVOffset = -1;
        this._cachedUScale = 0;
        this._cachedVScale = 0;
        this._cachedUAng = -1;
        this._cachedVAng = -1;
        this._cachedWAng = -1;
        this._cachedReflectionProjectionMatrixId = -1;
        this._cachedURotationCenter = -1;
        this._cachedVRotationCenter = -1;
        this._cachedWRotationCenter = -1;
        this._cachedHomogeneousRotationInUVTransform = false;
        this._cachedReflectionTextureMatrix = null;
        this._cachedReflectionUOffset = -1;
        this._cachedReflectionVOffset = -1;
        this._cachedReflectionUScale = 0;
        this._cachedReflectionVScale = 0;
        this._cachedReflectionCoordinatesMode = -1;
        this._buffer = null;
        this._deleteBuffer = false;
        this._format = null;
        this._delayedOnLoad = null;
        this._delayedOnError = null;
        this.onLoadObservable = new Observable();
        this._isBlocking = true;
        this.name = url || "";
        this.url = url;
        let noMipmap;
        let useSRGBBuffer = false;
        let internalTexture = null;
        if (typeof noMipmapOrOptions === "object" && noMipmapOrOptions !== null) {
          noMipmap = (_a = noMipmapOrOptions.noMipmap) !== null && _a !== void 0 ? _a : false;
          invertY = (_b = noMipmapOrOptions.invertY) !== null && _b !== void 0 ? _b : CompatibilityOptions.UseOpenGLOrientationForUV ? false : true;
          samplingMode = (_c = noMipmapOrOptions.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;
          onLoad = (_d = noMipmapOrOptions.onLoad) !== null && _d !== void 0 ? _d : null;
          onError = (_e = noMipmapOrOptions.onError) !== null && _e !== void 0 ? _e : null;
          buffer = (_f = noMipmapOrOptions.buffer) !== null && _f !== void 0 ? _f : null;
          deleteBuffer = (_g = noMipmapOrOptions.deleteBuffer) !== null && _g !== void 0 ? _g : false;
          format = noMipmapOrOptions.format;
          mimeType = noMipmapOrOptions.mimeType;
          loaderOptions = noMipmapOrOptions.loaderOptions;
          creationFlags = noMipmapOrOptions.creationFlags;
          useSRGBBuffer = (_h = noMipmapOrOptions.useSRGBBuffer) !== null && _h !== void 0 ? _h : false;
          internalTexture = (_j = noMipmapOrOptions.internalTexture) !== null && _j !== void 0 ? _j : null;
        } else {
          noMipmap = !!noMipmapOrOptions;
        }
        this._noMipmap = noMipmap;
        this._invertY = invertY === void 0 ? CompatibilityOptions.UseOpenGLOrientationForUV ? false : true : invertY;
        this._initialSamplingMode = samplingMode;
        this._buffer = buffer;
        this._deleteBuffer = deleteBuffer;
        this._mimeType = mimeType;
        this._loaderOptions = loaderOptions;
        this._creationFlags = creationFlags;
        this._useSRGBBuffer = useSRGBBuffer;
        this._forcedExtension = forcedExtension;
        if (format) {
          this._format = format;
        }
        const scene = this.getScene();
        const engine = this._getEngine();
        if (!engine) {
          return;
        }
        engine.onBeforeTextureInitObservable.notifyObservers(this);
        const load = () => {
          if (this._texture) {
            if (this._texture._invertVScale) {
              this.vScale *= -1;
              this.vOffset += 1;
            }
            if (this._texture._cachedWrapU !== null) {
              this.wrapU = this._texture._cachedWrapU;
              this._texture._cachedWrapU = null;
            }
            if (this._texture._cachedWrapV !== null) {
              this.wrapV = this._texture._cachedWrapV;
              this._texture._cachedWrapV = null;
            }
            if (this._texture._cachedWrapR !== null) {
              this.wrapR = this._texture._cachedWrapR;
              this._texture._cachedWrapR = null;
            }
          }
          if (this.onLoadObservable.hasObservers()) {
            this.onLoadObservable.notifyObservers(this);
          }
          if (onLoad) {
            onLoad();
          }
          if (!this.isBlocking && scene) {
            scene.resetCachedMaterial();
          }
        };
        const errorHandler = (message, exception) => {
          this._loadingError = true;
          this._errorObject = { message, exception };
          if (onError) {
            onError(message, exception);
          }
          Texture.OnTextureLoadErrorObservable.notifyObservers(this);
        };
        if (!this.url && !internalTexture) {
          this._delayedOnLoad = load;
          this._delayedOnError = errorHandler;
          return;
        }
        this._texture = internalTexture !== null && internalTexture !== void 0 ? internalTexture : this._getFromCache(this.url, noMipmap, samplingMode, this._invertY, useSRGBBuffer);
        if (!this._texture) {
          if (!scene || !scene.useDelayedTextureLoading) {
            try {
              this._texture = engine.createTexture(this.url, noMipmap, this._invertY, scene, samplingMode, load, errorHandler, this._buffer, void 0, this._format, this._forcedExtension, mimeType, loaderOptions, creationFlags, useSRGBBuffer);
            } catch (e) {
              errorHandler("error loading", e);
              throw e;
            }
            if (deleteBuffer) {
              this._buffer = null;
            }
          } else {
            this.delayLoadState = 4;
            this._delayedOnLoad = load;
            this._delayedOnError = errorHandler;
          }
        } else {
          if (this._texture.isReady) {
            TimingTools.SetImmediate(() => load());
          } else {
            const loadObserver = this._texture.onLoadedObservable.add(load);
            this._texture.onErrorObservable.add((e) => {
              var _a2;
              errorHandler(e.message, e.exception);
              (_a2 = this._texture) === null || _a2 === void 0 ? void 0 : _a2.onLoadedObservable.remove(loadObserver);
            });
          }
        }
      }
      updateURL(url, buffer = null, onLoad, forcedExtension) {
        if (this.url) {
          this.releaseInternalTexture();
          this.getScene().markAllMaterialsAsDirty(1);
        }
        if (!this.name || this.name.startsWith("data:")) {
          this.name = url;
        }
        this.url = url;
        this._buffer = buffer;
        this._forcedExtension = forcedExtension;
        this.delayLoadState = 4;
        if (onLoad) {
          this._delayedOnLoad = onLoad;
        }
        this.delayLoad();
      }
      delayLoad() {
        if (this.delayLoadState !== 4) {
          return;
        }
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        this.delayLoadState = 1;
        this._texture = this._getFromCache(this.url, this._noMipmap, this.samplingMode, this._invertY, this._useSRGBBuffer);
        if (!this._texture) {
          this._texture = scene.getEngine().createTexture(this.url, this._noMipmap, this._invertY, scene, this.samplingMode, this._delayedOnLoad, this._delayedOnError, this._buffer, null, this._format, this._forcedExtension, this._mimeType, this._loaderOptions, this._creationFlags, this._useSRGBBuffer);
          if (this._deleteBuffer) {
            this._buffer = null;
          }
        } else {
          if (this._delayedOnLoad) {
            if (this._texture.isReady) {
              TimingTools.SetImmediate(this._delayedOnLoad);
            } else {
              this._texture.onLoadedObservable.add(this._delayedOnLoad);
            }
          }
        }
        this._delayedOnLoad = null;
        this._delayedOnError = null;
      }
      _prepareRowForTextureGeneration(x, y, z, t) {
        x *= this._cachedUScale;
        y *= this._cachedVScale;
        x -= this.uRotationCenter * this._cachedUScale;
        y -= this.vRotationCenter * this._cachedVScale;
        z -= this.wRotationCenter;
        Vector3.TransformCoordinatesFromFloatsToRef(x, y, z, this._rowGenerationMatrix, t);
        t.x += this.uRotationCenter * this._cachedUScale + this._cachedUOffset;
        t.y += this.vRotationCenter * this._cachedVScale + this._cachedVOffset;
        t.z += this.wRotationCenter;
      }
      checkTransformsAreIdentical(texture) {
        return texture !== null && this.uOffset === texture.uOffset && this.vOffset === texture.vOffset && this.uScale === texture.uScale && this.vScale === texture.vScale && this.uAng === texture.uAng && this.vAng === texture.vAng && this.wAng === texture.wAng;
      }
      getTextureMatrix(uBase = 1) {
        if (this.uOffset === this._cachedUOffset && this.vOffset === this._cachedVOffset && this.uScale * uBase === this._cachedUScale && this.vScale === this._cachedVScale && this.uAng === this._cachedUAng && this.vAng === this._cachedVAng && this.wAng === this._cachedWAng && this.uRotationCenter === this._cachedURotationCenter && this.vRotationCenter === this._cachedVRotationCenter && this.wRotationCenter === this._cachedWRotationCenter && this.homogeneousRotationInUVTransform === this._cachedHomogeneousRotationInUVTransform) {
          return this._cachedTextureMatrix;
        }
        this._cachedUOffset = this.uOffset;
        this._cachedVOffset = this.vOffset;
        this._cachedUScale = this.uScale * uBase;
        this._cachedVScale = this.vScale;
        this._cachedUAng = this.uAng;
        this._cachedVAng = this.vAng;
        this._cachedWAng = this.wAng;
        this._cachedURotationCenter = this.uRotationCenter;
        this._cachedVRotationCenter = this.vRotationCenter;
        this._cachedWRotationCenter = this.wRotationCenter;
        this._cachedHomogeneousRotationInUVTransform = this.homogeneousRotationInUVTransform;
        if (!this._cachedTextureMatrix || !this._rowGenerationMatrix) {
          this._cachedTextureMatrix = Matrix.Zero();
          this._rowGenerationMatrix = new Matrix();
          this._t0 = Vector3.Zero();
          this._t1 = Vector3.Zero();
          this._t2 = Vector3.Zero();
        }
        Matrix.RotationYawPitchRollToRef(this.vAng, this.uAng, this.wAng, this._rowGenerationMatrix);
        if (this.homogeneousRotationInUVTransform) {
          Matrix.TranslationToRef(-this._cachedURotationCenter, -this._cachedVRotationCenter, -this._cachedWRotationCenter, TmpVectors.Matrix[0]);
          Matrix.TranslationToRef(this._cachedURotationCenter, this._cachedVRotationCenter, this._cachedWRotationCenter, TmpVectors.Matrix[1]);
          Matrix.ScalingToRef(this._cachedUScale, this._cachedVScale, 0, TmpVectors.Matrix[2]);
          Matrix.TranslationToRef(this._cachedUOffset, this._cachedVOffset, 0, TmpVectors.Matrix[3]);
          TmpVectors.Matrix[0].multiplyToRef(this._rowGenerationMatrix, this._cachedTextureMatrix);
          this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[1], this._cachedTextureMatrix);
          this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[2], this._cachedTextureMatrix);
          this._cachedTextureMatrix.multiplyToRef(TmpVectors.Matrix[3], this._cachedTextureMatrix);
          this._cachedTextureMatrix.setRowFromFloats(2, this._cachedTextureMatrix.m[12], this._cachedTextureMatrix.m[13], this._cachedTextureMatrix.m[14], 1);
        } else {
          this._prepareRowForTextureGeneration(0, 0, 0, this._t0);
          this._prepareRowForTextureGeneration(1, 0, 0, this._t1);
          this._prepareRowForTextureGeneration(0, 1, 0, this._t2);
          this._t1.subtractInPlace(this._t0);
          this._t2.subtractInPlace(this._t0);
          Matrix.FromValuesToRef(this._t1.x, this._t1.y, this._t1.z, 0, this._t2.x, this._t2.y, this._t2.z, 0, this._t0.x, this._t0.y, this._t0.z, 0, 0, 0, 0, 1, this._cachedTextureMatrix);
        }
        const scene = this.getScene();
        if (!scene) {
          return this._cachedTextureMatrix;
        }
        if (this.optimizeUVAllocation) {
          scene.markAllMaterialsAsDirty(1, (mat) => {
            return mat.hasTexture(this);
          });
        }
        return this._cachedTextureMatrix;
      }
      getReflectionTextureMatrix() {
        const scene = this.getScene();
        if (!scene) {
          return this._cachedReflectionTextureMatrix;
        }
        if (this.uOffset === this._cachedReflectionUOffset && this.vOffset === this._cachedReflectionVOffset && this.uScale === this._cachedReflectionUScale && this.vScale === this._cachedReflectionVScale && this.coordinatesMode === this._cachedReflectionCoordinatesMode) {
          if (this.coordinatesMode === Texture.PROJECTION_MODE) {
            if (this._cachedReflectionProjectionMatrixId === scene.getProjectionMatrix().updateFlag) {
              return this._cachedReflectionTextureMatrix;
            }
          } else {
            return this._cachedReflectionTextureMatrix;
          }
        }
        if (!this._cachedReflectionTextureMatrix) {
          this._cachedReflectionTextureMatrix = Matrix.Zero();
        }
        if (!this._projectionModeMatrix) {
          this._projectionModeMatrix = Matrix.Zero();
        }
        const flagMaterialsAsTextureDirty = this._cachedReflectionCoordinatesMode !== this.coordinatesMode;
        this._cachedReflectionUOffset = this.uOffset;
        this._cachedReflectionVOffset = this.vOffset;
        this._cachedReflectionUScale = this.uScale;
        this._cachedReflectionVScale = this.vScale;
        this._cachedReflectionCoordinatesMode = this.coordinatesMode;
        switch (this.coordinatesMode) {
          case Texture.PLANAR_MODE: {
            Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
            this._cachedReflectionTextureMatrix[0] = this.uScale;
            this._cachedReflectionTextureMatrix[5] = this.vScale;
            this._cachedReflectionTextureMatrix[12] = this.uOffset;
            this._cachedReflectionTextureMatrix[13] = this.vOffset;
            break;
          }
          case Texture.PROJECTION_MODE: {
            Matrix.FromValuesToRef(0.5, 0, 0, 0, 0, -0.5, 0, 0, 0, 0, 0, 0, 0.5, 0.5, 1, 1, this._projectionModeMatrix);
            const projectionMatrix = scene.getProjectionMatrix();
            this._cachedReflectionProjectionMatrixId = projectionMatrix.updateFlag;
            projectionMatrix.multiplyToRef(this._projectionModeMatrix, this._cachedReflectionTextureMatrix);
            break;
          }
          default:
            Matrix.IdentityToRef(this._cachedReflectionTextureMatrix);
            break;
        }
        if (flagMaterialsAsTextureDirty) {
          scene.markAllMaterialsAsDirty(1, (mat) => {
            return mat.getActiveTextures().indexOf(this) !== -1;
          });
        }
        return this._cachedReflectionTextureMatrix;
      }
      clone() {
        const options = {
          noMipmap: this._noMipmap,
          invertY: this._invertY,
          samplingMode: this.samplingMode,
          onLoad: void 0,
          onError: void 0,
          buffer: this._texture ? this._texture._buffer : void 0,
          deleteBuffer: this._deleteBuffer,
          format: this.textureFormat,
          mimeType: this.mimeType,
          loaderOptions: this._loaderOptions,
          creationFlags: this._creationFlags,
          useSRGBBuffer: this._useSRGBBuffer
        };
        return SerializationHelper.Clone(() => {
          return new Texture(this._texture ? this._texture.url : null, this.getScene(), options);
        }, this);
      }
      serialize() {
        var _a, _b;
        const savedName = this.name;
        if (!Texture.SerializeBuffers) {
          if (this.name.startsWith("data:")) {
            this.name = "";
          }
        }
        if (this.name.startsWith("data:") && this.url === this.name) {
          this.url = "";
        }
        const serializationObject = super.serialize(Texture._SerializeInternalTextureUniqueId);
        if (!serializationObject) {
          return null;
        }
        if (Texture.SerializeBuffers || Texture.ForceSerializeBuffers) {
          if (typeof this._buffer === "string" && this._buffer.substr(0, 5) === "data:") {
            serializationObject.base64String = this._buffer;
            serializationObject.name = serializationObject.name.replace("data:", "");
          } else if (this.url && this.url.startsWith("data:") && this._buffer instanceof Uint8Array) {
            serializationObject.base64String = "data:image/png;base64," + EncodeArrayBufferToBase64(this._buffer);
          } else if (Texture.ForceSerializeBuffers || this.url && this.url.startsWith("blob:") || this._forceSerialize) {
            serializationObject.base64String = !this._engine || this._engine._features.supportSyncTextureRead ? GenerateBase64StringFromTexture(this) : GenerateBase64StringFromTextureAsync(this);
          }
        }
        serializationObject.invertY = this._invertY;
        serializationObject.samplingMode = this.samplingMode;
        serializationObject._creationFlags = this._creationFlags;
        serializationObject._useSRGBBuffer = this._useSRGBBuffer;
        if (Texture._SerializeInternalTextureUniqueId) {
          serializationObject.internalTextureUniqueId = (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.uniqueId) !== null && _b !== void 0 ? _b : void 0;
        }
        this.name = savedName;
        return serializationObject;
      }
      getClassName() {
        return "Texture";
      }
      dispose() {
        super.dispose();
        this.onLoadObservable.clear();
        this._delayedOnLoad = null;
        this._delayedOnError = null;
        this._buffer = null;
      }
      static Parse(parsedTexture, scene, rootUrl) {
        if (parsedTexture.customType) {
          const customTexture = InstantiationTools.Instantiate(parsedTexture.customType);
          const parsedCustomTexture = customTexture.Parse(parsedTexture, scene, rootUrl);
          if (parsedTexture.samplingMode && parsedCustomTexture.updateSamplingMode && parsedCustomTexture._samplingMode) {
            if (parsedCustomTexture._samplingMode !== parsedTexture.samplingMode) {
              parsedCustomTexture.updateSamplingMode(parsedTexture.samplingMode);
            }
          }
          return parsedCustomTexture;
        }
        if (parsedTexture.isCube && !parsedTexture.isRenderTarget) {
          return Texture._CubeTextureParser(parsedTexture, scene, rootUrl);
        }
        const hasInternalTextureUniqueId = parsedTexture.internalTextureUniqueId !== void 0;
        if (!parsedTexture.name && !parsedTexture.isRenderTarget && !hasInternalTextureUniqueId) {
          return null;
        }
        let internalTexture;
        if (hasInternalTextureUniqueId) {
          const cache = scene.getEngine().getLoadedTexturesCache();
          for (const texture2 of cache) {
            if (texture2.uniqueId === parsedTexture.internalTextureUniqueId) {
              internalTexture = texture2;
              break;
            }
          }
        }
        const onLoaded = (texture2) => {
          var _a;
          if (texture2 && texture2._texture) {
            texture2._texture._cachedWrapU = null;
            texture2._texture._cachedWrapV = null;
            texture2._texture._cachedWrapR = null;
          }
          if (parsedTexture.samplingMode) {
            const sampling = parsedTexture.samplingMode;
            if (texture2 && texture2.samplingMode !== sampling) {
              texture2.updateSamplingMode(sampling);
            }
          }
          if (texture2 && parsedTexture.animations) {
            for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
              const parsedAnimation = parsedTexture.animations[animationIndex];
              const internalClass = GetClass("BABYLON.Animation");
              if (internalClass) {
                texture2.animations.push(internalClass.Parse(parsedAnimation));
              }
            }
          }
          if (hasInternalTextureUniqueId && !internalTexture) {
            (_a = texture2 === null || texture2 === void 0 ? void 0 : texture2._texture) === null || _a === void 0 ? void 0 : _a._setUniqueId(parsedTexture.internalTextureUniqueId);
          }
        };
        const texture = SerializationHelper.Parse(() => {
          var _a, _b, _c;
          let generateMipMaps = true;
          if (parsedTexture.noMipmap) {
            generateMipMaps = false;
          }
          if (parsedTexture.mirrorPlane) {
            const mirrorTexture = Texture._CreateMirror(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps);
            mirrorTexture._waitingRenderList = parsedTexture.renderList;
            mirrorTexture.mirrorPlane = Plane.FromArray(parsedTexture.mirrorPlane);
            onLoaded(mirrorTexture);
            return mirrorTexture;
          } else if (parsedTexture.isRenderTarget) {
            let renderTargetTexture = null;
            if (parsedTexture.isCube) {
              if (scene.reflectionProbes) {
                for (let index = 0; index < scene.reflectionProbes.length; index++) {
                  const probe = scene.reflectionProbes[index];
                  if (probe.name === parsedTexture.name) {
                    return probe.cubeTexture;
                  }
                }
              }
            } else {
              renderTargetTexture = Texture._CreateRenderTargetTexture(parsedTexture.name, parsedTexture.renderTargetSize, scene, generateMipMaps, (_a = parsedTexture._creationFlags) !== null && _a !== void 0 ? _a : 0);
              renderTargetTexture._waitingRenderList = parsedTexture.renderList;
            }
            onLoaded(renderTargetTexture);
            return renderTargetTexture;
          } else {
            let texture2;
            if (parsedTexture.base64String && !internalTexture) {
              texture2 = Texture.CreateFromBase64String(parsedTexture.base64String, parsedTexture.base64String, scene, !generateMipMaps, parsedTexture.invertY, parsedTexture.samplingMode, () => {
                onLoaded(texture2);
              }, (_b = parsedTexture._creationFlags) !== null && _b !== void 0 ? _b : 0, (_c = parsedTexture._useSRGBBuffer) !== null && _c !== void 0 ? _c : false);
              texture2.name = parsedTexture.name;
            } else {
              let url;
              if (parsedTexture.name && (parsedTexture.name.indexOf("://") > 0 || parsedTexture.name.startsWith("data:"))) {
                url = parsedTexture.name;
              } else {
                url = rootUrl + parsedTexture.name;
              }
              if (parsedTexture.url && (parsedTexture.url.startsWith("data:") || Texture.UseSerializedUrlIfAny)) {
                url = parsedTexture.url;
              }
              const options = {
                noMipmap: !generateMipMaps,
                invertY: parsedTexture.invertY,
                samplingMode: parsedTexture.samplingMode,
                onLoad: () => {
                  onLoaded(texture2);
                },
                internalTexture
              };
              texture2 = new Texture(url, scene, options);
            }
            return texture2;
          }
        }, parsedTexture, scene);
        return texture;
      }
      static CreateFromBase64String(data, name109, scene, noMipmapOrOptions, invertY, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {
        return new Texture("data:" + name109, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, data, false, format, void 0, void 0, creationFlags);
      }
      static LoadFromDataString(name109, buffer, scene, deleteBuffer = false, noMipmapOrOptions, invertY = true, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, onLoad = null, onError = null, format = 5, creationFlags) {
        if (name109.substr(0, 5) !== "data:") {
          name109 = "data:" + name109;
        }
        return new Texture(name109, scene, noMipmapOrOptions, invertY, samplingMode, onLoad, onError, buffer, deleteBuffer, format, void 0, void 0, creationFlags);
      }
    };
    Texture.SerializeBuffers = true;
    Texture.ForceSerializeBuffers = false;
    Texture.OnTextureLoadErrorObservable = new Observable();
    Texture._SerializeInternalTextureUniqueId = false;
    Texture._CubeTextureParser = (jsonTexture, scene, rootUrl) => {
      throw _WarnImport("CubeTexture");
    };
    Texture._CreateMirror = (name109, renderTargetSize, scene, generateMipMaps) => {
      throw _WarnImport("MirrorTexture");
    };
    Texture._CreateRenderTargetTexture = (name109, renderTargetSize, scene, generateMipMaps, creationFlags) => {
      throw _WarnImport("RenderTargetTexture");
    };
    Texture.NEAREST_SAMPLINGMODE = 1;
    Texture.NEAREST_NEAREST_MIPLINEAR = 8;
    Texture.BILINEAR_SAMPLINGMODE = 2;
    Texture.LINEAR_LINEAR_MIPNEAREST = 11;
    Texture.TRILINEAR_SAMPLINGMODE = 3;
    Texture.LINEAR_LINEAR_MIPLINEAR = 3;
    Texture.NEAREST_NEAREST_MIPNEAREST = 4;
    Texture.NEAREST_LINEAR_MIPNEAREST = 5;
    Texture.NEAREST_LINEAR_MIPLINEAR = 6;
    Texture.NEAREST_LINEAR = 7;
    Texture.NEAREST_NEAREST = 1;
    Texture.LINEAR_NEAREST_MIPNEAREST = 9;
    Texture.LINEAR_NEAREST_MIPLINEAR = 10;
    Texture.LINEAR_LINEAR = 2;
    Texture.LINEAR_NEAREST = 12;
    Texture.EXPLICIT_MODE = 0;
    Texture.SPHERICAL_MODE = 1;
    Texture.PLANAR_MODE = 2;
    Texture.CUBIC_MODE = 3;
    Texture.PROJECTION_MODE = 4;
    Texture.SKYBOX_MODE = 5;
    Texture.INVCUBIC_MODE = 6;
    Texture.EQUIRECTANGULAR_MODE = 7;
    Texture.FIXED_EQUIRECTANGULAR_MODE = 8;
    Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
    Texture.CLAMP_ADDRESSMODE = 0;
    Texture.WRAP_ADDRESSMODE = 1;
    Texture.MIRROR_ADDRESSMODE = 2;
    Texture.UseSerializedUrlIfAny = false;
    __decorate([
      serialize()
    ], Texture.prototype, "url", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "uOffset", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "vOffset", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "uScale", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "vScale", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "uAng", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "vAng", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "wAng", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "uRotationCenter", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "vRotationCenter", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "wRotationCenter", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "homogeneousRotationInUVTransform", void 0);
    __decorate([
      serialize()
    ], Texture.prototype, "isBlocking", null);
    RegisterClass("BABYLON.Texture", Texture);
    SerializationHelper._TextureParser = Texture.Parse;
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js
function _convertRGBtoRGBATextureData(rgbData, width, height, textureType) {
  let rgbaData;
  let val1 = 1;
  if (textureType === 1) {
    rgbaData = new Float32Array(width * height * 4);
  } else if (textureType === 2) {
    rgbaData = new Uint16Array(width * height * 4);
    val1 = 15360;
  } else if (textureType === 7) {
    rgbaData = new Uint32Array(width * height * 4);
  } else {
    rgbaData = new Uint8Array(width * height * 4);
  }
  for (let x = 0; x < width; x++) {
    for (let y = 0; y < height; y++) {
      const index = (y * width + x) * 3;
      const newIndex = (y * width + x) * 4;
      rgbaData[newIndex + 0] = rgbData[index + 0];
      rgbaData[newIndex + 1] = rgbData[index + 1];
      rgbaData[newIndex + 2] = rgbData[index + 2];
      rgbaData[newIndex + 3] = val1;
    }
  }
  return rgbaData;
}
function _makeCreateRawTextureFunction(is3D) {
  return function(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const source = is3D ? InternalTextureSource.Raw3D : InternalTextureSource.Raw2DArray;
    const texture = new InternalTexture(this, source);
    texture.baseWidth = width;
    texture.baseHeight = height;
    texture.baseDepth = depth;
    texture.width = width;
    texture.height = height;
    texture.depth = depth;
    texture.format = format;
    texture.type = textureType;
    texture.generateMipMaps = generateMipMaps;
    texture.samplingMode = samplingMode;
    if (is3D) {
      texture.is3D = true;
    } else {
      texture.is2DArray = true;
    }
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
    }
    if (is3D) {
      this.updateRawTexture3D(texture, data, format, invertY, compression, textureType);
    } else {
      this.updateRawTexture2DArray(texture, data, format, invertY, compression, textureType);
    }
    this._bindTextureDirectly(target, texture, true);
    const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
    this._gl.texParameteri(target, this._gl.TEXTURE_MAG_FILTER, filters.mag);
    this._gl.texParameteri(target, this._gl.TEXTURE_MIN_FILTER, filters.min);
    if (generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    this._internalTexturesCache.push(texture);
    return texture;
  };
}
function _makeUpdateRawTextureFunction(is3D) {
  return function(texture, data, format, invertY, compression = null, textureType = 0) {
    const target = is3D ? this._gl.TEXTURE_3D : this._gl.TEXTURE_2D_ARRAY;
    const internalType = this._getWebGLTextureType(textureType);
    const internalFormat = this._getInternalFormat(format);
    const internalSizedFomat = this._getRGBABufferInternalSizedFormat(textureType, format);
    this._bindTextureDirectly(target, texture, true);
    this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
    if (!this._doNotHandleContextLost) {
      texture._bufferView = data;
      texture.format = format;
      texture.invertY = invertY;
      texture._compression = compression;
    }
    if (texture.width % 4 !== 0) {
      this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
    }
    if (compression && data) {
      this._gl.compressedTexImage3D(target, 0, this.getCaps().s3tc[compression], texture.width, texture.height, texture.depth, 0, data);
    } else {
      this._gl.texImage3D(target, 0, internalSizedFomat, texture.width, texture.height, texture.depth, 0, internalFormat, internalType, data);
    }
    if (texture.generateMipMaps) {
      this._gl.generateMipmap(target);
    }
    this._bindTextureDirectly(target, null);
    texture.isReady = true;
  };
}
var init_engine_rawTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.rawTexture.js"() {
    init_internalTexture();
    init_logger();
    init_tools();
    init_thinEngine();
    ThinEngine.prototype.updateRawTexture = function(texture, data, format, invertY, compression = null, type = 0, useSRGBBuffer = false) {
      if (!texture) {
        return;
      }
      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type, format, useSRGBBuffer);
      const internalFormat = this._getInternalFormat(format);
      const textureType = this._getWebGLTextureType(type);
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
      if (!this._doNotHandleContextLost) {
        texture._bufferView = data;
        texture.format = format;
        texture.type = type;
        texture.invertY = invertY;
        texture._compression = compression;
      }
      if (texture.width % 4 !== 0) {
        this._gl.pixelStorei(this._gl.UNPACK_ALIGNMENT, 1);
      }
      if (compression && data) {
        this._gl.compressedTexImage2D(this._gl.TEXTURE_2D, 0, this.getCaps().s3tc[compression], texture.width, texture.height, 0, data);
      } else {
        this._gl.texImage2D(this._gl.TEXTURE_2D, 0, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, data);
      }
      if (texture.generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      texture.isReady = true;
    };
    ThinEngine.prototype.createRawTexture = function(data, width, height, format, generateMipMaps, invertY, samplingMode, compression = null, type = 0, creationFlags = 0, useSRGBBuffer = false) {
      const texture = new InternalTexture(this, InternalTextureSource.Raw);
      texture.baseWidth = width;
      texture.baseHeight = height;
      texture.width = width;
      texture.height = height;
      texture.format = format;
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      texture.invertY = invertY;
      texture._compression = compression;
      texture.type = type;
      texture._useSRGBBuffer = this._getUseSRGBBuffer(useSRGBBuffer, !generateMipMaps);
      if (!this._doNotHandleContextLost) {
        texture._bufferView = data;
      }
      this.updateRawTexture(texture, data, format, invertY, compression, type, texture._useSRGBBuffer);
      this._bindTextureDirectly(this._gl.TEXTURE_2D, texture, true);
      const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MAG_FILTER, filters.mag);
      this._gl.texParameteri(this._gl.TEXTURE_2D, this._gl.TEXTURE_MIN_FILTER, filters.min);
      if (generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_2D);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_2D, null);
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.createRawCubeTexture = function(data, size, format, type, generateMipMaps, invertY, samplingMode, compression = null) {
      const gl = this._gl;
      const texture = new InternalTexture(this, InternalTextureSource.CubeRaw);
      texture.isCube = true;
      texture.format = format;
      texture.type = type;
      if (!this._doNotHandleContextLost) {
        texture._bufferViewArray = data;
      }
      const textureType = this._getWebGLTextureType(type);
      let internalFormat = this._getInternalFormat(format);
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
      }
      if (textureType === gl.FLOAT && !this._caps.textureFloatLinearFiltering) {
        generateMipMaps = false;
        samplingMode = 1;
        Logger.Warn("Float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
      } else if (textureType === this._gl.HALF_FLOAT_OES && !this._caps.textureHalfFloatLinearFiltering) {
        generateMipMaps = false;
        samplingMode = 1;
        Logger.Warn("Half float texture filtering is not supported. Mipmap generation and sampling mode are forced to false and TEXTURE_NEAREST_SAMPLINGMODE, respectively.");
      } else if (textureType === gl.FLOAT && !this._caps.textureFloatRender) {
        generateMipMaps = false;
        Logger.Warn("Render to float textures is not supported. Mipmap generation forced to false.");
      } else if (textureType === gl.HALF_FLOAT && !this._caps.colorBufferFloat) {
        generateMipMaps = false;
        Logger.Warn("Render to half float textures is not supported. Mipmap generation forced to false.");
      }
      const width = size;
      const height = width;
      texture.width = width;
      texture.height = height;
      texture.invertY = invertY;
      texture._compression = compression;
      const isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
      if (!isPot) {
        generateMipMaps = false;
      }
      if (data) {
        this.updateRawCubeTexture(texture, data, format, type, invertY, compression);
      } else {
        const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
        const level = 0;
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          if (compression) {
            gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, void 0);
          } else {
            gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, null);
          }
        }
        this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, texture, true);
      if (data && generateMipMaps) {
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
      }
      const filters = this._getSamplingParameters(samplingMode, generateMipMaps);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      texture.generateMipMaps = generateMipMaps;
      texture.samplingMode = samplingMode;
      texture.isReady = true;
      return texture;
    };
    ThinEngine.prototype.updateRawCubeTexture = function(texture, data, format, type, invertY, compression = null, level = 0) {
      texture._bufferViewArray = data;
      texture.format = format;
      texture.type = type;
      texture.invertY = invertY;
      texture._compression = compression;
      const gl = this._gl;
      const textureType = this._getWebGLTextureType(type);
      let internalFormat = this._getInternalFormat(format);
      const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
      let needConversion = false;
      if (internalFormat === gl.RGB) {
        internalFormat = gl.RGBA;
        needConversion = true;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      this._unpackFlipY(invertY === void 0 ? true : invertY ? true : false);
      if (texture.width % 4 !== 0) {
        gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
      }
      for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
        let faceData = data[faceIndex];
        if (compression) {
          gl.compressedTexImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, this.getCaps().s3tc[compression], texture.width, texture.height, 0, faceData);
        } else {
          if (needConversion) {
            faceData = _convertRGBtoRGBATextureData(faceData, texture.width, texture.height, type);
          }
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndex, level, internalSizedFomat, texture.width, texture.height, 0, internalFormat, textureType, faceData);
        }
      }
      const isPot = !this.needPOTTextures || Tools.IsExponentOfTwo(texture.width) && Tools.IsExponentOfTwo(texture.height);
      if (isPot && texture.generateMipMaps && level === 0) {
        this._gl.generateMipmap(this._gl.TEXTURE_CUBE_MAP);
      }
      this._bindTextureDirectly(this._gl.TEXTURE_CUBE_MAP, null);
      texture.isReady = true;
    };
    ThinEngine.prototype.createRawCubeTextureFromUrl = function(url, scene, size, format, type, noMipmap, callback, mipmapGenerator, onLoad = null, onError = null, samplingMode = 3, invertY = false) {
      const gl = this._gl;
      const texture = this.createRawCubeTexture(null, size, format, type, !noMipmap, invertY, samplingMode, null);
      scene === null || scene === void 0 ? void 0 : scene.addPendingData(texture);
      texture.url = url;
      texture.isReady = false;
      this._internalTexturesCache.push(texture);
      const onerror = (request, exception) => {
        scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);
        if (onError && request) {
          onError(request.status + " " + request.statusText, exception);
        }
      };
      const internalCallback = (data) => {
        const width = texture.width;
        const faceDataArrays = callback(data);
        if (!faceDataArrays) {
          return;
        }
        if (mipmapGenerator) {
          const textureType = this._getWebGLTextureType(type);
          let internalFormat = this._getInternalFormat(format);
          const internalSizedFomat = this._getRGBABufferInternalSizedFormat(type);
          let needConversion = false;
          if (internalFormat === gl.RGB) {
            internalFormat = gl.RGBA;
            needConversion = true;
          }
          this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
          this._unpackFlipY(false);
          const mipData = mipmapGenerator(faceDataArrays);
          for (let level = 0; level < mipData.length; level++) {
            const mipSize = width >> level;
            for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
              let mipFaceData = mipData[level][faceIndex];
              if (needConversion) {
                mipFaceData = _convertRGBtoRGBATextureData(mipFaceData, mipSize, mipSize, type);
              }
              gl.texImage2D(faceIndex, level, internalSizedFomat, mipSize, mipSize, 0, internalFormat, textureType, mipFaceData);
            }
          }
          this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
        } else {
          this.updateRawCubeTexture(texture, faceDataArrays, format, type, invertY);
        }
        texture.isReady = true;
        scene === null || scene === void 0 ? void 0 : scene.removePendingData(texture);
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
          onLoad();
        }
      };
      this._loadFile(url, (data) => {
        internalCallback(data);
      }, void 0, scene === null || scene === void 0 ? void 0 : scene.offlineProvider, true, onerror);
      return texture;
    };
    ThinEngine.prototype.createRawTexture2DArray = _makeCreateRawTextureFunction(false);
    ThinEngine.prototype.createRawTexture3D = _makeCreateRawTextureFunction(true);
    ThinEngine.prototype.updateRawTexture2DArray = _makeUpdateRawTextureFunction(false);
    ThinEngine.prototype.updateRawTexture3D = _makeUpdateRawTextureFunction(true);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture.js
var RawTexture;
var init_rawTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture.js"() {
    init_texture();
    init_engine_rawTexture();
    RawTexture = class extends Texture {
      constructor(data, width, height, format, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags, useSRGBBuffer) {
        super(null, sceneOrEngine, !generateMipMaps, invertY, void 0, void 0, void 0, void 0, void 0, void 0, void 0, void 0, creationFlags);
        this.format = format;
        if (!this._engine) {
          return;
        }
        if (!this._engine._caps.textureFloatLinearFiltering && type === 1) {
          samplingMode = 1;
        }
        if (!this._engine._caps.textureHalfFloatLinearFiltering && type === 2) {
          samplingMode = 1;
        }
        this._texture = this._engine.createRawTexture(data, width, height, format, generateMipMaps, invertY, samplingMode, null, type, creationFlags !== null && creationFlags !== void 0 ? creationFlags : 0, useSRGBBuffer !== null && useSRGBBuffer !== void 0 ? useSRGBBuffer : false);
        this.wrapU = Texture.CLAMP_ADDRESSMODE;
        this.wrapV = Texture.CLAMP_ADDRESSMODE;
      }
      update(data) {
        this._getEngine().updateRawTexture(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type, this._texture._useSRGBBuffer);
      }
      static CreateLuminanceTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
        return new RawTexture(data, width, height, 1, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      }
      static CreateLuminanceAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
        return new RawTexture(data, width, height, 2, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      }
      static CreateAlphaTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3) {
        return new RawTexture(data, width, height, 0, sceneOrEngine, generateMipMaps, invertY, samplingMode);
      }
      static CreateRGBTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
        return new RawTexture(data, width, height, 4, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
      }
      static CreateRGBATexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, creationFlags = 0, useSRGBBuffer = false) {
        return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, creationFlags, useSRGBBuffer);
      }
      static CreateRGBAStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0, useSRGBBuffer = false) {
        return new RawTexture(data, width, height, 5, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1, useSRGBBuffer);
      }
      static CreateRTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
        return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type);
      }
      static CreateRStorageTexture(data, width, height, sceneOrEngine, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, type = 1) {
        return new RawTexture(data, width, height, 6, sceneOrEngine, generateMipMaps, invertY, samplingMode, type, 1);
      }
    };
  }
});

// node_modules/@babylonjs/core/Loading/sceneLoader.js
var SceneLoaderAnimationGroupLoadingMode, SceneLoader;
var init_sceneLoader = __esm({
  "node_modules/@babylonjs/core/Loading/sceneLoader.js"() {
    init_tools();
    init_observable();
    init_scene();
    init_engine();
    init_engineStore();
    init_logger();
    init_sceneLoaderFlags();
    init_fileTools();
    init_error();
    (function(SceneLoaderAnimationGroupLoadingMode2) {
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Clean"] = 0] = "Clean";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Stop"] = 1] = "Stop";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["Sync"] = 2] = "Sync";
      SceneLoaderAnimationGroupLoadingMode2[SceneLoaderAnimationGroupLoadingMode2["NoSync"] = 3] = "NoSync";
    })(SceneLoaderAnimationGroupLoadingMode || (SceneLoaderAnimationGroupLoadingMode = {}));
    SceneLoader = class {
      static get ForceFullSceneLoadingForIncremental() {
        return SceneLoaderFlags.ForceFullSceneLoadingForIncremental;
      }
      static set ForceFullSceneLoadingForIncremental(value) {
        SceneLoaderFlags.ForceFullSceneLoadingForIncremental = value;
      }
      static get ShowLoadingScreen() {
        return SceneLoaderFlags.ShowLoadingScreen;
      }
      static set ShowLoadingScreen(value) {
        SceneLoaderFlags.ShowLoadingScreen = value;
      }
      static get loggingLevel() {
        return SceneLoaderFlags.loggingLevel;
      }
      static set loggingLevel(value) {
        SceneLoaderFlags.loggingLevel = value;
      }
      static get CleanBoneMatrixWeights() {
        return SceneLoaderFlags.CleanBoneMatrixWeights;
      }
      static set CleanBoneMatrixWeights(value) {
        SceneLoaderFlags.CleanBoneMatrixWeights = value;
      }
      static GetDefaultPlugin() {
        return SceneLoader._RegisteredPlugins[".babylon"];
      }
      static _GetPluginForExtension(extension) {
        const registeredPlugin = SceneLoader._RegisteredPlugins[extension];
        if (registeredPlugin) {
          return registeredPlugin;
        }
        Logger.Warn("Unable to find a plugin to load " + extension + " files. Trying to use .babylon default plugin. To load from a specific filetype (eg. gltf) see: https://doc.babylonjs.com/features/featuresDeepDive/importers/loadingFileTypes");
        return SceneLoader.GetDefaultPlugin();
      }
      static _GetPluginForDirectLoad(data) {
        for (const extension in SceneLoader._RegisteredPlugins) {
          const plugin = SceneLoader._RegisteredPlugins[extension].plugin;
          if (plugin.canDirectLoad && plugin.canDirectLoad(data)) {
            return SceneLoader._RegisteredPlugins[extension];
          }
        }
        return SceneLoader.GetDefaultPlugin();
      }
      static _GetPluginForFilename(sceneFilename) {
        const queryStringPosition = sceneFilename.indexOf("?");
        if (queryStringPosition !== -1) {
          sceneFilename = sceneFilename.substring(0, queryStringPosition);
        }
        const dotPosition = sceneFilename.lastIndexOf(".");
        const extension = sceneFilename.substring(dotPosition, sceneFilename.length).toLowerCase();
        return SceneLoader._GetPluginForExtension(extension);
      }
      static _GetDirectLoad(sceneFilename) {
        if (sceneFilename.substr(0, 5) === "data:") {
          return sceneFilename.substr(5);
        }
        return null;
      }
      static _FormatErrorMessage(fileInfo, message, exception) {
        const fromLoad = fileInfo.rawData ? "binary data" : fileInfo.url;
        let errorMessage = "Unable to load from " + fromLoad;
        if (message) {
          errorMessage += `: ${message}`;
        } else if (exception) {
          errorMessage += `: ${exception}`;
        }
        return errorMessage;
      }
      static _LoadData(fileInfo, scene, onSuccess, onProgress, onError, onDispose, pluginExtension, name109) {
        const directLoad = SceneLoader._GetDirectLoad(fileInfo.url);
        if (fileInfo.rawData && !pluginExtension) {
          throw "When using ArrayBufferView to load data the file extension must be provided.";
        }
        const registeredPlugin = pluginExtension ? SceneLoader._GetPluginForExtension(pluginExtension) : directLoad ? SceneLoader._GetPluginForDirectLoad(fileInfo.url) : SceneLoader._GetPluginForFilename(fileInfo.url);
        if (fileInfo.rawData && !registeredPlugin.isBinary) {
          throw "Loading from ArrayBufferView can not be used with plugins that don't support binary loading.";
        }
        let plugin;
        if (registeredPlugin.plugin.createPlugin !== void 0) {
          plugin = registeredPlugin.plugin.createPlugin();
        } else {
          plugin = registeredPlugin.plugin;
        }
        if (!plugin) {
          throw "The loader plugin corresponding to the file type you are trying to load has not been found. If using es6, please import the plugin you wish to use before.";
        }
        SceneLoader.OnPluginActivatedObservable.notifyObservers(plugin);
        if (directLoad && (plugin.canDirectLoad && plugin.canDirectLoad(fileInfo.url) || !IsBase64DataUrl(fileInfo.url))) {
          if (plugin.directLoad) {
            const result = plugin.directLoad(scene, directLoad);
            if (result.then) {
              result.then((data) => {
                onSuccess(plugin, data);
              }).catch((error) => {
                onError("Error in directLoad of _loadData: " + error, error);
              });
            } else {
              onSuccess(plugin, result);
            }
          } else {
            onSuccess(plugin, directLoad);
          }
          return plugin;
        }
        const useArrayBuffer = registeredPlugin.isBinary;
        const dataCallback = (data, responseURL) => {
          if (scene.isDisposed) {
            onError("Scene has been disposed");
            return;
          }
          onSuccess(plugin, data, responseURL);
        };
        let request = null;
        let pluginDisposed = false;
        const onDisposeObservable = plugin.onDisposeObservable;
        if (onDisposeObservable) {
          onDisposeObservable.add(() => {
            pluginDisposed = true;
            if (request) {
              request.abort();
              request = null;
            }
            onDispose();
          });
        }
        const manifestChecked = () => {
          if (pluginDisposed) {
            return;
          }
          const errorCallback = (request2, exception) => {
            onError(request2 === null || request2 === void 0 ? void 0 : request2.statusText, exception);
          };
          if (!plugin.loadFile && fileInfo.rawData) {
            throw "Plugin does not support loading ArrayBufferView.";
          }
          request = plugin.loadFile ? plugin.loadFile(scene, fileInfo.rawData || fileInfo.file || fileInfo.url, fileInfo.rootUrl, dataCallback, onProgress, useArrayBuffer, errorCallback, name109) : scene._loadFile(fileInfo.file || fileInfo.url, dataCallback, onProgress, true, useArrayBuffer, errorCallback);
        };
        const engine = scene.getEngine();
        let canUseOfflineSupport = engine.enableOfflineSupport;
        if (canUseOfflineSupport) {
          let exceptionFound = false;
          for (const regex of scene.disableOfflineSupportExceptionRules) {
            if (regex.test(fileInfo.url)) {
              exceptionFound = true;
              break;
            }
          }
          canUseOfflineSupport = !exceptionFound;
        }
        if (canUseOfflineSupport && Engine.OfflineProviderFactory) {
          scene.offlineProvider = Engine.OfflineProviderFactory(fileInfo.url, manifestChecked, engine.disableManifestCheck);
        } else {
          manifestChecked();
        }
        return plugin;
      }
      static _GetFileInfo(rootUrl, sceneFilename) {
        let url;
        let name109;
        let file = null;
        let rawData = null;
        if (!sceneFilename) {
          url = rootUrl;
          name109 = Tools.GetFilename(rootUrl);
          rootUrl = Tools.GetFolderPath(rootUrl);
        } else if (sceneFilename.name) {
          const sceneFile = sceneFilename;
          url = `file:${sceneFile.name}`;
          name109 = sceneFile.name;
          file = sceneFile;
        } else if (ArrayBuffer.isView(sceneFilename)) {
          url = "";
          name109 = "arrayBuffer";
          rawData = sceneFilename;
        } else if (typeof sceneFilename === "string" && sceneFilename.startsWith("data:")) {
          url = sceneFilename;
          name109 = "";
        } else {
          const filename = sceneFilename;
          if (filename.substr(0, 1) === "/") {
            Tools.Error("Wrong sceneFilename parameter");
            return null;
          }
          url = rootUrl + filename;
          name109 = filename;
        }
        return {
          url,
          rootUrl,
          name: name109,
          file,
          rawData
        };
      }
      static GetPluginForExtension(extension) {
        return SceneLoader._GetPluginForExtension(extension).plugin;
      }
      static IsPluginForExtensionAvailable(extension) {
        return !!SceneLoader._RegisteredPlugins[extension];
      }
      static RegisterPlugin(plugin) {
        if (typeof plugin.extensions === "string") {
          const extension = plugin.extensions;
          SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {
            plugin,
            isBinary: false
          };
        } else {
          const extensions = plugin.extensions;
          Object.keys(extensions).forEach((extension) => {
            SceneLoader._RegisteredPlugins[extension.toLowerCase()] = {
              plugin,
              isBinary: extensions[extension].isBinary
            };
          });
        }
      }
      static ImportMesh(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name109 = "") {
        if (!scene) {
          Logger.Error("No scene available to import mesh to");
          return null;
        }
        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);
        if (!fileInfo) {
          return null;
        }
        const loadingToken = {};
        scene.addPendingData(loadingToken);
        const disposeHandler = () => {
          scene.removePendingData(loadingToken);
        };
        const errorHandler = (message, exception) => {
          const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);
          if (onError) {
            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
          } else {
            Logger.Error(errorMessage);
          }
          disposeHandler();
        };
        const progressHandler = onProgress ? (event) => {
          try {
            onProgress(event);
          } catch (e) {
            errorHandler("Error in onProgress callback: " + e, e);
          }
        } : void 0;
        const successHandler = (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {
          scene.importedMeshesFiles.push(fileInfo.url);
          if (onSuccess) {
            try {
              onSuccess(meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights);
            } catch (e) {
              errorHandler("Error in onSuccess callback: " + e, e);
            }
          }
          scene.removePendingData(loadingToken);
        };
        return SceneLoader._LoadData(fileInfo, scene, (plugin, data, responseURL) => {
          if (plugin.rewriteRootURL) {
            fileInfo.rootUrl = plugin.rewriteRootURL(fileInfo.rootUrl, responseURL);
          }
          if (plugin.importMesh) {
            const syncedPlugin = plugin;
            const meshes = new Array();
            const particleSystems = new Array();
            const skeletons = new Array();
            if (!syncedPlugin.importMesh(meshNames, scene, data, fileInfo.rootUrl, meshes, particleSystems, skeletons, errorHandler)) {
              return;
            }
            scene.loadingPluginName = plugin.name;
            successHandler(meshes, particleSystems, skeletons, [], [], [], []);
          } else {
            const asyncedPlugin = plugin;
            asyncedPlugin.importMeshAsync(meshNames, scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((result) => {
              scene.loadingPluginName = plugin.name;
              successHandler(result.meshes, result.particleSystems, result.skeletons, result.animationGroups, result.transformNodes, result.geometries, result.lights);
            }).catch((error) => {
              errorHandler(error.message, error);
            });
          }
        }, progressHandler, errorHandler, disposeHandler, pluginExtension, name109);
      }
      static ImportMeshAsync(meshNames, rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name109 = "") {
        return new Promise((resolve, reject) => {
          SceneLoader.ImportMesh(meshNames, rootUrl, sceneFilename, scene, (meshes, particleSystems, skeletons, animationGroups, transformNodes, geometries, lights) => {
            resolve({
              meshes,
              particleSystems,
              skeletons,
              animationGroups,
              transformNodes,
              geometries,
              lights
            });
          }, onProgress, (scene2, message, exception) => {
            reject(exception || new Error(message));
          }, pluginExtension, name109);
        });
      }
      static Load(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name109 = "") {
        if (!engine) {
          Tools.Error("No engine available");
          return null;
        }
        return SceneLoader.Append(rootUrl, sceneFilename, new Scene(engine), onSuccess, onProgress, onError, pluginExtension, name109);
      }
      static LoadAsync(rootUrl, sceneFilename = "", engine = EngineStore.LastCreatedEngine, onProgress = null, pluginExtension = null, name109 = "") {
        return new Promise((resolve, reject) => {
          SceneLoader.Load(rootUrl, sceneFilename, engine, (scene) => {
            resolve(scene);
          }, onProgress, (scene, message, exception) => {
            reject(exception || new Error(message));
          }, pluginExtension, name109);
        });
      }
      static Append(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name109 = "") {
        if (!scene) {
          Logger.Error("No scene available to append to");
          return null;
        }
        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);
        if (!fileInfo) {
          return null;
        }
        const loadingToken = {};
        scene.addPendingData(loadingToken);
        const disposeHandler = () => {
          scene.removePendingData(loadingToken);
        };
        if (SceneLoader.ShowLoadingScreen && !this._ShowingLoadingScreen) {
          this._ShowingLoadingScreen = true;
          scene.getEngine().displayLoadingUI();
          scene.executeWhenReady(() => {
            scene.getEngine().hideLoadingUI();
            this._ShowingLoadingScreen = false;
          });
        }
        const errorHandler = (message, exception) => {
          const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);
          if (onError) {
            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
          } else {
            Logger.Error(errorMessage);
          }
          disposeHandler();
        };
        const progressHandler = onProgress ? (event) => {
          try {
            onProgress(event);
          } catch (e) {
            errorHandler("Error in onProgress callback", e);
          }
        } : void 0;
        const successHandler = () => {
          if (onSuccess) {
            try {
              onSuccess(scene);
            } catch (e) {
              errorHandler("Error in onSuccess callback", e);
            }
          }
          scene.removePendingData(loadingToken);
        };
        return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {
          if (plugin.load) {
            const syncedPlugin = plugin;
            if (!syncedPlugin.load(scene, data, fileInfo.rootUrl, errorHandler)) {
              return;
            }
            scene.loadingPluginName = plugin.name;
            successHandler();
          } else {
            const asyncedPlugin = plugin;
            asyncedPlugin.loadAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then(() => {
              scene.loadingPluginName = plugin.name;
              successHandler();
            }).catch((error) => {
              errorHandler(error.message, error);
            });
          }
        }, progressHandler, errorHandler, disposeHandler, pluginExtension, name109);
      }
      static AppendAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null, name109 = "") {
        return new Promise((resolve, reject) => {
          SceneLoader.Append(rootUrl, sceneFilename, scene, (scene2) => {
            resolve(scene2);
          }, onProgress, (scene2, message, exception) => {
            reject(exception || new Error(message));
          }, pluginExtension, name109);
        });
      }
      static LoadAssetContainer(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onSuccess = null, onProgress = null, onError = null, pluginExtension = null, name109 = "") {
        if (!scene) {
          Logger.Error("No scene available to load asset container to");
          return null;
        }
        const fileInfo = SceneLoader._GetFileInfo(rootUrl, sceneFilename);
        if (!fileInfo) {
          return null;
        }
        const loadingToken = {};
        scene.addPendingData(loadingToken);
        const disposeHandler = () => {
          scene.removePendingData(loadingToken);
        };
        const errorHandler = (message, exception) => {
          const errorMessage = SceneLoader._FormatErrorMessage(fileInfo, message, exception);
          if (onError) {
            onError(scene, errorMessage, new RuntimeError(errorMessage, ErrorCodes.SceneLoaderError, exception));
          } else {
            Logger.Error(errorMessage);
          }
          disposeHandler();
        };
        const progressHandler = onProgress ? (event) => {
          try {
            onProgress(event);
          } catch (e) {
            errorHandler("Error in onProgress callback", e);
          }
        } : void 0;
        const successHandler = (assets) => {
          if (onSuccess) {
            try {
              onSuccess(assets);
            } catch (e) {
              errorHandler("Error in onSuccess callback", e);
            }
          }
          scene.removePendingData(loadingToken);
        };
        return SceneLoader._LoadData(fileInfo, scene, (plugin, data) => {
          if (plugin.loadAssetContainer) {
            const syncedPlugin = plugin;
            const assetContainer = syncedPlugin.loadAssetContainer(scene, data, fileInfo.rootUrl, errorHandler);
            if (!assetContainer) {
              return;
            }
            assetContainer.populateRootNodes();
            scene.loadingPluginName = plugin.name;
            successHandler(assetContainer);
          } else if (plugin.loadAssetContainerAsync) {
            const asyncedPlugin = plugin;
            asyncedPlugin.loadAssetContainerAsync(scene, data, fileInfo.rootUrl, progressHandler, fileInfo.name).then((assetContainer) => {
              assetContainer.populateRootNodes();
              scene.loadingPluginName = plugin.name;
              successHandler(assetContainer);
            }).catch((error) => {
              errorHandler(error.message, error);
            });
          } else {
            errorHandler("LoadAssetContainer is not supported by this plugin. Plugin did not provide a loadAssetContainer or loadAssetContainerAsync method.");
          }
        }, progressHandler, errorHandler, disposeHandler, pluginExtension, name109);
      }
      static LoadAssetContainerAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, onProgress = null, pluginExtension = null) {
        return new Promise((resolve, reject) => {
          SceneLoader.LoadAssetContainer(rootUrl, sceneFilename, scene, (assetContainer) => {
            resolve(assetContainer);
          }, onProgress, (scene2, message, exception) => {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      }
      static ImportAnimations(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
        if (!scene) {
          Logger.Error("No scene available to load animations to");
          return;
        }
        if (overwriteAnimations) {
          for (const animatable of scene.animatables) {
            animatable.reset();
          }
          scene.stopAllAnimations();
          scene.animationGroups.slice().forEach((animationGroup) => {
            animationGroup.dispose();
          });
          const nodes = scene.getNodes();
          nodes.forEach((node) => {
            if (node.animations) {
              node.animations = [];
            }
          });
        } else {
          switch (animationGroupLoadingMode) {
            case SceneLoaderAnimationGroupLoadingMode.Clean:
              scene.animationGroups.slice().forEach((animationGroup) => {
                animationGroup.dispose();
              });
              break;
            case SceneLoaderAnimationGroupLoadingMode.Stop:
              scene.animationGroups.forEach((animationGroup) => {
                animationGroup.stop();
              });
              break;
            case SceneLoaderAnimationGroupLoadingMode.Sync:
              scene.animationGroups.forEach((animationGroup) => {
                animationGroup.reset();
                animationGroup.restart();
              });
              break;
            case SceneLoaderAnimationGroupLoadingMode.NoSync:
              break;
            default:
              Logger.Error("Unknown animation group loading mode value '" + animationGroupLoadingMode + "'");
              return;
          }
        }
        const startingIndexForNewAnimatables = scene.animatables.length;
        const onAssetContainerLoaded = (container) => {
          container.mergeAnimationsTo(scene, scene.animatables.slice(startingIndexForNewAnimatables), targetConverter);
          container.dispose();
          scene.onAnimationFileImportedObservable.notifyObservers(scene);
          if (onSuccess) {
            onSuccess(scene);
          }
        };
        this.LoadAssetContainer(rootUrl, sceneFilename, scene, onAssetContainerLoaded, onProgress, onError, pluginExtension);
      }
      static ImportAnimationsAsync(rootUrl, sceneFilename = "", scene = EngineStore.LastCreatedScene, overwriteAnimations = true, animationGroupLoadingMode = SceneLoaderAnimationGroupLoadingMode.Clean, targetConverter = null, onSuccess = null, onProgress = null, onError = null, pluginExtension = null) {
        return new Promise((resolve, reject) => {
          SceneLoader.ImportAnimations(rootUrl, sceneFilename, scene, overwriteAnimations, animationGroupLoadingMode, targetConverter, (_scene) => {
            resolve(_scene);
          }, onProgress, (_scene, message, exception) => {
            reject(exception || new Error(message));
          }, pluginExtension);
        });
      }
    };
    SceneLoader.NO_LOGGING = 0;
    SceneLoader.MINIMAL_LOGGING = 1;
    SceneLoader.SUMMARY_LOGGING = 2;
    SceneLoader.DETAILED_LOGGING = 3;
    SceneLoader.OnPluginActivatedObservable = new Observable();
    SceneLoader._RegisteredPlugins = {};
    SceneLoader._ShowingLoadingScreen = false;
  }
});

// node_modules/@babylonjs/core/Materials/pushMaterial.js
var PushMaterial;
var init_pushMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/pushMaterial.js"() {
    init_math_vector();
    init_material();
    PushMaterial = class extends Material {
      constructor(name109, scene, storeEffectOnSubMeshes = true) {
        super(name109, scene);
        this._normalMatrix = new Matrix();
        this._storeEffectOnSubMeshes = storeEffectOnSubMeshes;
      }
      getEffect() {
        return this._storeEffectOnSubMeshes ? this._activeEffect : super.getEffect();
      }
      isReady(mesh, useInstances) {
        if (!mesh) {
          return false;
        }
        if (!this._storeEffectOnSubMeshes) {
          return true;
        }
        if (!mesh.subMeshes || mesh.subMeshes.length === 0) {
          return true;
        }
        return this.isReadyForSubMesh(mesh, mesh.subMeshes[0], useInstances);
      }
      _isReadyForSubMesh(subMesh) {
        const defines = subMesh.materialDefines;
        if (!this.checkReadyOnEveryCall && subMesh.effect && defines) {
          if (defines._renderId === this.getScene().getRenderId()) {
            return true;
          }
        }
        return false;
      }
      bindOnlyWorldMatrix(world) {
        this._activeEffect.setMatrix("world", world);
      }
      bindOnlyNormalMatrix(normalMatrix) {
        this._activeEffect.setMatrix("normalMatrix", normalMatrix);
      }
      bind(world, mesh) {
        if (!mesh) {
          return;
        }
        this.bindForSubMesh(world, mesh, mesh.subMeshes[0]);
      }
      _afterBind(mesh, effect = null) {
        super._afterBind(mesh, effect);
        this.getScene()._cachedEffect = effect;
        if (effect) {
          effect._forceRebindOnNextCall = false;
        }
      }
      _mustRebind(scene, effect, visibility = 1) {
        return scene.isCachedMaterialInvalid(this, effect, visibility);
      }
      dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        this._activeEffect = void 0;
        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
      }
    };
  }
});

// node_modules/@babylonjs/core/Maths/math.vertexFormat.js
var PositionNormalVertex, PositionNormalTextureVertex;
var init_math_vertexFormat = __esm({
  "node_modules/@babylonjs/core/Maths/math.vertexFormat.js"() {
    init_math_vector();
    PositionNormalVertex = class {
      constructor(position = Vector3.Zero(), normal = Vector3.Up()) {
        this.position = position;
        this.normal = normal;
      }
      clone() {
        return new PositionNormalVertex(this.position.clone(), this.normal.clone());
      }
    };
    PositionNormalTextureVertex = class {
      constructor(position = Vector3.Zero(), normal = Vector3.Up(), uv = Vector2.Zero()) {
        this.position = position;
        this.normal = normal;
        this.uv = uv;
      }
      clone() {
        return new PositionNormalTextureVertex(this.position.clone(), this.normal.clone(), this.uv.clone());
      }
    };
  }
});

// node_modules/@babylonjs/core/Materials/effectFallbacks.js
var EffectFallbacks;
var init_effectFallbacks = __esm({
  "node_modules/@babylonjs/core/Materials/effectFallbacks.js"() {
    EffectFallbacks = class {
      constructor() {
        this._defines = {};
        this._currentRank = 32;
        this._maxRank = -1;
        this._mesh = null;
      }
      unBindMesh() {
        this._mesh = null;
      }
      addFallback(rank, define) {
        if (!this._defines[rank]) {
          if (rank < this._currentRank) {
            this._currentRank = rank;
          }
          if (rank > this._maxRank) {
            this._maxRank = rank;
          }
          this._defines[rank] = new Array();
        }
        this._defines[rank].push(define);
      }
      addCPUSkinningFallback(rank, mesh) {
        this._mesh = mesh;
        if (rank < this._currentRank) {
          this._currentRank = rank;
        }
        if (rank > this._maxRank) {
          this._maxRank = rank;
        }
      }
      get hasMoreFallbacks() {
        return this._currentRank <= this._maxRank;
      }
      reduce(currentDefines, effect) {
        if (this._mesh && this._mesh.computeBonesUsingShaders && this._mesh.numBoneInfluencers > 0) {
          this._mesh.computeBonesUsingShaders = false;
          currentDefines = currentDefines.replace("#define NUM_BONE_INFLUENCERS " + this._mesh.numBoneInfluencers, "#define NUM_BONE_INFLUENCERS 0");
          effect._bonesComputationForcedToCPU = true;
          const scene = this._mesh.getScene();
          for (let index = 0; index < scene.meshes.length; index++) {
            const otherMesh = scene.meshes[index];
            if (!otherMesh.material) {
              if (!this._mesh.material && otherMesh.computeBonesUsingShaders && otherMesh.numBoneInfluencers > 0) {
                otherMesh.computeBonesUsingShaders = false;
              }
              continue;
            }
            if (!otherMesh.computeBonesUsingShaders || otherMesh.numBoneInfluencers === 0) {
              continue;
            }
            if (otherMesh.material.getEffect() === effect) {
              otherMesh.computeBonesUsingShaders = false;
            } else if (otherMesh.subMeshes) {
              for (const subMesh of otherMesh.subMeshes) {
                const subMeshEffect = subMesh.effect;
                if (subMeshEffect === effect) {
                  otherMesh.computeBonesUsingShaders = false;
                  break;
                }
              }
            }
          }
        } else {
          const currentFallbacks = this._defines[this._currentRank];
          if (currentFallbacks) {
            for (let index = 0; index < currentFallbacks.length; index++) {
              currentDefines = currentDefines.replace("#define " + currentFallbacks[index], "");
            }
          }
          this._currentRank++;
        }
        return currentDefines;
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/renderTargetWrapper.js
var RenderTargetWrapper;
var init_renderTargetWrapper = __esm({
  "node_modules/@babylonjs/core/Engines/renderTargetWrapper.js"() {
    init_internalTexture();
    RenderTargetWrapper = class {
      get depthStencilTexture() {
        return this._depthStencilTexture;
      }
      get depthStencilTextureWithStencil() {
        return this._depthStencilTextureWithStencil;
      }
      get isCube() {
        return this._isCube;
      }
      get isMulti() {
        return this._isMulti;
      }
      get is2DArray() {
        return this.layers > 0;
      }
      get size() {
        return this.width;
      }
      get width() {
        return this._size.width || this._size;
      }
      get height() {
        return this._size.height || this._size;
      }
      get layers() {
        return this._size.layers || 0;
      }
      get texture() {
        var _a, _b;
        return (_b = (_a = this._textures) === null || _a === void 0 ? void 0 : _a[0]) !== null && _b !== void 0 ? _b : null;
      }
      get textures() {
        return this._textures;
      }
      get faceIndices() {
        return this._faceIndices;
      }
      get layerIndices() {
        return this._layerIndices;
      }
      get samples() {
        return this._samples;
      }
      setSamples(value, initializeBuffers = true, force = false) {
        if (this.samples === value && !force) {
          return value;
        }
        const result = this._isMulti ? this._engine.updateMultipleRenderTargetTextureSampleCount(this, value, initializeBuffers) : this._engine.updateRenderTargetTextureSampleCount(this, value);
        this._samples = value;
        return result;
      }
      constructor(isMulti, isCube, size, engine, label) {
        this._textures = null;
        this._faceIndices = null;
        this._layerIndices = null;
        this._samples = 1;
        this._attachments = null;
        this._generateStencilBuffer = false;
        this._generateDepthBuffer = false;
        this._depthStencilTextureWithStencil = false;
        this._isMulti = isMulti;
        this._isCube = isCube;
        this._size = size;
        this._engine = engine;
        this._depthStencilTexture = null;
        this.label = label;
      }
      setTextures(textures) {
        if (Array.isArray(textures)) {
          this._textures = textures;
        } else if (textures) {
          this._textures = [textures];
        } else {
          this._textures = null;
        }
      }
      setTexture(texture, index = 0, disposePrevious = true) {
        if (!this._textures) {
          this._textures = [];
        }
        if (this._textures[index] === texture) {
          return;
        }
        if (this._textures[index] && disposePrevious) {
          this._textures[index].dispose();
        }
        this._textures[index] = texture;
      }
      setLayerAndFaceIndices(layers, faces) {
        this._layerIndices = layers;
        this._faceIndices = faces;
      }
      setLayerAndFaceIndex(index = 0, layer, face) {
        if (!this._layerIndices) {
          this._layerIndices = [];
        }
        if (!this._faceIndices) {
          this._faceIndices = [];
        }
        if (layer !== void 0 && layer >= 0) {
          this._layerIndices[index] = layer;
        }
        if (face !== void 0 && face >= 0) {
          this._faceIndices[index] = face;
        }
      }
      createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14, label) {
        var _a;
        (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
        this._depthStencilTextureWithStencil = generateStencil;
        this._depthStencilTexture = this._engine.createDepthStencilTexture(this._size, {
          bilinearFiltering,
          comparisonFunction,
          generateStencil,
          isCube: this._isCube,
          samples,
          depthTextureFormat: format,
          label
        }, this);
        return this._depthStencilTexture;
      }
      _shareDepth(renderTarget) {
        if (this._depthStencilTexture) {
          if (renderTarget._depthStencilTexture) {
            renderTarget._depthStencilTexture.dispose();
          }
          renderTarget._depthStencilTexture = this._depthStencilTexture;
          this._depthStencilTexture.incrementReferences();
        }
      }
      _swapAndDie(target) {
        if (this.texture) {
          this.texture._swapAndDie(target);
        }
        this._textures = null;
        this.dispose(true);
      }
      _cloneRenderTargetWrapper() {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        let rtw = null;
        if (this._isMulti) {
          const textureArray = this.textures;
          if (textureArray && textureArray.length > 0) {
            let generateDepthTexture = false;
            let textureCount = textureArray.length;
            const lastTextureSource = textureArray[textureArray.length - 1]._source;
            if (lastTextureSource === InternalTextureSource.Depth || lastTextureSource === InternalTextureSource.DepthStencil) {
              generateDepthTexture = true;
              textureCount--;
            }
            const samplingModes = [];
            const types = [];
            const formats = [];
            const targetTypes = [];
            const faceIndex = [];
            const layerIndex = [];
            const layerCounts = [];
            const internalTexture2Index = {};
            for (let i = 0; i < textureCount; ++i) {
              const texture = textureArray[i];
              samplingModes.push(texture.samplingMode);
              types.push(texture.type);
              formats.push(texture.format);
              const index = internalTexture2Index[texture.uniqueId];
              if (index !== void 0) {
                targetTypes.push(-1);
                layerCounts.push(0);
              } else {
                internalTexture2Index[texture.uniqueId] = i;
                if (texture.is2DArray) {
                  targetTypes.push(35866);
                  layerCounts.push(texture.depth);
                } else if (texture.isCube) {
                  targetTypes.push(34067);
                  layerCounts.push(0);
                } else if (texture.is3D) {
                  targetTypes.push(32879);
                  layerCounts.push(texture.depth);
                } else {
                  targetTypes.push(3553);
                  layerCounts.push(0);
                }
              }
              if (this._faceIndices) {
                faceIndex.push((_a = this._faceIndices[i]) !== null && _a !== void 0 ? _a : 0);
              }
              if (this._layerIndices) {
                layerIndex.push((_b = this._layerIndices[i]) !== null && _b !== void 0 ? _b : 0);
              }
            }
            const optionsMRT = {
              samplingModes,
              generateMipMaps: textureArray[0].generateMipMaps,
              generateDepthBuffer: this._generateDepthBuffer,
              generateStencilBuffer: this._generateStencilBuffer,
              generateDepthTexture,
              types,
              formats,
              textureCount,
              targetTypes,
              faceIndex,
              layerIndex,
              layerCounts
            };
            const size = {
              width: this.width,
              height: this.height
            };
            rtw = this._engine.createMultipleRenderTarget(size, optionsMRT);
            for (let i = 0; i < textureCount; ++i) {
              if (targetTypes[i] !== -1) {
                continue;
              }
              const index = internalTexture2Index[textureArray[i].uniqueId];
              rtw.setTexture(rtw.textures[index], i);
            }
          }
        } else {
          const options = {};
          options.generateDepthBuffer = this._generateDepthBuffer;
          options.generateMipMaps = (_d = (_c = this.texture) === null || _c === void 0 ? void 0 : _c.generateMipMaps) !== null && _d !== void 0 ? _d : false;
          options.generateStencilBuffer = this._generateStencilBuffer;
          options.samplingMode = (_e = this.texture) === null || _e === void 0 ? void 0 : _e.samplingMode;
          options.type = (_f = this.texture) === null || _f === void 0 ? void 0 : _f.type;
          options.format = (_g = this.texture) === null || _g === void 0 ? void 0 : _g.format;
          if (this.isCube) {
            rtw = this._engine.createRenderTargetCubeTexture(this.width, options);
          } else {
            const size = {
              width: this.width,
              height: this.height,
              layers: this.is2DArray ? (_h = this.texture) === null || _h === void 0 ? void 0 : _h.depth : void 0
            };
            rtw = this._engine.createRenderTargetTexture(size, options);
          }
          rtw.texture.isReady = true;
        }
        return rtw;
      }
      _swapRenderTargetWrapper(target) {
        if (this._textures && target._textures) {
          for (let i = 0; i < this._textures.length; ++i) {
            this._textures[i]._swapAndDie(target._textures[i], false);
            target._textures[i].isReady = true;
          }
        }
        if (this._depthStencilTexture && target._depthStencilTexture) {
          this._depthStencilTexture._swapAndDie(target._depthStencilTexture);
          target._depthStencilTexture.isReady = true;
        }
        this._textures = null;
        this._depthStencilTexture = null;
      }
      _rebuild() {
        const rtw = this._cloneRenderTargetWrapper();
        if (!rtw) {
          return;
        }
        if (this._depthStencilTexture) {
          const samplingMode = this._depthStencilTexture.samplingMode;
          const bilinear = samplingMode === 2 || samplingMode === 3 || samplingMode === 11;
          rtw.createDepthStencilTexture(this._depthStencilTexture._comparisonFunction, bilinear, this._depthStencilTextureWithStencil, this._depthStencilTexture.samples);
        }
        if (this.samples > 1) {
          rtw.setSamples(this.samples);
        }
        rtw._swapRenderTargetWrapper(this);
        rtw.dispose();
      }
      releaseTextures() {
        var _a, _b;
        if (this._textures) {
          for (let i = 0; (_b = i < ((_a = this._textures) === null || _a === void 0 ? void 0 : _a.length)) !== null && _b !== void 0 ? _b : 0; ++i) {
            this._textures[i].dispose();
          }
        }
        this._textures = null;
      }
      dispose(disposeOnlyFramebuffers = false) {
        var _a;
        if (!disposeOnlyFramebuffers) {
          (_a = this._depthStencilTexture) === null || _a === void 0 ? void 0 : _a.dispose();
          this._depthStencilTexture = null;
          this.releaseTextures();
        }
        this._engine._releaseRenderTargetWrapper(this);
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/postprocess.vertex.js
var name, shader;
var init_postprocess_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/postprocess.vertex.js"() {
    init_shaderStore();
    name = "postprocessVertexShader";
    shader = `attribute vec2 position;uniform vec2 scale;varying vec2 vUV;const vec2 madd=vec2(0.5,0.5);
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vUV=(position*madd+madd)*scale;gl_Position=vec4(position,0.0,1.0);
#define CUSTOM_VERTEX_MAIN_END
}`;
    ShaderStore.ShadersStore[name] = shader;
  }
});

// node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js
var WebGLRenderTargetWrapper;
var init_webGLRenderTargetWrapper = __esm({
  "node_modules/@babylonjs/core/Engines/WebGL/webGLRenderTargetWrapper.js"() {
    init_renderTargetWrapper();
    WebGLRenderTargetWrapper = class extends RenderTargetWrapper {
      constructor(isMulti, isCube, size, engine, context) {
        super(isMulti, isCube, size, engine);
        this._framebuffer = null;
        this._depthStencilBuffer = null;
        this._MSAAFramebuffer = null;
        this._colorTextureArray = null;
        this._depthStencilTextureArray = null;
        this._disposeOnlyFramebuffers = false;
        this._context = context;
      }
      _cloneRenderTargetWrapper() {
        let rtw = null;
        if (this._colorTextureArray && this._depthStencilTextureArray) {
          rtw = this._engine.createMultiviewRenderTargetTexture(this.width, this.height);
          rtw.texture.isReady = true;
        } else {
          rtw = super._cloneRenderTargetWrapper();
        }
        return rtw;
      }
      _swapRenderTargetWrapper(target) {
        super._swapRenderTargetWrapper(target);
        target._framebuffer = this._framebuffer;
        target._depthStencilBuffer = this._depthStencilBuffer;
        target._MSAAFramebuffer = this._MSAAFramebuffer;
        target._colorTextureArray = this._colorTextureArray;
        target._depthStencilTextureArray = this._depthStencilTextureArray;
        this._framebuffer = this._depthStencilBuffer = this._MSAAFramebuffer = this._colorTextureArray = this._depthStencilTextureArray = null;
      }
      _shareDepth(renderTarget) {
        super._shareDepth(renderTarget);
        const gl = this._context;
        const depthbuffer = this._depthStencilBuffer;
        const framebuffer = renderTarget._MSAAFramebuffer || renderTarget._framebuffer;
        if (renderTarget._depthStencilBuffer && renderTarget._depthStencilBuffer !== depthbuffer) {
          gl.deleteRenderbuffer(renderTarget._depthStencilBuffer);
        }
        renderTarget._depthStencilBuffer = depthbuffer;
        const attachment = renderTarget._generateStencilBuffer ? gl.DEPTH_STENCIL_ATTACHMENT : gl.DEPTH_ATTACHMENT;
        this._engine._bindUnboundFramebuffer(framebuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, attachment, gl.RENDERBUFFER, depthbuffer);
        this._engine._bindUnboundFramebuffer(null);
      }
      _bindTextureRenderTarget(texture, attachmentIndex = 0, faceIndexOrLayer, lodLevel = 0) {
        var _a, _b, _c, _d;
        if (!texture._hardwareTexture) {
          return;
        }
        const framebuffer = this._framebuffer;
        const currentFB = this._engine._currentFramebuffer;
        this._engine._bindUnboundFramebuffer(framebuffer);
        if (this._engine.webGLVersion > 1) {
          const gl = this._context;
          const attachment = gl["COLOR_ATTACHMENT" + attachmentIndex];
          if (texture.is2DArray || texture.is3D) {
            faceIndexOrLayer = (_b = faceIndexOrLayer !== null && faceIndexOrLayer !== void 0 ? faceIndexOrLayer : (_a = this.layerIndices) === null || _a === void 0 ? void 0 : _a[attachmentIndex]) !== null && _b !== void 0 ? _b : 0;
            gl.framebufferTextureLayer(gl.FRAMEBUFFER, attachment, texture._hardwareTexture.underlyingResource, lodLevel, faceIndexOrLayer);
          } else if (texture.isCube) {
            faceIndexOrLayer = (_d = faceIndexOrLayer !== null && faceIndexOrLayer !== void 0 ? faceIndexOrLayer : (_c = this.faceIndices) === null || _c === void 0 ? void 0 : _c[attachmentIndex]) !== null && _d !== void 0 ? _d : 0;
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer, texture._hardwareTexture.underlyingResource, lodLevel);
          } else {
            gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, lodLevel);
          }
        } else {
          const gl = this._context;
          const attachment = gl["COLOR_ATTACHMENT" + attachmentIndex + "_WEBGL"];
          const target = faceIndexOrLayer !== void 0 ? gl.TEXTURE_CUBE_MAP_POSITIVE_X + faceIndexOrLayer : gl.TEXTURE_2D;
          gl.framebufferTexture2D(gl.FRAMEBUFFER, attachment, target, texture._hardwareTexture.underlyingResource, lodLevel);
        }
        this._engine._bindUnboundFramebuffer(currentFB);
      }
      setTexture(texture, index = 0, disposePrevious = true) {
        super.setTexture(texture, index, disposePrevious);
        this._bindTextureRenderTarget(texture, index);
      }
      setLayerAndFaceIndices(layers, faces) {
        var _a, _b;
        super.setLayerAndFaceIndices(layers, faces);
        if (!this.textures || !this.layerIndices || !this.faceIndices) {
          return;
        }
        const textureCount = (_b = (_a = this._attachments) === null || _a === void 0 ? void 0 : _a.length) !== null && _b !== void 0 ? _b : this.textures.length;
        for (let index = 0; index < textureCount; index++) {
          const texture = this.textures[index];
          if (!texture) {
            continue;
          }
          if (texture.is2DArray || texture.is3D) {
            this._bindTextureRenderTarget(texture, index, this.layerIndices[index]);
          } else if (texture.isCube) {
            this._bindTextureRenderTarget(texture, index, this.faceIndices[index]);
          } else {
            this._bindTextureRenderTarget(texture, index);
          }
        }
      }
      setLayerAndFaceIndex(index = 0, layer, face) {
        super.setLayerAndFaceIndex(index, layer, face);
        if (!this.textures || !this.layerIndices || !this.faceIndices) {
          return;
        }
        const texture = this.textures[index];
        if (texture.is2DArray || texture.is3D) {
          this._bindTextureRenderTarget(this.textures[index], index, this.layerIndices[index]);
        } else if (texture.isCube) {
          this._bindTextureRenderTarget(this.textures[index], index, this.faceIndices[index]);
        }
      }
      dispose(disposeOnlyFramebuffers = this._disposeOnlyFramebuffers) {
        const gl = this._context;
        if (!disposeOnlyFramebuffers) {
          if (this._colorTextureArray) {
            this._context.deleteTexture(this._colorTextureArray);
            this._colorTextureArray = null;
          }
          if (this._depthStencilTextureArray) {
            this._context.deleteTexture(this._depthStencilTextureArray);
            this._depthStencilTextureArray = null;
          }
        }
        if (this._framebuffer) {
          gl.deleteFramebuffer(this._framebuffer);
          this._framebuffer = null;
        }
        if (this._depthStencilBuffer) {
          gl.deleteRenderbuffer(this._depthStencilBuffer);
          this._depthStencilBuffer = null;
        }
        if (this._MSAAFramebuffer) {
          gl.deleteFramebuffer(this._MSAAFramebuffer);
          this._MSAAFramebuffer = null;
        }
        super.dispose(disposeOnlyFramebuffers);
      }
    };
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js
var init_engine_renderTarget = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.renderTarget.js"() {
    init_internalTexture();
    init_logger();
    init_thinEngine();
    init_webGLRenderTargetWrapper();
    ThinEngine.prototype._createHardwareRenderTargetWrapper = function(isMulti, isCube, size) {
      const rtWrapper = new WebGLRenderTargetWrapper(isMulti, isCube, size, this, this._gl);
      this._renderTargetWrapperCache.push(rtWrapper);
      return rtWrapper;
    };
    ThinEngine.prototype.createRenderTargetTexture = function(size, options) {
      var _a, _b;
      const rtWrapper = this._createHardwareRenderTargetWrapper(false, false, size);
      let generateDepthBuffer = true;
      let generateStencilBuffer = false;
      let noColorAttachment = false;
      let colorAttachment = void 0;
      let samples = 1;
      if (options !== void 0 && typeof options === "object") {
        generateDepthBuffer = (_a = options.generateDepthBuffer) !== null && _a !== void 0 ? _a : true;
        generateStencilBuffer = !!options.generateStencilBuffer;
        noColorAttachment = !!options.noColorAttachment;
        colorAttachment = options.colorAttachment;
        samples = (_b = options.samples) !== null && _b !== void 0 ? _b : 1;
      }
      const texture = colorAttachment || (noColorAttachment ? null : this._createInternalTexture(size, options, true, InternalTextureSource.RenderTarget));
      const width = size.width || size;
      const height = size.height || size;
      const currentFrameBuffer = this._currentFramebuffer;
      const gl = this._gl;
      const framebuffer = gl.createFramebuffer();
      this._bindUnboundFramebuffer(framebuffer);
      rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(generateStencilBuffer, generateDepthBuffer, width, height);
      if (texture && !texture.is2DArray) {
        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, texture._hardwareTexture.underlyingResource, 0);
      }
      this._bindUnboundFramebuffer(currentFrameBuffer);
      rtWrapper._framebuffer = framebuffer;
      rtWrapper._generateDepthBuffer = generateDepthBuffer;
      rtWrapper._generateStencilBuffer = generateStencilBuffer;
      rtWrapper.setTextures(texture);
      this.updateRenderTargetTextureSampleCount(rtWrapper, samples);
      return rtWrapper;
    };
    ThinEngine.prototype.createDepthStencilTexture = function(size, options, rtWrapper) {
      if (options.isCube) {
        const width = size.width || size;
        return this._createDepthStencilCubeTexture(width, options, rtWrapper);
      } else {
        return this._createDepthStencilTexture(size, options, rtWrapper);
      }
    };
    ThinEngine.prototype._createDepthStencilTexture = function(size, options, rtWrapper) {
      const gl = this._gl;
      const layers = size.layers || 0;
      const target = layers !== 0 ? gl.TEXTURE_2D_ARRAY : gl.TEXTURE_2D;
      const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
      if (!this._caps.depthTextureExtension) {
        Logger.Error("Depth texture is not supported by your browser or hardware.");
        return internalTexture;
      }
      const internalOptions = Object.assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
      this._bindTextureDirectly(target, internalTexture, true);
      this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.comparisonFunction === 0 ? false : internalOptions.bilinearFiltering, internalOptions.comparisonFunction, internalOptions.samples);
      if (internalOptions.depthTextureFormat !== void 0) {
        if (internalOptions.depthTextureFormat !== 15 && internalOptions.depthTextureFormat !== 16 && internalOptions.depthTextureFormat !== 17 && internalOptions.depthTextureFormat !== 13 && internalOptions.depthTextureFormat !== 14 && internalOptions.depthTextureFormat !== 18) {
          Logger.Error("Depth texture format is not supported.");
          return internalTexture;
        }
        internalTexture.format = internalOptions.depthTextureFormat;
      } else {
        internalTexture.format = internalOptions.generateStencil ? 13 : 16;
      }
      const hasStencil = internalTexture.format === 17 || internalTexture.format === 13 || internalTexture.format === 18;
      rtWrapper._depthStencilTexture = internalTexture;
      rtWrapper._depthStencilTextureWithStencil = hasStencil;
      let type = gl.UNSIGNED_INT;
      if (internalTexture.format === 15) {
        type = gl.UNSIGNED_SHORT;
      } else if (internalTexture.format === 17 || internalTexture.format === 13) {
        type = gl.UNSIGNED_INT_24_8;
      } else if (internalTexture.format === 14) {
        type = gl.FLOAT;
      } else if (internalTexture.format === 18) {
        type = gl.FLOAT_32_UNSIGNED_INT_24_8_REV;
      }
      const format = hasStencil ? gl.DEPTH_STENCIL : gl.DEPTH_COMPONENT;
      let internalFormat = format;
      if (this.webGLVersion > 1) {
        if (internalTexture.format === 15) {
          internalFormat = gl.DEPTH_COMPONENT16;
        } else if (internalTexture.format === 16) {
          internalFormat = gl.DEPTH_COMPONENT24;
        } else if (internalTexture.format === 17 || internalTexture.format === 13) {
          internalFormat = gl.DEPTH24_STENCIL8;
        } else if (internalTexture.format === 14) {
          internalFormat = gl.DEPTH_COMPONENT32F;
        } else if (internalTexture.format === 18) {
          internalFormat = gl.DEPTH32F_STENCIL8;
        }
      }
      if (internalTexture.is2DArray) {
        gl.texImage3D(target, 0, internalFormat, internalTexture.width, internalTexture.height, layers, 0, format, type, null);
      } else {
        gl.texImage2D(target, 0, internalFormat, internalTexture.width, internalTexture.height, 0, format, type, null);
      }
      this._bindTextureDirectly(target, null);
      this._internalTexturesCache.push(internalTexture);
      const glRtWrapper = rtWrapper;
      if (glRtWrapper._depthStencilBuffer) {
        const currentFrameBuffer = this._currentFramebuffer;
        this._bindUnboundFramebuffer(glRtWrapper._framebuffer);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_ATTACHMENT, gl.RENDERBUFFER, null);
        gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.STENCIL_ATTACHMENT, gl.RENDERBUFFER, null);
        this._bindUnboundFramebuffer(currentFrameBuffer);
        gl.deleteRenderbuffer(glRtWrapper._depthStencilBuffer);
        glRtWrapper._depthStencilBuffer = null;
      }
      return internalTexture;
    };
    ThinEngine.prototype.updateRenderTargetTextureSampleCount = function(rtWrapper, samples) {
      if (this.webGLVersion < 2 || !rtWrapper || !rtWrapper.texture) {
        return 1;
      }
      if (rtWrapper.samples === samples) {
        return samples;
      }
      const gl = this._gl;
      samples = Math.min(samples, this.getCaps().maxMSAASamples);
      if (rtWrapper._depthStencilBuffer) {
        gl.deleteRenderbuffer(rtWrapper._depthStencilBuffer);
        rtWrapper._depthStencilBuffer = null;
      }
      if (rtWrapper._MSAAFramebuffer) {
        gl.deleteFramebuffer(rtWrapper._MSAAFramebuffer);
        rtWrapper._MSAAFramebuffer = null;
      }
      const hardwareTexture = rtWrapper.texture._hardwareTexture;
      hardwareTexture.releaseMSAARenderBuffers();
      if (samples > 1 && typeof gl.renderbufferStorageMultisample === "function") {
        const framebuffer = gl.createFramebuffer();
        if (!framebuffer) {
          throw new Error("Unable to create multi sampled framebuffer");
        }
        rtWrapper._MSAAFramebuffer = framebuffer;
        this._bindUnboundFramebuffer(rtWrapper._MSAAFramebuffer);
        const colorRenderbuffer = this._createRenderBuffer(rtWrapper.texture.width, rtWrapper.texture.height, samples, -1, this._getRGBAMultiSampleBufferFormat(rtWrapper.texture.type), gl.COLOR_ATTACHMENT0, false);
        if (!colorRenderbuffer) {
          throw new Error("Unable to create multi sampled framebuffer");
        }
        hardwareTexture.addMSAARenderBuffer(colorRenderbuffer);
      } else {
        this._bindUnboundFramebuffer(rtWrapper._framebuffer);
      }
      rtWrapper.texture.samples = samples;
      rtWrapper._samples = samples;
      rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(rtWrapper._generateStencilBuffer, rtWrapper._generateDepthBuffer, rtWrapper.texture.width, rtWrapper.texture.height, samples);
      this._bindUnboundFramebuffer(null);
      return samples;
    };
  }
});

// node_modules/@babylonjs/core/PostProcesses/postProcess.js
var PostProcess;
var init_postProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/postProcess.js"() {
    init_tslib_es6();
    init_smartArray();
    init_observable();
    init_math_vector();
    init_postprocess_vertex();
    init_engine();
    init_engine_renderTarget();
    init_decorators();
    init_typeStore();
    init_drawWrapper();
    init_shaderLanguage();
    PostProcess = class {
      static RegisterShaderCodeProcessing(postProcessName, customShaderCodeProcessing) {
        if (!customShaderCodeProcessing) {
          delete PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : ""];
          return;
        }
        PostProcess._CustomShaderCodeProcessing[postProcessName !== null && postProcessName !== void 0 ? postProcessName : ""] = customShaderCodeProcessing;
      }
      static _GetShaderCodeProcessing(postProcessName) {
        var _a;
        return (_a = PostProcess._CustomShaderCodeProcessing[postProcessName]) !== null && _a !== void 0 ? _a : PostProcess._CustomShaderCodeProcessing[""];
      }
      get samples() {
        return this._samples;
      }
      set samples(n) {
        this._samples = Math.min(n, this._engine.getCaps().maxMSAASamples);
        this._textures.forEach((texture) => {
          texture.setSamples(this._samples);
        });
      }
      getEffectName() {
        return this._fragmentUrl;
      }
      set onActivate(callback) {
        if (this._onActivateObserver) {
          this.onActivateObservable.remove(this._onActivateObserver);
        }
        if (callback) {
          this._onActivateObserver = this.onActivateObservable.add(callback);
        }
      }
      set onSizeChanged(callback) {
        if (this._onSizeChangedObserver) {
          this.onSizeChangedObservable.remove(this._onSizeChangedObserver);
        }
        this._onSizeChangedObserver = this.onSizeChangedObservable.add(callback);
      }
      set onApply(callback) {
        if (this._onApplyObserver) {
          this.onApplyObservable.remove(this._onApplyObserver);
        }
        this._onApplyObserver = this.onApplyObservable.add(callback);
      }
      set onBeforeRender(callback) {
        if (this._onBeforeRenderObserver) {
          this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
      set onAfterRender(callback) {
        if (this._onAfterRenderObserver) {
          this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
      get inputTexture() {
        return this._textures.data[this._currentRenderTextureInd];
      }
      set inputTexture(value) {
        this._forcedOutputTexture = value;
      }
      restoreDefaultInputTexture() {
        if (this._forcedOutputTexture) {
          this._forcedOutputTexture = null;
          this.markTextureDirty();
        }
      }
      getCamera() {
        return this._camera;
      }
      get texelSize() {
        if (this._shareOutputWithPostProcess) {
          return this._shareOutputWithPostProcess.texelSize;
        }
        if (this._forcedOutputTexture) {
          this._texelSize.copyFromFloats(1 / this._forcedOutputTexture.width, 1 / this._forcedOutputTexture.height);
        }
        return this._texelSize;
      }
      constructor(name109, fragmentUrl, parameters, samplers, options, camera, samplingMode = 1, engine, reusable, defines = null, textureType = 0, vertexUrl = "postprocess", indexParameters, blockCompilation = false, textureFormat = 5, shaderLanguage = ShaderLanguage.GLSL) {
        this._parentContainer = null;
        this.width = -1;
        this.height = -1;
        this.nodeMaterialSource = null;
        this._outputTexture = null;
        this.autoClear = true;
        this.forceAutoClearInAlphaMode = false;
        this.alphaMode = 0;
        this.animations = new Array();
        this.enablePixelPerfectMode = false;
        this.forceFullscreenViewport = true;
        this.scaleMode = 1;
        this.alwaysForcePOT = false;
        this._samples = 1;
        this.adaptScaleToCurrentViewport = false;
        this._reusable = false;
        this._renderId = 0;
        this.externalTextureSamplerBinding = false;
        this._textures = new SmartArray(2);
        this._textureCache = [];
        this._currentRenderTextureInd = 0;
        this._scaleRatio = new Vector2(1, 1);
        this._texelSize = Vector2.Zero();
        this.onActivateObservable = new Observable();
        this.onSizeChangedObservable = new Observable();
        this.onApplyObservable = new Observable();
        this.onBeforeRenderObservable = new Observable();
        this.onAfterRenderObservable = new Observable();
        this.name = name109;
        if (camera != null) {
          this._camera = camera;
          this._scene = camera.getScene();
          camera.attachPostProcess(this);
          this._engine = this._scene.getEngine();
          this._scene.postProcesses.push(this);
          this.uniqueId = this._scene.getUniqueId();
        } else if (engine) {
          this._engine = engine;
          this._engine.postProcesses.push(this);
        }
        this._options = options;
        this.renderTargetSamplingMode = samplingMode ? samplingMode : 1;
        this._reusable = reusable || false;
        this._textureType = textureType;
        this._textureFormat = textureFormat;
        this._shaderLanguage = shaderLanguage;
        this._samplers = samplers || [];
        this._samplers.push("textureSampler");
        this._fragmentUrl = fragmentUrl;
        this._vertexUrl = vertexUrl;
        this._parameters = parameters || [];
        this._parameters.push("scale");
        this._indexParameters = indexParameters;
        this._drawWrapper = new DrawWrapper(this._engine);
        if (!blockCompilation) {
          this.updateEffect(defines);
        }
      }
      getClassName() {
        return "PostProcess";
      }
      getEngine() {
        return this._engine;
      }
      getEffect() {
        return this._drawWrapper.effect;
      }
      shareOutputWith(postProcess) {
        this._disposeTextures();
        this._shareOutputWithPostProcess = postProcess;
        return this;
      }
      useOwnOutput() {
        if (this._textures.length == 0) {
          this._textures = new SmartArray(2);
        }
        this._shareOutputWithPostProcess = null;
      }
      updateEffect(defines = null, uniforms = null, samplers = null, indexParameters, onCompiled, onError, vertexUrl, fragmentUrl) {
        var _a, _b;
        const customShaderCodeProcessing = PostProcess._GetShaderCodeProcessing(this.name);
        if (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.defineCustomBindings) {
          const newUniforms = (_a = uniforms === null || uniforms === void 0 ? void 0 : uniforms.slice()) !== null && _a !== void 0 ? _a : [];
          newUniforms.push(...this._parameters);
          const newSamplers = (_b = samplers === null || samplers === void 0 ? void 0 : samplers.slice()) !== null && _b !== void 0 ? _b : [];
          newSamplers.push(...this._samplers);
          defines = customShaderCodeProcessing.defineCustomBindings(this.name, defines, newUniforms, newSamplers);
          uniforms = newUniforms;
          samplers = newSamplers;
        }
        this._postProcessDefines = defines;
        this._drawWrapper.effect = this._engine.createEffect({ vertex: vertexUrl !== null && vertexUrl !== void 0 ? vertexUrl : this._vertexUrl, fragment: fragmentUrl !== null && fragmentUrl !== void 0 ? fragmentUrl : this._fragmentUrl }, {
          attributes: ["position"],
          uniformsNames: uniforms || this._parameters,
          uniformBuffersNames: [],
          samplers: samplers || this._samplers,
          defines: defines !== null ? defines : "",
          fallbacks: null,
          onCompiled: onCompiled !== null && onCompiled !== void 0 ? onCompiled : null,
          onError: onError !== null && onError !== void 0 ? onError : null,
          indexParameters: indexParameters || this._indexParameters,
          processCodeAfterIncludes: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processCodeAfterIncludes) ? (shaderType, code) => customShaderCodeProcessing.processCodeAfterIncludes(this.name, shaderType, code) : null,
          processFinalCode: (customShaderCodeProcessing === null || customShaderCodeProcessing === void 0 ? void 0 : customShaderCodeProcessing.processFinalCode) ? (shaderType, code) => customShaderCodeProcessing.processFinalCode(this.name, shaderType, code) : null,
          shaderLanguage: this._shaderLanguage
        }, this._engine);
      }
      isReusable() {
        return this._reusable;
      }
      markTextureDirty() {
        this.width = -1;
      }
      _createRenderTargetTexture(textureSize, textureOptions, channel = 0) {
        for (let i = 0; i < this._textureCache.length; i++) {
          if (this._textureCache[i].texture.width === textureSize.width && this._textureCache[i].texture.height === textureSize.height && this._textureCache[i].postProcessChannel === channel && this._textureCache[i].texture._generateDepthBuffer === textureOptions.generateDepthBuffer && this._textureCache[i].texture.samples === textureOptions.samples) {
            return this._textureCache[i].texture;
          }
        }
        const tex = this._engine.createRenderTargetTexture(textureSize, textureOptions);
        this._textureCache.push({ texture: tex, postProcessChannel: channel, lastUsedRenderId: -1 });
        return tex;
      }
      _flushTextureCache() {
        const currentRenderId = this._renderId;
        for (let i = this._textureCache.length - 1; i >= 0; i--) {
          if (currentRenderId - this._textureCache[i].lastUsedRenderId > 100) {
            let currentlyUsed = false;
            for (let j = 0; j < this._textures.length; j++) {
              if (this._textures.data[j] === this._textureCache[i].texture) {
                currentlyUsed = true;
                break;
              }
            }
            if (!currentlyUsed) {
              this._textureCache[i].texture.dispose();
              this._textureCache.splice(i, 1);
            }
          }
        }
      }
      _resize(width, height, camera, needMipMaps, forceDepthStencil) {
        if (this._textures.length > 0) {
          this._textures.reset();
        }
        this.width = width;
        this.height = height;
        let firstPP = null;
        for (let i = 0; i < camera._postProcesses.length; i++) {
          if (camera._postProcesses[i] !== null) {
            firstPP = camera._postProcesses[i];
            break;
          }
        }
        const textureSize = { width: this.width, height: this.height };
        const textureOptions = {
          generateMipMaps: needMipMaps,
          generateDepthBuffer: forceDepthStencil || firstPP === this,
          generateStencilBuffer: (forceDepthStencil || firstPP === this) && this._engine.isStencilEnable,
          samplingMode: this.renderTargetSamplingMode,
          type: this._textureType,
          format: this._textureFormat,
          samples: this._samples,
          label: "PostProcessRTT-" + this.name
        };
        this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 0));
        if (this._reusable) {
          this._textures.push(this._createRenderTargetTexture(textureSize, textureOptions, 1));
        }
        this._texelSize.copyFromFloats(1 / this.width, 1 / this.height);
        this.onSizeChangedObservable.notifyObservers(this);
      }
      activate(camera, sourceTexture = null, forceDepthStencil) {
        var _a, _b;
        camera = camera || this._camera;
        const scene = camera.getScene();
        const engine = scene.getEngine();
        const maxSize = engine.getCaps().maxTextureSize;
        let requiredWidth = (sourceTexture ? sourceTexture.width : this._engine.getRenderWidth(true)) * this._options | 0;
        const requiredHeight = (sourceTexture ? sourceTexture.height : this._engine.getRenderHeight(true)) * this._options | 0;
        const webVRCamera = camera.parent;
        if (webVRCamera && (webVRCamera.leftCamera == camera || webVRCamera.rightCamera == camera)) {
          requiredWidth /= 2;
        }
        let desiredWidth = this._options.width || requiredWidth;
        let desiredHeight = this._options.height || requiredHeight;
        const needMipMaps = this.renderTargetSamplingMode !== 7 && this.renderTargetSamplingMode !== 1 && this.renderTargetSamplingMode !== 2;
        if (!this._shareOutputWithPostProcess && !this._forcedOutputTexture) {
          if (this.adaptScaleToCurrentViewport) {
            const currentViewport = engine.currentViewport;
            if (currentViewport) {
              desiredWidth *= currentViewport.width;
              desiredHeight *= currentViewport.height;
            }
          }
          if (needMipMaps || this.alwaysForcePOT) {
            if (!this._options.width) {
              desiredWidth = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredWidth, maxSize, this.scaleMode) : desiredWidth;
            }
            if (!this._options.height) {
              desiredHeight = engine.needPOTTextures ? Engine.GetExponentOfTwo(desiredHeight, maxSize, this.scaleMode) : desiredHeight;
            }
          }
          if (this.width !== desiredWidth || this.height !== desiredHeight) {
            this._resize(desiredWidth, desiredHeight, camera, needMipMaps, forceDepthStencil);
          }
          this._textures.forEach((texture) => {
            if (texture.samples !== this.samples) {
              this._engine.updateRenderTargetTextureSampleCount(texture, this.samples);
            }
          });
          this._flushTextureCache();
          this._renderId++;
        }
        let target;
        if (this._shareOutputWithPostProcess) {
          target = this._shareOutputWithPostProcess.inputTexture;
        } else if (this._forcedOutputTexture) {
          target = this._forcedOutputTexture;
          this.width = this._forcedOutputTexture.width;
          this.height = this._forcedOutputTexture.height;
        } else {
          target = this.inputTexture;
          let cache;
          for (let i = 0; i < this._textureCache.length; i++) {
            if (this._textureCache[i].texture === target) {
              cache = this._textureCache[i];
              break;
            }
          }
          if (cache) {
            cache.lastUsedRenderId = this._renderId;
          }
        }
        if (this.enablePixelPerfectMode) {
          this._scaleRatio.copyFromFloats(requiredWidth / desiredWidth, requiredHeight / desiredHeight);
          this._engine.bindFramebuffer(target, 0, requiredWidth, requiredHeight, this.forceFullscreenViewport);
        } else {
          this._scaleRatio.copyFromFloats(1, 1);
          this._engine.bindFramebuffer(target, 0, void 0, void 0, this.forceFullscreenViewport);
        }
        (_b = (_a = this._engine)._debugInsertMarker) === null || _b === void 0 ? void 0 : _b.call(_a, `post process ${this.name} input`);
        this.onActivateObservable.notifyObservers(camera);
        if (this.autoClear && (this.alphaMode === 0 || this.forceAutoClearInAlphaMode)) {
          this._engine.clear(this.clearColor ? this.clearColor : scene.clearColor, scene._allowPostProcessClearColor, true, true);
        }
        if (this._reusable) {
          this._currentRenderTextureInd = (this._currentRenderTextureInd + 1) % 2;
        }
        return target;
      }
      get isSupported() {
        return this._drawWrapper.effect.isSupported;
      }
      get aspectRatio() {
        if (this._shareOutputWithPostProcess) {
          return this._shareOutputWithPostProcess.aspectRatio;
        }
        if (this._forcedOutputTexture) {
          return this._forcedOutputTexture.width / this._forcedOutputTexture.height;
        }
        return this.width / this.height;
      }
      isReady() {
        var _a, _b;
        return (_b = (_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady()) !== null && _b !== void 0 ? _b : false;
      }
      apply() {
        var _a, _b, _c;
        if (!((_a = this._drawWrapper.effect) === null || _a === void 0 ? void 0 : _a.isReady())) {
          return null;
        }
        this._engine.enableEffect(this._drawWrapper);
        this._engine.setState(false);
        this._engine.setDepthBuffer(false);
        this._engine.setDepthWrite(false);
        this._engine.setAlphaMode(this.alphaMode);
        if (this.alphaConstants) {
          this.getEngine().setAlphaConstants(this.alphaConstants.r, this.alphaConstants.g, this.alphaConstants.b, this.alphaConstants.a);
        }
        let source;
        if (this._shareOutputWithPostProcess) {
          source = this._shareOutputWithPostProcess.inputTexture;
        } else if (this._forcedOutputTexture) {
          source = this._forcedOutputTexture;
        } else {
          source = this.inputTexture;
        }
        if (!this.externalTextureSamplerBinding) {
          this._drawWrapper.effect._bindTexture("textureSampler", source === null || source === void 0 ? void 0 : source.texture);
        }
        this._drawWrapper.effect.setVector2("scale", this._scaleRatio);
        this.onApplyObservable.notifyObservers(this._drawWrapper.effect);
        (_c = (_b = PostProcess._GetShaderCodeProcessing(this.name)) === null || _b === void 0 ? void 0 : _b.bindCustomBindings) === null || _c === void 0 ? void 0 : _c.call(_b, this.name, this._drawWrapper.effect);
        return this._drawWrapper.effect;
      }
      _disposeTextures() {
        if (this._shareOutputWithPostProcess || this._forcedOutputTexture) {
          this._disposeTextureCache();
          return;
        }
        this._disposeTextureCache();
        this._textures.dispose();
      }
      _disposeTextureCache() {
        for (let i = this._textureCache.length - 1; i >= 0; i--) {
          this._textureCache[i].texture.dispose();
        }
        this._textureCache.length = 0;
      }
      setPrePassRenderer(prePassRenderer) {
        if (this._prePassEffectConfiguration) {
          this._prePassEffectConfiguration = prePassRenderer.addEffectConfiguration(this._prePassEffectConfiguration);
          this._prePassEffectConfiguration.enabled = true;
          return true;
        }
        return false;
      }
      dispose(camera) {
        camera = camera || this._camera;
        this._disposeTextures();
        let index;
        if (this._scene) {
          index = this._scene.postProcesses.indexOf(this);
          if (index !== -1) {
            this._scene.postProcesses.splice(index, 1);
          }
        }
        if (this._parentContainer) {
          const index2 = this._parentContainer.postProcesses.indexOf(this);
          if (index2 > -1) {
            this._parentContainer.postProcesses.splice(index2, 1);
          }
          this._parentContainer = null;
        }
        index = this._engine.postProcesses.indexOf(this);
        if (index !== -1) {
          this._engine.postProcesses.splice(index, 1);
        }
        if (!camera) {
          return;
        }
        camera.detachPostProcess(this);
        index = camera._postProcesses.indexOf(this);
        if (index === 0 && camera._postProcesses.length > 0) {
          const firstPostProcess = this._camera._getFirstPostProcess();
          if (firstPostProcess) {
            firstPostProcess.markTextureDirty();
          }
        }
        this.onActivateObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onApplyObservable.clear();
        this.onBeforeRenderObservable.clear();
        this.onSizeChangedObservable.clear();
      }
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        const camera = this.getCamera() || this._scene && this._scene.activeCamera;
        serializationObject.customType = "BABYLON." + this.getClassName();
        serializationObject.cameraId = camera ? camera.id : null;
        serializationObject.reusable = this._reusable;
        serializationObject.textureType = this._textureType;
        serializationObject.fragmentUrl = this._fragmentUrl;
        serializationObject.parameters = this._parameters;
        serializationObject.samplers = this._samplers;
        serializationObject.options = this._options;
        serializationObject.defines = this._postProcessDefines;
        serializationObject.textureFormat = this._textureFormat;
        serializationObject.vertexUrl = this._vertexUrl;
        serializationObject.indexParameters = this._indexParameters;
        return serializationObject;
      }
      clone() {
        const serializationObject = this.serialize();
        serializationObject._engine = this._engine;
        serializationObject.cameraId = null;
        const result = PostProcess.Parse(serializationObject, this._scene, "");
        if (!result) {
          return null;
        }
        result.onActivateObservable = this.onActivateObservable.clone();
        result.onSizeChangedObservable = this.onSizeChangedObservable.clone();
        result.onApplyObservable = this.onApplyObservable.clone();
        result.onBeforeRenderObservable = this.onBeforeRenderObservable.clone();
        result.onAfterRenderObservable = this.onAfterRenderObservable.clone();
        result._prePassEffectConfiguration = this._prePassEffectConfiguration;
        return result;
      }
      static Parse(parsedPostProcess, scene, rootUrl) {
        const postProcessType = GetClass(parsedPostProcess.customType);
        if (!postProcessType || !postProcessType._Parse) {
          return null;
        }
        const camera = scene ? scene.getCameraById(parsedPostProcess.cameraId) : null;
        return postProcessType._Parse(parsedPostProcess, camera, scene, rootUrl);
      }
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new PostProcess(parsedPostProcess.name, parsedPostProcess.fragmentUrl, parsedPostProcess.parameters, parsedPostProcess.samplers, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable, parsedPostProcess.defines, parsedPostProcess.textureType, parsedPostProcess.vertexUrl, parsedPostProcess.indexParameters, false, parsedPostProcess.textureFormat);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    PostProcess._CustomShaderCodeProcessing = {};
    __decorate([
      serialize()
    ], PostProcess.prototype, "uniqueId", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "name", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "width", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "height", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "renderTargetSamplingMode", void 0);
    __decorate([
      serializeAsColor4()
    ], PostProcess.prototype, "clearColor", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "autoClear", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "forceAutoClearInAlphaMode", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "alphaMode", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "alphaConstants", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "enablePixelPerfectMode", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "forceFullscreenViewport", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "scaleMode", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "alwaysForcePOT", void 0);
    __decorate([
      serialize("samples")
    ], PostProcess.prototype, "_samples", void 0);
    __decorate([
      serialize()
    ], PostProcess.prototype, "adaptScaleToCurrentViewport", void 0);
    RegisterClass("BABYLON.PostProcess", PostProcess);
  }
});

// node_modules/@babylonjs/core/Materials/effectRenderer.js
var defaultOptions, EffectRenderer, EffectWrapper;
var init_effectRenderer = __esm({
  "node_modules/@babylonjs/core/Materials/effectRenderer.js"() {
    init_buffer();
    init_math_viewport();
    init_observable();
    init_effect();
    init_drawWrapper();
    init_postprocess_vertex();
    defaultOptions = {
      positions: [1, 1, -1, 1, -1, -1, 1, -1],
      indices: [0, 1, 2, 0, 2, 3]
    };
    EffectRenderer = class {
      constructor(engine, options = defaultOptions) {
        var _a, _b;
        this._fullscreenViewport = new Viewport(0, 0, 1, 1);
        const positions = (_a = options.positions) !== null && _a !== void 0 ? _a : defaultOptions.positions;
        const indices = (_b = options.indices) !== null && _b !== void 0 ? _b : defaultOptions.indices;
        this.engine = engine;
        this._vertexBuffers = {
          [VertexBuffer.PositionKind]: new VertexBuffer(engine, positions, VertexBuffer.PositionKind, false, false, 2)
        };
        this._indexBuffer = engine.createIndexBuffer(indices);
        this._onContextRestoredObserver = engine.onContextRestoredObservable.add(() => {
          this._indexBuffer = engine.createIndexBuffer(indices);
          for (const key in this._vertexBuffers) {
            const vertexBuffer = this._vertexBuffers[key];
            vertexBuffer._rebuild();
          }
        });
      }
      setViewport(viewport = this._fullscreenViewport) {
        this.engine.setViewport(viewport);
      }
      bindBuffers(effect) {
        this.engine.bindBuffers(this._vertexBuffers, this._indexBuffer, effect);
      }
      applyEffectWrapper(effectWrapper) {
        this.engine.setState(true);
        this.engine.depthCullingState.depthTest = false;
        this.engine.stencilState.stencilTest = false;
        this.engine.enableEffect(effectWrapper._drawWrapper);
        this.bindBuffers(effectWrapper.effect);
        effectWrapper.onApplyObservable.notifyObservers({});
      }
      saveStates() {
        this._savedStateDepthTest = this.engine.depthCullingState.depthTest;
        this._savedStateStencilTest = this.engine.stencilState.stencilTest;
      }
      restoreStates() {
        this.engine.depthCullingState.depthTest = this._savedStateDepthTest;
        this.engine.stencilState.stencilTest = this._savedStateStencilTest;
      }
      draw() {
        this.engine.drawElementsType(0, 0, 6);
      }
      _isRenderTargetTexture(texture) {
        return texture.renderTarget !== void 0;
      }
      render(effectWrapper, outputTexture = null) {
        if (!effectWrapper.effect.isReady()) {
          return;
        }
        this.saveStates();
        this.setViewport();
        const out = outputTexture === null ? null : this._isRenderTargetTexture(outputTexture) ? outputTexture.renderTarget : outputTexture;
        if (out) {
          this.engine.bindFramebuffer(out);
        }
        this.applyEffectWrapper(effectWrapper);
        this.draw();
        if (out) {
          this.engine.unBindFramebuffer(out);
        }
        this.restoreStates();
      }
      dispose() {
        const vertexBuffer = this._vertexBuffers[VertexBuffer.PositionKind];
        if (vertexBuffer) {
          vertexBuffer.dispose();
          delete this._vertexBuffers[VertexBuffer.PositionKind];
        }
        if (this._indexBuffer) {
          this.engine._releaseBuffer(this._indexBuffer);
        }
        if (this._onContextRestoredObserver) {
          this.engine.onContextRestoredObservable.remove(this._onContextRestoredObserver);
          this._onContextRestoredObserver = null;
        }
      }
    };
    EffectWrapper = class {
      get effect() {
        return this._drawWrapper.effect;
      }
      set effect(effect) {
        this._drawWrapper.effect = effect;
      }
      constructor(creationOptions) {
        this.onApplyObservable = new Observable();
        let effectCreationOptions;
        const uniformNames = creationOptions.uniformNames || [];
        if (creationOptions.vertexShader) {
          effectCreationOptions = {
            fragmentSource: creationOptions.fragmentShader,
            vertexSource: creationOptions.vertexShader,
            spectorName: creationOptions.name || "effectWrapper"
          };
        } else {
          uniformNames.push("scale");
          effectCreationOptions = {
            fragmentSource: creationOptions.fragmentShader,
            vertex: "postprocess",
            spectorName: creationOptions.name || "effectWrapper"
          };
          this.onApplyObservable.add(() => {
            this.effect.setFloat2("scale", 1, 1);
          });
        }
        const defines = creationOptions.defines ? creationOptions.defines.join("\n") : "";
        this._drawWrapper = new DrawWrapper(creationOptions.engine);
        if (creationOptions.useShaderStore) {
          effectCreationOptions.fragment = effectCreationOptions.fragmentSource;
          if (!effectCreationOptions.vertex) {
            effectCreationOptions.vertex = effectCreationOptions.vertexSource;
          }
          delete effectCreationOptions.fragmentSource;
          delete effectCreationOptions.vertexSource;
          this.effect = creationOptions.engine.createEffect(effectCreationOptions, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, defines, void 0, creationOptions.onCompiled, void 0, void 0, creationOptions.shaderLanguage);
        } else {
          this.effect = new Effect(effectCreationOptions, creationOptions.attributeNames || ["position"], uniformNames, creationOptions.samplerNames, creationOptions.engine, defines, void 0, creationOptions.onCompiled, void 0, void 0, void 0, creationOptions.shaderLanguage);
          this._onContextRestoredObserver = creationOptions.engine.onContextRestoredObservable.add(() => {
            this.effect._pipelineContext = null;
            this.effect._wasPreviouslyReady = false;
            this.effect._prepareEffect();
          });
        }
      }
      dispose() {
        if (this._onContextRestoredObserver) {
          this.effect.getEngine().onContextRestoredObservable.remove(this._onContextRestoredObserver);
          this._onContextRestoredObserver = null;
        }
        this.effect.dispose();
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/pass.fragment.js
var name2, shader2, passPixelShader;
var init_pass_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/pass.fragment.js"() {
    init_shaderStore();
    name2 = "passPixelShader";
    shader2 = `varying vec2 vUV;uniform sampler2D textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=texture2D(textureSampler,vUV);}`;
    ShaderStore.ShadersStore[name2] = shader2;
    passPixelShader = { name: name2, shader: shader2 };
  }
});

// node_modules/@babylonjs/core/Misc/dumpTools.js
var DumpTools, initSideEffects;
var init_dumpTools = __esm({
  "node_modules/@babylonjs/core/Misc/dumpTools.js"() {
    init_thinEngine();
    init_effectRenderer();
    init_tools();
    init_pass_fragment();
    init_math_scalar();
    DumpTools = class {
      static _CreateDumpRenderer() {
        if (!DumpTools._DumpToolsEngine) {
          let canvas;
          let engine = null;
          const options = {
            preserveDrawingBuffer: true,
            depth: false,
            stencil: false,
            alpha: true,
            premultipliedAlpha: false,
            antialias: false,
            failIfMajorPerformanceCaveat: false
          };
          try {
            canvas = new OffscreenCanvas(100, 100);
            engine = new ThinEngine(canvas, false, options);
          } catch (e) {
            canvas = document.createElement("canvas");
            engine = new ThinEngine(canvas, false, options);
          }
          engine.getCaps().parallelShaderCompile = void 0;
          const renderer = new EffectRenderer(engine);
          const wrapper = new EffectWrapper({
            engine,
            name: passPixelShader.name,
            fragmentShader: passPixelShader.shader,
            samplerNames: ["textureSampler"]
          });
          DumpTools._DumpToolsEngine = {
            canvas,
            engine,
            renderer,
            wrapper
          };
        }
        return DumpTools._DumpToolsEngine;
      }
      static async DumpFramebuffer(width, height, engine, successCallback, mimeType = "image/png", fileName, quality) {
        const bufferView = await engine.readPixels(0, 0, width, height);
        const data = new Uint8Array(bufferView.buffer);
        DumpTools.DumpData(width, height, data, successCallback, mimeType, fileName, true, void 0, quality);
      }
      static DumpDataAsync(width, height, data, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
        return new Promise((resolve) => {
          DumpTools.DumpData(width, height, data, (result) => resolve(result), mimeType, fileName, invertY, toArrayBuffer, quality);
        });
      }
      static DumpData(width, height, data, successCallback, mimeType = "image/png", fileName, invertY = false, toArrayBuffer = false, quality) {
        const renderer = DumpTools._CreateDumpRenderer();
        renderer.engine.setSize(width, height, true);
        if (data instanceof Float32Array) {
          const data2 = new Uint8Array(data.length);
          let n = data.length;
          while (n--) {
            const v = data[n];
            data2[n] = Math.round(Scalar.Clamp(v) * 255);
          }
          data = data2;
        }
        const texture = renderer.engine.createRawTexture(data, width, height, 5, false, !invertY, 1);
        renderer.renderer.setViewport();
        renderer.renderer.applyEffectWrapper(renderer.wrapper);
        renderer.wrapper.effect._bindTexture("textureSampler", texture);
        renderer.renderer.draw();
        if (toArrayBuffer) {
          Tools.ToBlob(renderer.canvas, (blob) => {
            const fileReader = new FileReader();
            fileReader.onload = (event) => {
              const arrayBuffer = event.target.result;
              if (successCallback) {
                successCallback(arrayBuffer);
              }
            };
            fileReader.readAsArrayBuffer(blob);
          }, mimeType, quality);
        } else {
          Tools.EncodeScreenshotCanvasData(renderer.canvas, successCallback, mimeType, fileName, quality);
        }
        texture.dispose();
      }
      static Dispose() {
        if (DumpTools._DumpToolsEngine) {
          DumpTools._DumpToolsEngine.wrapper.dispose();
          DumpTools._DumpToolsEngine.renderer.dispose();
          DumpTools._DumpToolsEngine.engine.dispose();
        }
        DumpTools._DumpToolsEngine = null;
      }
    };
    initSideEffects = () => {
      Tools.DumpData = DumpTools.DumpData;
      Tools.DumpDataAsync = DumpTools.DumpDataAsync;
      Tools.DumpFramebuffer = DumpTools.DumpFramebuffer;
    };
    initSideEffects();
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js
var init_engine_renderTargetCube = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.renderTargetCube.js"() {
    init_internalTexture();
    init_logger();
    init_thinEngine();
    ThinEngine.prototype.createRenderTargetCubeTexture = function(size, options) {
      const rtWrapper = this._createHardwareRenderTargetWrapper(false, true, size);
      const fullOptions = Object.assign({ generateMipMaps: true, generateDepthBuffer: true, generateStencilBuffer: false, type: 0, samplingMode: 3, format: 5 }, options);
      fullOptions.generateStencilBuffer = fullOptions.generateDepthBuffer && fullOptions.generateStencilBuffer;
      if (fullOptions.type === 1 && !this._caps.textureFloatLinearFiltering) {
        fullOptions.samplingMode = 1;
      } else if (fullOptions.type === 2 && !this._caps.textureHalfFloatLinearFiltering) {
        fullOptions.samplingMode = 1;
      }
      const gl = this._gl;
      const texture = new InternalTexture(this, InternalTextureSource.RenderTarget);
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
      const filters = this._getSamplingParameters(fullOptions.samplingMode, fullOptions.generateMipMaps);
      if (fullOptions.type === 1 && !this._caps.textureFloat) {
        fullOptions.type = 0;
        Logger.Warn("Float textures are not supported. Cube render target forced to TEXTURETYPE_UNESIGNED_BYTE type");
      }
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, filters.mag);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, filters.min);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      for (let face = 0; face < 6; face++) {
        gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, this._getRGBABufferInternalSizedFormat(fullOptions.type, fullOptions.format), size, size, 0, this._getInternalFormat(fullOptions.format), this._getWebGLTextureType(fullOptions.type), null);
      }
      const framebuffer = gl.createFramebuffer();
      this._bindUnboundFramebuffer(framebuffer);
      rtWrapper._depthStencilBuffer = this._setupFramebufferDepthAttachments(fullOptions.generateStencilBuffer, fullOptions.generateDepthBuffer, size, size);
      if (fullOptions.generateMipMaps) {
        gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      this._bindUnboundFramebuffer(null);
      rtWrapper._framebuffer = framebuffer;
      rtWrapper._generateDepthBuffer = fullOptions.generateDepthBuffer;
      rtWrapper._generateStencilBuffer = fullOptions.generateStencilBuffer;
      texture.width = size;
      texture.height = size;
      texture.isReady = true;
      texture.isCube = true;
      texture.samples = 1;
      texture.generateMipMaps = fullOptions.generateMipMaps;
      texture.samplingMode = fullOptions.samplingMode;
      texture.type = fullOptions.type;
      texture.format = fullOptions.format;
      this._internalTexturesCache.push(texture);
      rtWrapper.setTextures(texture);
      return rtWrapper;
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js
var RenderTargetTexture;
var init_renderTargetTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/renderTargetTexture.js"() {
    init_observable();
    init_math_vector();
    init_texture();
    init_postProcessManager();
    init_renderingManager();
    init_engine_renderTarget();
    init_engine_renderTargetCube();
    init_engine();
    init_arrayTools();
    init_dumpTools();
    RenderTargetTexture = class extends Texture {
      get renderList() {
        return this._renderList;
      }
      set renderList(value) {
        if (this._unObserveRenderList) {
          this._unObserveRenderList();
          this._unObserveRenderList = null;
        }
        if (value) {
          this._unObserveRenderList = _ObserveArray(value, this._renderListHasChanged);
        }
        this._renderList = value;
      }
      get postProcesses() {
        return this._postProcesses;
      }
      get _prePassEnabled() {
        return !!this._prePassRenderTarget && this._prePassRenderTarget.enabled;
      }
      set onAfterUnbind(callback) {
        if (this._onAfterUnbindObserver) {
          this.onAfterUnbindObservable.remove(this._onAfterUnbindObserver);
        }
        this._onAfterUnbindObserver = this.onAfterUnbindObservable.add(callback);
      }
      set onBeforeRender(callback) {
        if (this._onBeforeRenderObserver) {
          this.onBeforeRenderObservable.remove(this._onBeforeRenderObserver);
        }
        this._onBeforeRenderObserver = this.onBeforeRenderObservable.add(callback);
      }
      set onAfterRender(callback) {
        if (this._onAfterRenderObserver) {
          this.onAfterRenderObservable.remove(this._onAfterRenderObserver);
        }
        this._onAfterRenderObserver = this.onAfterRenderObservable.add(callback);
      }
      set onClear(callback) {
        if (this._onClearObserver) {
          this.onClearObservable.remove(this._onClearObserver);
        }
        this._onClearObserver = this.onClearObservable.add(callback);
      }
      get renderPassIds() {
        return this._renderPassIds;
      }
      get currentRefreshId() {
        return this._currentRefreshId;
      }
      setMaterialForRendering(mesh, material) {
        let meshes;
        if (!Array.isArray(mesh)) {
          meshes = [mesh];
        } else {
          meshes = mesh;
        }
        for (let j = 0; j < meshes.length; ++j) {
          for (let i = 0; i < this._renderPassIds.length; ++i) {
            meshes[j].setMaterialForRenderPass(this._renderPassIds[i], material !== void 0 ? Array.isArray(material) ? material[i] : material : void 0);
          }
        }
      }
      get isMulti() {
        var _a, _b;
        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.isMulti) !== null && _b !== void 0 ? _b : false;
      }
      get renderTargetOptions() {
        return this._renderTargetOptions;
      }
      get renderTarget() {
        return this._renderTarget;
      }
      _onRatioRescale() {
        if (this._sizeRatio) {
          this.resize(this._initialSizeParameter);
        }
      }
      set boundingBoxSize(value) {
        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
          return;
        }
        this._boundingBoxSize = value;
        const scene = this.getScene();
        if (scene) {
          scene.markAllMaterialsAsDirty(1);
        }
      }
      get boundingBoxSize() {
        return this._boundingBoxSize;
      }
      get depthStencilTexture() {
        var _a, _b;
        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a._depthStencilTexture) !== null && _b !== void 0 ? _b : null;
      }
      constructor(name109, size, scene, generateMipMaps = false, doNotChangeAspectRatio = true, type = 0, isCube = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, generateDepthBuffer = true, generateStencilBuffer = false, isMulti = false, format = 5, delayAllocation = false, samples, creationFlags, noColorAttachment = false, useSRGBBuffer = false) {
        var _a, _b, _c, _d, _e, _f;
        let colorAttachment = void 0;
        if (typeof generateMipMaps === "object") {
          const options = generateMipMaps;
          generateMipMaps = !!options.generateMipMaps;
          doNotChangeAspectRatio = (_a = options.doNotChangeAspectRatio) !== null && _a !== void 0 ? _a : true;
          type = (_b = options.type) !== null && _b !== void 0 ? _b : 0;
          isCube = !!options.isCube;
          samplingMode = (_c = options.samplingMode) !== null && _c !== void 0 ? _c : Texture.TRILINEAR_SAMPLINGMODE;
          generateDepthBuffer = (_d = options.generateDepthBuffer) !== null && _d !== void 0 ? _d : true;
          generateStencilBuffer = !!options.generateStencilBuffer;
          isMulti = !!options.isMulti;
          format = (_e = options.format) !== null && _e !== void 0 ? _e : 5;
          delayAllocation = !!options.delayAllocation;
          samples = options.samples;
          creationFlags = options.creationFlags;
          noColorAttachment = !!options.noColorAttachment;
          useSRGBBuffer = !!options.useSRGBBuffer;
          colorAttachment = options.colorAttachment;
        }
        super(null, scene, !generateMipMaps, void 0, samplingMode, void 0, void 0, void 0, void 0, format);
        this._unObserveRenderList = null;
        this._renderListHasChanged = (_functionName, previousLength) => {
          var _a2;
          const newLength = this._renderList ? this._renderList.length : 0;
          if (previousLength === 0 && newLength > 0 || newLength === 0) {
            (_a2 = this.getScene()) === null || _a2 === void 0 ? void 0 : _a2.meshes.forEach((mesh) => {
              mesh._markSubMeshesAsLightDirty();
            });
          }
        };
        this.renderParticles = true;
        this.renderSprites = false;
        this.forceLayerMaskCheck = false;
        this.ignoreCameraViewport = false;
        this.onBeforeBindObservable = new Observable();
        this.onAfterUnbindObservable = new Observable();
        this.onBeforeRenderObservable = new Observable();
        this.onAfterRenderObservable = new Observable();
        this.onClearObservable = new Observable();
        this.onResizeObservable = new Observable();
        this._cleared = false;
        this.skipInitialClear = false;
        this._currentRefreshId = -1;
        this._refreshRate = 1;
        this._samples = 1;
        this._canRescale = true;
        this._renderTarget = null;
        this.boundingBoxPosition = Vector3.Zero();
        scene = this.getScene();
        if (!scene) {
          return;
        }
        const engine = this.getScene().getEngine();
        this._coordinatesMode = Texture.PROJECTION_MODE;
        this.renderList = new Array();
        this.name = name109;
        this.isRenderTarget = true;
        this._initialSizeParameter = size;
        this._renderPassIds = [];
        this._isCubeData = isCube;
        this._processSizeParameter(size);
        this.renderPassId = this._renderPassIds[0];
        this._resizeObserver = engine.onResizeObservable.add(() => {
        });
        this._generateMipMaps = generateMipMaps ? true : false;
        this._doNotChangeAspectRatio = doNotChangeAspectRatio;
        this._renderingManager = new RenderingManager(scene);
        this._renderingManager._useSceneAutoClearSetup = true;
        if (isMulti) {
          return;
        }
        this._renderTargetOptions = {
          generateMipMaps,
          type,
          format: (_f = this._format) !== null && _f !== void 0 ? _f : void 0,
          samplingMode: this.samplingMode,
          generateDepthBuffer,
          generateStencilBuffer,
          samples,
          creationFlags,
          noColorAttachment,
          useSRGBBuffer,
          colorAttachment,
          label: this.name
        };
        if (this.samplingMode === Texture.NEAREST_SAMPLINGMODE) {
          this.wrapU = Texture.CLAMP_ADDRESSMODE;
          this.wrapV = Texture.CLAMP_ADDRESSMODE;
        }
        if (!delayAllocation) {
          if (isCube) {
            this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
            this.coordinatesMode = Texture.INVCUBIC_MODE;
            this._textureMatrix = Matrix.Identity();
          } else {
            this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
          }
          this._texture = this._renderTarget.texture;
          if (samples !== void 0) {
            this.samples = samples;
          }
        }
      }
      createDepthStencilTexture(comparisonFunction = 0, bilinearFiltering = true, generateStencil = false, samples = 1, format = 14) {
        var _a;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.createDepthStencilTexture(comparisonFunction, bilinearFiltering, generateStencil, samples, format);
      }
      _releaseRenderPassId() {
        if (this._scene) {
          const engine = this._scene.getEngine();
          for (let i = 0; i < this._renderPassIds.length; ++i) {
            engine.releaseRenderPassId(this._renderPassIds[i]);
          }
        }
        this._renderPassIds = [];
      }
      _createRenderPassId() {
        this._releaseRenderPassId();
        const engine = this._scene.getEngine();
        const numPasses = this._isCubeData ? 6 : this.getRenderLayers() || 1;
        for (let i = 0; i < numPasses; ++i) {
          this._renderPassIds[i] = engine.createRenderPassId(`RenderTargetTexture - ${this.name}#${i}`);
        }
      }
      _processSizeParameter(size, createRenderPassIds = true) {
        if (size.ratio) {
          this._sizeRatio = size.ratio;
          const engine = this._getEngine();
          this._size = {
            width: this._bestReflectionRenderTargetDimension(engine.getRenderWidth(), this._sizeRatio),
            height: this._bestReflectionRenderTargetDimension(engine.getRenderHeight(), this._sizeRatio)
          };
        } else {
          this._size = size;
        }
        if (createRenderPassIds) {
          this._createRenderPassId();
        }
      }
      get samples() {
        var _a, _b;
        return (_b = (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.samples) !== null && _b !== void 0 ? _b : this._samples;
      }
      set samples(value) {
        if (this._renderTarget) {
          this._samples = this._renderTarget.setSamples(value);
        }
      }
      resetRefreshCounter() {
        this._currentRefreshId = -1;
      }
      get refreshRate() {
        return this._refreshRate;
      }
      set refreshRate(value) {
        this._refreshRate = value;
        this.resetRefreshCounter();
      }
      addPostProcess(postProcess) {
        if (!this._postProcessManager) {
          const scene = this.getScene();
          if (!scene) {
            return;
          }
          this._postProcessManager = new PostProcessManager(scene);
          this._postProcesses = new Array();
        }
        this._postProcesses.push(postProcess);
        this._postProcesses[0].autoClear = false;
      }
      clearPostProcesses(dispose = false) {
        if (!this._postProcesses) {
          return;
        }
        if (dispose) {
          for (const postProcess of this._postProcesses) {
            postProcess.dispose();
          }
        }
        this._postProcesses = [];
      }
      removePostProcess(postProcess) {
        if (!this._postProcesses) {
          return;
        }
        const index = this._postProcesses.indexOf(postProcess);
        if (index === -1) {
          return;
        }
        this._postProcesses.splice(index, 1);
        if (this._postProcesses.length > 0) {
          this._postProcesses[0].autoClear = false;
        }
      }
      _shouldRender() {
        if (this._currentRefreshId === -1) {
          this._currentRefreshId = 1;
          return true;
        }
        if (this.refreshRate === this._currentRefreshId) {
          this._currentRefreshId = 1;
          return true;
        }
        this._currentRefreshId++;
        return false;
      }
      getRenderSize() {
        return this.getRenderWidth();
      }
      getRenderWidth() {
        if (this._size.width) {
          return this._size.width;
        }
        return this._size;
      }
      getRenderHeight() {
        if (this._size.width) {
          return this._size.height;
        }
        return this._size;
      }
      getRenderLayers() {
        const layers = this._size.layers;
        if (layers) {
          return layers;
        }
        return 0;
      }
      disableRescaling() {
        this._canRescale = false;
      }
      get canRescale() {
        return this._canRescale;
      }
      scale(ratio) {
        const newSize = Math.max(1, this.getRenderSize() * ratio);
        this.resize(newSize);
      }
      getReflectionTextureMatrix() {
        if (this.isCube) {
          return this._textureMatrix;
        }
        return super.getReflectionTextureMatrix();
      }
      resize(size) {
        var _a;
        const wasCube = this.isCube;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
        this._renderTarget = null;
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        this._processSizeParameter(size, false);
        if (wasCube) {
          this._renderTarget = scene.getEngine().createRenderTargetCubeTexture(this.getRenderSize(), this._renderTargetOptions);
        } else {
          this._renderTarget = scene.getEngine().createRenderTargetTexture(this._size, this._renderTargetOptions);
        }
        this._texture = this._renderTarget.texture;
        if (this._renderTargetOptions.samples !== void 0) {
          this.samples = this._renderTargetOptions.samples;
        }
        if (this.onResizeObservable.hasObservers()) {
          this.onResizeObservable.notifyObservers(this);
        }
      }
      render(useCameraPostProcess = false, dumpForDebug = false) {
        this._render(useCameraPostProcess, dumpForDebug);
      }
      isReadyForRendering() {
        return this._render(false, false, true);
      }
      _render(useCameraPostProcess = false, dumpForDebug = false, checkReadiness = false) {
        var _a;
        const scene = this.getScene();
        if (!scene) {
          return checkReadiness;
        }
        const engine = scene.getEngine();
        if (this.useCameraPostProcesses !== void 0) {
          useCameraPostProcess = this.useCameraPostProcesses;
        }
        if (this._waitingRenderList) {
          this.renderList = [];
          for (let index = 0; index < this._waitingRenderList.length; index++) {
            const id = this._waitingRenderList[index];
            const mesh = scene.getMeshById(id);
            if (mesh) {
              this.renderList.push(mesh);
            }
          }
          this._waitingRenderList = void 0;
        }
        if (this.renderListPredicate) {
          if (this.renderList) {
            this.renderList.length = 0;
          } else {
            this.renderList = [];
          }
          const scene2 = this.getScene();
          if (!scene2) {
            return checkReadiness;
          }
          const sceneMeshes = scene2.meshes;
          for (let index = 0; index < sceneMeshes.length; index++) {
            const mesh = sceneMeshes[index];
            if (this.renderListPredicate(mesh)) {
              this.renderList.push(mesh);
            }
          }
        }
        const currentRenderPassId = engine.currentRenderPassId;
        this.onBeforeBindObservable.notifyObservers(this);
        const camera = (_a = this.activeCamera) !== null && _a !== void 0 ? _a : scene.activeCamera;
        const sceneCamera = scene.activeCamera;
        if (camera) {
          if (camera !== scene.activeCamera) {
            scene.setTransformMatrix(camera.getViewMatrix(), camera.getProjectionMatrix(true));
            scene.activeCamera = camera;
          }
          engine.setViewport(camera.rigParent ? camera.rigParent.viewport : camera.viewport, this.getRenderWidth(), this.getRenderHeight());
        }
        this._defaultRenderListPrepared = false;
        let returnValue = checkReadiness;
        if (!checkReadiness) {
          if (this.is2DArray && !this.isMulti) {
            for (let layer = 0; layer < this.getRenderLayers(); layer++) {
              this._renderToTarget(0, useCameraPostProcess, dumpForDebug, layer, camera);
              scene.incrementRenderId();
              scene.resetCachedMaterial();
            }
          } else if (this.isCube && !this.isMulti) {
            for (let face = 0; face < 6; face++) {
              this._renderToTarget(face, useCameraPostProcess, dumpForDebug, void 0, camera);
              scene.incrementRenderId();
              scene.resetCachedMaterial();
            }
          } else {
            this._renderToTarget(0, useCameraPostProcess, dumpForDebug, void 0, camera);
          }
        } else {
          if (!scene.getViewMatrix()) {
            scene.updateTransformMatrix();
          }
          const numLayers = this.is2DArray ? this.getRenderLayers() : this.isCube ? 6 : 1;
          for (let layer = 0; layer < numLayers && returnValue; layer++) {
            let currentRenderList = null;
            const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
            const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
            engine.currentRenderPassId = this._renderPassIds[layer];
            this.onBeforeRenderObservable.notifyObservers(layer);
            if (this.getCustomRenderList) {
              currentRenderList = this.getCustomRenderList(layer, defaultRenderList, defaultRenderListLength);
            }
            if (!currentRenderList) {
              currentRenderList = defaultRenderList;
            }
            if (!this._doNotChangeAspectRatio) {
              scene.updateTransformMatrix(true);
            }
            for (let i = 0; i < currentRenderList.length && returnValue; ++i) {
              const mesh = currentRenderList[i];
              if (!mesh.isEnabled() || mesh.isBlocked || !mesh.isVisible || !mesh.subMeshes) {
                continue;
              }
              if (this.customIsReadyFunction) {
                if (!this.customIsReadyFunction(mesh, this.refreshRate, checkReadiness)) {
                  returnValue = false;
                  continue;
                }
              } else if (!mesh.isReady(true)) {
                returnValue = false;
                continue;
              }
            }
            this.onAfterRenderObservable.notifyObservers(layer);
            if (this.is2DArray || this.isCube) {
              scene.incrementRenderId();
              scene.resetCachedMaterial();
            }
          }
        }
        this.onAfterUnbindObservable.notifyObservers(this);
        engine.currentRenderPassId = currentRenderPassId;
        if (sceneCamera) {
          scene.activeCamera = sceneCamera;
          if (scene.getEngine().scenes.length > 1 || this.activeCamera && this.activeCamera !== scene.activeCamera) {
            scene.setTransformMatrix(scene.activeCamera.getViewMatrix(), scene.activeCamera.getProjectionMatrix(true));
          }
          engine.setViewport(scene.activeCamera.viewport);
        }
        scene.resetCachedMaterial();
        return returnValue;
      }
      _bestReflectionRenderTargetDimension(renderDimension, scale) {
        const minimum = 128;
        const x = renderDimension * scale;
        const curved = Engine.NearestPOT(x + minimum * minimum / (minimum + x));
        return Math.min(Engine.FloorPOT(renderDimension), curved);
      }
      _prepareRenderingManager(currentRenderList, currentRenderListLength, camera, checkLayerMask) {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        this._renderingManager.reset();
        const sceneRenderId = scene.getRenderId();
        for (let meshIndex = 0; meshIndex < currentRenderListLength; meshIndex++) {
          const mesh = currentRenderList[meshIndex];
          if (mesh && !mesh.isBlocked) {
            if (this.customIsReadyFunction) {
              if (!this.customIsReadyFunction(mesh, this.refreshRate, false)) {
                this.resetRefreshCounter();
                continue;
              }
            } else if (!mesh.isReady(this.refreshRate === 0)) {
              this.resetRefreshCounter();
              continue;
            }
            if (!mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate && scene.activeCamera) {
              mesh._internalAbstractMeshDataInfo._currentLOD = scene.customLODSelector ? scene.customLODSelector(mesh, this.activeCamera || scene.activeCamera) : mesh.getLOD(this.activeCamera || scene.activeCamera);
              mesh._internalAbstractMeshDataInfo._currentLODIsUpToDate = true;
            }
            if (!mesh._internalAbstractMeshDataInfo._currentLOD) {
              continue;
            }
            let meshToRender = mesh._internalAbstractMeshDataInfo._currentLOD;
            meshToRender._preActivateForIntermediateRendering(sceneRenderId);
            let isMasked;
            if (checkLayerMask && camera) {
              isMasked = (mesh.layerMask & camera.layerMask) === 0;
            } else {
              isMasked = false;
            }
            if (mesh.isEnabled() && mesh.isVisible && mesh.subMeshes && !isMasked) {
              if (meshToRender !== mesh) {
                meshToRender._activate(sceneRenderId, true);
              }
              if (mesh._activate(sceneRenderId, true) && mesh.subMeshes.length) {
                if (!mesh.isAnInstance) {
                  meshToRender._internalAbstractMeshDataInfo._onlyForInstancesIntermediate = false;
                } else {
                  if (mesh._internalAbstractMeshDataInfo._actAsRegularMesh) {
                    meshToRender = mesh;
                  }
                }
                meshToRender._internalAbstractMeshDataInfo._isActiveIntermediate = true;
                for (let subIndex = 0; subIndex < meshToRender.subMeshes.length; subIndex++) {
                  const subMesh = meshToRender.subMeshes[subIndex];
                  this._renderingManager.dispatch(subMesh, meshToRender);
                }
              }
            }
          }
        }
        for (let particleIndex = 0; particleIndex < scene.particleSystems.length; particleIndex++) {
          const particleSystem = scene.particleSystems[particleIndex];
          const emitter = particleSystem.emitter;
          if (!particleSystem.isStarted() || !emitter || emitter.position && !emitter.isEnabled()) {
            continue;
          }
          this._renderingManager.dispatchParticles(particleSystem);
        }
      }
      _bindFrameBuffer(faceIndex = 0, layer = 0) {
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        const engine = scene.getEngine();
        if (this._renderTarget) {
          engine.bindFramebuffer(this._renderTarget, this.isCube ? faceIndex : void 0, void 0, void 0, this.ignoreCameraViewport, 0, layer);
        }
      }
      _unbindFrameBuffer(engine, faceIndex) {
        if (!this._renderTarget) {
          return;
        }
        engine.unBindFramebuffer(this._renderTarget, this.isCube, () => {
          this.onAfterRenderObservable.notifyObservers(faceIndex);
        });
      }
      _prepareFrame(scene, faceIndex, layer, useCameraPostProcess) {
        if (this._postProcessManager) {
          if (!this._prePassEnabled) {
            this._postProcessManager._prepareFrame(this._texture, this._postProcesses);
          }
        } else if (!useCameraPostProcess || !scene.postProcessManager._prepareFrame(this._texture)) {
          this._bindFrameBuffer(faceIndex, layer);
        }
      }
      _renderToTarget(faceIndex, useCameraPostProcess, dumpForDebug, layer = 0, camera = null) {
        var _a, _b, _c, _d, _e, _f;
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        const engine = scene.getEngine();
        (_a = engine._debugPushGroup) === null || _a === void 0 ? void 0 : _a.call(engine, `render to face #${faceIndex} layer #${layer}`, 1);
        this._prepareFrame(scene, faceIndex, layer, useCameraPostProcess);
        if (this.is2DArray) {
          engine.currentRenderPassId = this._renderPassIds[layer];
          this.onBeforeRenderObservable.notifyObservers(layer);
        } else {
          engine.currentRenderPassId = this._renderPassIds[faceIndex];
          this.onBeforeRenderObservable.notifyObservers(faceIndex);
        }
        const fastPath = engine.snapshotRendering && engine.snapshotRenderingMode === 1;
        if (!fastPath) {
          let currentRenderList = null;
          const defaultRenderList = this.renderList ? this.renderList : scene.getActiveMeshes().data;
          const defaultRenderListLength = this.renderList ? this.renderList.length : scene.getActiveMeshes().length;
          if (this.getCustomRenderList) {
            currentRenderList = this.getCustomRenderList(this.is2DArray ? layer : faceIndex, defaultRenderList, defaultRenderListLength);
          }
          if (!currentRenderList) {
            if (!this._defaultRenderListPrepared) {
              this._prepareRenderingManager(defaultRenderList, defaultRenderListLength, camera, !this.renderList || this.forceLayerMaskCheck);
              this._defaultRenderListPrepared = true;
            }
            currentRenderList = defaultRenderList;
          } else {
            this._prepareRenderingManager(currentRenderList, currentRenderList.length, camera, this.forceLayerMaskCheck);
          }
          for (const step of scene._beforeRenderTargetClearStage) {
            step.action(this, faceIndex, layer);
          }
          if (this.onClearObservable.hasObservers()) {
            this.onClearObservable.notifyObservers(engine);
          } else {
            if (!this.skipInitialClear) {
              engine.clear(this.clearColor || scene.clearColor, true, true, true);
            }
          }
          if (!this._doNotChangeAspectRatio) {
            scene.updateTransformMatrix(true);
          }
          for (const step of scene._beforeRenderTargetDrawStage) {
            step.action(this, faceIndex, layer);
          }
          this._renderingManager.render(this.customRenderFunction, currentRenderList, this.renderParticles, this.renderSprites);
          for (const step of scene._afterRenderTargetDrawStage) {
            step.action(this, faceIndex, layer);
          }
          const saveGenerateMipMaps = (_c = (_b = this._texture) === null || _b === void 0 ? void 0 : _b.generateMipMaps) !== null && _c !== void 0 ? _c : false;
          if (this._texture) {
            this._texture.generateMipMaps = false;
          }
          if (this._postProcessManager) {
            this._postProcessManager._finalizeFrame(false, (_d = this._renderTarget) !== null && _d !== void 0 ? _d : void 0, faceIndex, this._postProcesses, this.ignoreCameraViewport);
          } else if (useCameraPostProcess) {
            scene.postProcessManager._finalizeFrame(false, (_e = this._renderTarget) !== null && _e !== void 0 ? _e : void 0, faceIndex);
          }
          for (const step of scene._afterRenderTargetPostProcessStage) {
            step.action(this, faceIndex, layer);
          }
          if (this._texture) {
            this._texture.generateMipMaps = saveGenerateMipMaps;
          }
          if (!this._doNotChangeAspectRatio) {
            scene.updateTransformMatrix(true);
          }
          if (dumpForDebug) {
            DumpTools.DumpFramebuffer(this.getRenderWidth(), this.getRenderHeight(), engine);
          }
        } else {
          if (this.onClearObservable.hasObservers()) {
            this.onClearObservable.notifyObservers(engine);
          } else {
            if (!this.skipInitialClear) {
              engine.clear(this.clearColor || scene.clearColor, true, true, true);
            }
          }
        }
        this._unbindFrameBuffer(engine, faceIndex);
        if (this._texture && this.isCube && faceIndex === 5) {
          engine.generateMipMapsForCubemap(this._texture);
        }
        (_f = engine._debugPopGroup) === null || _f === void 0 ? void 0 : _f.call(engine, 1);
      }
      setRenderingOrder(renderingGroupId, opaqueSortCompareFn = null, alphaTestSortCompareFn = null, transparentSortCompareFn = null) {
        this._renderingManager.setRenderingOrder(renderingGroupId, opaqueSortCompareFn, alphaTestSortCompareFn, transparentSortCompareFn);
      }
      setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil) {
        this._renderingManager.setRenderingAutoClearDepthStencil(renderingGroupId, autoClearDepthStencil);
        this._renderingManager._useSceneAutoClearSetup = false;
      }
      clone() {
        const textureSize = this.getSize();
        const newTexture = new RenderTargetTexture(this.name, textureSize, this.getScene(), this._renderTargetOptions.generateMipMaps, this._doNotChangeAspectRatio, this._renderTargetOptions.type, this.isCube, this._renderTargetOptions.samplingMode, this._renderTargetOptions.generateDepthBuffer, this._renderTargetOptions.generateStencilBuffer, void 0, this._renderTargetOptions.format, void 0, this._renderTargetOptions.samples);
        newTexture.hasAlpha = this.hasAlpha;
        newTexture.level = this.level;
        newTexture.coordinatesMode = this.coordinatesMode;
        if (this.renderList) {
          newTexture.renderList = this.renderList.slice(0);
        }
        return newTexture;
      }
      serialize() {
        if (!this.name) {
          return null;
        }
        const serializationObject = super.serialize();
        serializationObject.renderTargetSize = this.getRenderSize();
        serializationObject.renderList = [];
        if (this.renderList) {
          for (let index = 0; index < this.renderList.length; index++) {
            serializationObject.renderList.push(this.renderList[index].id);
          }
        }
        return serializationObject;
      }
      disposeFramebufferObjects() {
        var _a;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose(true);
      }
      releaseInternalTexture() {
        var _a;
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.releaseTextures();
        this._texture = null;
      }
      dispose() {
        var _a;
        this.onResizeObservable.clear();
        this.onClearObservable.clear();
        this.onAfterRenderObservable.clear();
        this.onAfterUnbindObservable.clear();
        this.onBeforeBindObservable.clear();
        this.onBeforeRenderObservable.clear();
        if (this._postProcessManager) {
          this._postProcessManager.dispose();
          this._postProcessManager = null;
        }
        if (this._prePassRenderTarget) {
          this._prePassRenderTarget.dispose();
        }
        this._releaseRenderPassId();
        this.clearPostProcesses(true);
        if (this._resizeObserver) {
          this.getScene().getEngine().onResizeObservable.remove(this._resizeObserver);
          this._resizeObserver = null;
        }
        this.renderList = null;
        const scene = this.getScene();
        if (!scene) {
          return;
        }
        let index = scene.customRenderTargets.indexOf(this);
        if (index >= 0) {
          scene.customRenderTargets.splice(index, 1);
        }
        for (const camera of scene.cameras) {
          index = camera.customRenderTargets.indexOf(this);
          if (index >= 0) {
            camera.customRenderTargets.splice(index, 1);
          }
        }
        (_a = this._renderTarget) === null || _a === void 0 ? void 0 : _a.dispose();
        this._renderTarget = null;
        this._texture = null;
        super.dispose();
      }
      _rebuild() {
        if (this.refreshRate === RenderTargetTexture.REFRESHRATE_RENDER_ONCE) {
          this.refreshRate = RenderTargetTexture.REFRESHRATE_RENDER_ONCE;
        }
        if (this._postProcessManager) {
          this._postProcessManager._rebuild();
        }
      }
      freeRenderingGroups() {
        if (this._renderingManager) {
          this._renderingManager.freeRenderingGroups();
        }
      }
      getViewCount() {
        return 1;
      }
    };
    RenderTargetTexture.REFRESHRATE_RENDER_ONCE = 0;
    RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYFRAME = 1;
    RenderTargetTexture.REFRESHRATE_RENDER_ONEVERYTWOFRAMES = 2;
    Texture._CreateRenderTargetTexture = (name109, renderTargetSize, scene, generateMipMaps, creationFlags) => {
      return new RenderTargetTexture(name109, renderTargetSize, scene, generateMipMaps);
    };
  }
});

// node_modules/@babylonjs/core/Bones/skeleton.js
var Skeleton;
var init_skeleton = __esm({
  "node_modules/@babylonjs/core/Bones/skeleton.js"() {
    init_bone();
    init_observable();
    init_math_vector();
    init_rawTexture();
    init_animation();
    init_animationRange();
    init_engineStore();
    init_logger();
    init_deepCopier();
    Skeleton = class {
      get useTextureToStoreBoneMatrices() {
        return this._useTextureToStoreBoneMatrices;
      }
      set useTextureToStoreBoneMatrices(value) {
        this._useTextureToStoreBoneMatrices = value;
        this._markAsDirty();
      }
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      get isUsingTextureForMatrices() {
        return this.useTextureToStoreBoneMatrices && this._canUseTextureForBones;
      }
      get uniqueId() {
        return this._uniqueId;
      }
      constructor(name109, id, scene) {
        this.name = name109;
        this.id = id;
        this.bones = new Array();
        this.needInitialSkinMatrix = false;
        this._isDirty = true;
        this._meshesWithPoseMatrix = new Array();
        this._identity = Matrix.Identity();
        this._currentRenderId = -1;
        this._ranges = {};
        this._absoluteTransformIsDirty = true;
        this._canUseTextureForBones = false;
        this._uniqueId = 0;
        this._numBonesWithLinkedTransformNode = 0;
        this._hasWaitingData = null;
        this._parentContainer = null;
        this.doNotSerialize = false;
        this._useTextureToStoreBoneMatrices = true;
        this._animationPropertiesOverride = null;
        this.onBeforeComputeObservable = new Observable();
        this.bones = [];
        this._scene = scene || EngineStore.LastCreatedScene;
        this._uniqueId = this._scene.getUniqueId();
        this._scene.addSkeleton(this);
        this._isDirty = true;
        const engineCaps = this._scene.getEngine().getCaps();
        this._canUseTextureForBones = engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0;
      }
      getClassName() {
        return "Skeleton";
      }
      getChildren() {
        return this.bones.filter((b) => !b.getParent());
      }
      getTransformMatrices(mesh) {
        if (this.needInitialSkinMatrix) {
          if (!mesh._bonesTransformMatrices) {
            this.prepare();
          }
          return mesh._bonesTransformMatrices;
        }
        if (!this._transformMatrices || this._isDirty) {
          this.prepare();
        }
        return this._transformMatrices;
      }
      getTransformMatrixTexture(mesh) {
        if (this.needInitialSkinMatrix && mesh._transformMatrixTexture) {
          return mesh._transformMatrixTexture;
        }
        return this._transformMatrixTexture;
      }
      getScene() {
        return this._scene;
      }
      toString(fullDetails) {
        let ret = `Name: ${this.name}, nBones: ${this.bones.length}`;
        ret += `, nAnimationRanges: ${this._ranges ? Object.keys(this._ranges).length : "none"}`;
        if (fullDetails) {
          ret += ", Ranges: {";
          let first = true;
          for (const name109 in this._ranges) {
            if (first) {
              ret += ", ";
              first = false;
            }
            ret += name109;
          }
          ret += "}";
        }
        return ret;
      }
      getBoneIndexByName(name109) {
        for (let boneIndex = 0, cache = this.bones.length; boneIndex < cache; boneIndex++) {
          if (this.bones[boneIndex].name === name109) {
            return boneIndex;
          }
        }
        return -1;
      }
      createAnimationRange(name109, from, to) {
        if (!this._ranges[name109]) {
          this._ranges[name109] = new AnimationRange(name109, from, to);
          for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
            if (this.bones[i].animations[0]) {
              this.bones[i].animations[0].createRange(name109, from, to);
            }
          }
        }
      }
      deleteAnimationRange(name109, deleteFrames = true) {
        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            this.bones[i].animations[0].deleteRange(name109, deleteFrames);
          }
        }
        this._ranges[name109] = null;
      }
      getAnimationRange(name109) {
        return this._ranges[name109] || null;
      }
      getAnimationRanges() {
        const animationRanges = [];
        let name109;
        for (name109 in this._ranges) {
          animationRanges.push(this._ranges[name109]);
        }
        return animationRanges;
      }
      copyAnimationRange(source, name109, rescaleAsRequired = false) {
        if (this._ranges[name109] || !source.getAnimationRange(name109)) {
          return false;
        }
        let ret = true;
        const frameOffset = this._getHighestAnimationFrame() + 1;
        const boneDict = {};
        const sourceBones = source.bones;
        let nBones;
        let i;
        for (i = 0, nBones = sourceBones.length; i < nBones; i++) {
          boneDict[sourceBones[i].name] = sourceBones[i];
        }
        if (this.bones.length !== sourceBones.length) {
          Logger.Warn(`copyAnimationRange: this rig has ${this.bones.length} bones, while source as ${sourceBones.length}`);
          ret = false;
        }
        const skelDimensionsRatio = rescaleAsRequired && this.dimensionsAtRest && source.dimensionsAtRest ? this.dimensionsAtRest.divide(source.dimensionsAtRest) : null;
        for (i = 0, nBones = this.bones.length; i < nBones; i++) {
          const boneName = this.bones[i].name;
          const sourceBone = boneDict[boneName];
          if (sourceBone) {
            ret = ret && this.bones[i].copyAnimationRange(sourceBone, name109, frameOffset, rescaleAsRequired, skelDimensionsRatio);
          } else {
            Logger.Warn("copyAnimationRange: not same rig, missing source bone " + boneName);
            ret = false;
          }
        }
        const range = source.getAnimationRange(name109);
        if (range) {
          this._ranges[name109] = new AnimationRange(name109, range.from + frameOffset, range.to + frameOffset);
        }
        return ret;
      }
      returnToRest() {
        for (const bone of this.bones) {
          if (bone._index !== -1) {
            bone.returnToRest();
          }
        }
      }
      _getHighestAnimationFrame() {
        let ret = 0;
        for (let i = 0, nBones = this.bones.length; i < nBones; i++) {
          if (this.bones[i].animations[0]) {
            const highest = this.bones[i].animations[0].getHighestFrame();
            if (ret < highest) {
              ret = highest;
            }
          }
        }
        return ret;
      }
      beginAnimation(name109, loop, speedRatio, onAnimationEnd) {
        const range = this.getAnimationRange(name109);
        if (!range) {
          return null;
        }
        return this._scene.beginAnimation(this, range.from, range.to, loop, speedRatio, onAnimationEnd);
      }
      static MakeAnimationAdditive(skeleton, referenceFrame = 0, range) {
        const rangeValue = skeleton.getAnimationRange(range);
        if (!rangeValue) {
          return null;
        }
        const sceneAnimatables = skeleton._scene.getAllAnimatablesByTarget(skeleton);
        let rangeAnimatable = null;
        for (let index = 0; index < sceneAnimatables.length; index++) {
          const sceneAnimatable = sceneAnimatables[index];
          if (sceneAnimatable.fromFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.from) && sceneAnimatable.toFrame === (rangeValue === null || rangeValue === void 0 ? void 0 : rangeValue.to)) {
            rangeAnimatable = sceneAnimatable;
            break;
          }
        }
        const animatables = skeleton.getAnimatables();
        for (let index = 0; index < animatables.length; index++) {
          const animatable = animatables[index];
          const animations = animatable.animations;
          if (!animations) {
            continue;
          }
          for (let animIndex = 0; animIndex < animations.length; animIndex++) {
            Animation.MakeAnimationAdditive(animations[animIndex], referenceFrame, range);
          }
        }
        if (rangeAnimatable) {
          rangeAnimatable.isAdditive = true;
        }
        return skeleton;
      }
      _markAsDirty() {
        this._isDirty = true;
        this._absoluteTransformIsDirty = true;
      }
      _registerMeshWithPoseMatrix(mesh) {
        this._meshesWithPoseMatrix.push(mesh);
      }
      _unregisterMeshWithPoseMatrix(mesh) {
        const index = this._meshesWithPoseMatrix.indexOf(mesh);
        if (index > -1) {
          this._meshesWithPoseMatrix.splice(index, 1);
        }
      }
      _computeTransformMatrices(targetMatrix, initialSkinMatrix) {
        this.onBeforeComputeObservable.notifyObservers(this);
        for (let index = 0; index < this.bones.length; index++) {
          const bone = this.bones[index];
          bone._childUpdateId++;
          const parentBone = bone.getParent();
          if (parentBone) {
            bone.getLocalMatrix().multiplyToRef(parentBone.getFinalMatrix(), bone.getFinalMatrix());
          } else {
            if (initialSkinMatrix) {
              bone.getLocalMatrix().multiplyToRef(initialSkinMatrix, bone.getFinalMatrix());
            } else {
              bone.getFinalMatrix().copyFrom(bone.getLocalMatrix());
            }
          }
          if (bone._index !== -1) {
            const mappedIndex = bone._index === null ? index : bone._index;
            bone.getAbsoluteInverseBindMatrix().multiplyToArray(bone.getFinalMatrix(), targetMatrix, mappedIndex * 16);
          }
        }
        this._identity.copyToArray(targetMatrix, this.bones.length * 16);
      }
      prepare(dontCheckFrameId = false) {
        if (!dontCheckFrameId) {
          const currentRenderId = this.getScene().getRenderId();
          if (this._currentRenderId === currentRenderId) {
            return;
          }
          this._currentRenderId = currentRenderId;
        }
        if (this._numBonesWithLinkedTransformNode > 0) {
          for (const bone of this.bones) {
            if (bone._linkedTransformNode) {
              const node = bone._linkedTransformNode;
              bone.position = node.position;
              if (node.rotationQuaternion) {
                bone.rotationQuaternion = node.rotationQuaternion;
              } else {
                bone.rotation = node.rotation;
              }
              bone.scaling = node.scaling;
            }
          }
        }
        if (this.needInitialSkinMatrix) {
          for (const mesh of this._meshesWithPoseMatrix) {
            const poseMatrix = mesh.getPoseMatrix();
            let needsUpdate = this._isDirty;
            if (!mesh._bonesTransformMatrices || mesh._bonesTransformMatrices.length !== 16 * (this.bones.length + 1)) {
              mesh._bonesTransformMatrices = new Float32Array(16 * (this.bones.length + 1));
              needsUpdate = true;
            }
            if (!needsUpdate) {
              continue;
            }
            if (this._synchronizedWithMesh !== mesh) {
              this._synchronizedWithMesh = mesh;
              for (const bone of this.bones) {
                if (!bone.getParent()) {
                  const matrix = bone.getBindMatrix();
                  matrix.multiplyToRef(poseMatrix, TmpVectors.Matrix[1]);
                  bone._updateAbsoluteBindMatrices(TmpVectors.Matrix[1]);
                }
              }
              if (this.isUsingTextureForMatrices) {
                const textureWidth = (this.bones.length + 1) * 4;
                if (!mesh._transformMatrixTexture || mesh._transformMatrixTexture.getSize().width !== textureWidth) {
                  if (mesh._transformMatrixTexture) {
                    mesh._transformMatrixTexture.dispose();
                  }
                  mesh._transformMatrixTexture = RawTexture.CreateRGBATexture(mesh._bonesTransformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
                }
              }
            }
            this._computeTransformMatrices(mesh._bonesTransformMatrices, poseMatrix);
            if (this.isUsingTextureForMatrices && mesh._transformMatrixTexture) {
              mesh._transformMatrixTexture.update(mesh._bonesTransformMatrices);
            }
          }
        } else {
          if (!this._isDirty) {
            return;
          }
          if (!this._transformMatrices || this._transformMatrices.length !== 16 * (this.bones.length + 1)) {
            this._transformMatrices = new Float32Array(16 * (this.bones.length + 1));
            if (this.isUsingTextureForMatrices) {
              if (this._transformMatrixTexture) {
                this._transformMatrixTexture.dispose();
              }
              this._transformMatrixTexture = RawTexture.CreateRGBATexture(this._transformMatrices, (this.bones.length + 1) * 4, 1, this._scene, false, false, 1, 1);
            }
          }
          this._computeTransformMatrices(this._transformMatrices, null);
          if (this.isUsingTextureForMatrices && this._transformMatrixTexture) {
            this._transformMatrixTexture.update(this._transformMatrices);
          }
        }
        this._isDirty = false;
      }
      getAnimatables() {
        if (!this._animatables || this._animatables.length !== this.bones.length) {
          this._animatables = [];
          for (let index = 0; index < this.bones.length; index++) {
            this._animatables.push(this.bones[index]);
          }
        }
        return this._animatables;
      }
      clone(name109, id) {
        const result = new Skeleton(name109, id || name109, this._scene);
        result.needInitialSkinMatrix = this.needInitialSkinMatrix;
        for (let index = 0; index < this.bones.length; index++) {
          const source = this.bones[index];
          let parentBone = null;
          const parent = source.getParent();
          if (parent) {
            const parentIndex = this.bones.indexOf(parent);
            parentBone = result.bones[parentIndex];
          }
          const bone = new Bone(source.name, result, parentBone, source.getBindMatrix().clone(), source.getRestMatrix().clone());
          bone._index = source._index;
          if (source._linkedTransformNode) {
            bone.linkTransformNode(source._linkedTransformNode);
          }
          DeepCopier.DeepCopy(source.animations, bone.animations);
        }
        if (this._ranges) {
          result._ranges = {};
          for (const rangeName in this._ranges) {
            const range = this._ranges[rangeName];
            if (range) {
              result._ranges[rangeName] = range.clone();
            }
          }
        }
        this._isDirty = true;
        result.prepare(true);
        return result;
      }
      enableBlending(blendingSpeed = 0.01) {
        this.bones.forEach((bone) => {
          bone.animations.forEach((animation) => {
            animation.enableBlending = true;
            animation.blendingSpeed = blendingSpeed;
          });
        });
      }
      dispose() {
        this._meshesWithPoseMatrix.length = 0;
        this.getScene().stopAnimation(this);
        this.getScene().removeSkeleton(this);
        if (this._parentContainer) {
          const index = this._parentContainer.skeletons.indexOf(this);
          if (index > -1) {
            this._parentContainer.skeletons.splice(index, 1);
          }
          this._parentContainer = null;
        }
        if (this._transformMatrixTexture) {
          this._transformMatrixTexture.dispose();
          this._transformMatrixTexture = null;
        }
      }
      serialize() {
        var _a;
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.id = this.id;
        if (this.dimensionsAtRest) {
          serializationObject.dimensionsAtRest = this.dimensionsAtRest.asArray();
        }
        serializationObject.bones = [];
        serializationObject.needInitialSkinMatrix = this.needInitialSkinMatrix;
        for (let index = 0; index < this.bones.length; index++) {
          const bone = this.bones[index];
          const parent = bone.getParent();
          const serializedBone = {
            parentBoneIndex: parent ? this.bones.indexOf(parent) : -1,
            index: bone.getIndex(),
            name: bone.name,
            id: bone.id,
            matrix: bone.getBindMatrix().toArray(),
            rest: bone.getRestMatrix().toArray(),
            linkedTransformNodeId: (_a = bone.getTransformNode()) === null || _a === void 0 ? void 0 : _a.id
          };
          serializationObject.bones.push(serializedBone);
          if (bone.length) {
            serializedBone.length = bone.length;
          }
          if (bone.metadata) {
            serializedBone.metadata = bone.metadata;
          }
          if (bone.animations && bone.animations.length > 0) {
            serializedBone.animation = bone.animations[0].serialize();
          }
          serializationObject.ranges = [];
          for (const name109 in this._ranges) {
            const source = this._ranges[name109];
            if (!source) {
              continue;
            }
            const range = {};
            range.name = name109;
            range.from = source.from;
            range.to = source.to;
            serializationObject.ranges.push(range);
          }
        }
        return serializationObject;
      }
      static Parse(parsedSkeleton, scene) {
        const skeleton = new Skeleton(parsedSkeleton.name, parsedSkeleton.id, scene);
        if (parsedSkeleton.dimensionsAtRest) {
          skeleton.dimensionsAtRest = Vector3.FromArray(parsedSkeleton.dimensionsAtRest);
        }
        skeleton.needInitialSkinMatrix = parsedSkeleton.needInitialSkinMatrix;
        let index;
        for (index = 0; index < parsedSkeleton.bones.length; index++) {
          const parsedBone = parsedSkeleton.bones[index];
          const parsedBoneIndex = parsedSkeleton.bones[index].index;
          let parentBone = null;
          if (parsedBone.parentBoneIndex > -1) {
            parentBone = skeleton.bones[parsedBone.parentBoneIndex];
          }
          const rest = parsedBone.rest ? Matrix.FromArray(parsedBone.rest) : null;
          const bone = new Bone(parsedBone.name, skeleton, parentBone, Matrix.FromArray(parsedBone.matrix), rest, null, parsedBoneIndex);
          if (parsedBone.id !== void 0 && parsedBone.id !== null) {
            bone.id = parsedBone.id;
          }
          if (parsedBone.length) {
            bone.length = parsedBone.length;
          }
          if (parsedBone.metadata) {
            bone.metadata = parsedBone.metadata;
          }
          if (parsedBone.animation) {
            bone.animations.push(Animation.Parse(parsedBone.animation));
          }
          if (parsedBone.linkedTransformNodeId !== void 0 && parsedBone.linkedTransformNodeId !== null) {
            skeleton._hasWaitingData = true;
            bone._waitingTransformNodeId = parsedBone.linkedTransformNodeId;
          }
        }
        if (parsedSkeleton.ranges) {
          for (index = 0; index < parsedSkeleton.ranges.length; index++) {
            const data = parsedSkeleton.ranges[index];
            skeleton.createAnimationRange(data.name, data.from, data.to);
          }
        }
        return skeleton;
      }
      computeAbsoluteMatrices(forceUpdate = false) {
        if (this._absoluteTransformIsDirty || forceUpdate) {
          this.bones[0].computeAbsoluteMatrices();
          this._absoluteTransformIsDirty = false;
        }
      }
      computeAbsoluteTransforms(forceUpdate = false) {
        this.computeAbsoluteMatrices(forceUpdate);
      }
      getPoseMatrix() {
        let poseMatrix = null;
        if (this._meshesWithPoseMatrix.length > 0) {
          poseMatrix = this._meshesWithPoseMatrix[0].getPoseMatrix();
        }
        return poseMatrix;
      }
      sortBones() {
        const bones = new Array();
        const visited = new Array(this.bones.length);
        for (let index = 0; index < this.bones.length; index++) {
          this._sortBones(index, bones, visited);
        }
        this.bones = bones;
      }
      _sortBones(index, bones, visited) {
        if (visited[index]) {
          return;
        }
        visited[index] = true;
        const bone = this.bones[index];
        if (!bone)
          return;
        if (bone._index === void 0) {
          bone._index = index;
        }
        const parentBone = bone.getParent();
        if (parentBone) {
          this._sortBones(this.bones.indexOf(parentBone), bones, visited);
        }
        bones.push(bone);
      }
      setCurrentPoseAsRest() {
        this.bones.forEach((b) => {
          b.setCurrentPoseAsRest();
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js
var BaseCameraMouseWheelInput;
var init_BaseCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/BaseCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_observable();
    init_pointerEvents();
    init_deviceInputEvents();
    init_tools();
    BaseCameraMouseWheelInput = class {
      constructor() {
        this.wheelPrecisionX = 3;
        this.wheelPrecisionY = 3;
        this.wheelPrecisionZ = 3;
        this.onChangedObservable = new Observable();
        this._wheelDeltaX = 0;
        this._wheelDeltaY = 0;
        this._wheelDeltaZ = 0;
        this._ffMultiplier = 12;
        this._normalize = 120;
      }
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this._wheel = (pointer) => {
          if (pointer.type !== PointerEventTypes.POINTERWHEEL) {
            return;
          }
          const event = pointer.event;
          const platformScale = event.deltaMode === EventConstants.DOM_DELTA_LINE ? this._ffMultiplier : 1;
          this._wheelDeltaX += this.wheelPrecisionX * platformScale * event.deltaX / this._normalize;
          this._wheelDeltaY -= this.wheelPrecisionY * platformScale * event.deltaY / this._normalize;
          this._wheelDeltaZ += this.wheelPrecisionZ * platformScale * event.deltaZ / this._normalize;
          if (event.preventDefault) {
            if (!noPreventDefault) {
              event.preventDefault();
            }
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._wheel, PointerEventTypes.POINTERWHEEL);
      }
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          this._observer = null;
          this._wheel = null;
        }
        if (this.onChangedObservable) {
          this.onChangedObservable.clear();
        }
      }
      checkInputs() {
        this.onChangedObservable.notifyObservers({
          wheelDeltaX: this._wheelDeltaX,
          wheelDeltaY: this._wheelDeltaY,
          wheelDeltaZ: this._wheelDeltaZ
        });
        this._wheelDeltaX = 0;
        this._wheelDeltaY = 0;
        this._wheelDeltaZ = 0;
      }
      getClassName() {
        return "BaseCameraMouseWheelInput";
      }
      getSimpleName() {
        return "mousewheel";
      }
    };
    __decorate([
      serialize()
    ], BaseCameraMouseWheelInput.prototype, "wheelPrecisionX", void 0);
    __decorate([
      serialize()
    ], BaseCameraMouseWheelInput.prototype, "wheelPrecisionY", void 0);
    __decorate([
      serialize()
    ], BaseCameraMouseWheelInput.prototype, "wheelPrecisionZ", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/cameraInputsManager.js
var CameraInputTypes, CameraInputsManager;
var init_cameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/cameraInputsManager.js"() {
    init_logger();
    init_decorators();
    init_camera();
    CameraInputTypes = {};
    CameraInputsManager = class {
      constructor(camera) {
        this.attachedToElement = false;
        this.attached = {};
        this.camera = camera;
        this.checkInputs = () => {
        };
      }
      add(input) {
        const type = input.getSimpleName();
        if (this.attached[type]) {
          Logger.Warn("camera input of type " + type + " already exists on camera");
          return;
        }
        this.attached[type] = input;
        input.camera = this.camera;
        if (input.checkInputs) {
          this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
        }
        if (this.attachedToElement) {
          input.attachControl(this.noPreventDefault);
        }
      }
      remove(inputToRemove) {
        for (const cam in this.attached) {
          const input = this.attached[cam];
          if (input === inputToRemove) {
            input.detachControl();
            input.camera = null;
            delete this.attached[cam];
            this.rebuildInputCheck();
            return;
          }
        }
      }
      removeByType(inputType) {
        for (const cam in this.attached) {
          const input = this.attached[cam];
          if (input.getClassName() === inputType) {
            input.detachControl();
            input.camera = null;
            delete this.attached[cam];
            this.rebuildInputCheck();
          }
        }
      }
      _addCheckInputs(fn) {
        const current = this.checkInputs;
        return () => {
          current();
          fn();
        };
      }
      attachInput(input) {
        if (this.attachedToElement) {
          input.attachControl(this.noPreventDefault);
        }
      }
      attachElement(noPreventDefault = false) {
        if (this.attachedToElement) {
          return;
        }
        noPreventDefault = Camera.ForceAttachControlToAlwaysPreventDefault ? false : noPreventDefault;
        this.attachedToElement = true;
        this.noPreventDefault = noPreventDefault;
        for (const cam in this.attached) {
          this.attached[cam].attachControl(noPreventDefault);
        }
      }
      detachElement(disconnect = false) {
        for (const cam in this.attached) {
          this.attached[cam].detachControl();
          if (disconnect) {
            this.attached[cam].camera = null;
          }
        }
        this.attachedToElement = false;
      }
      rebuildInputCheck() {
        this.checkInputs = () => {
        };
        for (const cam in this.attached) {
          const input = this.attached[cam];
          if (input.checkInputs) {
            this.checkInputs = this._addCheckInputs(input.checkInputs.bind(input));
          }
        }
      }
      clear() {
        if (this.attachedToElement) {
          this.detachElement(true);
        }
        this.attached = {};
        this.attachedToElement = false;
        this.checkInputs = () => {
        };
      }
      serialize(serializedCamera) {
        const inputs = {};
        for (const cam in this.attached) {
          const input = this.attached[cam];
          const res = SerializationHelper.Serialize(input);
          inputs[input.getClassName()] = res;
        }
        serializedCamera.inputsmgr = inputs;
      }
      parse(parsedCamera) {
        const parsedInputs = parsedCamera.inputsmgr;
        if (parsedInputs) {
          this.clear();
          for (const n in parsedInputs) {
            const construct = CameraInputTypes[n];
            if (construct) {
              const parsedinput = parsedInputs[n];
              const input = SerializationHelper.Parse(() => {
                return new construct();
              }, parsedinput, null);
              this.add(input);
            }
          }
        } else {
          for (const n in this.attached) {
            const construct = CameraInputTypes[this.attached[n].getClassName()];
            if (construct) {
              const input = SerializationHelper.Parse(() => {
                return new construct();
              }, parsedCamera, null);
              this.remove(this.attached[n]);
              this.add(input);
            }
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js
var FreeCameraKeyboardMoveInput;
var init_freeCameraKeyboardMoveInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraKeyboardMoveInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_keyboardEvents();
    init_math_vector();
    init_tools();
    FreeCameraKeyboardMoveInput = class {
      constructor() {
        this.keysUp = [38];
        this.keysUpward = [33];
        this.keysDown = [40];
        this.keysDownward = [34];
        this.keysLeft = [37];
        this.keysRight = [39];
        this.rotationSpeed = 0.5;
        this.keysRotateLeft = [];
        this.keysRotateRight = [];
        this.keysRotateUp = [];
        this.keysRotateDown = [];
        this._keys = new Array();
      }
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        if (this._onCanvasBlurObserver) {
          return;
        }
        this._scene = this.camera.getScene();
        this._engine = this._scene.getEngine();
        this._onCanvasBlurObserver = this._engine.onCanvasBlurObservable.add(() => {
          this._keys.length = 0;
        });
        this._onKeyboardObserver = this._scene.onKeyboardObservable.add((info) => {
          const evt = info.event;
          if (!evt.metaKey) {
            if (info.type === KeyboardEventTypes.KEYDOWN) {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index === -1) {
                  this._keys.push(evt.keyCode);
                }
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            } else {
              if (this.keysUp.indexOf(evt.keyCode) !== -1 || this.keysDown.indexOf(evt.keyCode) !== -1 || this.keysLeft.indexOf(evt.keyCode) !== -1 || this.keysRight.indexOf(evt.keyCode) !== -1 || this.keysUpward.indexOf(evt.keyCode) !== -1 || this.keysDownward.indexOf(evt.keyCode) !== -1 || this.keysRotateLeft.indexOf(evt.keyCode) !== -1 || this.keysRotateRight.indexOf(evt.keyCode) !== -1 || this.keysRotateUp.indexOf(evt.keyCode) !== -1 || this.keysRotateDown.indexOf(evt.keyCode) !== -1) {
                const index = this._keys.indexOf(evt.keyCode);
                if (index >= 0) {
                  this._keys.splice(index, 1);
                }
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            }
          }
        });
      }
      detachControl() {
        if (this._scene) {
          if (this._onKeyboardObserver) {
            this._scene.onKeyboardObservable.remove(this._onKeyboardObserver);
          }
          if (this._onCanvasBlurObserver) {
            this._engine.onCanvasBlurObservable.remove(this._onCanvasBlurObserver);
          }
          this._onKeyboardObserver = null;
          this._onCanvasBlurObserver = null;
        }
        this._keys.length = 0;
      }
      checkInputs() {
        if (this._onKeyboardObserver) {
          const camera = this.camera;
          for (let index = 0; index < this._keys.length; index++) {
            const keyCode = this._keys[index];
            const speed = camera._computeLocalCameraSpeed();
            if (this.keysLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(-speed, 0, 0);
            } else if (this.keysUp.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, speed);
            } else if (this.keysRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(speed, 0, 0);
            } else if (this.keysDown.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, -speed);
            } else if (this.keysUpward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, speed, 0);
            } else if (this.keysDownward.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, -speed, 0);
            } else if (this.keysRotateLeft.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.y -= this._getLocalRotation();
            } else if (this.keysRotateRight.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.y += this._getLocalRotation();
            } else if (this.keysRotateUp.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.x -= this._getLocalRotation();
            } else if (this.keysRotateDown.indexOf(keyCode) !== -1) {
              camera._localDirection.copyFromFloats(0, 0, 0);
              camera.cameraRotation.x += this._getLocalRotation();
            }
            if (camera.getScene().useRightHandedSystem) {
              camera._localDirection.z *= -1;
            }
            camera.getViewMatrix().invertToRef(camera._cameraTransformMatrix);
            Vector3.TransformNormalToRef(camera._localDirection, camera._cameraTransformMatrix, camera._transformedDirection);
            camera.cameraDirection.addInPlace(camera._transformedDirection);
          }
        }
      }
      getClassName() {
        return "FreeCameraKeyboardMoveInput";
      }
      _onLostFocus() {
        this._keys.length = 0;
      }
      getSimpleName() {
        return "keyboard";
      }
      _getLocalRotation() {
        const handednessMultiplier = this.camera._calculateHandednessMultiplier();
        const rotation = this.rotationSpeed * this._engine.getDeltaTime() / 1e3 * handednessMultiplier;
        return rotation;
      }
    };
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysUp", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysUpward", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysDown", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysDownward", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysLeft", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRight", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "rotationSpeed", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateLeft", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateRight", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateUp", void 0);
    __decorate([
      serialize()
    ], FreeCameraKeyboardMoveInput.prototype, "keysRotateDown", void 0);
    CameraInputTypes["FreeCameraKeyboardMoveInput"] = FreeCameraKeyboardMoveInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js
var FreeCameraMouseInput;
var init_freeCameraMouseInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseInput.js"() {
    init_tslib_es6();
    init_observable();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_tools();
    FreeCameraMouseInput = class {
      constructor(touchEnabled = true) {
        this.touchEnabled = touchEnabled;
        this.buttons = [0, 1, 2];
        this.angularSensibility = 2e3;
        this._previousPosition = null;
        this.onPointerMovedObservable = new Observable();
        this._allowCameraRotation = true;
        this._currentActiveButton = -1;
        this._activePointerId = -1;
      }
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        const engine = this.camera.getEngine();
        const element = engine.getInputElement();
        if (!this._pointerInput) {
          this._pointerInput = (p) => {
            const evt = p.event;
            const isTouch = evt.pointerType === "touch";
            if (engine.isInVRExclusivePointerMode) {
              return;
            }
            if (!this.touchEnabled && isTouch) {
              return;
            }
            if (p.type !== PointerEventTypes.POINTERMOVE && this.buttons.indexOf(evt.button) === -1) {
              return;
            }
            const srcElement = evt.target;
            if (p.type === PointerEventTypes.POINTERDOWN) {
              if (isTouch && this._activePointerId !== -1 || !isTouch && this._currentActiveButton !== -1) {
                return;
              }
              this._activePointerId = evt.pointerId;
              try {
                srcElement === null || srcElement === void 0 ? void 0 : srcElement.setPointerCapture(evt.pointerId);
              } catch (e) {
              }
              if (this._currentActiveButton === -1) {
                this._currentActiveButton = evt.button;
              }
              this._previousPosition = {
                x: evt.clientX,
                y: evt.clientY
              };
              if (!noPreventDefault) {
                evt.preventDefault();
                element && element.focus();
              }
              if (engine.isPointerLock && this._onMouseMove) {
                this._onMouseMove(p.event);
              }
            } else if (p.type === PointerEventTypes.POINTERUP) {
              if (isTouch && this._activePointerId !== evt.pointerId || !isTouch && this._currentActiveButton !== evt.button) {
                return;
              }
              try {
                srcElement === null || srcElement === void 0 ? void 0 : srcElement.releasePointerCapture(evt.pointerId);
              } catch (e) {
              }
              this._currentActiveButton = -1;
              this._previousPosition = null;
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              this._activePointerId = -1;
            } else if (p.type === PointerEventTypes.POINTERMOVE && (this._activePointerId === evt.pointerId || !isTouch)) {
              if (engine.isPointerLock && this._onMouseMove) {
                this._onMouseMove(p.event);
              } else if (this._previousPosition) {
                const handednessMultiplier = this.camera._calculateHandednessMultiplier();
                const offsetX = (evt.clientX - this._previousPosition.x) * handednessMultiplier;
                const offsetY = evt.clientY - this._previousPosition.y;
                if (this._allowCameraRotation) {
                  this.camera.cameraRotation.y += offsetX / this.angularSensibility;
                  this.camera.cameraRotation.x += offsetY / this.angularSensibility;
                }
                this.onPointerMovedObservable.notifyObservers({ offsetX, offsetY });
                this._previousPosition = {
                  x: evt.clientX,
                  y: evt.clientY
                };
                if (!noPreventDefault) {
                  evt.preventDefault();
                }
              }
            }
          };
        }
        this._onMouseMove = (evt) => {
          if (!engine.isPointerLock) {
            return;
          }
          if (engine.isInVRExclusivePointerMode) {
            return;
          }
          const handednessMultiplier = this.camera._calculateHandednessMultiplier();
          const offsetX = evt.movementX * handednessMultiplier;
          this.camera.cameraRotation.y += offsetX / this.angularSensibility;
          const offsetY = evt.movementY;
          this.camera.cameraRotation.x += offsetY / this.angularSensibility;
          this._previousPosition = null;
          if (!noPreventDefault) {
            evt.preventDefault();
          }
        };
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        if (element) {
          this._contextMenuBind = this.onContextMenu.bind(this);
          element.addEventListener("contextmenu", this._contextMenuBind, false);
        }
      }
      onContextMenu(evt) {
        evt.preventDefault();
      }
      detachControl() {
        if (this._observer) {
          this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
          if (this._contextMenuBind) {
            const engine = this.camera.getEngine();
            const element = engine.getInputElement();
            element && element.removeEventListener("contextmenu", this._contextMenuBind);
          }
          if (this.onPointerMovedObservable) {
            this.onPointerMovedObservable.clear();
          }
          this._observer = null;
          this._onMouseMove = null;
          this._previousPosition = null;
        }
        this._activePointerId = -1;
        this._currentActiveButton = -1;
      }
      getClassName() {
        return "FreeCameraMouseInput";
      }
      getSimpleName() {
        return "mouse";
      }
    };
    __decorate([
      serialize()
    ], FreeCameraMouseInput.prototype, "buttons", void 0);
    __decorate([
      serialize()
    ], FreeCameraMouseInput.prototype, "angularSensibility", void 0);
    CameraInputTypes["FreeCameraMouseInput"] = FreeCameraMouseInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js
var _CameraProperty, FreeCameraMouseWheelInput;
var init_freeCameraMouseWheelInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraMouseWheelInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_BaseCameraMouseWheelInput();
    init_math_vector();
    init_math_axis();
    (function(_CameraProperty2) {
      _CameraProperty2[_CameraProperty2["MoveRelative"] = 0] = "MoveRelative";
      _CameraProperty2[_CameraProperty2["RotateRelative"] = 1] = "RotateRelative";
      _CameraProperty2[_CameraProperty2["MoveScene"] = 2] = "MoveScene";
    })(_CameraProperty || (_CameraProperty = {}));
    FreeCameraMouseWheelInput = class extends BaseCameraMouseWheelInput {
      constructor() {
        super(...arguments);
        this._moveRelative = Vector3.Zero();
        this._rotateRelative = Vector3.Zero();
        this._moveScene = Vector3.Zero();
        this._wheelXAction = _CameraProperty.MoveRelative;
        this._wheelXActionCoordinate = Coordinate.X;
        this._wheelYAction = _CameraProperty.MoveRelative;
        this._wheelYActionCoordinate = Coordinate.Z;
        this._wheelZAction = null;
        this._wheelZActionCoordinate = null;
      }
      getClassName() {
        return "FreeCameraMouseWheelInput";
      }
      set wheelXMoveRelative(axis) {
        if (axis === null && this._wheelXAction !== _CameraProperty.MoveRelative) {
          return;
        }
        this._wheelXAction = _CameraProperty.MoveRelative;
        this._wheelXActionCoordinate = axis;
      }
      get wheelXMoveRelative() {
        if (this._wheelXAction !== _CameraProperty.MoveRelative) {
          return null;
        }
        return this._wheelXActionCoordinate;
      }
      set wheelYMoveRelative(axis) {
        if (axis === null && this._wheelYAction !== _CameraProperty.MoveRelative) {
          return;
        }
        this._wheelYAction = _CameraProperty.MoveRelative;
        this._wheelYActionCoordinate = axis;
      }
      get wheelYMoveRelative() {
        if (this._wheelYAction !== _CameraProperty.MoveRelative) {
          return null;
        }
        return this._wheelYActionCoordinate;
      }
      set wheelZMoveRelative(axis) {
        if (axis === null && this._wheelZAction !== _CameraProperty.MoveRelative) {
          return;
        }
        this._wheelZAction = _CameraProperty.MoveRelative;
        this._wheelZActionCoordinate = axis;
      }
      get wheelZMoveRelative() {
        if (this._wheelZAction !== _CameraProperty.MoveRelative) {
          return null;
        }
        return this._wheelZActionCoordinate;
      }
      set wheelXRotateRelative(axis) {
        if (axis === null && this._wheelXAction !== _CameraProperty.RotateRelative) {
          return;
        }
        this._wheelXAction = _CameraProperty.RotateRelative;
        this._wheelXActionCoordinate = axis;
      }
      get wheelXRotateRelative() {
        if (this._wheelXAction !== _CameraProperty.RotateRelative) {
          return null;
        }
        return this._wheelXActionCoordinate;
      }
      set wheelYRotateRelative(axis) {
        if (axis === null && this._wheelYAction !== _CameraProperty.RotateRelative) {
          return;
        }
        this._wheelYAction = _CameraProperty.RotateRelative;
        this._wheelYActionCoordinate = axis;
      }
      get wheelYRotateRelative() {
        if (this._wheelYAction !== _CameraProperty.RotateRelative) {
          return null;
        }
        return this._wheelYActionCoordinate;
      }
      set wheelZRotateRelative(axis) {
        if (axis === null && this._wheelZAction !== _CameraProperty.RotateRelative) {
          return;
        }
        this._wheelZAction = _CameraProperty.RotateRelative;
        this._wheelZActionCoordinate = axis;
      }
      get wheelZRotateRelative() {
        if (this._wheelZAction !== _CameraProperty.RotateRelative) {
          return null;
        }
        return this._wheelZActionCoordinate;
      }
      set wheelXMoveScene(axis) {
        if (axis === null && this._wheelXAction !== _CameraProperty.MoveScene) {
          return;
        }
        this._wheelXAction = _CameraProperty.MoveScene;
        this._wheelXActionCoordinate = axis;
      }
      get wheelXMoveScene() {
        if (this._wheelXAction !== _CameraProperty.MoveScene) {
          return null;
        }
        return this._wheelXActionCoordinate;
      }
      set wheelYMoveScene(axis) {
        if (axis === null && this._wheelYAction !== _CameraProperty.MoveScene) {
          return;
        }
        this._wheelYAction = _CameraProperty.MoveScene;
        this._wheelYActionCoordinate = axis;
      }
      get wheelYMoveScene() {
        if (this._wheelYAction !== _CameraProperty.MoveScene) {
          return null;
        }
        return this._wheelYActionCoordinate;
      }
      set wheelZMoveScene(axis) {
        if (axis === null && this._wheelZAction !== _CameraProperty.MoveScene) {
          return;
        }
        this._wheelZAction = _CameraProperty.MoveScene;
        this._wheelZActionCoordinate = axis;
      }
      get wheelZMoveScene() {
        if (this._wheelZAction !== _CameraProperty.MoveScene) {
          return null;
        }
        return this._wheelZActionCoordinate;
      }
      checkInputs() {
        if (this._wheelDeltaX === 0 && this._wheelDeltaY === 0 && this._wheelDeltaZ == 0) {
          return;
        }
        this._moveRelative.setAll(0);
        this._rotateRelative.setAll(0);
        this._moveScene.setAll(0);
        this._updateCamera();
        if (this.camera.getScene().useRightHandedSystem) {
          this._moveRelative.z *= -1;
        }
        const cameraTransformMatrix = Matrix.Zero();
        this.camera.getViewMatrix().invertToRef(cameraTransformMatrix);
        const transformedDirection = Vector3.Zero();
        Vector3.TransformNormalToRef(this._moveRelative, cameraTransformMatrix, transformedDirection);
        this.camera.cameraRotation.x += this._rotateRelative.x / 200;
        this.camera.cameraRotation.y += this._rotateRelative.y / 200;
        this.camera.cameraDirection.addInPlace(transformedDirection);
        this.camera.cameraDirection.addInPlace(this._moveScene);
        super.checkInputs();
      }
      _updateCamera() {
        this._updateCameraProperty(this._wheelDeltaX, this._wheelXAction, this._wheelXActionCoordinate);
        this._updateCameraProperty(this._wheelDeltaY, this._wheelYAction, this._wheelYActionCoordinate);
        this._updateCameraProperty(this._wheelDeltaZ, this._wheelZAction, this._wheelZActionCoordinate);
      }
      _updateCameraProperty(value, cameraProperty, coordinate) {
        if (value === 0) {
          return;
        }
        if (cameraProperty === null || coordinate === null) {
          return;
        }
        let action = null;
        switch (cameraProperty) {
          case _CameraProperty.MoveRelative:
            action = this._moveRelative;
            break;
          case _CameraProperty.RotateRelative:
            action = this._rotateRelative;
            break;
          case _CameraProperty.MoveScene:
            action = this._moveScene;
            break;
        }
        switch (coordinate) {
          case Coordinate.X:
            action.set(value, 0, 0);
            break;
          case Coordinate.Y:
            action.set(0, value, 0);
            break;
          case Coordinate.Z:
            action.set(0, 0, value);
            break;
        }
      }
    };
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelXMoveRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelYMoveRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelZMoveRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelXRotateRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelYRotateRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelZRotateRelative", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelXMoveScene", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelYMoveScene", null);
    __decorate([
      serialize()
    ], FreeCameraMouseWheelInput.prototype, "wheelZMoveScene", null);
    CameraInputTypes["FreeCameraMouseWheelInput"] = FreeCameraMouseWheelInput;
  }
});

// node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js
var FreeCameraTouchInput;
var init_freeCameraTouchInput = __esm({
  "node_modules/@babylonjs/core/Cameras/Inputs/freeCameraTouchInput.js"() {
    init_tslib_es6();
    init_decorators();
    init_cameraInputsManager();
    init_pointerEvents();
    init_math_vector();
    init_tools();
    FreeCameraTouchInput = class {
      constructor(allowMouse = false) {
        this.allowMouse = allowMouse;
        this.touchAngularSensibility = 2e5;
        this.touchMoveSensibility = 250;
        this.singleFingerRotate = false;
        this._offsetX = null;
        this._offsetY = null;
        this._pointerPressed = new Array();
        this._isSafari = Tools.IsSafari();
      }
      attachControl(noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        let previousPosition = null;
        if (this._pointerInput === void 0) {
          this._onLostFocus = () => {
            this._offsetX = null;
            this._offsetY = null;
          };
          this._pointerInput = (p) => {
            const evt = p.event;
            const isMouseEvent = evt.pointerType === "mouse" || this._isSafari && typeof evt.pointerType === "undefined";
            if (!this.allowMouse && isMouseEvent) {
              return;
            }
            if (p.type === PointerEventTypes.POINTERDOWN) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              this._pointerPressed.push(evt.pointerId);
              if (this._pointerPressed.length !== 1) {
                return;
              }
              previousPosition = {
                x: evt.clientX,
                y: evt.clientY
              };
            } else if (p.type === PointerEventTypes.POINTERUP) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              const index = this._pointerPressed.indexOf(evt.pointerId);
              if (index === -1) {
                return;
              }
              this._pointerPressed.splice(index, 1);
              if (index != 0) {
                return;
              }
              previousPosition = null;
              this._offsetX = null;
              this._offsetY = null;
            } else if (p.type === PointerEventTypes.POINTERMOVE) {
              if (!noPreventDefault) {
                evt.preventDefault();
              }
              if (!previousPosition) {
                return;
              }
              const index = this._pointerPressed.indexOf(evt.pointerId);
              if (index != 0) {
                return;
              }
              this._offsetX = evt.clientX - previousPosition.x;
              this._offsetY = -(evt.clientY - previousPosition.y);
            }
          };
        }
        this._observer = this.camera.getScene()._inputManager._addCameraPointerObserver(this._pointerInput, PointerEventTypes.POINTERDOWN | PointerEventTypes.POINTERUP | PointerEventTypes.POINTERMOVE);
        if (this._onLostFocus) {
          const engine = this.camera.getEngine();
          const element = engine.getInputElement();
          element && element.addEventListener("blur", this._onLostFocus);
        }
      }
      detachControl() {
        if (this._pointerInput) {
          if (this._observer) {
            this.camera.getScene()._inputManager._removeCameraPointerObserver(this._observer);
            this._observer = null;
          }
          if (this._onLostFocus) {
            const engine = this.camera.getEngine();
            const element = engine.getInputElement();
            element && element.removeEventListener("blur", this._onLostFocus);
            this._onLostFocus = null;
          }
          this._pointerPressed.length = 0;
          this._offsetX = null;
          this._offsetY = null;
        }
      }
      checkInputs() {
        if (this._offsetX === null || this._offsetY === null) {
          return;
        }
        if (this._offsetX === 0 && this._offsetY === 0) {
          return;
        }
        const camera = this.camera;
        const handednessMultiplier = camera._calculateHandednessMultiplier();
        camera.cameraRotation.y = handednessMultiplier * this._offsetX / this.touchAngularSensibility;
        const rotateCamera = this.singleFingerRotate && this._pointerPressed.length === 1 || !this.singleFingerRotate && this._pointerPressed.length > 1;
        if (rotateCamera) {
          camera.cameraRotation.x = -this._offsetY / this.touchAngularSensibility;
        } else {
          const speed = camera._computeLocalCameraSpeed();
          const direction = new Vector3(0, 0, this.touchMoveSensibility !== 0 ? speed * this._offsetY / this.touchMoveSensibility : 0);
          Matrix.RotationYawPitchRollToRef(camera.rotation.y, camera.rotation.x, 0, camera._cameraRotationMatrix);
          camera.cameraDirection.addInPlace(Vector3.TransformCoordinates(direction, camera._cameraRotationMatrix));
        }
      }
      getClassName() {
        return "FreeCameraTouchInput";
      }
      getSimpleName() {
        return "touch";
      }
    };
    __decorate([
      serialize()
    ], FreeCameraTouchInput.prototype, "touchAngularSensibility", void 0);
    __decorate([
      serialize()
    ], FreeCameraTouchInput.prototype, "touchMoveSensibility", void 0);
    CameraInputTypes["FreeCameraTouchInput"] = FreeCameraTouchInput;
  }
});

// node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js
var FreeCameraInputsManager;
var init_freeCameraInputsManager = __esm({
  "node_modules/@babylonjs/core/Cameras/freeCameraInputsManager.js"() {
    init_cameraInputsManager();
    init_freeCameraKeyboardMoveInput();
    init_freeCameraMouseInput();
    init_freeCameraMouseWheelInput();
    init_freeCameraTouchInput();
    FreeCameraInputsManager = class extends CameraInputsManager {
      constructor(camera) {
        super(camera);
        this._mouseInput = null;
        this._mouseWheelInput = null;
      }
      addKeyboard() {
        this.add(new FreeCameraKeyboardMoveInput());
        return this;
      }
      addMouse(touchEnabled = true) {
        if (!this._mouseInput) {
          this._mouseInput = new FreeCameraMouseInput(touchEnabled);
          this.add(this._mouseInput);
        }
        return this;
      }
      removeMouse() {
        if (this._mouseInput) {
          this.remove(this._mouseInput);
        }
        return this;
      }
      addMouseWheel() {
        if (!this._mouseWheelInput) {
          this._mouseWheelInput = new FreeCameraMouseWheelInput();
          this.add(this._mouseWheelInput);
        }
        return this;
      }
      removeMouseWheel() {
        if (this._mouseWheelInput) {
          this.remove(this._mouseWheelInput);
        }
        return this;
      }
      addTouch() {
        this.add(new FreeCameraTouchInput());
        return this;
      }
      clear() {
        super.clear();
        this._mouseInput = null;
      }
    };
  }
});

// node_modules/@babylonjs/core/Cameras/targetCamera.js
var TargetCamera;
var init_targetCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/targetCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_camera();
    init_math_vector();
    init_math_constants();
    init_math_axis();
    TargetCamera = class extends Camera {
      constructor(name109, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name109, position, scene, setActiveOnSceneIfNoneActive);
        this._tmpUpVector = Vector3.Zero();
        this._tmpTargetVector = Vector3.Zero();
        this.cameraDirection = new Vector3(0, 0, 0);
        this.cameraRotation = new Vector2(0, 0);
        this.ignoreParentScaling = false;
        this.updateUpVectorFromRotation = false;
        this._tmpQuaternion = new Quaternion();
        this.rotation = new Vector3(0, 0, 0);
        this.speed = 2;
        this.noRotationConstraint = false;
        this.invertRotation = false;
        this.inverseRotationSpeed = 0.2;
        this.lockedTarget = null;
        this._currentTarget = Vector3.Zero();
        this._initialFocalDistance = 1;
        this._viewMatrix = Matrix.Zero();
        this._camMatrix = Matrix.Zero();
        this._cameraTransformMatrix = Matrix.Zero();
        this._cameraRotationMatrix = Matrix.Zero();
        this._referencePoint = new Vector3(0, 0, 1);
        this._transformedReferencePoint = Vector3.Zero();
        this._deferredPositionUpdate = new Vector3();
        this._deferredRotationQuaternionUpdate = new Quaternion();
        this._deferredRotationUpdate = new Vector3();
        this._deferredUpdated = false;
        this._deferOnly = false;
        this._defaultUp = Vector3.Up();
        this._cachedRotationZ = 0;
        this._cachedQuaternionRotationZ = 0;
      }
      getFrontPosition(distance) {
        this.getWorldMatrix();
        const direction = this.getTarget().subtract(this.position);
        direction.normalize();
        direction.scaleInPlace(distance);
        return this.globalPosition.add(direction);
      }
      _getLockedTargetPosition() {
        if (!this.lockedTarget) {
          return null;
        }
        if (this.lockedTarget.absolutePosition) {
          const lockedTarget = this.lockedTarget;
          const m = lockedTarget.computeWorldMatrix();
          m.getTranslationToRef(lockedTarget.absolutePosition);
        }
        return this.lockedTarget.absolutePosition || this.lockedTarget;
      }
      storeState() {
        this._storedPosition = this.position.clone();
        this._storedRotation = this.rotation.clone();
        if (this.rotationQuaternion) {
          this._storedRotationQuaternion = this.rotationQuaternion.clone();
        }
        return super.storeState();
      }
      _restoreStateValues() {
        if (!super._restoreStateValues()) {
          return false;
        }
        this.position = this._storedPosition.clone();
        this.rotation = this._storedRotation.clone();
        if (this.rotationQuaternion) {
          this.rotationQuaternion = this._storedRotationQuaternion.clone();
        }
        this.cameraDirection.copyFromFloats(0, 0, 0);
        this.cameraRotation.copyFromFloats(0, 0);
        return true;
      }
      _initCache() {
        super._initCache();
        this._cache.lockedTarget = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotation = new Vector3(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
        this._cache.rotationQuaternion = new Quaternion(Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE, Number.MAX_VALUE);
      }
      _updateCache(ignoreParentClass) {
        if (!ignoreParentClass) {
          super._updateCache();
        }
        const lockedTargetPosition = this._getLockedTargetPosition();
        if (!lockedTargetPosition) {
          this._cache.lockedTarget = null;
        } else {
          if (!this._cache.lockedTarget) {
            this._cache.lockedTarget = lockedTargetPosition.clone();
          } else {
            this._cache.lockedTarget.copyFrom(lockedTargetPosition);
          }
        }
        this._cache.rotation.copyFrom(this.rotation);
        if (this.rotationQuaternion) {
          this._cache.rotationQuaternion.copyFrom(this.rotationQuaternion);
        }
      }
      _isSynchronizedViewMatrix() {
        if (!super._isSynchronizedViewMatrix()) {
          return false;
        }
        const lockedTargetPosition = this._getLockedTargetPosition();
        return (this._cache.lockedTarget ? this._cache.lockedTarget.equals(lockedTargetPosition) : !lockedTargetPosition) && (this.rotationQuaternion ? this.rotationQuaternion.equals(this._cache.rotationQuaternion) : this._cache.rotation.equals(this.rotation));
      }
      _computeLocalCameraSpeed() {
        const engine = this.getEngine();
        return this.speed * Math.sqrt(engine.getDeltaTime() / (engine.getFps() * 100));
      }
      setTarget(target) {
        this.upVector.normalize();
        this._initialFocalDistance = target.subtract(this.position).length();
        if (this.position.z === target.z) {
          this.position.z += Epsilon;
        }
        this._referencePoint.normalize().scaleInPlace(this._initialFocalDistance);
        Matrix.LookAtLHToRef(this.position, target, this._defaultUp, this._camMatrix);
        this._camMatrix.invert();
        this.rotation.x = Math.atan(this._camMatrix.m[6] / this._camMatrix.m[10]);
        const vDir = target.subtract(this.position);
        if (vDir.x >= 0) {
          this.rotation.y = -Math.atan(vDir.z / vDir.x) + Math.PI / 2;
        } else {
          this.rotation.y = -Math.atan(vDir.z / vDir.x) - Math.PI / 2;
        }
        this.rotation.z = 0;
        if (isNaN(this.rotation.x)) {
          this.rotation.x = 0;
        }
        if (isNaN(this.rotation.y)) {
          this.rotation.y = 0;
        }
        if (isNaN(this.rotation.z)) {
          this.rotation.z = 0;
        }
        if (this.rotationQuaternion) {
          Quaternion.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this.rotationQuaternion);
        }
      }
      get target() {
        return this.getTarget();
      }
      set target(value) {
        this.setTarget(value);
      }
      getTarget() {
        return this._currentTarget;
      }
      _decideIfNeedsToMove() {
        return Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      }
      _updatePosition() {
        if (this.parent) {
          this.parent.getWorldMatrix().invertToRef(TmpVectors.Matrix[0]);
          Vector3.TransformNormalToRef(this.cameraDirection, TmpVectors.Matrix[0], TmpVectors.Vector3[0]);
          this._deferredPositionUpdate.addInPlace(TmpVectors.Vector3[0]);
          if (!this._deferOnly) {
            this.position.copyFrom(this._deferredPositionUpdate);
          } else {
            this._deferredUpdated = true;
          }
          return;
        }
        this._deferredPositionUpdate.addInPlace(this.cameraDirection);
        if (!this._deferOnly) {
          this.position.copyFrom(this._deferredPositionUpdate);
        } else {
          this._deferredUpdated = true;
        }
      }
      _checkInputs() {
        const directionMultiplier = this.invertRotation ? -this.inverseRotationSpeed : 1;
        const needToMove = this._decideIfNeedsToMove();
        const needToRotate = this.cameraRotation.x || this.cameraRotation.y;
        this._deferredUpdated = false;
        this._deferredRotationUpdate.copyFrom(this.rotation);
        this._deferredPositionUpdate.copyFrom(this.position);
        if (this.rotationQuaternion) {
          this._deferredRotationQuaternionUpdate.copyFrom(this.rotationQuaternion);
        }
        if (needToMove) {
          this._updatePosition();
        }
        if (needToRotate) {
          if (this.rotationQuaternion) {
            this.rotationQuaternion.toEulerAnglesToRef(this._deferredRotationUpdate);
          }
          this._deferredRotationUpdate.x += this.cameraRotation.x * directionMultiplier;
          this._deferredRotationUpdate.y += this.cameraRotation.y * directionMultiplier;
          if (!this.noRotationConstraint) {
            const limit = 1.570796;
            if (this._deferredRotationUpdate.x > limit) {
              this._deferredRotationUpdate.x = limit;
            }
            if (this._deferredRotationUpdate.x < -limit) {
              this._deferredRotationUpdate.x = -limit;
            }
          }
          if (!this._deferOnly) {
            this.rotation.copyFrom(this._deferredRotationUpdate);
          } else {
            this._deferredUpdated = true;
          }
          if (this.rotationQuaternion) {
            const len = this._deferredRotationUpdate.lengthSquared();
            if (len) {
              Quaternion.RotationYawPitchRollToRef(this._deferredRotationUpdate.y, this._deferredRotationUpdate.x, this._deferredRotationUpdate.z, this._deferredRotationQuaternionUpdate);
              if (!this._deferOnly) {
                this.rotationQuaternion.copyFrom(this._deferredRotationQuaternionUpdate);
              } else {
                this._deferredUpdated = true;
              }
            }
          }
        }
        if (needToMove) {
          if (Math.abs(this.cameraDirection.x) < this.speed * Epsilon) {
            this.cameraDirection.x = 0;
          }
          if (Math.abs(this.cameraDirection.y) < this.speed * Epsilon) {
            this.cameraDirection.y = 0;
          }
          if (Math.abs(this.cameraDirection.z) < this.speed * Epsilon) {
            this.cameraDirection.z = 0;
          }
          this.cameraDirection.scaleInPlace(this.inertia);
        }
        if (needToRotate) {
          if (Math.abs(this.cameraRotation.x) < this.speed * Epsilon) {
            this.cameraRotation.x = 0;
          }
          if (Math.abs(this.cameraRotation.y) < this.speed * Epsilon) {
            this.cameraRotation.y = 0;
          }
          this.cameraRotation.scaleInPlace(this.inertia);
        }
        super._checkInputs();
      }
      _updateCameraRotationMatrix() {
        if (this.rotationQuaternion) {
          this.rotationQuaternion.toRotationMatrix(this._cameraRotationMatrix);
        } else {
          Matrix.RotationYawPitchRollToRef(this.rotation.y, this.rotation.x, this.rotation.z, this._cameraRotationMatrix);
        }
      }
      _rotateUpVectorWithCameraRotationMatrix() {
        Vector3.TransformNormalToRef(this._defaultUp, this._cameraRotationMatrix, this.upVector);
        return this;
      }
      _getViewMatrix() {
        if (this.lockedTarget) {
          this.setTarget(this._getLockedTargetPosition());
        }
        this._updateCameraRotationMatrix();
        if (this.rotationQuaternion && this._cachedQuaternionRotationZ != this.rotationQuaternion.z) {
          this._rotateUpVectorWithCameraRotationMatrix();
          this._cachedQuaternionRotationZ = this.rotationQuaternion.z;
        } else if (this._cachedRotationZ !== this.rotation.z) {
          this._rotateUpVectorWithCameraRotationMatrix();
          this._cachedRotationZ = this.rotation.z;
        }
        Vector3.TransformCoordinatesToRef(this._referencePoint, this._cameraRotationMatrix, this._transformedReferencePoint);
        this.position.addToRef(this._transformedReferencePoint, this._currentTarget);
        if (this.updateUpVectorFromRotation) {
          if (this.rotationQuaternion) {
            Axis.Y.rotateByQuaternionToRef(this.rotationQuaternion, this.upVector);
          } else {
            Quaternion.FromEulerVectorToRef(this.rotation, this._tmpQuaternion);
            Axis.Y.rotateByQuaternionToRef(this._tmpQuaternion, this.upVector);
          }
        }
        this._computeViewMatrix(this.position, this._currentTarget, this.upVector);
        return this._viewMatrix;
      }
      _computeViewMatrix(position, target, up) {
        if (this.ignoreParentScaling) {
          if (this.parent) {
            const parentWorldMatrix = this.parent.getWorldMatrix();
            Vector3.TransformCoordinatesToRef(position, parentWorldMatrix, this._globalPosition);
            Vector3.TransformCoordinatesToRef(target, parentWorldMatrix, this._tmpTargetVector);
            Vector3.TransformNormalToRef(up, parentWorldMatrix, this._tmpUpVector);
            this._markSyncedWithParent();
          } else {
            this._globalPosition.copyFrom(position);
            this._tmpTargetVector.copyFrom(target);
            this._tmpUpVector.copyFrom(up);
          }
          if (this.getScene().useRightHandedSystem) {
            Matrix.LookAtRHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
          } else {
            Matrix.LookAtLHToRef(this._globalPosition, this._tmpTargetVector, this._tmpUpVector, this._viewMatrix);
          }
          return;
        }
        if (this.getScene().useRightHandedSystem) {
          Matrix.LookAtRHToRef(position, target, up, this._viewMatrix);
        } else {
          Matrix.LookAtLHToRef(position, target, up, this._viewMatrix);
        }
        if (this.parent) {
          const parentWorldMatrix = this.parent.getWorldMatrix();
          this._viewMatrix.invert();
          this._viewMatrix.multiplyToRef(parentWorldMatrix, this._viewMatrix);
          this._viewMatrix.getTranslationToRef(this._globalPosition);
          this._viewMatrix.invert();
          this._markSyncedWithParent();
        } else {
          this._globalPosition.copyFrom(position);
        }
      }
      createRigCamera(name109, cameraIndex) {
        if (this.cameraRigMode !== Camera.RIG_MODE_NONE) {
          const rigCamera = new TargetCamera(name109, this.position.clone(), this.getScene());
          rigCamera.isRigCamera = true;
          rigCamera.rigParent = this;
          if (this.cameraRigMode === Camera.RIG_MODE_VR || this.cameraRigMode === Camera.RIG_MODE_WEBVR) {
            if (!this.rotationQuaternion) {
              this.rotationQuaternion = new Quaternion();
            }
            rigCamera._cameraRigParams = {};
            rigCamera.rotationQuaternion = new Quaternion();
          }
          rigCamera.mode = this.mode;
          rigCamera.orthoLeft = this.orthoLeft;
          rigCamera.orthoRight = this.orthoRight;
          rigCamera.orthoTop = this.orthoTop;
          rigCamera.orthoBottom = this.orthoBottom;
          return rigCamera;
        }
        return null;
      }
      _updateRigCameras() {
        const camLeft = this._rigCameras[0];
        const camRight = this._rigCameras[1];
        this.computeWorldMatrix();
        switch (this.cameraRigMode) {
          case Camera.RIG_MODE_STEREOSCOPIC_ANAGLYPH:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL:
          case Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED:
          case Camera.RIG_MODE_STEREOSCOPIC_OVERUNDER:
          case Camera.RIG_MODE_STEREOSCOPIC_INTERLACED: {
            const leftSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? 1 : -1;
            const rightSign = this.cameraRigMode === Camera.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED ? -1 : 1;
            this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * leftSign, camLeft);
            this._getRigCamPositionAndTarget(this._cameraRigParams.stereoHalfAngle * rightSign, camRight);
            break;
          }
          case Camera.RIG_MODE_VR:
            if (camLeft.rotationQuaternion) {
              camLeft.rotationQuaternion.copyFrom(this.rotationQuaternion);
              camRight.rotationQuaternion.copyFrom(this.rotationQuaternion);
            } else {
              camLeft.rotation.copyFrom(this.rotation);
              camRight.rotation.copyFrom(this.rotation);
            }
            camLeft.position.copyFrom(this.position);
            camRight.position.copyFrom(this.position);
            break;
        }
        super._updateRigCameras();
      }
      _getRigCamPositionAndTarget(halfSpace, rigCamera) {
        const target = this.getTarget();
        target.subtractToRef(this.position, TargetCamera._TargetFocalPoint);
        TargetCamera._TargetFocalPoint.normalize().scaleInPlace(this._initialFocalDistance);
        const newFocalTarget = TargetCamera._TargetFocalPoint.addInPlace(this.position);
        Matrix.TranslationToRef(-newFocalTarget.x, -newFocalTarget.y, -newFocalTarget.z, TargetCamera._TargetTransformMatrix);
        TargetCamera._TargetTransformMatrix.multiplyToRef(Matrix.RotationAxis(rigCamera.upVector, halfSpace), TargetCamera._RigCamTransformMatrix);
        Matrix.TranslationToRef(newFocalTarget.x, newFocalTarget.y, newFocalTarget.z, TargetCamera._TargetTransformMatrix);
        TargetCamera._RigCamTransformMatrix.multiplyToRef(TargetCamera._TargetTransformMatrix, TargetCamera._RigCamTransformMatrix);
        Vector3.TransformCoordinatesToRef(this.position, TargetCamera._RigCamTransformMatrix, rigCamera.position);
        rigCamera.setTarget(newFocalTarget);
      }
      getClassName() {
        return "TargetCamera";
      }
    };
    TargetCamera._RigCamTransformMatrix = new Matrix();
    TargetCamera._TargetTransformMatrix = new Matrix();
    TargetCamera._TargetFocalPoint = new Vector3();
    __decorate([
      serializeAsVector3()
    ], TargetCamera.prototype, "rotation", void 0);
    __decorate([
      serialize()
    ], TargetCamera.prototype, "speed", void 0);
    __decorate([
      serializeAsMeshReference("lockedTargetId")
    ], TargetCamera.prototype, "lockedTarget", void 0);
  }
});

// node_modules/@babylonjs/core/Cameras/freeCamera.js
var FreeCamera;
var init_freeCamera = __esm({
  "node_modules/@babylonjs/core/Cameras/freeCamera.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_engine();
    init_targetCamera();
    init_freeCameraInputsManager();
    init_tools();
    FreeCamera = class extends TargetCamera {
      get angularSensibility() {
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          return mouse.angularSensibility;
        }
        return 0;
      }
      set angularSensibility(value) {
        const mouse = this.inputs.attached["mouse"];
        if (mouse) {
          mouse.angularSensibility = value;
        }
      }
      get keysUp() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysUp;
        }
        return [];
      }
      set keysUp(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysUp = value;
        }
      }
      get keysUpward() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysUpward;
        }
        return [];
      }
      set keysUpward(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysUpward = value;
        }
      }
      get keysDown() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysDown;
        }
        return [];
      }
      set keysDown(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysDown = value;
        }
      }
      get keysDownward() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysDownward;
        }
        return [];
      }
      set keysDownward(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysDownward = value;
        }
      }
      get keysLeft() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysLeft;
        }
        return [];
      }
      set keysLeft(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysLeft = value;
        }
      }
      get keysRight() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRight;
        }
        return [];
      }
      set keysRight(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRight = value;
        }
      }
      get keysRotateLeft() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateLeft;
        }
        return [];
      }
      set keysRotateLeft(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateLeft = value;
        }
      }
      get keysRotateRight() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateRight;
        }
        return [];
      }
      set keysRotateRight(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateRight = value;
        }
      }
      get keysRotateUp() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateUp;
        }
        return [];
      }
      set keysRotateUp(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateUp = value;
        }
      }
      get keysRotateDown() {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          return keyboard.keysRotateDown;
        }
        return [];
      }
      set keysRotateDown(value) {
        const keyboard = this.inputs.attached["keyboard"];
        if (keyboard) {
          keyboard.keysRotateDown = value;
        }
      }
      constructor(name109, position, scene, setActiveOnSceneIfNoneActive = true) {
        super(name109, position, scene, setActiveOnSceneIfNoneActive);
        this.ellipsoid = new Vector3(0.5, 1, 0.5);
        this.ellipsoidOffset = new Vector3(0, 0, 0);
        this.checkCollisions = false;
        this.applyGravity = false;
        this._needMoveForGravity = false;
        this._oldPosition = Vector3.Zero();
        this._diffPosition = Vector3.Zero();
        this._newPosition = Vector3.Zero();
        this._collisionMask = -1;
        this._onCollisionPositionChange = (collisionId, newPosition, collidedMesh = null) => {
          this._newPosition.copyFrom(newPosition);
          this._newPosition.subtractToRef(this._oldPosition, this._diffPosition);
          if (this._diffPosition.length() > Engine.CollisionsEpsilon) {
            this.position.addToRef(this._diffPosition, this._deferredPositionUpdate);
            if (!this._deferOnly) {
              this.position.copyFrom(this._deferredPositionUpdate);
            } else {
              this._deferredUpdated = true;
            }
            if (this.onCollide && collidedMesh) {
              this.onCollide(collidedMesh);
            }
          }
        };
        this.inputs = new FreeCameraInputsManager(this);
        this.inputs.addKeyboard().addMouse();
      }
      attachControl(ignored, noPreventDefault) {
        noPreventDefault = Tools.BackCompatCameraNoPreventDefault(arguments);
        this.inputs.attachElement(noPreventDefault);
      }
      detachControl() {
        this.inputs.detachElement();
        this.cameraDirection = new Vector3(0, 0, 0);
        this.cameraRotation = new Vector2(0, 0);
      }
      get collisionMask() {
        return this._collisionMask;
      }
      set collisionMask(mask) {
        this._collisionMask = !isNaN(mask) ? mask : -1;
      }
      _collideWithWorld(displacement) {
        let globalPosition;
        if (this.parent) {
          globalPosition = Vector3.TransformCoordinates(this.position, this.parent.getWorldMatrix());
        } else {
          globalPosition = this.position;
        }
        globalPosition.subtractFromFloatsToRef(0, this.ellipsoid.y, 0, this._oldPosition);
        this._oldPosition.addInPlace(this.ellipsoidOffset);
        const coordinator = this.getScene().collisionCoordinator;
        if (!this._collider) {
          this._collider = coordinator.createCollider();
        }
        this._collider._radius = this.ellipsoid;
        this._collider.collisionMask = this._collisionMask;
        let actualDisplacement = displacement;
        if (this.applyGravity) {
          actualDisplacement = displacement.add(this.getScene().gravity);
        }
        coordinator.getNewPosition(this._oldPosition, actualDisplacement, this._collider, 3, null, this._onCollisionPositionChange, this.uniqueId);
      }
      _checkInputs() {
        if (!this._localDirection) {
          this._localDirection = Vector3.Zero();
          this._transformedDirection = Vector3.Zero();
        }
        this.inputs.checkInputs();
        super._checkInputs();
      }
      set needMoveForGravity(value) {
        this._needMoveForGravity = value;
      }
      get needMoveForGravity() {
        return this._needMoveForGravity;
      }
      _decideIfNeedsToMove() {
        return this._needMoveForGravity || Math.abs(this.cameraDirection.x) > 0 || Math.abs(this.cameraDirection.y) > 0 || Math.abs(this.cameraDirection.z) > 0;
      }
      _updatePosition() {
        if (this.checkCollisions && this.getScene().collisionsEnabled) {
          this._collideWithWorld(this.cameraDirection);
        } else {
          super._updatePosition();
        }
      }
      dispose() {
        this.inputs.clear();
        super.dispose();
      }
      getClassName() {
        return "FreeCamera";
      }
    };
    __decorate([
      serializeAsVector3()
    ], FreeCamera.prototype, "ellipsoid", void 0);
    __decorate([
      serializeAsVector3()
    ], FreeCamera.prototype, "ellipsoidOffset", void 0);
    __decorate([
      serialize()
    ], FreeCamera.prototype, "checkCollisions", void 0);
    __decorate([
      serialize()
    ], FreeCamera.prototype, "applyGravity", void 0);
  }
});

// node_modules/@babylonjs/core/Shaders/passCube.fragment.js
var name3, shader3;
var init_passCube_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/passCube.fragment.js"() {
    init_shaderStore();
    name3 = "passCubePixelShader";
    shader3 = `varying vec2 vUV;uniform samplerCube textureSampler;
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{vec2 uv=vUV*2.0-1.0;
#ifdef POSITIVEX
gl_FragColor=textureCube(textureSampler,vec3(1.001,uv.y,uv.x));
#endif
#ifdef NEGATIVEX
gl_FragColor=textureCube(textureSampler,vec3(-1.001,uv.y,uv.x));
#endif
#ifdef POSITIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,1.001,uv.x));
#endif
#ifdef NEGATIVEY
gl_FragColor=textureCube(textureSampler,vec3(uv.y,-1.001,uv.x));
#endif
#ifdef POSITIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,1.001));
#endif
#ifdef NEGATIVEZ
gl_FragColor=textureCube(textureSampler,vec3(uv,-1.001));
#endif
}`;
    ShaderStore.ShadersStore[name3] = shader3;
  }
});

// node_modules/@babylonjs/core/PostProcesses/passPostProcess.js
var PassPostProcess, PassCubePostProcess;
var init_passPostProcess = __esm({
  "node_modules/@babylonjs/core/PostProcesses/passPostProcess.js"() {
    init_postProcess();
    init_engine();
    init_pass_fragment();
    init_passCube_fragment();
    init_typeStore();
    init_decorators();
    PassPostProcess = class extends PostProcess {
      getClassName() {
        return "PassPostProcess";
      }
      constructor(name109, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        super(name109, "pass", null, null, options, camera, samplingMode, engine, reusable, void 0, textureType, void 0, null, blockCompilation);
      }
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new PassPostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    RegisterClass("BABYLON.PassPostProcess", PassPostProcess);
    PassCubePostProcess = class extends PostProcess {
      get face() {
        return this._face;
      }
      set face(value) {
        if (value < 0 || value > 5) {
          return;
        }
        this._face = value;
        switch (this._face) {
          case 0:
            this.updateEffect("#define POSITIVEX");
            break;
          case 1:
            this.updateEffect("#define NEGATIVEX");
            break;
          case 2:
            this.updateEffect("#define POSITIVEY");
            break;
          case 3:
            this.updateEffect("#define NEGATIVEY");
            break;
          case 4:
            this.updateEffect("#define POSITIVEZ");
            break;
          case 5:
            this.updateEffect("#define NEGATIVEZ");
            break;
        }
      }
      getClassName() {
        return "PassCubePostProcess";
      }
      constructor(name109, options, camera = null, samplingMode, engine, reusable, textureType = 0, blockCompilation = false) {
        super(name109, "passCube", null, null, options, camera, samplingMode, engine, reusable, "#define POSITIVEX", textureType, void 0, null, blockCompilation);
        this._face = 0;
      }
      static _Parse(parsedPostProcess, targetCamera, scene, rootUrl) {
        return SerializationHelper.Parse(() => {
          return new PassCubePostProcess(parsedPostProcess.name, parsedPostProcess.options, targetCamera, parsedPostProcess.renderTargetSamplingMode, parsedPostProcess._engine, parsedPostProcess.reusable);
        }, parsedPostProcess, scene, rootUrl);
      }
    };
    Engine._RescalePostProcessFactory = (engine) => {
      return new PassPostProcess("rescale", 1, null, 2, engine, false, 0);
    };
  }
});

// node_modules/@babylonjs/core/Lights/hemisphericLight.js
var HemisphericLight;
var init_hemisphericLight = __esm({
  "node_modules/@babylonjs/core/Lights/hemisphericLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_math_color();
    init_node();
    init_light();
    Node.AddNodeConstructor("Light_Type_3", (name109, scene) => {
      return () => new HemisphericLight(name109, Vector3.Zero(), scene);
    });
    HemisphericLight = class extends Light {
      constructor(name109, direction, scene) {
        super(name109, scene);
        this.groundColor = new Color3(0, 0, 0);
        this.direction = direction || Vector3.Up();
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightGround", 3);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      getClassName() {
        return "HemisphericLight";
      }
      setDirectionToTarget(target) {
        this.direction = Vector3.Normalize(target.subtract(Vector3.Zero()));
        return this.direction;
      }
      getShadowGenerator() {
        return null;
      }
      transferToEffect(_effect, lightIndex) {
        const normalizeDirection = Vector3.Normalize(this.direction);
        this._uniformBuffer.updateFloat4("vLightData", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, 0, lightIndex);
        this._uniformBuffer.updateColor3("vLightGround", this.groundColor.scale(this.intensity), lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        const normalizeDirection = Vector3.Normalize(this.direction);
        effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
        return this;
      }
      computeWorldMatrix() {
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        return this._worldMatrix;
      }
      getTypeID() {
        return Light.LIGHTTYPEID_HEMISPHERICLIGHT;
      }
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["HEMILIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serializeAsColor3()
    ], HemisphericLight.prototype, "groundColor", void 0);
    __decorate([
      serializeAsVector3()
    ], HemisphericLight.prototype, "direction", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/materialFlags.js
var MaterialFlags;
var init_materialFlags = __esm({
  "node_modules/@babylonjs/core/Materials/materialFlags.js"() {
    init_engine();
    MaterialFlags = class {
      static get DiffuseTextureEnabled() {
        return this._DiffuseTextureEnabled;
      }
      static set DiffuseTextureEnabled(value) {
        if (this._DiffuseTextureEnabled === value) {
          return;
        }
        this._DiffuseTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get DetailTextureEnabled() {
        return this._DetailTextureEnabled;
      }
      static set DetailTextureEnabled(value) {
        if (this._DetailTextureEnabled === value) {
          return;
        }
        this._DetailTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get DecalMapEnabled() {
        return this._DecalMapEnabled;
      }
      static set DecalMapEnabled(value) {
        if (this._DecalMapEnabled === value) {
          return;
        }
        this._DecalMapEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get AmbientTextureEnabled() {
        return this._AmbientTextureEnabled;
      }
      static set AmbientTextureEnabled(value) {
        if (this._AmbientTextureEnabled === value) {
          return;
        }
        this._AmbientTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get OpacityTextureEnabled() {
        return this._OpacityTextureEnabled;
      }
      static set OpacityTextureEnabled(value) {
        if (this._OpacityTextureEnabled === value) {
          return;
        }
        this._OpacityTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get ReflectionTextureEnabled() {
        return this._ReflectionTextureEnabled;
      }
      static set ReflectionTextureEnabled(value) {
        if (this._ReflectionTextureEnabled === value) {
          return;
        }
        this._ReflectionTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get EmissiveTextureEnabled() {
        return this._EmissiveTextureEnabled;
      }
      static set EmissiveTextureEnabled(value) {
        if (this._EmissiveTextureEnabled === value) {
          return;
        }
        this._EmissiveTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get SpecularTextureEnabled() {
        return this._SpecularTextureEnabled;
      }
      static set SpecularTextureEnabled(value) {
        if (this._SpecularTextureEnabled === value) {
          return;
        }
        this._SpecularTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get BumpTextureEnabled() {
        return this._BumpTextureEnabled;
      }
      static set BumpTextureEnabled(value) {
        if (this._BumpTextureEnabled === value) {
          return;
        }
        this._BumpTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get LightmapTextureEnabled() {
        return this._LightmapTextureEnabled;
      }
      static set LightmapTextureEnabled(value) {
        if (this._LightmapTextureEnabled === value) {
          return;
        }
        this._LightmapTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get RefractionTextureEnabled() {
        return this._RefractionTextureEnabled;
      }
      static set RefractionTextureEnabled(value) {
        if (this._RefractionTextureEnabled === value) {
          return;
        }
        this._RefractionTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get ColorGradingTextureEnabled() {
        return this._ColorGradingTextureEnabled;
      }
      static set ColorGradingTextureEnabled(value) {
        if (this._ColorGradingTextureEnabled === value) {
          return;
        }
        this._ColorGradingTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get FresnelEnabled() {
        return this._FresnelEnabled;
      }
      static set FresnelEnabled(value) {
        if (this._FresnelEnabled === value) {
          return;
        }
        this._FresnelEnabled = value;
        Engine.MarkAllMaterialsAsDirty(4);
      }
      static get ClearCoatTextureEnabled() {
        return this._ClearCoatTextureEnabled;
      }
      static set ClearCoatTextureEnabled(value) {
        if (this._ClearCoatTextureEnabled === value) {
          return;
        }
        this._ClearCoatTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get ClearCoatBumpTextureEnabled() {
        return this._ClearCoatBumpTextureEnabled;
      }
      static set ClearCoatBumpTextureEnabled(value) {
        if (this._ClearCoatBumpTextureEnabled === value) {
          return;
        }
        this._ClearCoatBumpTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get ClearCoatTintTextureEnabled() {
        return this._ClearCoatTintTextureEnabled;
      }
      static set ClearCoatTintTextureEnabled(value) {
        if (this._ClearCoatTintTextureEnabled === value) {
          return;
        }
        this._ClearCoatTintTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get SheenTextureEnabled() {
        return this._SheenTextureEnabled;
      }
      static set SheenTextureEnabled(value) {
        if (this._SheenTextureEnabled === value) {
          return;
        }
        this._SheenTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get AnisotropicTextureEnabled() {
        return this._AnisotropicTextureEnabled;
      }
      static set AnisotropicTextureEnabled(value) {
        if (this._AnisotropicTextureEnabled === value) {
          return;
        }
        this._AnisotropicTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get ThicknessTextureEnabled() {
        return this._ThicknessTextureEnabled;
      }
      static set ThicknessTextureEnabled(value) {
        if (this._ThicknessTextureEnabled === value) {
          return;
        }
        this._ThicknessTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get RefractionIntensityTextureEnabled() {
        return this._ThicknessTextureEnabled;
      }
      static set RefractionIntensityTextureEnabled(value) {
        if (this._RefractionIntensityTextureEnabled === value) {
          return;
        }
        this._RefractionIntensityTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get TranslucencyIntensityTextureEnabled() {
        return this._ThicknessTextureEnabled;
      }
      static set TranslucencyIntensityTextureEnabled(value) {
        if (this._TranslucencyIntensityTextureEnabled === value) {
          return;
        }
        this._TranslucencyIntensityTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
      static get IridescenceTextureEnabled() {
        return this._IridescenceTextureEnabled;
      }
      static set IridescenceTextureEnabled(value) {
        if (this._IridescenceTextureEnabled === value) {
          return;
        }
        this._IridescenceTextureEnabled = value;
        Engine.MarkAllMaterialsAsDirty(1);
      }
    };
    MaterialFlags._DiffuseTextureEnabled = true;
    MaterialFlags._DetailTextureEnabled = true;
    MaterialFlags._DecalMapEnabled = true;
    MaterialFlags._AmbientTextureEnabled = true;
    MaterialFlags._OpacityTextureEnabled = true;
    MaterialFlags._ReflectionTextureEnabled = true;
    MaterialFlags._EmissiveTextureEnabled = true;
    MaterialFlags._SpecularTextureEnabled = true;
    MaterialFlags._BumpTextureEnabled = true;
    MaterialFlags._LightmapTextureEnabled = true;
    MaterialFlags._RefractionTextureEnabled = true;
    MaterialFlags._ColorGradingTextureEnabled = true;
    MaterialFlags._FresnelEnabled = true;
    MaterialFlags._ClearCoatTextureEnabled = true;
    MaterialFlags._ClearCoatBumpTextureEnabled = true;
    MaterialFlags._ClearCoatTintTextureEnabled = true;
    MaterialFlags._SheenTextureEnabled = true;
    MaterialFlags._AnisotropicTextureEnabled = true;
    MaterialFlags._ThicknessTextureEnabled = true;
    MaterialFlags._RefractionIntensityTextureEnabled = true;
    MaterialFlags._TranslucencyIntensityTextureEnabled = true;
    MaterialFlags._IridescenceTextureEnabled = true;
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginManager.js
function RegisterMaterialPlugin(pluginName, factory) {
  if (!inited) {
    observer = Material.OnEventObservable.add((material) => {
      for (const [, factory2] of plugins) {
        factory2(material);
      }
    }, MaterialPluginEvent.Created);
    inited = true;
  }
  const existing = plugins.filter(([name109, _factory]) => name109 === pluginName);
  if (existing.length > 0) {
    existing[0][1] = factory;
  } else {
    plugins.push([pluginName, factory]);
  }
}
function UnregisterMaterialPlugin(pluginName) {
  for (let i = 0; i < plugins.length; ++i) {
    if (plugins[i][0] === pluginName) {
      plugins.splice(i, 1);
      if (plugins.length === 0) {
        UnregisterAllMaterialPlugins();
      }
      return true;
    }
  }
  return false;
}
function UnregisterAllMaterialPlugins() {
  plugins.length = 0;
  inited = false;
  Material.OnEventObservable.remove(observer);
  observer = null;
}
var rxOption, MaterialPluginManager, plugins, inited, observer;
var init_materialPluginManager = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginManager.js"() {
    init_material();
    init_materialPluginEvent();
    init_engineStore();
    init_shaderProcessor();
    init_shaderLanguage();
    init_shaderStore();
    rxOption = new RegExp("^([gimus]+)!");
    MaterialPluginManager = class {
      constructor(material) {
        this._plugins = [];
        this._activePlugins = [];
        this._activePluginsForExtraEvents = [];
        this._material = material;
        this._scene = material.getScene();
        this._engine = this._scene.getEngine();
      }
      _addPlugin(plugin) {
        for (let i = 0; i < this._plugins.length; ++i) {
          if (this._plugins[i].name === plugin.name) {
            return false;
          }
        }
        if (this._material._uniformBufferLayoutBuilt) {
          throw `The plugin "${plugin.name}" can't be added to the material "${this._material.name}" because this material has already been used for rendering! Please add plugins to materials before any rendering with this material occurs.`;
        }
        const pluginClassName = plugin.getClassName();
        if (!MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]) {
          MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName] = "MATERIALPLUGIN_" + ++MaterialPluginManager._MaterialPluginCounter;
        }
        this._material._callbackPluginEventGeneric = this._handlePluginEvent.bind(this);
        this._plugins.push(plugin);
        this._plugins.sort((a, b) => a.priority - b.priority);
        this._codeInjectionPoints = {};
        const defineNamesFromPlugins = {};
        defineNamesFromPlugins[MaterialPluginManager._MaterialPluginClassToMainDefine[pluginClassName]] = {
          type: "boolean",
          default: true
        };
        for (const plugin2 of this._plugins) {
          plugin2.collectDefines(defineNamesFromPlugins);
          this._collectPointNames("vertex", plugin2.getCustomCode("vertex"));
          this._collectPointNames("fragment", plugin2.getCustomCode("fragment"));
        }
        this._defineNamesFromPlugins = defineNamesFromPlugins;
        return true;
      }
      _activatePlugin(plugin) {
        if (this._activePlugins.indexOf(plugin) === -1) {
          this._activePlugins.push(plugin);
          this._activePlugins.sort((a, b) => a.priority - b.priority);
          this._material._callbackPluginEventIsReadyForSubMesh = this._handlePluginEventIsReadyForSubMesh.bind(this);
          this._material._callbackPluginEventPrepareDefinesBeforeAttributes = this._handlePluginEventPrepareDefinesBeforeAttributes.bind(this);
          this._material._callbackPluginEventPrepareDefines = this._handlePluginEventPrepareDefines.bind(this);
          this._material._callbackPluginEventBindForSubMesh = this._handlePluginEventBindForSubMesh.bind(this);
          if (plugin.registerForExtraEvents) {
            this._activePluginsForExtraEvents.push(plugin);
            this._activePluginsForExtraEvents.sort((a, b) => a.priority - b.priority);
            this._material._callbackPluginEventHasRenderTargetTextures = this._handlePluginEventHasRenderTargetTextures.bind(this);
            this._material._callbackPluginEventFillRenderTargetTextures = this._handlePluginEventFillRenderTargetTextures.bind(this);
            this._material._callbackPluginEventHardBindForSubMesh = this._handlePluginEventHardBindForSubMesh.bind(this);
          }
        }
      }
      getPlugin(name109) {
        for (let i = 0; i < this._plugins.length; ++i) {
          if (this._plugins[i].name === name109) {
            return this._plugins[i];
          }
        }
        return null;
      }
      _handlePluginEventIsReadyForSubMesh(eventData) {
        let isReady = true;
        for (const plugin of this._activePlugins) {
          isReady = isReady && plugin.isReadyForSubMesh(eventData.defines, this._scene, this._engine, eventData.subMesh);
        }
        eventData.isReadyForSubMesh = isReady;
      }
      _handlePluginEventPrepareDefinesBeforeAttributes(eventData) {
        for (const plugin of this._activePlugins) {
          plugin.prepareDefinesBeforeAttributes(eventData.defines, this._scene, eventData.mesh);
        }
      }
      _handlePluginEventPrepareDefines(eventData) {
        for (const plugin of this._activePlugins) {
          plugin.prepareDefines(eventData.defines, this._scene, eventData.mesh);
        }
      }
      _handlePluginEventHardBindForSubMesh(eventData) {
        for (const plugin of this._activePluginsForExtraEvents) {
          plugin.hardBindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
        }
      }
      _handlePluginEventBindForSubMesh(eventData) {
        for (const plugin of this._activePlugins) {
          plugin.bindForSubMesh(this._material._uniformBuffer, this._scene, this._engine, eventData.subMesh);
        }
      }
      _handlePluginEventHasRenderTargetTextures(eventData) {
        let hasRenderTargetTextures = false;
        for (const plugin of this._activePluginsForExtraEvents) {
          hasRenderTargetTextures = plugin.hasRenderTargetTextures();
          if (hasRenderTargetTextures) {
            break;
          }
        }
        eventData.hasRenderTargetTextures = hasRenderTargetTextures;
      }
      _handlePluginEventFillRenderTargetTextures(eventData) {
        for (const plugin of this._activePluginsForExtraEvents) {
          plugin.fillRenderTargetTextures(eventData.renderTargets);
        }
      }
      _handlePluginEvent(id, info) {
        var _a;
        switch (id) {
          case MaterialPluginEvent.GetActiveTextures: {
            const eventData = info;
            for (const plugin of this._activePlugins) {
              plugin.getActiveTextures(eventData.activeTextures);
            }
            break;
          }
          case MaterialPluginEvent.GetAnimatables: {
            const eventData = info;
            for (const plugin of this._activePlugins) {
              plugin.getAnimatables(eventData.animatables);
            }
            break;
          }
          case MaterialPluginEvent.HasTexture: {
            const eventData = info;
            let hasTexture = false;
            for (const plugin of this._activePlugins) {
              hasTexture = plugin.hasTexture(eventData.texture);
              if (hasTexture) {
                break;
              }
            }
            eventData.hasTexture = hasTexture;
            break;
          }
          case MaterialPluginEvent.Disposed: {
            const eventData = info;
            for (const plugin of this._plugins) {
              plugin.dispose(eventData.forceDisposeTextures);
            }
            break;
          }
          case MaterialPluginEvent.GetDefineNames: {
            const eventData = info;
            eventData.defineNames = this._defineNamesFromPlugins;
            break;
          }
          case MaterialPluginEvent.PrepareEffect: {
            const eventData = info;
            for (const plugin of this._activePlugins) {
              eventData.fallbackRank = plugin.addFallbacks(eventData.defines, eventData.fallbacks, eventData.fallbackRank);
              plugin.getAttributes(eventData.attributes, this._scene, eventData.mesh);
            }
            if (this._uniformList.length > 0) {
              eventData.uniforms.push(...this._uniformList);
            }
            if (this._samplerList.length > 0) {
              eventData.samplers.push(...this._samplerList);
            }
            if (this._uboList.length > 0) {
              eventData.uniformBuffersNames.push(...this._uboList);
            }
            eventData.customCode = this._injectCustomCode(eventData, eventData.customCode);
            break;
          }
          case MaterialPluginEvent.PrepareUniformBuffer: {
            const eventData = info;
            this._uboDeclaration = "";
            this._vertexDeclaration = "";
            this._fragmentDeclaration = "";
            this._uniformList = [];
            this._samplerList = [];
            this._uboList = [];
            for (const plugin of this._plugins) {
              const uniforms = plugin.getUniforms();
              if (uniforms) {
                if (uniforms.ubo) {
                  for (const uniform of uniforms.ubo) {
                    if (uniform.size && uniform.type) {
                      const arraySize = (_a = uniform.arraySize) !== null && _a !== void 0 ? _a : 0;
                      eventData.ubo.addUniform(uniform.name, uniform.size, arraySize);
                      this._uboDeclaration += `${uniform.type} ${uniform.name}${arraySize > 0 ? `[${arraySize}]` : ""};
`;
                    }
                    this._uniformList.push(uniform.name);
                  }
                }
                if (uniforms.vertex) {
                  this._vertexDeclaration += uniforms.vertex + "\n";
                }
                if (uniforms.fragment) {
                  this._fragmentDeclaration += uniforms.fragment + "\n";
                }
              }
              plugin.getSamplers(this._samplerList);
              plugin.getUniformBuffersNames(this._uboList);
            }
            break;
          }
        }
      }
      _collectPointNames(shaderType, customCode) {
        if (!customCode) {
          return;
        }
        for (const pointName in customCode) {
          if (!this._codeInjectionPoints[shaderType]) {
            this._codeInjectionPoints[shaderType] = {};
          }
          this._codeInjectionPoints[shaderType][pointName] = true;
        }
      }
      _injectCustomCode(eventData, existingCallback) {
        return (shaderType, code) => {
          var _a, _b;
          if (existingCallback) {
            code = existingCallback(shaderType, code);
          }
          if (this._uboDeclaration) {
            code = code.replace("#define ADDITIONAL_UBO_DECLARATION", this._uboDeclaration);
          }
          if (this._vertexDeclaration) {
            code = code.replace("#define ADDITIONAL_VERTEX_DECLARATION", this._vertexDeclaration);
          }
          if (this._fragmentDeclaration) {
            code = code.replace("#define ADDITIONAL_FRAGMENT_DECLARATION", this._fragmentDeclaration);
          }
          const points = (_a = this._codeInjectionPoints) === null || _a === void 0 ? void 0 : _a[shaderType];
          if (!points) {
            return code;
          }
          let processorOptions = null;
          for (let pointName in points) {
            let injectedCode = "";
            for (const plugin of this._activePlugins) {
              let customCode = (_b = plugin.getCustomCode(shaderType)) === null || _b === void 0 ? void 0 : _b[pointName];
              if (!customCode) {
                continue;
              }
              if (plugin.resolveIncludes) {
                if (processorOptions === null) {
                  const shaderLanguage = ShaderLanguage.GLSL;
                  processorOptions = {
                    defines: [],
                    indexParameters: eventData.indexParameters,
                    isFragment: false,
                    shouldUseHighPrecisionShader: this._engine._shouldUseHighPrecisionShader,
                    processor: void 0,
                    supportsUniformBuffers: this._engine.supportsUniformBuffers,
                    shadersRepository: ShaderStore.GetShadersRepository(shaderLanguage),
                    includesShadersStore: ShaderStore.GetIncludesShadersStore(shaderLanguage),
                    version: void 0,
                    platformName: this._engine.shaderPlatformName,
                    processingContext: void 0,
                    isNDCHalfZRange: this._engine.isNDCHalfZRange,
                    useReverseDepthBuffer: this._engine.useReverseDepthBuffer,
                    processCodeAfterIncludes: void 0
                  };
                }
                processorOptions.isFragment = shaderType === "fragment";
                ShaderProcessor._ProcessIncludes(customCode, processorOptions, (code2) => customCode = code2);
              }
              injectedCode += customCode + "\n";
            }
            if (injectedCode.length > 0) {
              if (pointName.charAt(0) === "!") {
                pointName = pointName.substring(1);
                let regexFlags = "g";
                if (pointName.charAt(0) === "!") {
                  regexFlags = "";
                  pointName = pointName.substring(1);
                } else {
                  const matchOption = rxOption.exec(pointName);
                  if (matchOption && matchOption.length >= 2) {
                    regexFlags = matchOption[1];
                    pointName = pointName.substring(regexFlags.length + 1);
                  }
                }
                if (regexFlags.indexOf("g") < 0) {
                  regexFlags += "g";
                }
                const sourceCode = code;
                const rx = new RegExp(pointName, regexFlags);
                let match = rx.exec(sourceCode);
                while (match !== null) {
                  let newCode = injectedCode;
                  for (let i = 0; i < match.length; ++i) {
                    newCode = newCode.replace("$" + i, match[i]);
                  }
                  code = code.replace(match[0], newCode);
                  match = rx.exec(sourceCode);
                }
              } else {
                const fullPointName = "#define " + pointName;
                code = code.replace(fullPointName, "\n" + injectedCode + "\n" + fullPointName);
              }
            }
          }
          return code;
        };
      }
    };
    MaterialPluginManager._MaterialPluginClassToMainDefine = {};
    MaterialPluginManager._MaterialPluginCounter = 0;
    (() => {
      EngineStore.OnEnginesDisposedObservable.add(() => {
        UnregisterAllMaterialPlugins();
      });
    })();
    plugins = [];
    inited = false;
    observer = null;
  }
});

// node_modules/@babylonjs/core/Materials/materialPluginBase.js
var MaterialPluginBase;
var init_materialPluginBase = __esm({
  "node_modules/@babylonjs/core/Materials/materialPluginBase.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialPluginManager();
    MaterialPluginBase = class {
      _enable(enable) {
        if (enable) {
          this._pluginManager._activatePlugin(this);
        }
      }
      constructor(material, name109, priority, defines, addToPluginList = true, enable = false, resolveIncludes = false) {
        this.priority = 500;
        this.resolveIncludes = false;
        this.registerForExtraEvents = false;
        this._material = material;
        this.name = name109;
        this.priority = priority;
        this.resolveIncludes = resolveIncludes;
        if (!material.pluginManager) {
          material.pluginManager = new MaterialPluginManager(material);
          material.onDisposeObservable.add(() => {
            material.pluginManager = void 0;
          });
        }
        this._pluginDefineNames = defines;
        this._pluginManager = material.pluginManager;
        if (addToPluginList) {
          this._pluginManager._addPlugin(this);
        }
        if (enable) {
          this._enable(true);
        }
        this.markAllDefinesAsDirty = material._dirtyCallbacks[63];
      }
      getClassName() {
        return "MaterialPluginBase";
      }
      isReadyForSubMesh(defines, scene, engine, subMesh) {
        return true;
      }
      hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
      }
      dispose(forceDisposeTextures) {
      }
      getCustomCode(shaderType) {
        return null;
      }
      collectDefines(defines) {
        if (!this._pluginDefineNames) {
          return;
        }
        for (const key of Object.keys(this._pluginDefineNames)) {
          if (key[0] === "_") {
            continue;
          }
          const type = typeof this._pluginDefineNames[key];
          defines[key] = {
            type: type === "number" ? "number" : type === "string" ? "string" : type === "boolean" ? "boolean" : "object",
            default: this._pluginDefineNames[key]
          };
        }
      }
      prepareDefinesBeforeAttributes(defines, scene, mesh) {
      }
      prepareDefines(defines, scene, mesh) {
      }
      hasTexture(texture) {
        return false;
      }
      hasRenderTargetTextures() {
        return false;
      }
      fillRenderTargetTextures(renderTargets) {
      }
      getActiveTextures(activeTextures) {
      }
      getAnimatables(animatables) {
      }
      addFallbacks(defines, fallbacks, currentRank) {
        return currentRank;
      }
      getSamplers(samplers) {
      }
      getAttributes(attributes, scene, mesh) {
      }
      getUniformBuffersNames(ubos) {
      }
      getUniforms() {
        return {};
      }
      copyTo(plugin) {
        SerializationHelper.Clone(() => plugin, this);
      }
      serialize() {
        return SerializationHelper.Serialize(this);
      }
      parse(source, scene, rootUrl) {
        SerializationHelper.Parse(() => this, source, scene, rootUrl);
      }
    };
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "name", void 0);
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "priority", void 0);
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "resolveIncludes", void 0);
    __decorate([
      serialize()
    ], MaterialPluginBase.prototype, "registerForExtraEvents", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js
var MaterialDetailMapDefines, DetailMapConfiguration;
var init_material_detailMapConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/material.detailMapConfiguration.js"() {
    init_tslib_es6();
    init_material();
    init_decorators();
    init_materialFlags();
    init_materialHelper();
    init_materialDefines();
    init_materialPluginBase();
    MaterialDetailMapDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.DETAIL = false;
        this.DETAILDIRECTUV = 0;
        this.DETAIL_NORMALBLENDMETHOD = 0;
      }
    };
    DetailMapConfiguration = class extends MaterialPluginBase {
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "DetailMap", 140, new MaterialDetailMapDefines(), addToPluginList);
        this._texture = null;
        this.diffuseBlendLevel = 1;
        this.roughnessBlendLevel = 1;
        this.bumpLevel = 1;
        this._normalBlendMethod = Material.MATERIAL_NORMALBLENDMETHOD_WHITEOUT;
        this._isEnabled = false;
        this.isEnabled = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty && scene.texturesEnabled) {
          if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled) {
            if (!this._texture.isReady()) {
              return false;
            }
          }
        }
        return true;
      }
      prepareDefines(defines, scene) {
        if (this._isEnabled) {
          defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
          const engine = scene.getEngine();
          if (defines._areTexturesDirty) {
            if (engine.getCaps().standardDerivatives && this._texture && MaterialFlags.DetailTextureEnabled && this._isEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "DETAIL");
              defines.DETAIL_NORMALBLENDMETHOD = this._normalBlendMethod;
            } else {
              defines.DETAIL = false;
            }
          }
        } else {
          defines.DETAIL = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.DetailTextureEnabled) {
            uniformBuffer.updateFloat4("vDetailInfos", this._texture.coordinatesIndex, this.diffuseBlendLevel, this.bumpLevel, this.roughnessBlendLevel);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "detail");
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.DetailTextureEnabled) {
            uniformBuffer.setTexture("detailSampler", this._texture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      }
      dispose(forceDisposeTextures) {
        var _a;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
        }
      }
      getClassName() {
        return "DetailMapConfiguration";
      }
      getSamplers(samplers) {
        samplers.push("detailSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vDetailInfos", size: 4, type: "vec4" },
            { name: "detailMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    __decorate([
      serializeAsTexture("detailTexture"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], DetailMapConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize()
    ], DetailMapConfiguration.prototype, "diffuseBlendLevel", void 0);
    __decorate([
      serialize()
    ], DetailMapConfiguration.prototype, "roughnessBlendLevel", void 0);
    __decorate([
      serialize()
    ], DetailMapConfiguration.prototype, "bumpLevel", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], DetailMapConfiguration.prototype, "normalBlendMethod", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], DetailMapConfiguration.prototype, "isEnabled", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/prePassConfiguration.js
var PrePassConfiguration;
var init_prePassConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/prePassConfiguration.js"() {
    PrePassConfiguration = class {
      constructor() {
        this.previousWorldMatrices = {};
        this.previousBones = {};
      }
      static AddUniforms(uniforms) {
        uniforms.push("previousWorld", "previousViewProjection", "mPreviousBones");
      }
      static AddSamplers(samplers) {
      }
      bindForSubMesh(effect, scene, mesh, world, isFrozen) {
        if (scene.prePassRenderer && scene.prePassRenderer.enabled && scene.prePassRenderer.currentRTisSceneRT) {
          if (scene.prePassRenderer.getIndex(2) !== -1) {
            if (!this.previousWorldMatrices[mesh.uniqueId]) {
              this.previousWorldMatrices[mesh.uniqueId] = world.clone();
            }
            if (!this.previousViewProjection) {
              this.previousViewProjection = scene.getTransformMatrix().clone();
              this.currentViewProjection = scene.getTransformMatrix().clone();
            }
            const engine = scene.getEngine();
            if (this.currentViewProjection.updateFlag !== scene.getTransformMatrix().updateFlag) {
              this._lastUpdateFrameId = engine.frameId;
              this.previousViewProjection.copyFrom(this.currentViewProjection);
              this.currentViewProjection.copyFrom(scene.getTransformMatrix());
            } else if (this._lastUpdateFrameId !== engine.frameId) {
              this._lastUpdateFrameId = engine.frameId;
              this.previousViewProjection.copyFrom(this.currentViewProjection);
            }
            effect.setMatrix("previousWorld", this.previousWorldMatrices[mesh.uniqueId]);
            effect.setMatrix("previousViewProjection", this.previousViewProjection);
            this.previousWorldMatrices[mesh.uniqueId] = world.clone();
          }
        }
      }
    };
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js
var name4, shader4;
var init_decalFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragmentDeclaration.js"() {
    init_shaderStore();
    name4 = "decalFragmentDeclaration";
    shader4 = `#ifdef DECAL
uniform vec4 vDecalInfos;
#endif
`;
    ShaderStore.IncludesShadersStore[name4] = shader4;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js
var name5, shader5;
var init_defaultFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultFragmentDeclaration.js"() {
    init_shaderStore();
    init_decalFragmentDeclaration();
    name5 = "defaultFragmentDeclaration";
    shader5 = `uniform vec4 vEyePosition;uniform vec4 vDiffuseColor;
#ifdef SPECULARTERM
uniform vec4 vSpecularColor;
#endif
uniform vec3 vEmissiveColor;uniform vec3 vAmbientColor;uniform float visibility;
#ifdef DIFFUSE
uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY 
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef ALPHATEST
uniform float alphaCutOff;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFRACTION
uniform vec4 vRefractionInfos;
#ifndef REFRACTIONMAP_3D
uniform mat4 refractionMatrix;
#endif
#ifdef REFRACTIONFRESNEL
uniform vec4 refractionLeftColor;uniform vec4 refractionRightColor;
#endif
#if defined(USE_LOCAL_REFRACTIONMAP_CUBIC) && defined(REFRACTIONMAP_3D)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;
#endif
#ifdef DIFFUSEFRESNEL
uniform vec4 diffuseLeftColor;uniform vec4 diffuseRightColor;
#endif
#ifdef OPACITYFRESNEL
uniform vec4 opacityParts;
#endif
#ifdef EMISSIVEFRESNEL
uniform vec4 emissiveLeftColor;uniform vec4 emissiveRightColor;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#if defined(REFLECTIONMAP_PLANAR) || defined(REFLECTIONMAP_CUBIC) || defined(REFLECTIONMAP_PROJECTION) || defined(REFLECTIONMAP_EQUIRECTANGULAR) || defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_SKYBOX)
uniform mat4 reflectionMatrix;
#endif
#ifndef REFLECTIONMAP_SKYBOX
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#ifdef REFLECTIONFRESNEL
uniform vec4 reflectionLeftColor;uniform vec4 reflectionRightColor;
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
    ShaderStore.IncludesShadersStore[name5] = shader5;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js
var name6, shader6;
var init_sceneUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/sceneUboDeclaration.js"() {
    init_shaderStore();
    name6 = "sceneUboDeclaration";
    shader6 = `layout(std140,column_major) uniform;uniform Scene {mat4 viewProjection;
#ifdef MULTIVIEW
mat4 viewProjectionR;
#endif 
mat4 view;mat4 projection;vec4 vEyePosition;};
`;
    ShaderStore.IncludesShadersStore[name6] = shader6;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js
var name7, shader7;
var init_meshUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/meshUboDeclaration.js"() {
    init_shaderStore();
    name7 = "meshUboDeclaration";
    shader7 = `#ifdef WEBGL2
uniform mat4 world;uniform float visibility;
#else
layout(std140,column_major) uniform;uniform Mesh
{mat4 world;float visibility;};
#endif
#define WORLD_UBO
`;
    ShaderStore.IncludesShadersStore[name7] = shader7;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js
var name8, shader8;
var init_defaultUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultUboDeclaration.js"() {
    init_shaderStore();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    name8 = "defaultUboDeclaration";
    shader8 = `layout(std140,column_major) uniform;uniform Material
{vec4 diffuseLeftColor;vec4 diffuseRightColor;vec4 opacityParts;vec4 reflectionLeftColor;vec4 reflectionRightColor;vec4 refractionLeftColor;vec4 refractionRightColor;vec4 emissiveLeftColor;vec4 emissiveRightColor;vec2 vDiffuseInfos;vec2 vAmbientInfos;vec2 vOpacityInfos;vec2 vReflectionInfos;vec3 vReflectionPosition;vec3 vReflectionSize;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec2 vSpecularInfos;vec3 vBumpInfos;mat4 diffuseMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 reflectionMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 specularMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;float pointSize;float alphaCutOff;mat4 refractionMatrix;vec4 vRefractionInfos;vec3 vRefractionPosition;vec3 vRefractionSize;vec4 vSpecularColor;vec3 vEmissiveColor;vec4 vDiffuseColor;vec3 vAmbientColor;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
    ShaderStore.IncludesShadersStore[name8] = shader8;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js
var name9, shader9;
var init_prePassDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassDeclaration.js"() {
    init_shaderStore();
    name9 = "prePassDeclaration";
    shader9 = `#ifdef PREPASS
#extension GL_EXT_draw_buffers : require
layout(location=0) out highp vec4 glFragData[{X}];highp vec4 gl_FragColor;
#ifdef PREPASS_DEPTH
varying highp vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
varying highp vec4 vCurrentPosition;varying highp vec4 vPreviousPosition;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name9] = shader9;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js
var name10, shader10;
var init_oitDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/oitDeclaration.js"() {
    init_shaderStore();
    name10 = "oitDeclaration";
    shader10 = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
#extension GL_EXT_draw_buffers : require
layout(location=0) out vec2 depth; 
layout(location=1) out vec4 frontColor;layout(location=2) out vec4 backColor;
#define MAX_DEPTH 99999.0
highp vec4 gl_FragColor;uniform sampler2D oitDepthSampler;uniform sampler2D oitFrontColorSampler;
#endif
`;
    ShaderStore.IncludesShadersStore[name10] = shader10;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js
var name11, shader11;
var init_mainUVVaryingDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/mainUVVaryingDeclaration.js"() {
    init_shaderStore();
    name11 = "mainUVVaryingDeclaration";
    shader11 = `#ifdef MAINUV{X}
varying vec2 vMainUV{X};
#endif
`;
    ShaderStore.IncludesShadersStore[name11] = shader11;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js
var name12, shader12;
var init_helperFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/helperFunctions.js"() {
    init_shaderStore();
    name12 = "helperFunctions";
    shader12 = `const float PI=3.1415926535897932384626433832795;const float HALF_MIN=5.96046448e-08; 
const float LinearEncodePowerApprox=2.2;const float GammaEncodePowerApprox=1.0/LinearEncodePowerApprox;const vec3 LuminanceEncodeApprox=vec3(0.2126,0.7152,0.0722);const float Epsilon=0.0000001;
#define saturate(x) clamp(x,0.0,1.0)
#define absEps(x) abs(x)+Epsilon
#define maxEps(x) max(x,Epsilon)
#define saturateEps(x) clamp(x,Epsilon,1.0)
mat3 transposeMat3(mat3 inMatrix) {vec3 i0=inMatrix[0];vec3 i1=inMatrix[1];vec3 i2=inMatrix[2];mat3 outMatrix=mat3(
vec3(i0.x,i1.x,i2.x),
vec3(i0.y,i1.y,i2.y),
vec3(i0.z,i1.z,i2.z)
);return outMatrix;}
mat3 inverseMat3(mat3 inMatrix) {float a00=inMatrix[0][0],a01=inMatrix[0][1],a02=inMatrix[0][2];float a10=inMatrix[1][0],a11=inMatrix[1][1],a12=inMatrix[1][2];float a20=inMatrix[2][0],a21=inMatrix[2][1],a22=inMatrix[2][2];float b01=a22*a11-a12*a21;float b11=-a22*a10+a12*a20;float b21=a21*a10-a11*a20;float det=a00*b01+a01*b11+a02*b21;return mat3(b01,(-a22*a01+a02*a21),(a12*a01-a02*a11),
b11,(a22*a00-a02*a20),(-a12*a00+a02*a10),
b21,(-a21*a00+a01*a20),(a11*a00-a01*a10))/det;}
#if USE_EXACT_SRGB_CONVERSIONS
vec3 toLinearSpaceExact(vec3 color)
{vec3 nearZeroSection=0.0773993808*color;vec3 remainingSection=pow(0.947867299*(color+vec3(0.055)),vec3(2.4));
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.04045)));
#else
return
vec3(
color.r<=0.04045 ? nearZeroSection.r : remainingSection.r,
color.g<=0.04045 ? nearZeroSection.g : remainingSection.g,
color.b<=0.04045 ? nearZeroSection.b : remainingSection.b);
#endif
}
vec3 toGammaSpaceExact(vec3 color)
{vec3 nearZeroSection=12.92*color;vec3 remainingSection=1.055*pow(color,vec3(0.41666))-vec3(0.055);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
return mix(remainingSection,nearZeroSection,lessThanEqual(color,vec3(0.0031308)));
#else
return
vec3(
color.r<=0.0031308 ? nearZeroSection.r : remainingSection.r,
color.g<=0.0031308 ? nearZeroSection.g : remainingSection.g,
color.b<=0.0031308 ? nearZeroSection.b : remainingSection.b);
#endif
}
#endif
float toLinearSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=0.0773993808*color;float remainingSection=pow(0.947867299*(color+0.055),2.4);return color<=0.04045 ? nearZeroSection : remainingSection;
#else
return pow(color,LinearEncodePowerApprox);
#endif
}
vec3 toLinearSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toLinearSpaceExact(color);
#else
return pow(color,vec3(LinearEncodePowerApprox));
#endif
}
vec4 toLinearSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toLinearSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(LinearEncodePowerApprox)),color.a);
#endif
}
float toGammaSpace(float color)
{
#if USE_EXACT_SRGB_CONVERSIONS
float nearZeroSection=12.92*color;float remainingSection=1.055*pow(color,0.41666)-0.055;return color<=0.0031308 ? nearZeroSection : remainingSection;
#else
return pow(color,GammaEncodePowerApprox);
#endif
}
vec3 toGammaSpace(vec3 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return toGammaSpaceExact(color);
#else
return pow(color,vec3(GammaEncodePowerApprox));
#endif
}
vec4 toGammaSpace(vec4 color)
{
#if USE_EXACT_SRGB_CONVERSIONS
return vec4(toGammaSpaceExact(color.rgb),color.a);
#else
return vec4(pow(color.rgb,vec3(GammaEncodePowerApprox)),color.a);
#endif
}
float square(float value)
{return value*value;}
vec3 square(vec3 value)
{return value*value;}
float pow5(float value) {float sq=value*value;return sq*sq*value;}
float getLuminance(vec3 color)
{return clamp(dot(color,LuminanceEncodeApprox),0.,1.);}
float getRand(vec2 seed) {return fract(sin(dot(seed.xy ,vec2(12.9898,78.233)))*43758.5453);}
float dither(vec2 seed,float varianceAmount) {float rand=getRand(seed);float normVariance=varianceAmount/255.0;float dither=mix(-normVariance,normVariance,rand);return dither;}
const float rgbdMaxRange=255.0;vec4 toRGBD(vec3 color) {float maxRGB=maxEps(max(color.r,max(color.g,color.b)));float D =max(rgbdMaxRange/maxRGB,1.);D =clamp(floor(D)/255.0,0.,1.);vec3 rgb=color.rgb*D;rgb=toGammaSpace(rgb);return vec4(clamp(rgb,0.,1.),D); }
vec3 fromRGBD(vec4 rgbd) {rgbd.rgb=toLinearSpace(rgbd.rgb);return rgbd.rgb/rgbd.a;}
vec3 parallaxCorrectNormal( vec3 vertexPos,vec3 origVec,vec3 cubeSize,vec3 cubePos ) {vec3 invOrigVec=vec3(1.0,1.0,1.0)/origVec;vec3 halfSize=cubeSize*0.5;vec3 intersecAtMaxPlane=(cubePos+halfSize-vertexPos)*invOrigVec;vec3 intersecAtMinPlane=(cubePos-halfSize-vertexPos)*invOrigVec;vec3 largestIntersec=max(intersecAtMaxPlane,intersecAtMinPlane);float distance=min(min(largestIntersec.x,largestIntersec.y),largestIntersec.z);vec3 intersectPositionWS=vertexPos+origVec*distance;return intersectPositionWS-cubePos;}
`;
    ShaderStore.IncludesShadersStore[name12] = shader12;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js
var name13, shader13;
var init_lightFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragmentDeclaration.js"() {
    init_shaderStore();
    name13 = "lightFragmentDeclaration";
    shader13 = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X};
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name13] = shader13;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js
var name14, shader14;
var init_lightUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightUboDeclaration.js"() {
    init_shaderStore();
    name14 = "lightUboDeclaration";
    shader14 = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef PROJECTEDLIGHTTEXTURE{X}
uniform mat4 textureProjectionMatrix{X};uniform sampler2D projectionLightSampler{X};
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];uniform float viewFrustumZ{X}[SHADOWCSMNUM_CASCADES{X}];uniform float frustumLengths{X}[SHADOWCSMNUM_CASCADES{X}];uniform float cascadeBlendFactor{X};varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DArrayShadow shadowSampler{X};uniform highp sampler2DArray depthSampler{X};uniform vec2 lightSizeUVCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float depthCorrection{X}[SHADOWCSMNUM_CASCADES{X}];uniform float penumbraDarkness{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DArrayShadow shadowSampler{X};
#else
uniform highp sampler2DArray shadowSampler{X};
#endif
#ifdef SHADOWCSMDEBUG{X}
const vec3 vCascadeColorsMultiplier{X}[8]=vec3[8]
(
vec3 ( 1.5,0.0,0.0 ),
vec3 ( 0.0,1.5,0.0 ),
vec3 ( 0.0,0.0,5.5 ),
vec3 ( 1.5,0.0,5.5 ),
vec3 ( 1.5,1.5,0.0 ),
vec3 ( 1.0,1.0,1.0 ),
vec3 ( 0.0,1.0,5.5 ),
vec3 ( 0.5,3.5,0.75 )
);vec3 shadowDebug{X};
#endif
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
int index{X}=-1;
#else
int index{X}=SHADOWCSMNUM_CASCADES{X}-1;
#endif
float diff{X}=0.;
#elif defined(SHADOWCUBE{X})
uniform samplerCube shadowSampler{X}; 
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};
#if defined(SHADOWPCSS{X})
uniform highp sampler2DShadow shadowSampler{X};uniform highp sampler2D depthSampler{X};
#elif defined(SHADOWPCF{X})
uniform highp sampler2DShadow shadowSampler{X};
#else
uniform sampler2D shadowSampler{X};
#endif
uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name14] = shader14;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js
var name15, shader15;
var init_lightsFragmentFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightsFragmentFunctions.js"() {
    init_shaderStore();
    name15 = "lightsFragmentFunctions";
    shader15 = `struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef NDOTL
float ndl;
#endif
};lightingInfo computeLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 lightVectorW;float attenuation=1.0;if (lightData.w==0.)
{vec3 direction=lightData.xyz-vPositionW;attenuation=max(0.,1.0-length(direction)/range);lightVectorW=normalize(direction);}
else
{lightVectorW=normalize(-lightData.xyz);}
float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
lightingInfo computeSpotLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec4 lightDirection,vec3 diffuseColor,vec3 specularColor,float range,float glossiness) {lightingInfo result;vec3 direction=lightData.xyz-vPositionW;vec3 lightVectorW=normalize(direction);float attenuation=max(0.,1.0-length(direction)/range);float cosAngle=max(0.,dot(lightDirection.xyz,-lightVectorW));if (cosAngle>=lightDirection.w)
{cosAngle=max(0.,pow(cosAngle,lightData.w));attenuation*=cosAngle;float ndl=max(0.,dot(vNormal,lightVectorW));
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=ndl*diffuseColor*attenuation;
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightVectorW);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor*attenuation;
#endif
return result;}
result.diffuse=vec3(0.);
#ifdef SPECULARTERM
result.specular=vec3(0.);
#endif
#ifdef NDOTL
result.ndl=0.;
#endif
return result;}
lightingInfo computeHemisphericLighting(vec3 viewDirectionW,vec3 vNormal,vec4 lightData,vec3 diffuseColor,vec3 specularColor,vec3 groundColor,float glossiness) {lightingInfo result;float ndl=dot(vNormal,lightData.xyz)*0.5+0.5;
#ifdef NDOTL
result.ndl=ndl;
#endif
result.diffuse=mix(groundColor,diffuseColor,ndl);
#ifdef SPECULARTERM
vec3 angleW=normalize(viewDirectionW+lightData.xyz);float specComp=max(0.,dot(vNormal,angleW));specComp=pow(specComp,max(1.,glossiness));result.specular=specComp*specularColor;
#endif
return result;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return textureColor;}`;
    ShaderStore.IncludesShadersStore[name15] = shader15;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js
var name16, shader16;
var init_shadowsFragmentFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsFragmentFunctions.js"() {
    init_shaderStore();
    name16 = "shadowsFragmentFunctions";
    shader16 = `#ifdef SHADOWS
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define TEXTUREFUNC(s,c,l) texture2DLodEXT(s,c,l)
#else
#define TEXTUREFUNC(s,c,b) texture2D(s,c,b)
#endif
#ifndef SHADOWFLOAT
float unpack(vec4 color)
{const vec4 bit_shift=vec4(1.0/(255.0*255.0*255.0),1.0/(255.0*255.0),1.0/255.0,1.0);return dot(color,bit_shift);}
#endif
float computeFallOff(float value,vec2 clipSpace,float frustumEdgeFalloff)
{float mask=smoothstep(1.0-frustumEdgeFalloff,1.00000012,clamp(dot(clipSpace,clipSpace),0.,1.));return mix(value,1.0,mask);}
#define inline
float computeShadowCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,vec2 depthValues)
{vec3 directionToLight=vPositionW-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadow=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadow=textureCube(shadowSampler,directionToLight).x;
#endif
return depth>shadow ? darkness : 1.0;}
#define inline
float computeShadowWithPoissonSamplingCube(vec3 lightPosition,samplerCube shadowSampler,float mapSize,float darkness,vec2 depthValues)
{vec3 directionToLight=vPositionW-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);depth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;float visibility=1.;vec3 poissonDisk[4];poissonDisk[0]=vec3(-1.0,1.0,-1.0);poissonDisk[1]=vec3(1.0,-1.0,-1.0);poissonDisk[2]=vec3(-1.0,-1.0,-1.0);poissonDisk[3]=vec3(1.0,-1.0,1.0);
#ifndef SHADOWFLOAT
if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize))<depth) visibility-=0.25;if (unpack(textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize))<depth) visibility-=0.25;
#else
if (textureCube(shadowSampler,directionToLight+poissonDisk[0]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[1]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[2]*mapSize).x<depth) visibility-=0.25;if (textureCube(shadowSampler,directionToLight+poissonDisk[3]*mapSize).x<depth) visibility-=0.25;
#endif
return min(1.0,visibility+darkness);}
#define inline
float computeShadowWithESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=vPositionW-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness); 
return esm;}
#define inline
float computeShadowWithCloseESMCube(vec3 lightPosition,samplerCube shadowSampler,float darkness,float depthScale,vec2 depthValues)
{vec3 directionToLight=vPositionW-lightPosition;float depth=length(directionToLight);depth=(depth+depthValues.x)/(depthValues.y);float shadowPixelDepth=clamp(depth,0.,1.0);directionToLight=normalize(directionToLight);directionToLight.y=-directionToLight.y;
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(textureCube(shadowSampler,directionToLight));
#else
float shadowMapSample=textureCube(shadowSampler,directionToLight).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return esm;}
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define inline
float computeShadowCSM(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);vec3 uvLayer=vec3(uv.x,uv.y,layer);float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(texture2D(shadowSampler,uvLayer));
#else
float shadow=texture2D(shadowSampler,uvLayer).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}
#endif
#define inline
float computeShadow(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadow=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadow=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
return shadowPixelDepth>shadow ? computeFallOff(darkness,clipSpace.xy,frustumEdgeFalloff) : 1.;}}
#define inline
float computeShadowWithPoissonSampling(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float mapSize,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);float visibility=1.;vec2 poissonDisk[4];poissonDisk[0]=vec2(-0.94201624,-0.39906216);poissonDisk[1]=vec2(0.94558609,-0.76890725);poissonDisk[2]=vec2(-0.094184101,-0.92938870);poissonDisk[3]=vec2(0.34495938,0.29387760);
#ifndef SHADOWFLOAT
if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;if (unpack(TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.))<shadowPixelDepth) visibility-=0.25;
#else
if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[0]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[1]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[2]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;if (TEXTUREFUNC(shadowSampler,uv+poissonDisk[3]*mapSize,0.).x<shadowPixelDepth) visibility-=0.25;
#endif
return computeFallOff(min(1.0,visibility+darkness),clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0);
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=1.0-clamp(exp(min(87.,depthScale*shadowPixelDepth))*shadowMapSample,0.,1.-darkness);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithCloseESM(vec4 vPositionFromLight,float depthMetric,sampler2D shadowSampler,float darkness,float depthScale,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec2 uv=0.5*clipSpace.xy+vec2(0.5);if (uv.x<0. || uv.x>1.0 || uv.y<0. || uv.y>1.0)
{return 1.0;}
else
{float shadowPixelDepth=clamp(depthMetric,0.,1.0); 
#ifndef SHADOWFLOAT
float shadowMapSample=unpack(TEXTUREFUNC(shadowSampler,uv,0.));
#else
float shadowMapSample=TEXTUREFUNC(shadowSampler,uv,0.).x;
#endif
float esm=clamp(exp(min(87.,-depthScale*(shadowPixelDepth-shadowMapSample))),darkness,1.);return computeFallOff(esm,clipSpace.xy,frustumEdgeFalloff);}}
#ifdef IS_NDC_HALF_ZRANGE
#define ZINCLIP clipSpace.z
#else
#define ZINCLIP uvDepth.z
#endif
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
#define GREATEST_LESS_THAN_ONE 0.99999994
#define inline
float computeShadowWithCSMPCF1(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float shadow=texture2D(shadowSampler,uvDepthLayer);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF3(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithCSMPCF5(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArrayShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[0]),layer,uvDepth.z));shadow+=uvw1.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[0]),layer,uvDepth.z));shadow+=uvw2.x*uvw0.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[0]),layer,uvDepth.z));shadow+=uvw0.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[1]),layer,uvDepth.z));shadow+=uvw1.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[1]),layer,uvDepth.z));shadow+=uvw2.x*uvw1.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[1]),layer,uvDepth.z));shadow+=uvw0.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[0],v[2]),layer,uvDepth.z));shadow+=uvw1.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[1],v[2]),layer,uvDepth.z));shadow+=uvw2.x*uvw2.y*texture2D(shadowSampler,vec4(base_uv.xy+vec2(u[2],v[2]),layer,uvDepth.z));shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}
#define inline
float computeShadowWithPCF1(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float shadow=TEXTUREFUNC(shadowSampler,uvDepth,0.);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF3(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=3.-2.*st;vec2 uvw1=1.+2.*st;vec2 u=vec2((2.-st.x)/uvw0.x-1.,st.x/uvw1.x+1.)*shadowMapSizeAndInverse.y;vec2 v=vec2((2.-st.y)/uvw0.y-1.,st.y/uvw1.y+1.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow=shadow/16.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCF5(vec4 vPositionFromLight,float depthMetric,highp sampler2DShadow shadowSampler,vec2 shadowMapSizeAndInverse,float darkness,float frustumEdgeFalloff)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;vec2 uv=uvDepth.xy*shadowMapSizeAndInverse.x; 
uv+=0.5; 
vec2 st=fract(uv); 
vec2 base_uv=floor(uv)-0.5; 
base_uv*=shadowMapSizeAndInverse.y; 
vec2 uvw0=4.-3.*st;vec2 uvw1=vec2(7.);vec2 uvw2=1.+3.*st;vec3 u=vec3((3.-2.*st.x)/uvw0.x-2.,(3.+st.x)/uvw1.x,st.x/uvw2.x+2.)*shadowMapSizeAndInverse.y;vec3 v=vec3((3.-2.*st.y)/uvw0.y-2.,(3.+st.y)/uvw1.y,st.y/uvw2.y+2.)*shadowMapSizeAndInverse.y;float shadow=0.;shadow+=uvw0.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[0]),uvDepth.z),0.);shadow+=uvw1.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[0]),uvDepth.z),0.);shadow+=uvw2.x*uvw0.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[0]),uvDepth.z),0.);shadow+=uvw0.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[1]),uvDepth.z),0.);shadow+=uvw1.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[1]),uvDepth.z),0.);shadow+=uvw2.x*uvw1.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[1]),uvDepth.z),0.);shadow+=uvw0.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[0],v[2]),uvDepth.z),0.);shadow+=uvw1.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[1],v[2]),uvDepth.z),0.);shadow+=uvw2.x*uvw2.y*TEXTUREFUNC(shadowSampler,vec3(base_uv.xy+vec2(u[2],v[2]),uvDepth.z),0.);shadow=shadow/144.;shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
const vec3 PoissonSamplers32[64]=vec3[64](
vec3(0.06407013,0.05409927,0.),
vec3(0.7366577,0.5789394,0.),
vec3(-0.6270542,-0.5320278,0.),
vec3(-0.4096107,0.8411095,0.),
vec3(0.6849564,-0.4990818,0.),
vec3(-0.874181,-0.04579735,0.),
vec3(0.9989998,0.0009880066,0.),
vec3(-0.004920578,-0.9151649,0.),
vec3(0.1805763,0.9747483,0.),
vec3(-0.2138451,0.2635818,0.),
vec3(0.109845,0.3884785,0.),
vec3(0.06876755,-0.3581074,0.),
vec3(0.374073,-0.7661266,0.),
vec3(0.3079132,-0.1216763,0.),
vec3(-0.3794335,-0.8271583,0.),
vec3(-0.203878,-0.07715034,0.),
vec3(0.5912697,0.1469799,0.),
vec3(-0.88069,0.3031784,0.),
vec3(0.5040108,0.8283722,0.),
vec3(-0.5844124,0.5494877,0.),
vec3(0.6017799,-0.1726654,0.),
vec3(-0.5554981,0.1559997,0.),
vec3(-0.3016369,-0.3900928,0.),
vec3(-0.5550632,-0.1723762,0.),
vec3(0.925029,0.2995041,0.),
vec3(-0.2473137,0.5538505,0.),
vec3(0.9183037,-0.2862392,0.),
vec3(0.2469421,0.6718712,0.),
vec3(0.3916397,-0.4328209,0.),
vec3(-0.03576927,-0.6220032,0.),
vec3(-0.04661255,0.7995201,0.),
vec3(0.4402924,0.3640312,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.),
vec3(0.,0.,0.)
);const vec3 PoissonSamplers64[64]=vec3[64](
vec3(-0.613392,0.617481,0.),
vec3(0.170019,-0.040254,0.),
vec3(-0.299417,0.791925,0.),
vec3(0.645680,0.493210,0.),
vec3(-0.651784,0.717887,0.),
vec3(0.421003,0.027070,0.),
vec3(-0.817194,-0.271096,0.),
vec3(-0.705374,-0.668203,0.),
vec3(0.977050,-0.108615,0.),
vec3(0.063326,0.142369,0.),
vec3(0.203528,0.214331,0.),
vec3(-0.667531,0.326090,0.),
vec3(-0.098422,-0.295755,0.),
vec3(-0.885922,0.215369,0.),
vec3(0.566637,0.605213,0.),
vec3(0.039766,-0.396100,0.),
vec3(0.751946,0.453352,0.),
vec3(0.078707,-0.715323,0.),
vec3(-0.075838,-0.529344,0.),
vec3(0.724479,-0.580798,0.),
vec3(0.222999,-0.215125,0.),
vec3(-0.467574,-0.405438,0.),
vec3(-0.248268,-0.814753,0.),
vec3(0.354411,-0.887570,0.),
vec3(0.175817,0.382366,0.),
vec3(0.487472,-0.063082,0.),
vec3(-0.084078,0.898312,0.),
vec3(0.488876,-0.783441,0.),
vec3(0.470016,0.217933,0.),
vec3(-0.696890,-0.549791,0.),
vec3(-0.149693,0.605762,0.),
vec3(0.034211,0.979980,0.),
vec3(0.503098,-0.308878,0.),
vec3(-0.016205,-0.872921,0.),
vec3(0.385784,-0.393902,0.),
vec3(-0.146886,-0.859249,0.),
vec3(0.643361,0.164098,0.),
vec3(0.634388,-0.049471,0.),
vec3(-0.688894,0.007843,0.),
vec3(0.464034,-0.188818,0.),
vec3(-0.440840,0.137486,0.),
vec3(0.364483,0.511704,0.),
vec3(0.034028,0.325968,0.),
vec3(0.099094,-0.308023,0.),
vec3(0.693960,-0.366253,0.),
vec3(0.678884,-0.204688,0.),
vec3(0.001801,0.780328,0.),
vec3(0.145177,-0.898984,0.),
vec3(0.062655,-0.611866,0.),
vec3(0.315226,-0.604297,0.),
vec3(-0.780145,0.486251,0.),
vec3(-0.371868,0.882138,0.),
vec3(0.200476,0.494430,0.),
vec3(-0.494552,-0.711051,0.),
vec3(0.612476,0.705252,0.),
vec3(-0.578845,-0.768792,0.),
vec3(-0.772454,-0.090976,0.),
vec3(0.504440,0.372295,0.),
vec3(0.155736,0.065157,0.),
vec3(0.391522,0.849605,0.),
vec3(-0.620106,-0.328104,0.),
vec3(0.789239,-0.419965,0.),
vec3(-0.545396,0.538133,0.),
vec3(-0.178564,-0.596057,0.)
);
#define inline
float computeShadowWithCSMPCSS(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=clamp(ZINCLIP,0.,GREATEST_LESS_THAN_ONE);vec4 uvDepthLayer=vec4(uvDepth.x,uvDepth.y,layer,uvDepth.z);float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=texture2D(depthSampler,vec3(uvDepth.xy+(lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse*PoissonSamplers32[i].xy),layer)).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)*depthCorrection+AAOffset);vec4 filterRadius=vec4(penumbraRatio*lightSizeUV*lightSizeUVCorrection*shadowMapSizeInverse,0.,0.);float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec4 offset=vec4(poissonSamplers[i],0.);offset=vec4(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.,0.);shadow+=texture2D(shadowSampler,uvDepthLayer+offset*filterRadius);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,min((depthMetric-avgBlockerDepth)*depthCorrection*penumbraDarkness,1.));shadow=mix(darkness,1.,shadow);if (numBlocker<1.0) {return 1.0;}
else
{return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}
#define inline
float computeShadowWithPCSS(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,int searchTapCount,int pcfTapCount,vec3[64] poissonSamplers)
{if (depthMetric>1.0 || depthMetric<0.0) {return 1.0;}
else
{vec3 clipSpace=vPositionFromLight.xyz/vPositionFromLight.w;vec3 uvDepth=vec3(0.5*clipSpace.xyz+vec3(0.5));uvDepth.z=ZINCLIP;float blockerDepth=0.0;float sumBlockerDepth=0.0;float numBlocker=0.0;for (int i=0; i<searchTapCount; i ++) {blockerDepth=TEXTUREFUNC(depthSampler,uvDepth.xy+(lightSizeUV*shadowMapSizeInverse*PoissonSamplers32[i].xy),0.).r;if (blockerDepth<depthMetric) {sumBlockerDepth+=blockerDepth;numBlocker++;}}
if (numBlocker<1.0) {return 1.0;}
else
{float avgBlockerDepth=sumBlockerDepth/numBlocker;float AAOffset=shadowMapSizeInverse*10.;float penumbraRatio=((depthMetric-avgBlockerDepth)+AAOffset);float filterRadius=penumbraRatio*lightSizeUV*shadowMapSizeInverse;float random=getRand(vPositionFromLight.xy);float rotationAngle=random*3.1415926;vec2 rotationVector=vec2(cos(rotationAngle),sin(rotationAngle));float shadow=0.;for (int i=0; i<pcfTapCount; i++) {vec3 offset=poissonSamplers[i];offset=vec3(offset.x*rotationVector.x-offset.y*rotationVector.y,offset.y*rotationVector.x+offset.x*rotationVector.y,0.);shadow+=TEXTUREFUNC(shadowSampler,uvDepth+offset*filterRadius,0.);}
shadow/=float(pcfTapCount);shadow=mix(shadow,1.,depthMetric-avgBlockerDepth);shadow=mix(darkness,1.,shadow);return computeFallOff(shadow,clipSpace.xy,frustumEdgeFalloff);}}}
#define inline
float computeShadowWithPCSS16(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS32(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32);}
#define inline
float computeShadowWithPCSS64(vec4 vPositionFromLight,float depthMetric,sampler2D depthSampler,highp sampler2DShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff)
{return computeShadowWithPCSS(vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64);}
#define inline
float computeShadowWithCSMPCSS16(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,16,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS32(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,16,32,PoissonSamplers32,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#define inline
float computeShadowWithCSMPCSS64(float layer,vec4 vPositionFromLight,float depthMetric,highp sampler2DArray depthSampler,highp sampler2DArrayShadow shadowSampler,float shadowMapSizeInverse,float lightSizeUV,float darkness,float frustumEdgeFalloff,vec2 lightSizeUVCorrection,float depthCorrection,float penumbraDarkness)
{return computeShadowWithCSMPCSS(layer,vPositionFromLight,depthMetric,depthSampler,shadowSampler,shadowMapSizeInverse,lightSizeUV,darkness,frustumEdgeFalloff,32,64,PoissonSamplers64,lightSizeUVCorrection,depthCorrection,penumbraDarkness);}
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name16] = shader16;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js
var name17, shader17;
var init_samplerFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentDeclaration.js"() {
    init_shaderStore();
    name17 = "samplerFragmentDeclaration";
    shader17 = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
uniform sampler2D _SAMPLERNAME_Sampler;
#endif
`;
    ShaderStore.IncludesShadersStore[name17] = shader17;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js
var name18, shader18;
var init_fresnelFunction = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fresnelFunction.js"() {
    init_shaderStore();
    name18 = "fresnelFunction";
    shader18 = `#ifdef FRESNEL
float computeFresnelTerm(vec3 viewDirection,vec3 worldNormal,float bias,float power)
{float fresnelTerm=pow(bias+abs(dot(viewDirection,worldNormal)),power);return clamp(fresnelTerm,0.,1.);}
#endif
`;
    ShaderStore.IncludesShadersStore[name18] = shader18;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js
var name19, shader19;
var init_reflectionFunction = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/reflectionFunction.js"() {
    init_shaderStore();
    name19 = "reflectionFunction";
    shader19 = `vec3 computeFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0); }
vec3 computeMirroredFixedEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 direction)
{float lon=atan(direction.z,direction.x);float lat=acos(direction.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(1.0-s,t,0); }
vec3 computeEquirectangularCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 cameraToVertex=normalize(worldPos.xyz-eyePosition);vec3 r=normalize(reflect(cameraToVertex,worldNormal));r=vec3(reflectionMatrix*vec4(r,0));float lon=atan(r.z,r.x);float lat=acos(r.y);vec2 sphereCoords=vec2(lon,lat)*RECIPROCAL_PI2*2.0;float s=sphereCoords.x*0.5+0.5;float t=sphereCoords.y;return vec3(s,t,0);}
vec3 computeSphericalCoords(vec4 worldPos,vec3 worldNormal,mat4 view,mat4 reflectionMatrix)
{vec3 viewDir=normalize(vec3(view*worldPos));vec3 viewNormal=normalize(vec3(view*vec4(worldNormal,0.0)));vec3 r=reflect(viewDir,viewNormal);r=vec3(reflectionMatrix*vec4(r,0));r.z=r.z-1.0;float m=2.0*length(r);return vec3(r.x/m+0.5,1.0-r.y/m-0.5,0);}
vec3 computePlanarCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=worldPos.xyz-eyePosition;vec3 coords=normalize(reflect(viewDir,worldNormal));return vec3(reflectionMatrix*vec4(coords,1));}
vec3 computeCubicCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeCubicLocalCoords(vec4 worldPos,vec3 worldNormal,vec3 eyePosition,mat4 reflectionMatrix,vec3 reflectionSize,vec3 reflectionPosition)
{vec3 viewDir=normalize(worldPos.xyz-eyePosition);vec3 coords=reflect(viewDir,worldNormal);coords=parallaxCorrectNormal(worldPos.xyz,coords,reflectionSize,reflectionPosition);coords=vec3(reflectionMatrix*vec4(coords,0));
#ifdef INVERTCUBICMAP
coords.y*=-1.0;
#endif
return coords;}
vec3 computeProjectionCoords(vec4 worldPos,mat4 view,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*(view*worldPos));}
vec3 computeSkyBoxCoords(vec3 positionW,mat4 reflectionMatrix)
{return vec3(reflectionMatrix*vec4(positionW,1.));}
#ifdef REFLECTION
vec3 computeReflectionCoords(vec4 worldPos,vec3 worldNormal)
{
#ifdef REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeMirroredFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR_FIXED
vec3 direction=normalize(vDirectionW);return computeFixedEquirectangularCoords(worldPos,worldNormal,direction);
#endif
#ifdef REFLECTIONMAP_EQUIRECTANGULAR
return computeEquirectangularCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SPHERICAL
return computeSphericalCoords(worldPos,worldNormal,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_PLANAR
return computePlanarCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_CUBIC
#ifdef USE_LOCAL_REFLECTIONMAP_CUBIC
return computeCubicLocalCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix,vReflectionSize,vReflectionPosition);
#else
return computeCubicCoords(worldPos,worldNormal,vEyePosition.xyz,reflectionMatrix);
#endif
#endif
#ifdef REFLECTIONMAP_PROJECTION
return computeProjectionCoords(worldPos,view,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_SKYBOX
return computeSkyBoxCoords(vPositionUVW,reflectionMatrix);
#endif
#ifdef REFLECTIONMAP_EXPLICIT
return vec3(0,0,0);
#endif
}
#endif
`;
    ShaderStore.IncludesShadersStore[name19] = shader19;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js
var name20, shader20;
var init_imageProcessingDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingDeclaration.js"() {
    init_shaderStore();
    name20 = "imageProcessingDeclaration";
    shader20 = `#ifdef EXPOSURE
uniform float exposureLinear;
#endif
#ifdef CONTRAST
uniform float contrast;
#endif
#if defined(VIGNETTE) || defined(DITHER)
uniform vec2 vInverseScreenSize;
#endif
#ifdef VIGNETTE
uniform vec4 vignetteSettings1;uniform vec4 vignetteSettings2;
#endif
#ifdef COLORCURVES
uniform vec4 vCameraColorCurveNegative;uniform vec4 vCameraColorCurveNeutral;uniform vec4 vCameraColorCurvePositive;
#endif
#ifdef COLORGRADING
#ifdef COLORGRADING3D
uniform highp sampler3D txColorTransform;
#else
uniform sampler2D txColorTransform;
#endif
uniform vec4 colorTransformSettings;
#endif
#ifdef DITHER
uniform float ditherIntensity;
#endif
`;
    ShaderStore.IncludesShadersStore[name20] = shader20;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js
var name21, shader21;
var init_imageProcessingFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/imageProcessingFunctions.js"() {
    init_shaderStore();
    name21 = "imageProcessingFunctions";
    shader21 = `#if defined(COLORGRADING) && !defined(COLORGRADING3D)
/** 
* Polyfill for SAMPLE_TEXTURE_3D,which is unsupported in WebGL.
* sampler3dSetting.x=textureOffset (0.5/textureSize).
* sampler3dSetting.y=textureSize.
*/
#define inline
vec3 sampleTexture3D(sampler2D colorTransform,vec3 color,vec2 sampler3dSetting)
{float sliceSize=2.0*sampler3dSetting.x; 
#ifdef SAMPLER3DGREENDEPTH
float sliceContinuous=(color.g-sampler3dSetting.x)*sampler3dSetting.y;
#else
float sliceContinuous=(color.b-sampler3dSetting.x)*sampler3dSetting.y;
#endif
float sliceInteger=floor(sliceContinuous);float sliceFraction=sliceContinuous-sliceInteger;
#ifdef SAMPLER3DGREENDEPTH
vec2 sliceUV=color.rb;
#else
vec2 sliceUV=color.rg;
#endif
sliceUV.x*=sliceSize;sliceUV.x+=sliceInteger*sliceSize;sliceUV=saturate(sliceUV);vec4 slice0Color=texture2D(colorTransform,sliceUV);sliceUV.x+=sliceSize;sliceUV=saturate(sliceUV);vec4 slice1Color=texture2D(colorTransform,sliceUV);vec3 result=mix(slice0Color.rgb,slice1Color.rgb,sliceFraction);
#ifdef SAMPLER3DBGRMAP
color.rgb=result.rgb;
#else
color.rgb=result.bgr;
#endif
return color;}
#endif
#ifdef TONEMAPPING_ACES
const mat3 ACESInputMat=mat3(
vec3(0.59719,0.07600,0.02840),
vec3(0.35458,0.90834,0.13383),
vec3(0.04823,0.01566,0.83777)
);const mat3 ACESOutputMat=mat3(
vec3( 1.60475,-0.10208,-0.00327),
vec3(-0.53108, 1.10813,-0.07276),
vec3(-0.07367,-0.00605, 1.07602)
);vec3 RRTAndODTFit(vec3 v)
{vec3 a=v*(v+0.0245786)-0.000090537;vec3 b=v*(0.983729*v+0.4329510)+0.238081;return a/b;}
vec3 ACESFitted(vec3 color)
{color=ACESInputMat*color;color=RRTAndODTFit(color);color=ACESOutputMat*color;color=saturate(color);return color;}
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_DEFINITIONS
vec4 applyImageProcessing(vec4 result) {
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATSTART
#ifdef EXPOSURE
result.rgb*=exposureLinear;
#endif
#ifdef VIGNETTE
vec2 viewportXY=gl_FragCoord.xy*vInverseScreenSize;viewportXY=viewportXY*2.0-1.0;vec3 vignetteXY1=vec3(viewportXY*vignetteSettings1.xy+vignetteSettings1.zw,1.0);float vignetteTerm=dot(vignetteXY1,vignetteXY1);float vignette=pow(vignetteTerm,vignetteSettings2.w);vec3 vignetteColor=vignetteSettings2.rgb;
#ifdef VIGNETTEBLENDMODEMULTIPLY
vec3 vignetteColorMultiplier=mix(vignetteColor,vec3(1,1,1),vignette);result.rgb*=vignetteColorMultiplier;
#endif
#ifdef VIGNETTEBLENDMODEOPAQUE
result.rgb=mix(vignetteColor,result.rgb,vignette);
#endif
#endif
#ifdef TONEMAPPING
#ifdef TONEMAPPING_ACES
result.rgb=ACESFitted(result.rgb);
#else
const float tonemappingCalibration=1.590579;result.rgb=1.0-exp2(-tonemappingCalibration*result.rgb);
#endif
#endif
result.rgb=toGammaSpace(result.rgb);result.rgb=saturate(result.rgb);
#ifdef CONTRAST
vec3 resultHighContrast=result.rgb*result.rgb*(3.0-2.0*result.rgb);if (contrast<1.0) {result.rgb=mix(vec3(0.5,0.5,0.5),result.rgb,contrast);} else {result.rgb=mix(result.rgb,resultHighContrast,contrast-1.0);}
#endif
#ifdef COLORGRADING
vec3 colorTransformInput=result.rgb*colorTransformSettings.xxx+colorTransformSettings.yyy;
#ifdef COLORGRADING3D
vec3 colorTransformOutput=texture(txColorTransform,colorTransformInput).rgb;
#else
vec3 colorTransformOutput=sampleTexture3D(txColorTransform,colorTransformInput,colorTransformSettings.yz).rgb;
#endif
result.rgb=mix(result.rgb,colorTransformOutput,colorTransformSettings.www);
#endif
#ifdef COLORCURVES
float luma=getLuminance(result.rgb);vec2 curveMix=clamp(vec2(luma*3.0-1.5,luma*-3.0+1.5),vec2(0.0),vec2(1.0));vec4 colorCurve=vCameraColorCurveNeutral+curveMix.x*vCameraColorCurvePositive-curveMix.y*vCameraColorCurveNegative;result.rgb*=colorCurve.rgb;result.rgb=mix(vec3(luma),result.rgb,colorCurve.a);
#endif
#ifdef DITHER
float rand=getRand(gl_FragCoord.xy*vInverseScreenSize);float dither=mix(-ditherIntensity,ditherIntensity,rand);result.rgb=saturate(result.rgb+vec3(dither));
#endif
#define CUSTOM_IMAGEPROCESSINGFUNCTIONS_UPDATERESULT_ATEND
return result;}`;
    ShaderStore.IncludesShadersStore[name21] = shader21;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js
var name22, shader22;
var init_bumpFragmentMainFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentMainFunctions.js"() {
    init_shaderStore();
    name22 = "bumpFragmentMainFunctions";
    shader22 = `#if defined(BUMP) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC) || defined(DETAIL)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#ifdef OBJECTSPACE_NORMALMAP
uniform mat4 normalMatrix;
#if defined(WEBGL2) || defined(WEBGPU)
mat4 toNormalMatrix(mat4 wMatrix)
{mat4 ret=inverse(wMatrix);ret=transpose(ret);ret[0][3]=0.;ret[1][3]=0.;ret[2][3]=0.;ret[3]=vec4(0.,0.,0.,1.);return ret;}
#else
mat4 toNormalMatrix(mat4 m)
{float
a00=m[0][0],a01=m[0][1],a02=m[0][2],a03=m[0][3],
a10=m[1][0],a11=m[1][1],a12=m[1][2],a13=m[1][3],
a20=m[2][0],a21=m[2][1],a22=m[2][2],a23=m[2][3],
a30=m[3][0],a31=m[3][1],a32=m[3][2],a33=m[3][3],
b00=a00*a11-a01*a10,
b01=a00*a12-a02*a10,
b02=a00*a13-a03*a10,
b03=a01*a12-a02*a11,
b04=a01*a13-a03*a11,
b05=a02*a13-a03*a12,
b06=a20*a31-a21*a30,
b07=a20*a32-a22*a30,
b08=a20*a33-a23*a30,
b09=a21*a32-a22*a31,
b10=a21*a33-a23*a31,
b11=a22*a33-a23*a32,
det=b00*b11-b01*b10+b02*b09+b03*b08-b04*b07+b05*b06;mat4 mi=mat4(
a11*b11-a12*b10+a13*b09,
a02*b10-a01*b11-a03*b09,
a31*b05-a32*b04+a33*b03,
a22*b04-a21*b05-a23*b03,
a12*b08-a10*b11-a13*b07,
a00*b11-a02*b08+a03*b07,
a32*b02-a30*b05-a33*b01,
a20*b05-a22*b02+a23*b01,
a10*b10-a11*b08+a13*b06,
a01*b08-a00*b10-a03*b06,
a30*b04-a31*b02+a33*b00,
a21*b02-a20*b04-a23*b00,
a11*b07-a10*b09-a12*b06,
a00*b09-a01*b07+a02*b06,
a31*b01-a30*b03-a32*b00,
a20*b03-a21*b01+a22*b00)/det;return mat4(mi[0][0],mi[1][0],mi[2][0],mi[3][0],
mi[0][1],mi[1][1],mi[2][1],mi[3][1],
mi[0][2],mi[1][2],mi[2][2],mi[3][2],
mi[0][3],mi[1][3],mi[2][3],mi[3][3]);}
#endif
#endif
vec3 perturbNormalBase(mat3 cotangentFrame,vec3 normal,float scale)
{
#ifdef NORMALXYSCALE
normal=normalize(normal*vec3(scale,scale,1.0));
#endif
return normalize(cotangentFrame*normal);}
vec3 perturbNormal(mat3 cotangentFrame,vec3 textureSample,float scale)
{return perturbNormalBase(cotangentFrame,textureSample*2.0-1.0,scale);}
mat3 cotangent_frame(vec3 normal,vec3 p,vec2 uv,vec2 tangentSpaceParams)
{vec3 dp1=dFdx(p);vec3 dp2=dFdy(p);vec2 duv1=dFdx(uv);vec2 duv2=dFdy(uv);vec3 dp2perp=cross(dp2,normal);vec3 dp1perp=cross(normal,dp1);vec3 tangent=dp2perp*duv1.x+dp1perp*duv2.x;vec3 bitangent=dp2perp*duv1.y+dp1perp*duv2.y;tangent*=tangentSpaceParams.x;bitangent*=tangentSpaceParams.y;float det=max(dot(tangent,tangent),dot(bitangent,bitangent));float invmax=det==0.0 ? 0.0 : inversesqrt(det);return mat3(tangent*invmax,bitangent*invmax,normal);}
#endif
`;
    ShaderStore.IncludesShadersStore[name22] = shader22;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js
var name23, shader23;
var init_bumpFragmentFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragmentFunctions.js"() {
    init_shaderStore();
    init_samplerFragmentDeclaration();
    name23 = "bumpFragmentFunctions";
    shader23 = `#if defined(BUMP)
#include<samplerFragmentDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_SAMPLERNAME_,bump)
#endif
#if defined(DETAIL)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_SAMPLERNAME_,detail)
#endif
#if defined(BUMP) && defined(PARALLAX)
const float minSamples=4.;const float maxSamples=15.;const int iMaxSamples=15;vec2 parallaxOcclusion(vec3 vViewDirCoT,vec3 vNormalCoT,vec2 texCoord,float parallaxScale) {float parallaxLimit=length(vViewDirCoT.xy)/vViewDirCoT.z;parallaxLimit*=parallaxScale;vec2 vOffsetDir=normalize(vViewDirCoT.xy);vec2 vMaxOffset=vOffsetDir*parallaxLimit;float numSamples=maxSamples+(dot(vViewDirCoT,vNormalCoT)*(minSamples-maxSamples));float stepSize=1.0/numSamples;float currRayHeight=1.0;vec2 vCurrOffset=vec2(0,0);vec2 vLastOffset=vec2(0,0);float lastSampledHeight=1.0;float currSampledHeight=1.0;bool keepWorking=true;for (int i=0; i<iMaxSamples; i++)
{currSampledHeight=texture2D(bumpSampler,texCoord+vCurrOffset).w;if (!keepWorking)
{}
else if (currSampledHeight>currRayHeight)
{float delta1=currSampledHeight-currRayHeight;float delta2=(currRayHeight+stepSize)-lastSampledHeight;float ratio=delta1/(delta1+delta2);vCurrOffset=(ratio)* vLastOffset+(1.0-ratio)*vCurrOffset;keepWorking=false;}
else
{currRayHeight-=stepSize;vLastOffset=vCurrOffset;vCurrOffset+=stepSize*vMaxOffset;lastSampledHeight=currSampledHeight;}}
return vCurrOffset;}
vec2 parallaxOffset(vec3 viewDir,float heightScale)
{float height=texture2D(bumpSampler,vBumpUV).w;vec2 texCoordOffset=heightScale*viewDir.xy*height;return -texCoordOffset;}
#endif
`;
    ShaderStore.IncludesShadersStore[name23] = shader23;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js
var name24, shader24;
var init_clipPlaneFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragmentDeclaration.js"() {
    init_shaderStore();
    name24 = "clipPlaneFragmentDeclaration";
    shader24 = `#ifdef CLIPPLANE
varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
varying float fClipDistance6;
#endif
`;
    ShaderStore.IncludesShadersStore[name24] = shader24;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js
var name25, shader25;
var init_logDepthDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthDeclaration.js"() {
    init_shaderStore();
    name25 = "logDepthDeclaration";
    shader25 = `#ifdef LOGARITHMICDEPTH
uniform float logarithmicDepthConstant;varying float vFragmentDepth;
#endif
`;
    ShaderStore.IncludesShadersStore[name25] = shader25;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js
var name26, shader26;
var init_fogFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragmentDeclaration.js"() {
    init_shaderStore();
    name26 = "fogFragmentDeclaration";
    shader26 = `#ifdef FOG
#define FOGMODE_NONE 0.
#define FOGMODE_EXP 1.
#define FOGMODE_EXP2 2.
#define FOGMODE_LINEAR 3.
#define E 2.71828
uniform vec4 vFogInfos;uniform vec3 vFogColor;varying vec3 vFogDistance;float CalcFogFactor()
{float fogCoeff=1.0;float fogStart=vFogInfos.y;float fogEnd=vFogInfos.z;float fogDensity=vFogInfos.w;float fogDistance=length(vFogDistance);if (FOGMODE_LINEAR==vFogInfos.x)
{fogCoeff=(fogEnd-fogDistance)/(fogEnd-fogStart);}
else if (FOGMODE_EXP==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDensity);}
else if (FOGMODE_EXP2==vFogInfos.x)
{fogCoeff=1.0/pow(E,fogDistance*fogDistance*fogDensity*fogDensity);}
return clamp(fogCoeff,0.0,1.0);}
#endif
`;
    ShaderStore.IncludesShadersStore[name26] = shader26;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js
var name27, shader27;
var init_clipPlaneFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneFragment.js"() {
    init_shaderStore();
    name27 = "clipPlaneFragment";
    shader27 = `#if defined(CLIPPLANE) || defined(CLIPPLANE2) || defined(CLIPPLANE3) || defined(CLIPPLANE4) || defined(CLIPPLANE5) || defined(CLIPPLANE6)
if (false) {}
#endif
#ifdef CLIPPLANE
else if (fClipDistance>0.0)
{discard;}
#endif
#ifdef CLIPPLANE2
else if (fClipDistance2>0.0)
{discard;}
#endif
#ifdef CLIPPLANE3
else if (fClipDistance3>0.0)
{discard;}
#endif
#ifdef CLIPPLANE4
else if (fClipDistance4>0.0)
{discard;}
#endif
#ifdef CLIPPLANE5
else if (fClipDistance5>0.0)
{discard;}
#endif
#ifdef CLIPPLANE6
else if (fClipDistance6>0.0)
{discard;}
#endif
`;
    ShaderStore.IncludesShadersStore[name27] = shader27;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js
var name28, shader28;
var init_bumpFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpFragment.js"() {
    init_shaderStore();
    name28 = "bumpFragment";
    shader28 = `vec2 uvOffset=vec2(0.0,0.0);
#if defined(BUMP) || defined(PARALLAX) || defined(DETAIL)
#ifdef NORMALXYSCALE
float normalScale=1.0;
#elif defined(BUMP)
float normalScale=vBumpInfos.y;
#else
float normalScale=1.0;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#elif defined(BUMP)
vec2 TBNUV=gl_FrontFacing ? vBumpUV : -vBumpUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vTangentSpaceParams);
#else
vec2 TBNUV=gl_FrontFacing ? vDetailUV : -vDetailUV;mat3 TBN=cotangent_frame(normalW*normalScale,vPositionW,TBNUV,vec2(1.,1.));
#endif
#elif defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
mat3 TBN=vTBN;
#else
vec2 TBNUV=gl_FrontFacing ? vMainUV1 : -vMainUV1;mat3 TBN=cotangent_frame(normalW,vPositionW,TBNUV,vec2(1.,1.));
#endif
#endif
#ifdef PARALLAX
mat3 invTBN=transposeMat3(TBN);
#ifdef PARALLAXOCCLUSION
uvOffset=parallaxOcclusion(invTBN*-viewDirectionW,invTBN*normalW,vBumpUV,vBumpInfos.z);
#else
uvOffset=parallaxOffset(invTBN*viewDirectionW,vBumpInfos.z);
#endif
#endif
#ifdef DETAIL
vec4 detailColor=texture2D(detailSampler,vDetailUV+uvOffset);vec2 detailNormalRG=detailColor.wy*2.0-1.0;float detailNormalB=sqrt(1.-saturate(dot(detailNormalRG,detailNormalRG)));vec3 detailNormal=vec3(detailNormalRG,detailNormalB);
#endif
#ifdef BUMP
#ifdef OBJECTSPACE_NORMALMAP
#define CUSTOM_FRAGMENT_BUMP_FRAGMENT
normalW=normalize(texture2D(bumpSampler,vBumpUV).xyz *2.0-1.0);normalW=normalize(mat3(normalMatrix)*normalW);
#elif !defined(DETAIL)
normalW=perturbNormal(TBN,texture2D(bumpSampler,vBumpUV+uvOffset).xyz,vBumpInfos.y);
#else
vec3 bumpNormal=texture2D(bumpSampler,vBumpUV+uvOffset).xyz*2.0-1.0;
#if DETAIL_NORMALBLENDMETHOD==0 
detailNormal.xy*=vDetailInfos.z;vec3 blendedNormal=normalize(vec3(bumpNormal.xy+detailNormal.xy,bumpNormal.z*detailNormal.z));
#elif DETAIL_NORMALBLENDMETHOD==1 
detailNormal.xy*=vDetailInfos.z;bumpNormal+=vec3(0.0,0.0,1.0);detailNormal*=vec3(-1.0,-1.0,1.0);vec3 blendedNormal=bumpNormal*dot(bumpNormal,detailNormal)/bumpNormal.z-detailNormal;
#endif
normalW=perturbNormalBase(TBN,blendedNormal,vBumpInfos.y);
#endif
#elif defined(DETAIL)
detailNormal.xy*=vDetailInfos.z;normalW=perturbNormalBase(TBN,detailNormal,vDetailInfos.z);
#endif
`;
    ShaderStore.IncludesShadersStore[name28] = shader28;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js
var name29, shader29;
var init_decalFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/decalFragment.js"() {
    init_shaderStore();
    name29 = "decalFragment";
    shader29 = `#ifdef DECAL
#ifdef GAMMADECAL
decalColor.rgb=toLinearSpace(decalColor.rgb);
#endif
#ifdef DECAL_SMOOTHALPHA
decalColor.a*=decalColor.a;
#endif
surfaceAlbedo.rgb=mix(surfaceAlbedo.rgb,decalColor.rgb,decalColor.a);
#endif
`;
    ShaderStore.IncludesShadersStore[name29] = shader29;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js
var name30, shader30;
var init_depthPrePass = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/depthPrePass.js"() {
    init_shaderStore();
    name30 = "depthPrePass";
    shader30 = `#ifdef DEPTHPREPASS
gl_FragColor=vec4(0.,0.,0.,1.0);return;
#endif
`;
    ShaderStore.IncludesShadersStore[name30] = shader30;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js
var name31, shader31;
var init_lightFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightFragment.js"() {
    init_shaderStore();
    name31 = "lightFragment";
    shader31 = `#ifdef LIGHT{X}
#if defined(SHADOWONLY) || defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X}) && defined(LIGHTMAPNOSPECULAR{X})
#else
#ifdef PBR
#ifdef SPOTLIGHT{X}
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(POINTLIGHT{X})
preInfo=computePointAndSpotPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(HEMILIGHT{X})
preInfo=computeHemisphericPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#elif defined(DIRLIGHT{X})
preInfo=computeDirectionalPreLightingInfo(light{X}.vLightData,viewDirectionW,normalW);
#endif
preInfo.NdotV=NdotV;
#ifdef SPOTLIGHT{X}
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff_GLTF(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);preInfo.attenuation*=computeDirectionalLightFalloff_Physical(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);preInfo.attenuation*=computeDirectionalLightFalloff_Standard(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);preInfo.attenuation*=computeDirectionalLightFalloff(light{X}.vLightDirection.xyz,preInfo.L,light{X}.vLightDirection.w,light{X}.vLightData.w,light{X}.vLightFalloff.z,light{X}.vLightFalloff.w);
#endif
#elif defined(POINTLIGHT{X})
#ifdef LIGHT_FALLOFF_GLTF{X}
preInfo.attenuation=computeDistanceLightFalloff_GLTF(preInfo.lightDistanceSquared,light{X}.vLightFalloff.y);
#elif defined(LIGHT_FALLOFF_PHYSICAL{X})
preInfo.attenuation=computeDistanceLightFalloff_Physical(preInfo.lightDistanceSquared);
#elif defined(LIGHT_FALLOFF_STANDARD{X})
preInfo.attenuation=computeDistanceLightFalloff_Standard(preInfo.lightOffset,light{X}.vLightFalloff.x);
#else
preInfo.attenuation=computeDistanceLightFalloff(preInfo.lightOffset,preInfo.lightDistanceSquared,light{X}.vLightFalloff.x,light{X}.vLightFalloff.y);
#endif
#else
preInfo.attenuation=1.0;
#endif
#ifdef HEMILIGHT{X}
preInfo.roughness=roughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(roughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#ifdef IRIDESCENCE
preInfo.iridescenceIntensity=iridescenceIntensity;
#endif
#ifdef HEMILIGHT{X}
info.diffuse=computeHemisphericDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb,light{X}.vLightGround);
#elif defined(SS_TRANSLUCENCY)
info.diffuse=computeDiffuseAndTransmittedLighting(preInfo,light{X}.vLightDiffuse.rgb,subSurfaceOut.transmittance);
#else
info.diffuse=computeDiffuseLighting(preInfo,light{X}.vLightDiffuse.rgb);
#endif
#ifdef SPECULARTERM
#ifdef ANISOTROPIC
info.specular=computeAnisotropicSpecularLighting(preInfo,viewDirectionW,normalW,anisotropicOut.anisotropicTangent,anisotropicOut.anisotropicBitangent,anisotropicOut.anisotropy,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#else
info.specular=computeSpecularLighting(preInfo,normalW,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#endif
#ifdef SHEEN
#ifdef SHEEN_LINKWITHALBEDO
preInfo.roughness=sheenOut.sheenIntensity;
#else
#ifdef HEMILIGHT{X}
preInfo.roughness=sheenOut.sheenRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(sheenOut.sheenRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
#endif
info.sheen=computeSheenLighting(preInfo,normalW,sheenOut.sheenColor,specularEnvironmentR90,AARoughnessFactors.x,light{X}.vLightDiffuse.rgb);
#endif
#ifdef CLEARCOAT
#ifdef HEMILIGHT{X}
preInfo.roughness=clearcoatOut.clearCoatRoughness;
#else
preInfo.roughness=adjustRoughnessFromLightProperties(clearcoatOut.clearCoatRoughness,light{X}.vLightSpecular.a,preInfo.lightDistance);
#endif
info.clearCoat=computeClearCoatLighting(preInfo,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatAARoughnessFactors.x,clearcoatOut.clearCoatIntensity,light{X}.vLightDiffuse.rgb);
#ifdef CLEARCOAT_TINT
absorption=computeClearCoatLightingAbsorption(clearcoatOut.clearCoatNdotVRefract,preInfo.L,clearcoatOut.clearCoatNormalW,clearcoatOut.clearCoatColor,clearcoatOut.clearCoatThickness,clearcoatOut.clearCoatIntensity);info.diffuse*=absorption;
#ifdef SPECULARTERM
info.specular*=absorption;
#endif
#endif
info.diffuse*=info.clearCoat.w;
#ifdef SPECULARTERM
info.specular*=info.clearCoat.w;
#endif
#ifdef SHEEN
info.sheen*=info.clearCoat.w;
#endif
#endif
#else
#ifdef SPOTLIGHT{X}
info=computeSpotLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDirection,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#elif defined(HEMILIGHT{X})
info=computeHemisphericLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightGround,glossiness);
#elif defined(POINTLIGHT{X}) || defined(DIRLIGHT{X})
info=computeLighting(viewDirectionW,normalW,light{X}.vLightData,light{X}.vLightDiffuse.rgb,light{X}.vLightSpecular.rgb,light{X}.vLightDiffuse.a,glossiness);
#endif
#endif
#ifdef PROJECTEDLIGHTTEXTURE{X}
info.diffuse*=computeProjectionTextureDiffuseLighting(projectionLightSampler{X},textureProjectionMatrix{X});
#endif
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) 
{
#ifdef SHADOWCSM_RIGHTHANDED{X}
diff{X}=viewFrustumZ{X}[i]+vPositionFromCamera{X}.z;
#else
diff{X}=viewFrustumZ{X}[i]-vPositionFromCamera{X}.z;
#endif
if (diff{X}>=0.) {index{X}=i;break;}}
#ifdef SHADOWCSMUSESHADOWMAXZ{X}
if (index{X}>=0)
#endif
{
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
shadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
shadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=vec3(shadow)*vCascadeColorsMultiplier{X}[index{X}];
#endif
#ifndef SHADOWCSMNOBLEND{X}
float frustumLength=frustumLengths{X}[index{X}];float diffRatio=clamp(diff{X}/frustumLength,0.,1.)*cascadeBlendFactor{X};if (index{X}<(SHADOWCSMNUM_CASCADES{X}-1) && diffRatio<1.)
{index{X}+=1;float nextShadow=0.;
#if defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCF1(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCF3(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
nextShadow=computeShadowWithCSMPCF5(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
nextShadow=computeShadowWithCSMPCSS16(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#elif defined(SHADOWMEDIUMQUALITY{X})
nextShadow=computeShadowWithCSMPCSS32(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#else
nextShadow=computeShadowWithCSMPCSS64(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w,lightSizeUVCorrection{X}[index{X}],depthCorrection{X}[index{X}],penumbraDarkness{X});
#endif
#else
nextShadow=computeShadowCSM(float(index{X}),vPositionFromLight{X}[index{X}],vDepthMetric{X}[index{X}],shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
shadow=mix(nextShadow,shadow,diffRatio);
#ifdef SHADOWCSMDEBUG{X}
shadowDebug{X}=mix(vec3(nextShadow)*vCascadeColorsMultiplier{X}[index{X}],shadowDebug{X},diffRatio);
#endif
}
#endif
}
#elif defined(SHADOWCLOSEESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithCloseESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithCloseESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWESM{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithESMCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.depthValues);
#else
shadow=computeShadowWithESM(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.z,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPOISSON{X})
#if defined(SHADOWCUBE{X})
shadow=computeShadowWithPoissonSamplingCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadowWithPoissonSampling(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCF{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCF1(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCF3(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCF5(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.yz,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#elif defined(SHADOWPCSS{X})
#if defined(SHADOWLOWQUALITY{X})
shadow=computeShadowWithPCSS16(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#elif defined(SHADOWMEDIUMQUALITY{X})
shadow=computeShadowWithPCSS32(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#else
shadow=computeShadowWithPCSS64(vPositionFromLight{X},vDepthMetric{X},depthSampler{X},shadowSampler{X},light{X}.shadowsInfo.y,light{X}.shadowsInfo.z,light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#else
#if defined(SHADOWCUBE{X})
shadow=computeShadowCube(light{X}.vLightData.xyz,shadowSampler{X},light{X}.shadowsInfo.x,light{X}.depthValues);
#else
shadow=computeShadow(vPositionFromLight{X},vDepthMetric{X},shadowSampler{X},light{X}.shadowsInfo.x,light{X}.shadowsInfo.w);
#endif
#endif
#ifdef SHADOWONLY
#ifndef SHADOWINUSE
#define SHADOWINUSE
#endif
globalShadow+=shadow;shadowLightCount+=1.0;
#endif
#else
shadow=1.;
#endif
aggShadow+=shadow;numLights+=1.0;
#ifndef SHADOWONLY
#ifdef CUSTOMUSERLIGHTING
diffuseBase+=computeCustomDiffuseLighting(info,diffuseBase,shadow);
#ifdef SPECULARTERM
specularBase+=computeCustomSpecularLighting(info,specularBase,shadow);
#endif
#elif defined(LIGHTMAP) && defined(LIGHTMAPEXCLUDED{X})
diffuseBase+=lightmapColor.rgb*shadow;
#ifdef SPECULARTERM
#ifndef LIGHTMAPNOSPECULAR{X}
specularBase+=info.specular*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef CLEARCOAT
#ifndef LIGHTMAPNOSPECULAR{X}
clearCoatBase+=info.clearCoat.rgb*shadow*lightmapColor.rgb;
#endif
#endif
#ifdef SHEEN
#ifndef LIGHTMAPNOSPECULAR{X}
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#else
#ifdef SHADOWCSMDEBUG{X}
diffuseBase+=info.diffuse*shadowDebug{X};
#else 
diffuseBase+=info.diffuse*shadow;
#endif
#ifdef SPECULARTERM
specularBase+=info.specular*shadow;
#endif
#ifdef CLEARCOAT
clearCoatBase+=info.clearCoat.rgb*shadow;
#endif
#ifdef SHEEN
sheenBase+=info.sheen.rgb*shadow;
#endif
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name31] = shader31;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js
var name32, shader32;
var init_logDepthFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthFragment.js"() {
    init_shaderStore();
    name32 = "logDepthFragment";
    shader32 = `#ifdef LOGARITHMICDEPTH
gl_FragDepthEXT=log2(vFragmentDepth)*logarithmicDepthConstant*0.5;
#endif
`;
    ShaderStore.IncludesShadersStore[name32] = shader32;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js
var name33, shader33;
var init_fogFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogFragment.js"() {
    init_shaderStore();
    name33 = "fogFragment";
    shader33 = `#ifdef FOG
float fog=CalcFogFactor();
#ifdef PBR
fog=toLinearSpace(fog);
#endif
color.rgb=mix(vFogColor,color.rgb,fog);
#endif
`;
    ShaderStore.IncludesShadersStore[name33] = shader33;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js
var name34, shader34;
var init_oitFragment = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/oitFragment.js"() {
    init_shaderStore();
    name34 = "oitFragment";
    shader34 = `#ifdef ORDER_INDEPENDENT_TRANSPARENCY
float fragDepth=gl_FragCoord.z; 
#ifdef ORDER_INDEPENDENT_TRANSPARENCY_16BITS
uint halfFloat=packHalf2x16(vec2(fragDepth));vec2 full=unpackHalf2x16(halfFloat);fragDepth=full.x;
#endif
ivec2 fragCoord=ivec2(gl_FragCoord.xy);vec2 lastDepth=texelFetch(oitDepthSampler,fragCoord,0).rg;vec4 lastFrontColor=texelFetch(oitFrontColorSampler,fragCoord,0);depth.rg=vec2(-MAX_DEPTH);frontColor=lastFrontColor;backColor=vec4(0.0);
#ifdef USE_REVERSE_DEPTHBUFFER
float furthestDepth=-lastDepth.x;float nearestDepth=lastDepth.y;
#else
float nearestDepth=-lastDepth.x;float furthestDepth=lastDepth.y;
#endif
float alphaMultiplier=1.0-lastFrontColor.a;
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth>nearestDepth || fragDepth<furthestDepth) {
#else
if (fragDepth<nearestDepth || fragDepth>furthestDepth) {
#endif
return;}
#ifdef USE_REVERSE_DEPTHBUFFER
if (fragDepth<nearestDepth && fragDepth>furthestDepth) {
#else
if (fragDepth>nearestDepth && fragDepth<furthestDepth) {
#endif
depth.rg=vec2(-fragDepth,fragDepth);return;}
#endif
`;
    ShaderStore.IncludesShadersStore[name34] = shader34;
  }
});

// node_modules/@babylonjs/core/Shaders/default.fragment.js
var name35, shader35;
var init_default_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/default.fragment.js"() {
    init_shaderStore();
    init_defaultFragmentDeclaration();
    init_defaultUboDeclaration();
    init_prePassDeclaration();
    init_oitDeclaration();
    init_mainUVVaryingDeclaration();
    init_helperFunctions();
    init_lightFragmentDeclaration();
    init_lightUboDeclaration();
    init_lightsFragmentFunctions();
    init_shadowsFragmentFunctions();
    init_samplerFragmentDeclaration();
    init_fresnelFunction();
    init_reflectionFunction();
    init_imageProcessingDeclaration();
    init_imageProcessingFunctions();
    init_bumpFragmentMainFunctions();
    init_bumpFragmentFunctions();
    init_clipPlaneFragmentDeclaration();
    init_logDepthDeclaration();
    init_fogFragmentDeclaration();
    init_clipPlaneFragment();
    init_bumpFragment();
    init_decalFragment();
    init_depthPrePass();
    init_lightFragment();
    init_logDepthFragment();
    init_fogFragment();
    init_oitFragment();
    name35 = "defaultPixelShader";
    shader35 = `#include<__decl__defaultFragment>
#if defined(BUMP) || !defined(NORMAL)
#extension GL_OES_standard_derivatives : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
#include<oitDeclaration>
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#define RECIPROCAL_PI2 0.15915494
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#include<helperFunctions>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<lightsFragmentFunctions>
#include<shadowsFragmentFunctions>
#include<samplerFragmentDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_SAMPLERNAME_,diffuse)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef REFRACTION
#ifdef REFRACTIONMAP_3D
uniform samplerCube refractionCubeSampler;
#else
uniform sampler2D refraction2DSampler;
#endif
#endif
#if defined(SPECULARTERM)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_SAMPLERNAME_,specular)
#endif
#include<fresnelFunction>
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
uniform samplerCube reflectionCubeSampler;
#else
uniform sampler2D reflection2DSampler;
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#include<reflectionFunction>
#endif
#include<imageProcessingDeclaration>
#include<imageProcessingFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);vec4 baseColor=vec4(1.,1.,1.,1.);vec3 diffuseColor=vDiffuseColor.rgb;float alpha=vDiffuseColor.a;
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(-cross(dFdx(vPositionW),dFdy(vPositionW)));
#endif
#include<bumpFragment>
#ifdef TWOSIDEDLIGHTING
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
#ifdef DIFFUSE
baseColor=texture2D(diffuseSampler,vDiffuseUV+uvOffset);
#if defined(ALPHATEST) && !defined(ALPHATEST_AFTERALLALPHACOMPUTATIONS)
if (baseColor.a<alphaCutOff)
discard;
#endif
#ifdef ALPHAFROMDIFFUSE
alpha*=baseColor.a;
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
baseColor.rgb*=vDiffuseInfos.y;
#endif
#if defined(DECAL) && !defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#include<depthPrePass>
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
baseColor.rgb*=vColor.rgb;
#endif
#ifdef DETAIL
baseColor.rgb=baseColor.rgb*2.0*mix(0.5,detailColor.r,vDetailInfos.y);
#endif
#if defined(DECAL) && defined(DECAL_AFTER_DETAIL)
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#include<decalFragment>(surfaceAlbedo,baseColor,GAMMADECAL,_GAMMADECAL_NOTUSED_)
#endif
#define CUSTOM_FRAGMENT_UPDATE_DIFFUSE
vec3 baseAmbientColor=vec3(1.,1.,1.);
#ifdef AMBIENT
baseAmbientColor=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb*vAmbientInfos.y;
#endif
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
#ifdef SPECULARTERM
float glossiness=vSpecularColor.a;vec3 specularColor=vSpecularColor.rgb;
#ifdef SPECULAR
vec4 specularMapColor=texture2D(specularSampler,vSpecularUV+uvOffset);specularColor=specularMapColor.rgb;
#ifdef GLOSSINESS
glossiness=glossiness*specularMapColor.a;
#endif
#endif
#else
float glossiness=0.;
#endif
vec3 diffuseBase=vec3(0.,0.,0.);lightingInfo info;
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
float shadow=1.;float aggShadow=0.;float numLights=0.;
#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
#include<lightFragment>[0..maxSimultaneousLights]
aggShadow=aggShadow/numLights;vec4 refractionColor=vec4(0.,0.,0.,1.);
#ifdef REFRACTION
vec3 refractionVector=normalize(refract(-viewDirectionW,normalW,vRefractionInfos.y));
#ifdef REFRACTIONMAP_3D
#ifdef USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,vRefractionSize,vRefractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec4 refractionLookup=textureCube(refractionCubeSampler,refractionVector);if (dot(refractionVector,viewDirectionW)<1.0) {refractionColor=refractionLookup;}
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;refractionColor=texture2D(refraction2DSampler,refractionCoords);
#endif
#ifdef RGBDREFRACTION
refractionColor.rgb=fromRGBD(refractionColor);
#endif
#ifdef IS_REFRACTION_LINEAR
refractionColor.rgb=toGammaSpace(refractionColor.rgb);
#endif
refractionColor.rgb*=vRefractionInfos.x;
#endif
vec4 reflectionColor=vec4(0.,0.,0.,1.);
#ifdef REFLECTION
vec3 vReflectionUVW=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
vReflectionUVW.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
#ifdef ROUGHNESS
float bias=vReflectionInfos.y;
#ifdef SPECULARTERM
#ifdef SPECULAR
#ifdef GLOSSINESS
bias*=(1.0-specularMapColor.a);
#endif
#endif
#endif
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW,bias);
#else
reflectionColor=textureCube(reflectionCubeSampler,vReflectionUVW);
#endif
#else
vec2 coords=vReflectionUVW.xy;
#ifdef REFLECTIONMAP_PROJECTION
coords/=vReflectionUVW.z;
#endif
coords.y=1.0-coords.y;reflectionColor=texture2D(reflection2DSampler,coords);
#endif
#ifdef RGBDREFLECTION
reflectionColor.rgb=fromRGBD(reflectionColor);
#endif
#ifdef IS_REFLECTION_LINEAR
reflectionColor.rgb=toGammaSpace(reflectionColor.rgb);
#endif
reflectionColor.rgb*=vReflectionInfos.x;
#ifdef REFLECTIONFRESNEL
float reflectionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,reflectionRightColor.a,reflectionLeftColor.a);
#ifdef REFLECTIONFRESNELFROMSPECULAR
#ifdef SPECULARTERM
reflectionColor.rgb*=specularColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#else
reflectionColor.rgb*=reflectionLeftColor.rgb*(1.0-reflectionFresnelTerm)+reflectionFresnelTerm*reflectionRightColor.rgb;
#endif
#endif
#endif
#ifdef REFRACTIONFRESNEL
float refractionFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,refractionRightColor.a,refractionLeftColor.a);refractionColor.rgb*=refractionLeftColor.rgb*(1.0-refractionFresnelTerm)+refractionFresnelTerm*refractionRightColor.rgb;
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#ifdef OPACITYRGB
opacityMap.rgb=opacityMap.rgb*vec3(0.3,0.59,0.11);alpha*=(opacityMap.x+opacityMap.y+opacityMap.z)* vOpacityInfos.y;
#else
alpha*=opacityMap.a*vOpacityInfos.y;
#endif
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#ifdef OPACITYFRESNEL
float opacityFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,opacityParts.z,opacityParts.w);alpha+=opacityParts.x*(1.0-opacityFresnelTerm)+opacityFresnelTerm*opacityParts.y;
#endif
#ifdef ALPHATEST
#ifdef ALPHATEST_AFTERALLALPHACOMPUTATIONS
if (alpha<alphaCutOff)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
vec3 emissiveColor=vEmissiveColor;
#ifdef EMISSIVE
emissiveColor+=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb*vEmissiveInfos.y;
#endif
#ifdef EMISSIVEFRESNEL
float emissiveFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,emissiveRightColor.a,emissiveLeftColor.a);emissiveColor*=emissiveLeftColor.rgb*(1.0-emissiveFresnelTerm)+emissiveFresnelTerm*emissiveRightColor.rgb;
#endif
#ifdef DIFFUSEFRESNEL
float diffuseFresnelTerm=computeFresnelTerm(viewDirectionW,normalW,diffuseRightColor.a,diffuseLeftColor.a);diffuseBase*=diffuseLeftColor.rgb*(1.0-diffuseFresnelTerm)+diffuseFresnelTerm*diffuseRightColor.rgb;
#endif
#ifdef EMISSIVEASILLUMINATION
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
#ifdef LINKEMISSIVEWITHDIFFUSE
vec3 finalDiffuse=clamp((diffuseBase+emissiveColor)*diffuseColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#else
vec3 finalDiffuse=clamp(diffuseBase*diffuseColor+emissiveColor+vAmbientColor,0.0,1.0)*baseColor.rgb;
#endif
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase*specularColor;
#ifdef SPECULAROVERALPHA
alpha=clamp(alpha+dot(finalSpecular,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#else
vec3 finalSpecular=vec3(0.0);
#endif
#ifdef REFLECTIONOVERALPHA
alpha=clamp(alpha+dot(reflectionColor.rgb,vec3(0.3,0.59,0.11)),0.,1.);
#endif
#ifdef EMISSIVEASILLUMINATION
vec4 color=vec4(clamp(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+emissiveColor+refractionColor.rgb,0.0,1.0),alpha);
#else
vec4 color=vec4(finalDiffuse*baseAmbientColor+finalSpecular+reflectionColor.rgb+refractionColor.rgb,alpha);
#endif
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
color.rgb*=lightmapColor.rgb;
#else
color.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
#define CUSTOM_FRAGMENT_BEFORE_FOG
color.rgb=max(color.rgb,0.);
#include<logDepthFragment>
#include<fogFragment>
#ifdef IMAGEPROCESSINGPOSTPROCESS
color.rgb=toLinearSpace(color.rgb);
#else
#ifdef IMAGEPROCESSING
color.rgb=toLinearSpace(color.rgb);color=applyImageProcessing(color);
#endif
#endif
color.a*=visibility;
#ifdef PREMULTIPLYALPHA
color.rgb*=color.a;
#endif
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=color.a>0.4 ? 1.0 : 0.0;gl_FragData[0]=color; 
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_IRRADIANCE
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(0.0,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#if defined(SPECULARTERM)
#if defined(SPECULAR)
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularMapColor))*writeGeometryInfo; 
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(toLinearSpace(specularColor),1.0)*writeGeometryInfo;
#endif
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(0.0,0.0,0.0,1.0)*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=color;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=color.rgb*color.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-color.a);} else {backColor+=color;}
#endif
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
    ShaderStore.ShadersStore[name35] = shader35;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/decalVertexDeclaration.js
var name36, shader36;
var init_decalVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/decalVertexDeclaration.js"() {
    init_shaderStore();
    name36 = "decalVertexDeclaration";
    shader36 = `#ifdef DECAL
uniform vec4 vDecalInfos;uniform mat4 decalMatrix;
#endif
`;
    ShaderStore.IncludesShadersStore[name36] = shader36;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js
var name37, shader37;
var init_defaultVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/defaultVertexDeclaration.js"() {
    init_shaderStore();
    init_decalVertexDeclaration();
    name37 = "defaultVertexDeclaration";
    shader37 = `uniform mat4 viewProjection;uniform mat4 view;
#ifdef DIFFUSE
uniform mat4 diffuseMatrix;uniform vec2 vDiffuseInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec2 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#if defined(SPECULAR) && defined(SPECULARTERM)
uniform vec2 vSpecularInfos;uniform mat4 specularMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef REFLECTION
uniform mat4 reflectionMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;
    ShaderStore.IncludesShadersStore[name37] = shader37;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js
var name38, shader38;
var init_uvAttributeDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/uvAttributeDeclaration.js"() {
    init_shaderStore();
    name38 = "uvAttributeDeclaration";
    shader38 = `#ifdef UV{X}
attribute vec2 uv{X};
#endif
`;
    ShaderStore.IncludesShadersStore[name38] = shader38;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js
var name39, shader39;
var init_bonesDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesDeclaration.js"() {
    init_shaderStore();
    name39 = "bonesDeclaration";
    shader39 = `#if NUM_BONE_INFLUENCERS>0
attribute vec4 matricesIndices;attribute vec4 matricesWeights;
#if NUM_BONE_INFLUENCERS>4
attribute vec4 matricesIndicesExtra;attribute vec4 matricesWeightsExtra;
#endif
#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#ifdef BONETEXTURE
uniform sampler2D boneSampler;uniform float boneTextureWidth;
#else
uniform mat4 mBones[BonesPerMesh];
#ifdef BONES_VELOCITY_ENABLED
uniform mat4 mPreviousBones[BonesPerMesh];
#endif
#endif
#ifdef BONETEXTURE
#define inline
mat4 readMatrixFromRawSampler(sampler2D smp,float index)
{float offset=index *4.0;float dx=1.0/boneTextureWidth;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),0.));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),0.));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),0.));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),0.));return mat4(m0,m1,m2,m3);}
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name39] = shader39;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js
var name40, shader40;
var init_bakedVertexAnimationDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimationDeclaration.js"() {
    init_shaderStore();
    name40 = "bakedVertexAnimationDeclaration";
    shader40 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
uniform float bakedVertexAnimationTime;uniform vec2 bakedVertexAnimationTextureSizeInverted;uniform vec4 bakedVertexAnimationSettings;uniform sampler2D bakedVertexAnimationTexture;
#ifdef INSTANCES
attribute vec4 bakedVertexAnimationSettingsInstanced;
#endif
#define inline
mat4 readMatrixFromRawSamplerVAT(sampler2D smp,float index,float frame)
{float offset=index*4.0;float frameUV=(frame+0.5)*bakedVertexAnimationTextureSizeInverted.y;float dx=bakedVertexAnimationTextureSizeInverted.x;vec4 m0=texture2D(smp,vec2(dx*(offset+0.5),frameUV));vec4 m1=texture2D(smp,vec2(dx*(offset+1.5),frameUV));vec4 m2=texture2D(smp,vec2(dx*(offset+2.5),frameUV));vec4 m3=texture2D(smp,vec2(dx*(offset+3.5),frameUV));return mat4(m0,m1,m2,m3);}
#endif
`;
    ShaderStore.IncludesShadersStore[name40] = shader40;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js
var name41, shader41;
var init_instancesDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesDeclaration.js"() {
    init_shaderStore();
    name41 = "instancesDeclaration";
    shader41 = `#ifdef INSTANCES
attribute vec4 world0;attribute vec4 world1;attribute vec4 world2;attribute vec4 world3;
#ifdef INSTANCESCOLOR
attribute vec4 instanceColor;
#endif
#if defined(THIN_INSTANCES) && !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
attribute vec4 previousWorld0;attribute vec4 previousWorld1;attribute vec4 previousWorld2;attribute vec4 previousWorld3;
#ifdef THIN_INSTANCES
uniform mat4 previousWorld;
#endif
#endif
#else
#if !defined(WORLD_UBO)
uniform mat4 world;
#endif
#if defined(VELOCITY) || defined(PREPASS_VELOCITY)
uniform mat4 previousWorld;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name41] = shader41;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js
var name42, shader42;
var init_prePassVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertexDeclaration.js"() {
    init_shaderStore();
    name42 = "prePassVertexDeclaration";
    shader42 = `#ifdef PREPASS
#ifdef PREPASS_DEPTH
varying vec3 vViewPos;
#endif
#ifdef PREPASS_VELOCITY
uniform mat4 previousViewProjection;varying vec4 vCurrentPosition;varying vec4 vPreviousPosition;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name42] = shader42;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js
var name43, shader43;
var init_samplerVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexDeclaration.js"() {
    init_shaderStore();
    name43 = "samplerVertexDeclaration";
    shader43 = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
varying vec2 v_VARYINGNAME_UV;
#endif
`;
    ShaderStore.IncludesShadersStore[name43] = shader43;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js
var name44, shader44;
var init_bumpVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertexDeclaration.js"() {
    init_shaderStore();
    name44 = "bumpVertexDeclaration";
    shader44 = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL) 
varying mat3 vTBN;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name44] = shader44;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js
var name45, shader45;
var init_clipPlaneVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertexDeclaration.js"() {
    init_shaderStore();
    name45 = "clipPlaneVertexDeclaration";
    shader45 = `#ifdef CLIPPLANE
uniform vec4 vClipPlane;varying float fClipDistance;
#endif
#ifdef CLIPPLANE2
uniform vec4 vClipPlane2;varying float fClipDistance2;
#endif
#ifdef CLIPPLANE3
uniform vec4 vClipPlane3;varying float fClipDistance3;
#endif
#ifdef CLIPPLANE4
uniform vec4 vClipPlane4;varying float fClipDistance4;
#endif
#ifdef CLIPPLANE5
uniform vec4 vClipPlane5;varying float fClipDistance5;
#endif
#ifdef CLIPPLANE6
uniform vec4 vClipPlane6;varying float fClipDistance6;
#endif
`;
    ShaderStore.IncludesShadersStore[name45] = shader45;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js
var name46, shader46;
var init_fogVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertexDeclaration.js"() {
    init_shaderStore();
    name46 = "fogVertexDeclaration";
    shader46 = `#ifdef FOG
varying vec3 vFogDistance;
#endif
`;
    ShaderStore.IncludesShadersStore[name46] = shader46;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js
var name47, shader47;
var init_lightVxFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxFragmentDeclaration.js"() {
    init_shaderStore();
    name47 = "lightVxFragmentDeclaration";
    shader47 = `#ifdef LIGHT{X}
uniform vec4 vLightData{X};uniform vec4 vLightDiffuse{X};
#ifdef SPECULARTERM
uniform vec4 vLightSpecular{X};
#else
vec4 vLightSpecular{X}=vec4(0.);
#endif
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
uniform vec4 shadowsInfo{X};uniform vec2 depthValues{X};
#endif
#ifdef SPOTLIGHT{X}
uniform vec4 vLightDirection{X};uniform vec4 vLightFalloff{X};
#elif defined(POINTLIGHT{X})
uniform vec4 vLightFalloff{X};
#elif defined(HEMILIGHT{X})
uniform vec3 vLightGround{X};
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name47] = shader47;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js
var name48, shader48;
var init_lightVxUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/lightVxUboDeclaration.js"() {
    init_shaderStore();
    name48 = "lightVxUboDeclaration";
    shader48 = `#ifdef LIGHT{X}
uniform Light{X}
{vec4 vLightData;vec4 vLightDiffuse;vec4 vLightSpecular;
#ifdef SPOTLIGHT{X}
vec4 vLightDirection;vec4 vLightFalloff;
#elif defined(POINTLIGHT{X})
vec4 vLightFalloff;
#elif defined(HEMILIGHT{X})
vec3 vLightGround;
#endif
vec4 shadowsInfo;vec2 depthValues;} light{X};
#ifdef SHADOW{X}
#ifdef SHADOWCSM{X}
uniform mat4 lightMatrix{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromLight{X}[SHADOWCSMNUM_CASCADES{X}];varying float vDepthMetric{X}[SHADOWCSMNUM_CASCADES{X}];varying vec4 vPositionFromCamera{X};
#elif defined(SHADOWCUBE{X})
#else
varying vec4 vPositionFromLight{X};varying float vDepthMetric{X};uniform mat4 lightMatrix{X};
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name48] = shader48;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js
var name49, shader49;
var init_morphTargetsVertexGlobalDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobalDeclaration.js"() {
    init_shaderStore();
    name49 = "morphTargetsVertexGlobalDeclaration";
    shader49 = `#ifdef MORPHTARGETS
uniform float morphTargetInfluences[NUM_MORPH_INFLUENCERS];
#ifdef MORPHTARGETS_TEXTURE 
precision mediump sampler2DArray; 
uniform float morphTargetTextureIndices[NUM_MORPH_INFLUENCERS];uniform vec3 morphTargetTextureInfo;uniform sampler2DArray morphTargets;vec3 readVector3FromRawSampler(int targetIndex,float vertexIndex)
{ 
float y=floor(vertexIndex/morphTargetTextureInfo.y);float x=vertexIndex-y*morphTargetTextureInfo.y;vec3 textureUV=vec3((x+0.5)/morphTargetTextureInfo.y,(y+0.5)/morphTargetTextureInfo.z,morphTargetTextureIndices[targetIndex]);return texture(morphTargets,textureUV).xyz;}
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name49] = shader49;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js
var name50, shader50;
var init_morphTargetsVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexDeclaration.js"() {
    init_shaderStore();
    name50 = "morphTargetsVertexDeclaration";
    shader50 = `#ifdef MORPHTARGETS
#ifndef MORPHTARGETS_TEXTURE
attribute vec3 position{X};
#ifdef MORPHTARGETS_NORMAL
attribute vec3 normal{X};
#endif
#ifdef MORPHTARGETS_TANGENT
attribute vec3 tangent{X};
#endif
#ifdef MORPHTARGETS_UV
attribute vec2 uv_{X};
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name50] = shader50;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js
var name51, shader51;
var init_morphTargetsVertexGlobal = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertexGlobal.js"() {
    init_shaderStore();
    name51 = "morphTargetsVertexGlobal";
    shader51 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE
float vertexID;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name51] = shader51;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js
var name52, shader52;
var init_morphTargetsVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/morphTargetsVertex.js"() {
    init_shaderStore();
    name52 = "morphTargetsVertex";
    shader52 = `#ifdef MORPHTARGETS
#ifdef MORPHTARGETS_TEXTURE 
vertexID=float(gl_VertexID)*morphTargetTextureInfo.x;positionUpdated+=(readVector3FromRawSampler({X},vertexID)-position)*morphTargetInfluences[{X}];vertexID+=1.0;
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(readVector3FromRawSampler({X},vertexID) -normal)*morphTargetInfluences[{X}];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(readVector3FromRawSampler({X},vertexID).xy-uv)*morphTargetInfluences[{X}];vertexID+=1.0;
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(readVector3FromRawSampler({X},vertexID) -tangent.xyz)*morphTargetInfluences[{X}];
#endif
#else
positionUpdated+=(position{X}-position)*morphTargetInfluences[{X}];
#ifdef MORPHTARGETS_NORMAL
normalUpdated+=(normal{X}-normal)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_TANGENT
tangentUpdated.xyz+=(tangent{X}-tangent.xyz)*morphTargetInfluences[{X}];
#endif
#ifdef MORPHTARGETS_UV
uvUpdated+=(uv_{X}-uv)*morphTargetInfluences[{X}];
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name52] = shader52;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js
var name53, shader53;
var init_instancesVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/instancesVertex.js"() {
    init_shaderStore();
    name53 = "instancesVertex";
    shader53 = `#ifdef INSTANCES
mat4 finalWorld=mat4(world0,world1,world2,world3);
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=mat4(previousWorld0,previousWorld1,previousWorld2,previousWorld3);
#endif
#ifdef THIN_INSTANCES
finalWorld=world*finalWorld;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
finalPreviousWorld=previousWorld*finalPreviousWorld;
#endif
#endif
#else
mat4 finalWorld=world;
#if defined(PREPASS_VELOCITY) || defined(VELOCITY)
mat4 finalPreviousWorld=previousWorld;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name53] = shader53;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js
var name54, shader54;
var init_bonesVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bonesVertex.js"() {
    init_shaderStore();
    name54 = "bonesVertex";
    shader54 = `#ifndef BAKED_VERTEX_ANIMATION_TEXTURE
#if NUM_BONE_INFLUENCERS>0
mat4 influence;
#ifdef BONETEXTURE
influence=readMatrixFromRawSampler(boneSampler,matricesIndices[0])*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[1])*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[2])*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=readMatrixFromRawSampler(boneSampler,matricesIndices[3])*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[0])*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[1])*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[2])*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=readMatrixFromRawSampler(boneSampler,matricesIndicesExtra[3])*matricesWeightsExtra[3];
#endif
#else
influence=mBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
influence+=mBones[int(matricesIndices[1])]*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
influence+=mBones[int(matricesIndices[2])]*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
influence+=mBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
influence+=mBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
influence+=mBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
influence+=mBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
influence+=mBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
#endif
finalWorld=finalWorld*influence;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name54] = shader54;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js
var name55, shader55;
var init_bakedVertexAnimation = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bakedVertexAnimation.js"() {
    init_shaderStore();
    name55 = "bakedVertexAnimation";
    shader55 = `#ifdef BAKED_VERTEX_ANIMATION_TEXTURE
{
#ifdef INSTANCES
#define BVASNAME bakedVertexAnimationSettingsInstanced
#else
#define BVASNAME bakedVertexAnimationSettings
#endif
float VATStartFrame=BVASNAME.x;float VATEndFrame=BVASNAME.y;float VATOffsetFrame=BVASNAME.z;float VATSpeed=BVASNAME.w;float totalFrames=VATEndFrame-VATStartFrame+1.0;float time=bakedVertexAnimationTime*VATSpeed/totalFrames;float frameCorrection=time<1.0 ? 0.0 : 1.0;float numOfFrames=totalFrames-frameCorrection;float VATFrameNum=fract(time)*numOfFrames;VATFrameNum=mod(VATFrameNum+VATOffsetFrame,numOfFrames);VATFrameNum=floor(VATFrameNum);VATFrameNum+=VATStartFrame+frameCorrection;mat4 VATInfluence;VATInfluence=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[0],VATFrameNum)*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[1],VATFrameNum)*matricesWeights[1];
#endif
#if NUM_BONE_INFLUENCERS>2
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[2],VATFrameNum)*matricesWeights[2];
#endif
#if NUM_BONE_INFLUENCERS>3
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndices[3],VATFrameNum)*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[0],VATFrameNum)*matricesWeightsExtra[0];
#endif
#if NUM_BONE_INFLUENCERS>5
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[1],VATFrameNum)*matricesWeightsExtra[1];
#endif
#if NUM_BONE_INFLUENCERS>6
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[2],VATFrameNum)*matricesWeightsExtra[2];
#endif
#if NUM_BONE_INFLUENCERS>7
VATInfluence+=readMatrixFromRawSamplerVAT(bakedVertexAnimationTexture,matricesIndicesExtra[3],VATFrameNum)*matricesWeightsExtra[3];
#endif
finalWorld=finalWorld*VATInfluence;}
#endif
`;
    ShaderStore.IncludesShadersStore[name55] = shader55;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js
var name56, shader56;
var init_prePassVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/prePassVertex.js"() {
    init_shaderStore();
    name56 = "prePassVertex";
    shader56 = `#ifdef PREPASS_DEPTH
vViewPos=(view*worldPos).rgb;
#endif
#if defined(PREPASS_VELOCITY) && defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*worldPos;
#if NUM_BONE_INFLUENCERS>0
mat4 previousInfluence;previousInfluence=mPreviousBones[int(matricesIndices[0])]*matricesWeights[0];
#if NUM_BONE_INFLUENCERS>1
previousInfluence+=mPreviousBones[int(matricesIndices[1])]*matricesWeights[1];
#endif 
#if NUM_BONE_INFLUENCERS>2
previousInfluence+=mPreviousBones[int(matricesIndices[2])]*matricesWeights[2];
#endif 
#if NUM_BONE_INFLUENCERS>3
previousInfluence+=mPreviousBones[int(matricesIndices[3])]*matricesWeights[3];
#endif
#if NUM_BONE_INFLUENCERS>4
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[0])]*matricesWeightsExtra[0];
#endif 
#if NUM_BONE_INFLUENCERS>5
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[1])]*matricesWeightsExtra[1];
#endif 
#if NUM_BONE_INFLUENCERS>6
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[2])]*matricesWeightsExtra[2];
#endif 
#if NUM_BONE_INFLUENCERS>7
previousInfluence+=mPreviousBones[int(matricesIndicesExtra[3])]*matricesWeightsExtra[3];
#endif
vPreviousPosition=previousViewProjection*finalPreviousWorld*previousInfluence*vec4(positionUpdated,1.0);
#else
vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name56] = shader56;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js
var name57, shader57;
var init_uvVariableDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/uvVariableDeclaration.js"() {
    init_shaderStore();
    name57 = "uvVariableDeclaration";
    shader57 = `#if !defined(UV{X}) && defined(MAINUV{X})
vec2 uv{X}=vec2(0.,0.);
#endif
#ifdef MAINUV{X}
vMainUV{X}=uv{X};
#endif
`;
    ShaderStore.IncludesShadersStore[name57] = shader57;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js
var name58, shader58;
var init_samplerVertexImplementation = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerVertexImplementation.js"() {
    init_shaderStore();
    name58 = "samplerVertexImplementation";
    shader58 = `#if defined(_DEFINENAME_) && _DEFINENAME_DIRECTUV==0
if (v_INFONAME_==0.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uvUpdated,1.0,0.0));}
#ifdef UV2
else if (v_INFONAME_==1.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv2,1.0,0.0));}
#endif
#ifdef UV3
else if (v_INFONAME_==2.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv3,1.0,0.0));}
#endif
#ifdef UV4
else if (v_INFONAME_==3.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv4,1.0,0.0));}
#endif
#ifdef UV5
else if (v_INFONAME_==4.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv5,1.0,0.0));}
#endif
#ifdef UV6
else if (v_INFONAME_==5.)
{v_VARYINGNAME_UV=vec2(_MATRIXNAME_Matrix*vec4(uv6,1.0,0.0));}
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name58] = shader58;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js
var name59, shader59;
var init_bumpVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/bumpVertex.js"() {
    init_shaderStore();
    name59 = "bumpVertex";
    shader59 = `#if defined(BUMP) || defined(PARALLAX) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#if defined(TANGENT) && defined(NORMAL)
vec3 tbnNormal=normalize(normalUpdated);vec3 tbnTangent=normalize(tangentUpdated.xyz);vec3 tbnBitangent=cross(tbnNormal,tbnTangent)*tangentUpdated.w;vTBN=mat3(finalWorld)*mat3(tbnTangent,tbnBitangent,tbnNormal);
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name59] = shader59;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js
var name60, shader60;
var init_clipPlaneVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/clipPlaneVertex.js"() {
    init_shaderStore();
    name60 = "clipPlaneVertex";
    shader60 = `#ifdef CLIPPLANE
fClipDistance=dot(worldPos,vClipPlane);
#endif
#ifdef CLIPPLANE2
fClipDistance2=dot(worldPos,vClipPlane2);
#endif
#ifdef CLIPPLANE3
fClipDistance3=dot(worldPos,vClipPlane3);
#endif
#ifdef CLIPPLANE4
fClipDistance4=dot(worldPos,vClipPlane4);
#endif
#ifdef CLIPPLANE5
fClipDistance5=dot(worldPos,vClipPlane5);
#endif
#ifdef CLIPPLANE6
fClipDistance6=dot(worldPos,vClipPlane6);
#endif
`;
    ShaderStore.IncludesShadersStore[name60] = shader60;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js
var name61, shader61;
var init_fogVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/fogVertex.js"() {
    init_shaderStore();
    name61 = "fogVertex";
    shader61 = `#ifdef FOG
vFogDistance=(view*worldPos).xyz;
#endif
`;
    ShaderStore.IncludesShadersStore[name61] = shader61;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js
var name62, shader62;
var init_shadowsVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/shadowsVertex.js"() {
    init_shaderStore();
    name62 = "shadowsVertex";
    shader62 = `#ifdef SHADOWS
#if defined(SHADOWCSM{X})
vPositionFromCamera{X}=view*worldPos;for (int i=0; i<SHADOWCSMNUM_CASCADES{X}; i++) {vPositionFromLight{X}[i]=lightMatrix{X}[i]*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}[i]=(-vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}[i]=(vPositionFromLight{X}[i].z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
}
#elif defined(SHADOW{X}) && !defined(SHADOWCUBE{X})
vPositionFromLight{X}=lightMatrix{X}*worldPos;
#ifdef USE_REVERSE_DEPTHBUFFER
vDepthMetric{X}=(-vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#else
vDepthMetric{X}=(vPositionFromLight{X}.z+light{X}.depthValues.x)/light{X}.depthValues.y;
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name62] = shader62;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js
var name63, shader63;
var init_vertexColorMixing = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/vertexColorMixing.js"() {
    init_shaderStore();
    name63 = "vertexColorMixing";
    shader63 = `#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
vColor=vec4(1.0);
#ifdef VERTEXCOLOR
#ifdef VERTEXALPHA
vColor*=color;
#else
vColor.rgb*=color.rgb;
#endif
#endif
#ifdef INSTANCESCOLOR
vColor*=instanceColor;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name63] = shader63;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js
var name64, shader64;
var init_pointCloudVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pointCloudVertex.js"() {
    init_shaderStore();
    name64 = "pointCloudVertex";
    shader64 = `#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
`;
    ShaderStore.IncludesShadersStore[name64] = shader64;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js
var name65, shader65;
var init_logDepthVertex = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/logDepthVertex.js"() {
    init_shaderStore();
    name65 = "logDepthVertex";
    shader65 = `#ifdef LOGARITHMICDEPTH
vFragmentDepth=1.0+gl_Position.w;gl_Position.z=log2(max(0.000001,vFragmentDepth))*logarithmicDepthConstant;
#endif
`;
    ShaderStore.IncludesShadersStore[name65] = shader65;
  }
});

// node_modules/@babylonjs/core/Shaders/default.vertex.js
var name66, shader66;
var init_default_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/default.vertex.js"() {
    init_shaderStore();
    init_defaultVertexDeclaration();
    init_defaultUboDeclaration();
    init_uvAttributeDeclaration();
    init_helperFunctions();
    init_bonesDeclaration();
    init_bakedVertexAnimationDeclaration();
    init_instancesDeclaration();
    init_prePassVertexDeclaration();
    init_mainUVVaryingDeclaration();
    init_samplerVertexDeclaration();
    init_bumpVertexDeclaration();
    init_clipPlaneVertexDeclaration();
    init_fogVertexDeclaration();
    init_lightVxFragmentDeclaration();
    init_lightVxUboDeclaration();
    init_morphTargetsVertexGlobalDeclaration();
    init_morphTargetsVertexDeclaration();
    init_logDepthDeclaration();
    init_morphTargetsVertexGlobal();
    init_morphTargetsVertex();
    init_instancesVertex();
    init_bonesVertex();
    init_bakedVertexAnimation();
    init_prePassVertex();
    init_uvVariableDeclaration();
    init_samplerVertexImplementation();
    init_bumpVertex();
    init_clipPlaneVertex();
    init_fogVertex();
    init_shadowsVertex();
    init_vertexColorMixing();
    init_pointCloudVertex();
    init_logDepthVertex();
    name66 = "defaultVertexShader";
    shader66 = `#include<__decl__defaultVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<mainUVVaryingDeclaration>[1..7]
#include<samplerVertexDeclaration>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#if defined(SPECULARTERM)
#include<samplerVertexDeclaration>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular)
#endif
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
varying vec3 vPositionW;
#ifdef NORMAL
varying vec3 vNormalW;
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
vPositionW=vec3(worldPos);
#include<prePassVertex>
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,DIFFUSE,_VARYINGNAME_,Diffuse,_MATRIXNAME_,diffuse,_INFONAME_,DiffuseInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#if defined(SPECULARTERM)
#include<samplerVertexImplementation>(_DEFINENAME_,SPECULAR,_VARYINGNAME_,Specular,_MATRIXNAME_,specular,_INFONAME_,SpecularInfos.x)
#endif
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#include<pointCloudVertex>
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}
`;
    ShaderStore.ShadersStore[name66] = shader66;
  }
});

// node_modules/@babylonjs/core/Materials/standardMaterial.js
var onCreatedEffectParameters, StandardMaterialDefines, StandardMaterial;
var init_standardMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/standardMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_smartArray();
    init_scene();
    init_math_vector();
    init_math_color();
    init_buffer();
    init_prePassConfiguration();
    init_imageProcessingConfiguration();
    init_material();
    init_materialPluginEvent();
    init_materialDefines();
    init_pushMaterial();
    init_materialHelper();
    init_texture();
    init_typeStore();
    init_materialFlags();
    init_default_fragment();
    init_default_vertex();
    init_effectFallbacks();
    init_material_detailMapConfiguration();
    init_clipPlaneMaterialHelper();
    onCreatedEffectParameters = { effect: null, subMesh: null };
    StandardMaterialDefines = class extends MaterialDefines {
      constructor(externalProperties) {
        super(externalProperties);
        this.MAINUV1 = false;
        this.MAINUV2 = false;
        this.MAINUV3 = false;
        this.MAINUV4 = false;
        this.MAINUV5 = false;
        this.MAINUV6 = false;
        this.DIFFUSE = false;
        this.DIFFUSEDIRECTUV = 0;
        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        this.AMBIENT = false;
        this.AMBIENTDIRECTUV = 0;
        this.OPACITY = false;
        this.OPACITYDIRECTUV = 0;
        this.OPACITYRGB = false;
        this.REFLECTION = false;
        this.EMISSIVE = false;
        this.EMISSIVEDIRECTUV = 0;
        this.SPECULAR = false;
        this.SPECULARDIRECTUV = 0;
        this.BUMP = false;
        this.BUMPDIRECTUV = 0;
        this.PARALLAX = false;
        this.PARALLAXOCCLUSION = false;
        this.SPECULAROVERALPHA = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.ALPHATEST = false;
        this.DEPTHPREPASS = false;
        this.ALPHAFROMDIFFUSE = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.SPECULARTERM = false;
        this.DIFFUSEFRESNEL = false;
        this.OPACITYFRESNEL = false;
        this.REFLECTIONFRESNEL = false;
        this.REFRACTIONFRESNEL = false;
        this.EMISSIVEFRESNEL = false;
        this.FRESNEL = false;
        this.NORMAL = false;
        this.TANGENT = false;
        this.UV1 = false;
        this.UV2 = false;
        this.UV3 = false;
        this.UV4 = false;
        this.UV5 = false;
        this.UV6 = false;
        this.VERTEXCOLOR = false;
        this.VERTEXALPHA = false;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.BONES_VELOCITY_ENABLED = false;
        this.INSTANCES = false;
        this.THIN_INSTANCES = false;
        this.INSTANCESCOLOR = false;
        this.GLOSSINESS = false;
        this.ROUGHNESS = false;
        this.EMISSIVEASILLUMINATION = false;
        this.LINKEMISSIVEWITHDIFFUSE = false;
        this.REFLECTIONFRESNELFROMSPECULAR = false;
        this.LIGHTMAP = false;
        this.LIGHTMAPDIRECTUV = 0;
        this.OBJECTSPACE_NORMALMAP = false;
        this.USELIGHTMAPASSHADOWMAP = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.INVERTCUBICMAP = false;
        this.LOGARITHMICDEPTH = false;
        this.REFRACTION = false;
        this.REFRACTIONMAP_3D = false;
        this.REFLECTIONOVERALPHA = false;
        this.TWOSIDEDLIGHTING = false;
        this.SHADOWFLOAT = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.NONUNIFORMSCALING = false;
        this.PREMULTIPLYALPHA = false;
        this.ALPHATEST_AFTERALLALPHACOMPUTATIONS = false;
        this.ALPHABLEND = true;
        this.PREPASS = false;
        this.PREPASS_IRRADIANCE = false;
        this.PREPASS_IRRADIANCE_INDEX = -1;
        this.PREPASS_ALBEDO_SQRT = false;
        this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_NORMAL_WORLDSPACE = false;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_VELOCITY = false;
        this.PREPASS_VELOCITY_INDEX = -1;
        this.PREPASS_REFLECTIVITY = false;
        this.PREPASS_REFLECTIVITY_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.RGBDLIGHTMAP = false;
        this.RGBDREFLECTION = false;
        this.RGBDREFRACTION = false;
        this.IMAGEPROCESSING = false;
        this.VIGNETTE = false;
        this.VIGNETTEBLENDMODEMULTIPLY = false;
        this.VIGNETTEBLENDMODEOPAQUE = false;
        this.TONEMAPPING = false;
        this.TONEMAPPING_ACES = false;
        this.CONTRAST = false;
        this.COLORCURVES = false;
        this.COLORGRADING = false;
        this.COLORGRADING3D = false;
        this.SAMPLER3DGREENDEPTH = false;
        this.SAMPLER3DBGRMAP = false;
        this.DITHER = false;
        this.IMAGEPROCESSINGPOSTPROCESS = false;
        this.SKIPFINALCOLORCLAMP = false;
        this.MULTIVIEW = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.IS_REFLECTION_LINEAR = false;
        this.IS_REFRACTION_LINEAR = false;
        this.EXPOSURE = false;
        this.DECAL_AFTER_DETAIL = false;
        this.rebuild();
      }
      setReflectionMode(modeToEnable) {
        const modes = [
          "REFLECTIONMAP_CUBIC",
          "REFLECTIONMAP_EXPLICIT",
          "REFLECTIONMAP_PLANAR",
          "REFLECTIONMAP_PROJECTION",
          "REFLECTIONMAP_PROJECTION",
          "REFLECTIONMAP_SKYBOX",
          "REFLECTIONMAP_SPHERICAL",
          "REFLECTIONMAP_EQUIRECTANGULAR",
          "REFLECTIONMAP_EQUIRECTANGULAR_FIXED",
          "REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED"
        ];
        for (const mode of modes) {
          this[mode] = mode === modeToEnable;
        }
      }
    };
    StandardMaterial = class extends PushMaterial {
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      set imageProcessingConfiguration(value) {
        this._attachImageProcessingConfiguration(value);
        this._markAllSubMeshesAsTexturesDirty();
      }
      _attachImageProcessingConfiguration(configuration) {
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
            this._markAllSubMeshesAsImageProcessingDirty();
          });
        }
      }
      get isPrePassCapable() {
        return !this.disableDepthWrite;
      }
      get cameraColorCurvesEnabled() {
        return this.imageProcessingConfiguration.colorCurvesEnabled;
      }
      set cameraColorCurvesEnabled(value) {
        this.imageProcessingConfiguration.colorCurvesEnabled = value;
      }
      get cameraColorGradingEnabled() {
        return this.imageProcessingConfiguration.colorGradingEnabled;
      }
      set cameraColorGradingEnabled(value) {
        this.imageProcessingConfiguration.colorGradingEnabled = value;
      }
      get cameraToneMappingEnabled() {
        return this._imageProcessingConfiguration.toneMappingEnabled;
      }
      set cameraToneMappingEnabled(value) {
        this._imageProcessingConfiguration.toneMappingEnabled = value;
      }
      get cameraExposure() {
        return this._imageProcessingConfiguration.exposure;
      }
      set cameraExposure(value) {
        this._imageProcessingConfiguration.exposure = value;
      }
      get cameraContrast() {
        return this._imageProcessingConfiguration.contrast;
      }
      set cameraContrast(value) {
        this._imageProcessingConfiguration.contrast = value;
      }
      get cameraColorGradingTexture() {
        return this._imageProcessingConfiguration.colorGradingTexture;
      }
      set cameraColorGradingTexture(value) {
        this._imageProcessingConfiguration.colorGradingTexture = value;
      }
      get cameraColorCurves() {
        return this._imageProcessingConfiguration.colorCurves;
      }
      set cameraColorCurves(value) {
        this._imageProcessingConfiguration.colorCurves = value;
      }
      get canRenderToMRT() {
        return true;
      }
      constructor(name109, scene) {
        super(name109, scene);
        this._diffuseTexture = null;
        this._ambientTexture = null;
        this._opacityTexture = null;
        this._reflectionTexture = null;
        this._emissiveTexture = null;
        this._specularTexture = null;
        this._bumpTexture = null;
        this._lightmapTexture = null;
        this._refractionTexture = null;
        this.ambientColor = new Color3(0, 0, 0);
        this.diffuseColor = new Color3(1, 1, 1);
        this.specularColor = new Color3(1, 1, 1);
        this.emissiveColor = new Color3(0, 0, 0);
        this.specularPower = 64;
        this._useAlphaFromDiffuseTexture = false;
        this._useEmissiveAsIllumination = false;
        this._linkEmissiveWithDiffuse = false;
        this._useSpecularOverAlpha = false;
        this._useReflectionOverAlpha = false;
        this._disableLighting = false;
        this._useObjectSpaceNormalMap = false;
        this._useParallax = false;
        this._useParallaxOcclusion = false;
        this.parallaxScaleBias = 0.05;
        this._roughness = 0;
        this.indexOfRefraction = 0.98;
        this.invertRefractionY = true;
        this.alphaCutOff = 0.4;
        this._useLightmapAsShadowmap = false;
        this._useReflectionFresnelFromSpecular = false;
        this._useGlossinessFromSpecularMapAlpha = false;
        this._maxSimultaneousLights = 4;
        this._invertNormalMapX = false;
        this._invertNormalMapY = false;
        this._twoSidedLighting = false;
        this._applyDecalMapAfterDetailMap = false;
        this._renderTargets = new SmartArray(16);
        this._worldViewProjectionMatrix = Matrix.Zero();
        this._globalAmbientColor = new Color3(0, 0, 0);
        this._cacheHasRenderTargetTextures = false;
        this.detailMap = new DetailMapConfiguration(this);
        this._attachImageProcessingConfiguration(null);
        this.prePassConfiguration = new PrePassConfiguration();
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._renderTargets.push(this._reflectionTexture);
          }
          if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
            this._renderTargets.push(this._refractionTexture);
          }
          this._eventInfo.renderTargets = this._renderTargets;
          this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
          return this._renderTargets;
        };
      }
      get hasRenderTargetTextures() {
        if (StandardMaterial.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          return true;
        }
        if (StandardMaterial.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          return true;
        }
        return this._cacheHasRenderTargetTextures;
      }
      getClassName() {
        return "StandardMaterial";
      }
      get useLogarithmicDepth() {
        return this._useLogarithmicDepth;
      }
      set useLogarithmicDepth(value) {
        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
        this._markAllSubMeshesAsMiscDirty();
      }
      needAlphaBlending() {
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromDiffuseTexture() || this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
      }
      needAlphaTesting() {
        if (this._forceAlphaTest) {
          return true;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === Material.MATERIAL_ALPHATEST);
      }
      _shouldUseAlphaFromDiffuseTexture() {
        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha && this._useAlphaFromDiffuseTexture && this._transparencyMode !== Material.MATERIAL_OPAQUE;
      }
      _hasAlphaChannel() {
        return this._diffuseTexture != null && this._diffuseTexture.hasAlpha || this._opacityTexture != null;
      }
      getAlphaTestTexture() {
        return this._diffuseTexture;
      }
      isReadyForSubMesh(mesh, subMesh, useInstances = false) {
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        if (subMesh.effect && this.isFrozen) {
          if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
          subMesh.materialDefines = new StandardMaterialDefines(this._eventInfo.defineNames);
        }
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const engine = scene.getEngine();
        defines._needNormals = MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        MaterialHelper.PrepareDefinesForMultiview(scene, defines);
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          defines._needUVs = false;
          for (let i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            defines.DIFFUSEDIRECTUV = 0;
            defines.BUMPDIRECTUV = 0;
            defines.AMBIENTDIRECTUV = 0;
            defines.OPACITYDIRECTUV = 0;
            defines.EMISSIVEDIRECTUV = 0;
            defines.SPECULARDIRECTUV = 0;
            defines.LIGHTMAPDIRECTUV = 0;
            if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {
              if (!this._diffuseTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._diffuseTexture, defines, "DIFFUSE");
              }
            } else {
              defines.DIFFUSE = false;
            }
            if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              }
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
                defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
              }
            } else {
              defines.OPACITY = false;
            }
            if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {
              if (!this._reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                defines._needNormals = true;
                defines.REFLECTION = true;
                defines.ROUGHNESS = this._roughness > 0;
                defines.REFLECTIONOVERALPHA = this._useReflectionOverAlpha;
                defines.INVERTCUBICMAP = this._reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
                defines.REFLECTIONMAP_3D = this._reflectionTexture.isCube;
                defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !this._reflectionTexture.invertZ : this._reflectionTexture.invertZ;
                defines.RGBDREFLECTION = this._reflectionTexture.isRGBD;
                switch (this._reflectionTexture.coordinatesMode) {
                  case Texture.EXPLICIT_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_EXPLICIT");
                    break;
                  case Texture.PLANAR_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_PLANAR");
                    break;
                  case Texture.PROJECTION_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_PROJECTION");
                    break;
                  case Texture.SKYBOX_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_SKYBOX");
                    break;
                  case Texture.SPHERICAL_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_SPHERICAL");
                    break;
                  case Texture.EQUIRECTANGULAR_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR");
                    break;
                  case Texture.FIXED_EQUIRECTANGULAR_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_EQUIRECTANGULAR_FIXED");
                    break;
                  case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                    defines.setReflectionMode("REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED");
                    break;
                  case Texture.CUBIC_MODE:
                  case Texture.INVCUBIC_MODE:
                  default:
                    defines.setReflectionMode("REFLECTIONMAP_CUBIC");
                    break;
                }
                defines.USE_LOCAL_REFLECTIONMAP_CUBIC = this._reflectionTexture.boundingBoxSize ? true : false;
              }
            } else {
              defines.REFLECTION = false;
              defines.REFLECTIONMAP_OPPOSITEZ = false;
            }
            if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              }
            } else {
              defines.EMISSIVE = false;
            }
            if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
                defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
                defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
              }
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {
              if (!this._specularTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._specularTexture, defines, "SPECULAR");
                defines.GLOSSINESS = this._useGlossinessFromSpecularMapAlpha;
              }
            } else {
              defines.SPECULAR = false;
            }
            if (scene.getEngine().getCaps().standardDerivatives && this._bumpTexture && StandardMaterial.BumpTextureEnabled) {
              if (!this._bumpTexture.isReady()) {
                return false;
              } else {
                MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
                defines.PARALLAX = this._useParallax;
                defines.PARALLAXOCCLUSION = this._useParallaxOcclusion;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
              defines.PARALLAX = false;
              defines.PARALLAXOCCLUSION = false;
            }
            if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {
              if (!this._refractionTexture.isReadyOrNotBlocking()) {
                return false;
              } else {
                defines._needUVs = true;
                defines.REFRACTION = true;
                defines.REFRACTIONMAP_3D = this._refractionTexture.isCube;
                defines.RGBDREFRACTION = this._refractionTexture.isRGBD;
                defines.USE_LOCAL_REFRACTIONMAP_CUBIC = this._refractionTexture.boundingBoxSize ? true : false;
              }
            } else {
              defines.REFRACTION = false;
            }
            defines.TWOSIDEDLIGHTING = !this._backFaceCulling && this._twoSidedLighting;
          } else {
            defines.DIFFUSE = false;
            defines.AMBIENT = false;
            defines.OPACITY = false;
            defines.REFLECTION = false;
            defines.EMISSIVE = false;
            defines.LIGHTMAP = false;
            defines.BUMP = false;
            defines.REFRACTION = false;
          }
          defines.ALPHAFROMDIFFUSE = this._shouldUseAlphaFromDiffuseTexture();
          defines.EMISSIVEASILLUMINATION = this._useEmissiveAsIllumination;
          defines.LINKEMISSIVEWITHDIFFUSE = this._linkEmissiveWithDiffuse;
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHATEST_AFTERALLALPHACOMPUTATIONS = this.transparencyMode !== null;
          defines.ALPHABLEND = this.transparencyMode === null || this.needAlphaBlendingForMesh(mesh);
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
          this._imageProcessingConfiguration.prepareDefines(defines);
          defines.IS_REFLECTION_LINEAR = this.reflectionTexture != null && !this.reflectionTexture.gammaSpace;
          defines.IS_REFRACTION_LINEAR = this.refractionTexture != null && !this.refractionTexture.gammaSpace;
        }
        if (defines._areFresnelDirty) {
          if (StandardMaterial.FresnelEnabled) {
            if (this._diffuseFresnelParameters || this._opacityFresnelParameters || this._emissiveFresnelParameters || this._refractionFresnelParameters || this._reflectionFresnelParameters) {
              defines.DIFFUSEFRESNEL = this._diffuseFresnelParameters && this._diffuseFresnelParameters.isEnabled;
              defines.OPACITYFRESNEL = this._opacityFresnelParameters && this._opacityFresnelParameters.isEnabled;
              defines.REFLECTIONFRESNEL = this._reflectionFresnelParameters && this._reflectionFresnelParameters.isEnabled;
              defines.REFLECTIONFRESNELFROMSPECULAR = this._useReflectionFresnelFromSpecular;
              defines.REFRACTIONFRESNEL = this._refractionFresnelParameters && this._refractionFresnelParameters.isEnabled;
              defines.EMISSIVEFRESNEL = this._emissiveFresnelParameters && this._emissiveFresnelParameters.isEnabled;
              defines._needNormals = true;
              defines.FRESNEL = true;
            }
          } else {
            defines.FRESNEL = false;
          }
        }
        MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines, this._applyDecalMapAfterDetailMap);
        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true);
        this._callbackPluginEventPrepareDefines(this._eventInfo);
        let forceWasNotReadyPreviously = false;
        if (defines.isDirty) {
          const lightDisposed = defines._areLightsDisposed;
          defines.markAsProcessed();
          const fallbacks = new EffectFallbacks();
          if (defines.REFLECTION) {
            fallbacks.addFallback(0, "REFLECTION");
          }
          if (defines.SPECULAR) {
            fallbacks.addFallback(0, "SPECULAR");
          }
          if (defines.BUMP) {
            fallbacks.addFallback(0, "BUMP");
          }
          if (defines.PARALLAX) {
            fallbacks.addFallback(1, "PARALLAX");
          }
          if (defines.PARALLAXOCCLUSION) {
            fallbacks.addFallback(0, "PARALLAXOCCLUSION");
          }
          if (defines.SPECULAROVERALPHA) {
            fallbacks.addFallback(0, "SPECULAROVERALPHA");
          }
          if (defines.FOG) {
            fallbacks.addFallback(1, "FOG");
          }
          if (defines.POINTSIZE) {
            fallbacks.addFallback(0, "POINTSIZE");
          }
          if (defines.LOGARITHMICDEPTH) {
            fallbacks.addFallback(0, "LOGARITHMICDEPTH");
          }
          MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights);
          if (defines.SPECULARTERM) {
            fallbacks.addFallback(0, "SPECULARTERM");
          }
          if (defines.DIFFUSEFRESNEL) {
            fallbacks.addFallback(1, "DIFFUSEFRESNEL");
          }
          if (defines.OPACITYFRESNEL) {
            fallbacks.addFallback(2, "OPACITYFRESNEL");
          }
          if (defines.REFLECTIONFRESNEL) {
            fallbacks.addFallback(3, "REFLECTIONFRESNEL");
          }
          if (defines.EMISSIVEFRESNEL) {
            fallbacks.addFallback(4, "EMISSIVEFRESNEL");
          }
          if (defines.FRESNEL) {
            fallbacks.addFallback(4, "FRESNEL");
          }
          if (defines.MULTIVIEW) {
            fallbacks.addFallback(0, "MULTIVIEW");
          }
          const attribs = [VertexBuffer.PositionKind];
          if (defines.NORMAL) {
            attribs.push(VertexBuffer.NormalKind);
          }
          if (defines.TANGENT) {
            attribs.push(VertexBuffer.TangentKind);
          }
          for (let i = 1; i <= 6; ++i) {
            if (defines["UV" + i]) {
              attribs.push(`uv${i === 1 ? "" : i}`);
            }
          }
          if (defines.VERTEXCOLOR) {
            attribs.push(VertexBuffer.ColorKind);
          }
          MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
          MaterialHelper.PrepareAttributesForInstances(attribs, defines);
          MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
          MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
          let shaderName = "default";
          const uniforms = [
            "world",
            "view",
            "viewProjection",
            "vEyePosition",
            "vLightsType",
            "vAmbientColor",
            "vDiffuseColor",
            "vSpecularColor",
            "vEmissiveColor",
            "visibility",
            "vFogInfos",
            "vFogColor",
            "pointSize",
            "vDiffuseInfos",
            "vAmbientInfos",
            "vOpacityInfos",
            "vReflectionInfos",
            "vEmissiveInfos",
            "vSpecularInfos",
            "vBumpInfos",
            "vLightmapInfos",
            "vRefractionInfos",
            "mBones",
            "diffuseMatrix",
            "ambientMatrix",
            "opacityMatrix",
            "reflectionMatrix",
            "emissiveMatrix",
            "specularMatrix",
            "bumpMatrix",
            "normalMatrix",
            "lightmapMatrix",
            "refractionMatrix",
            "diffuseLeftColor",
            "diffuseRightColor",
            "opacityParts",
            "reflectionLeftColor",
            "reflectionRightColor",
            "emissiveLeftColor",
            "emissiveRightColor",
            "refractionLeftColor",
            "refractionRightColor",
            "vReflectionPosition",
            "vReflectionSize",
            "vRefractionPosition",
            "vRefractionSize",
            "logarithmicDepthConstant",
            "vTangentSpaceParams",
            "alphaCutOff",
            "boneTextureWidth",
            "morphTargetTextureInfo",
            "morphTargetTextureIndices"
          ];
          const samplers = [
            "diffuseSampler",
            "ambientSampler",
            "opacitySampler",
            "reflectionCubeSampler",
            "reflection2DSampler",
            "emissiveSampler",
            "specularSampler",
            "bumpSampler",
            "lightmapSampler",
            "refractionCubeSampler",
            "refraction2DSampler",
            "boneSampler",
            "morphTargets",
            "oitDepthSampler",
            "oitFrontColorSampler"
          ];
          const uniformBuffers = ["Material", "Scene", "Mesh"];
          const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
          this._eventInfo.fallbacks = fallbacks;
          this._eventInfo.fallbackRank = 0;
          this._eventInfo.defines = defines;
          this._eventInfo.uniforms = uniforms;
          this._eventInfo.attributes = attribs;
          this._eventInfo.samplers = samplers;
          this._eventInfo.uniformBuffersNames = uniformBuffers;
          this._eventInfo.customCode = void 0;
          this._eventInfo.mesh = mesh;
          this._eventInfo.indexParameters = indexParameters;
          this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
          PrePassConfiguration.AddUniforms(uniforms);
          PrePassConfiguration.AddSamplers(samplers);
          if (ImageProcessingConfiguration) {
            ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
            ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
          }
          MaterialHelper.PrepareUniformsAndSamplersList({
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines,
            maxSimultaneousLights: this._maxSimultaneousLights
          });
          addClipPlaneUniforms(uniforms);
          const csnrOptions = {};
          if (this.customShaderNameResolve) {
            shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
          }
          const join = defines.toString();
          const previousEffect = subMesh.effect;
          let effect = scene.getEngine().createEffect(shaderName, {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters,
            processFinalCode: csnrOptions.processFinalCode,
            processCodeAfterIncludes: this._eventInfo.customCode,
            multiTarget: defines.PREPASS
          }, engine);
          this._eventInfo.customCode = void 0;
          if (effect) {
            if (this._onEffectCreatedObservable) {
              onCreatedEffectParameters.effect = effect;
              onCreatedEffectParameters.subMesh = subMesh;
              this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters);
            }
            if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
              effect = previousEffect;
              defines.markAsUnprocessed();
              forceWasNotReadyPreviously = this.isFrozen;
              if (lightDisposed) {
                defines._areLightsDisposed = true;
                return false;
              }
            } else {
              scene.resetCachedMaterial();
              subMesh.setEffect(effect, defines, this._materialContext);
            }
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        subMesh.effect._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
        subMesh.effect._wasPreviouslyUsingInstances = useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        ubo.addUniform("diffuseLeftColor", 4);
        ubo.addUniform("diffuseRightColor", 4);
        ubo.addUniform("opacityParts", 4);
        ubo.addUniform("reflectionLeftColor", 4);
        ubo.addUniform("reflectionRightColor", 4);
        ubo.addUniform("refractionLeftColor", 4);
        ubo.addUniform("refractionRightColor", 4);
        ubo.addUniform("emissiveLeftColor", 4);
        ubo.addUniform("emissiveRightColor", 4);
        ubo.addUniform("vDiffuseInfos", 2);
        ubo.addUniform("vAmbientInfos", 2);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vReflectionInfos", 2);
        ubo.addUniform("vReflectionPosition", 3);
        ubo.addUniform("vReflectionSize", 3);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vSpecularInfos", 2);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("diffuseMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("reflectionMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("specularMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("alphaCutOff", 1);
        ubo.addUniform("refractionMatrix", 16);
        ubo.addUniform("vRefractionInfos", 4);
        ubo.addUniform("vRefractionPosition", 3);
        ubo.addUniform("vRefractionSize", 3);
        ubo.addUniform("vSpecularColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vDiffuseColor", 4);
        ubo.addUniform("vAmbientColor", 3);
        super.buildUniformLayout();
      }
      bindForSubMesh(world, mesh, subMesh) {
        var _a;
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        const mustRebind = effect._forceRebindOnNextCall || this._mustRebind(scene, effect, mesh.visibility);
        MaterialHelper.BindBonesParameters(mesh, effect);
        const ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || effect._forceRebindOnNextCall) {
            if (StandardMaterial.FresnelEnabled && defines.FRESNEL) {
              if (this.diffuseFresnelParameters && this.diffuseFresnelParameters.isEnabled) {
                ubo.updateColor4("diffuseLeftColor", this.diffuseFresnelParameters.leftColor, this.diffuseFresnelParameters.power);
                ubo.updateColor4("diffuseRightColor", this.diffuseFresnelParameters.rightColor, this.diffuseFresnelParameters.bias);
              }
              if (this.opacityFresnelParameters && this.opacityFresnelParameters.isEnabled) {
                ubo.updateColor4("opacityParts", new Color3(this.opacityFresnelParameters.leftColor.toLuminance(), this.opacityFresnelParameters.rightColor.toLuminance(), this.opacityFresnelParameters.bias), this.opacityFresnelParameters.power);
              }
              if (this.reflectionFresnelParameters && this.reflectionFresnelParameters.isEnabled) {
                ubo.updateColor4("reflectionLeftColor", this.reflectionFresnelParameters.leftColor, this.reflectionFresnelParameters.power);
                ubo.updateColor4("reflectionRightColor", this.reflectionFresnelParameters.rightColor, this.reflectionFresnelParameters.bias);
              }
              if (this.refractionFresnelParameters && this.refractionFresnelParameters.isEnabled) {
                ubo.updateColor4("refractionLeftColor", this.refractionFresnelParameters.leftColor, this.refractionFresnelParameters.power);
                ubo.updateColor4("refractionRightColor", this.refractionFresnelParameters.rightColor, this.refractionFresnelParameters.bias);
              }
              if (this.emissiveFresnelParameters && this.emissiveFresnelParameters.isEnabled) {
                ubo.updateColor4("emissiveLeftColor", this.emissiveFresnelParameters.leftColor, this.emissiveFresnelParameters.power);
                ubo.updateColor4("emissiveRightColor", this.emissiveFresnelParameters.rightColor, this.emissiveFresnelParameters.bias);
              }
            }
            if (scene.texturesEnabled) {
              if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {
                ubo.updateFloat2("vDiffuseInfos", this._diffuseTexture.coordinatesIndex, this._diffuseTexture.level);
                MaterialHelper.BindTextureMatrix(this._diffuseTexture, ubo, "diffuse");
              }
              if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {
                ubo.updateFloat2("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level);
                MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (this._hasAlphaChannel()) {
                ubo.updateFloat("alphaCutOff", this.alphaCutOff);
              }
              if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {
                ubo.updateFloat2("vReflectionInfos", this._reflectionTexture.level, this.roughness);
                ubo.updateMatrix("reflectionMatrix", this._reflectionTexture.getReflectionTextureMatrix());
                if (this._reflectionTexture.boundingBoxSize) {
                  const cubeTexture = this._reflectionTexture;
                  ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
                }
              }
              if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {
                ubo.updateFloat2("vSpecularInfos", this._specularTexture.coordinatesIndex, this._specularTexture.level);
                MaterialHelper.BindTextureMatrix(this._specularTexture, ubo, "specular");
              }
              if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, 1 / this._bumpTexture.level, this.parallaxScaleBias);
                MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
              if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {
                let depth = 1;
                if (!this._refractionTexture.isCube) {
                  ubo.updateMatrix("refractionMatrix", this._refractionTexture.getReflectionTextureMatrix());
                  if (this._refractionTexture.depth) {
                    depth = this._refractionTexture.depth;
                  }
                }
                ubo.updateFloat4("vRefractionInfos", this._refractionTexture.level, this.indexOfRefraction, depth, this.invertRefractionY ? -1 : 1);
                if (this._refractionTexture.boundingBoxSize) {
                  const cubeTexture = this._refractionTexture;
                  ubo.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
                }
              }
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            if (defines.SPECULARTERM) {
              ubo.updateColor4("vSpecularColor", this.specularColor, this.specularPower);
            }
            ubo.updateColor3("vEmissiveColor", StandardMaterial.EmissiveTextureEnabled ? this.emissiveColor : Color3.BlackReadOnly);
            ubo.updateColor4("vDiffuseColor", this.diffuseColor, this.alpha);
            scene.ambientColor.multiplyToRef(this.ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
          }
          if (scene.texturesEnabled) {
            if (this._diffuseTexture && StandardMaterial.DiffuseTextureEnabled) {
              effect.setTexture("diffuseSampler", this._diffuseTexture);
            }
            if (this._ambientTexture && StandardMaterial.AmbientTextureEnabled) {
              effect.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && StandardMaterial.OpacityTextureEnabled) {
              effect.setTexture("opacitySampler", this._opacityTexture);
            }
            if (this._reflectionTexture && StandardMaterial.ReflectionTextureEnabled) {
              if (this._reflectionTexture.isCube) {
                effect.setTexture("reflectionCubeSampler", this._reflectionTexture);
              } else {
                effect.setTexture("reflection2DSampler", this._reflectionTexture);
              }
            }
            if (this._emissiveTexture && StandardMaterial.EmissiveTextureEnabled) {
              effect.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && StandardMaterial.LightmapTextureEnabled) {
              effect.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (this._specularTexture && StandardMaterial.SpecularTextureEnabled) {
              effect.setTexture("specularSampler", this._specularTexture);
            }
            if (this._bumpTexture && scene.getEngine().getCaps().standardDerivatives && StandardMaterial.BumpTextureEnabled) {
              effect.setTexture("bumpSampler", this._bumpTexture);
            }
            if (this._refractionTexture && StandardMaterial.RefractionTextureEnabled) {
              if (this._refractionTexture.isCube) {
                effect.setTexture("refractionCubeSampler", this._refractionTexture);
              } else {
                effect.setTexture("refraction2DSampler", this._refractionTexture);
              }
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          bindClipPlane(effect, this, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            MaterialHelper.BindLights(scene, mesh, effect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || this._reflectionTexture || this._refractionTexture || mesh.receiveShadows || defines.PREPASS) {
            this.bindView(effect);
          }
          MaterialHelper.BindFogParameters(scene, mesh, effect);
          if (defines.NUM_MORPH_INFLUENCERS) {
            MaterialHelper.BindMorphTargetParameters(mesh, effect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, defines.INSTANCES);
          }
          if (this.useLogarithmicDepth) {
            MaterialHelper.BindLogDepth(defines, effect, scene);
          }
          if (this._imageProcessingConfiguration && !this._imageProcessingConfiguration.applyByPostProcess) {
            this._imageProcessingConfiguration.bind(this._activeEffect);
          }
        }
        this._afterBind(mesh, this._activeEffect);
        ubo.update();
      }
      getAnimatables() {
        const results = super.getAnimatables();
        if (this._diffuseTexture && this._diffuseTexture.animations && this._diffuseTexture.animations.length > 0) {
          results.push(this._diffuseTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._specularTexture && this._specularTexture.animations && this._specularTexture.animations.length > 0) {
          results.push(this._specularTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          results.push(this._refractionTexture);
        }
        return results;
      }
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        if (this._diffuseTexture) {
          activeTextures.push(this._diffuseTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._specularTexture) {
          activeTextures.push(this._specularTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
        return activeTextures;
      }
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (this._diffuseTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._emissiveTexture === texture) {
          return true;
        }
        if (this._specularTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        return false;
      }
      dispose(forceDisposeEffect, forceDisposeTextures) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j;
        if (forceDisposeTextures) {
          (_a = this._diffuseTexture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
          (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
          (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
          (_f = this._specularTexture) === null || _f === void 0 ? void 0 : _f.dispose();
          (_g = this._bumpTexture) === null || _g === void 0 ? void 0 : _g.dispose();
          (_h = this._lightmapTexture) === null || _h === void 0 ? void 0 : _h.dispose();
          (_j = this._refractionTexture) === null || _j === void 0 ? void 0 : _j.dispose();
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
      clone(name109, cloneTexturesOnlyOnce = true, rootUrl = "") {
        const result = SerializationHelper.Clone(() => new StandardMaterial(name109, this.getScene()), this, { cloneTexturesOnlyOnce });
        result.name = name109;
        result.id = name109;
        this.stencil.copyTo(result.stencil);
        this._clonePlugins(result, rootUrl);
        return result;
      }
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new StandardMaterial(source.name, scene), source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        Material._parsePlugins(source, material, scene, rootUrl);
        return material;
      }
      static get DiffuseTextureEnabled() {
        return MaterialFlags.DiffuseTextureEnabled;
      }
      static set DiffuseTextureEnabled(value) {
        MaterialFlags.DiffuseTextureEnabled = value;
      }
      static get DetailTextureEnabled() {
        return MaterialFlags.DetailTextureEnabled;
      }
      static set DetailTextureEnabled(value) {
        MaterialFlags.DetailTextureEnabled = value;
      }
      static get AmbientTextureEnabled() {
        return MaterialFlags.AmbientTextureEnabled;
      }
      static set AmbientTextureEnabled(value) {
        MaterialFlags.AmbientTextureEnabled = value;
      }
      static get OpacityTextureEnabled() {
        return MaterialFlags.OpacityTextureEnabled;
      }
      static set OpacityTextureEnabled(value) {
        MaterialFlags.OpacityTextureEnabled = value;
      }
      static get ReflectionTextureEnabled() {
        return MaterialFlags.ReflectionTextureEnabled;
      }
      static set ReflectionTextureEnabled(value) {
        MaterialFlags.ReflectionTextureEnabled = value;
      }
      static get EmissiveTextureEnabled() {
        return MaterialFlags.EmissiveTextureEnabled;
      }
      static set EmissiveTextureEnabled(value) {
        MaterialFlags.EmissiveTextureEnabled = value;
      }
      static get SpecularTextureEnabled() {
        return MaterialFlags.SpecularTextureEnabled;
      }
      static set SpecularTextureEnabled(value) {
        MaterialFlags.SpecularTextureEnabled = value;
      }
      static get BumpTextureEnabled() {
        return MaterialFlags.BumpTextureEnabled;
      }
      static set BumpTextureEnabled(value) {
        MaterialFlags.BumpTextureEnabled = value;
      }
      static get LightmapTextureEnabled() {
        return MaterialFlags.LightmapTextureEnabled;
      }
      static set LightmapTextureEnabled(value) {
        MaterialFlags.LightmapTextureEnabled = value;
      }
      static get RefractionTextureEnabled() {
        return MaterialFlags.RefractionTextureEnabled;
      }
      static set RefractionTextureEnabled(value) {
        MaterialFlags.RefractionTextureEnabled = value;
      }
      static get ColorGradingTextureEnabled() {
        return MaterialFlags.ColorGradingTextureEnabled;
      }
      static set ColorGradingTextureEnabled(value) {
        MaterialFlags.ColorGradingTextureEnabled = value;
      }
      static get FresnelEnabled() {
        return MaterialFlags.FresnelEnabled;
      }
      static set FresnelEnabled(value) {
        MaterialFlags.FresnelEnabled = value;
      }
    };
    __decorate([
      serializeAsTexture("diffuseTexture")
    ], StandardMaterial.prototype, "_diffuseTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], StandardMaterial.prototype, "diffuseTexture", void 0);
    __decorate([
      serializeAsTexture("ambientTexture")
    ], StandardMaterial.prototype, "_ambientTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "ambientTexture", void 0);
    __decorate([
      serializeAsTexture("opacityTexture")
    ], StandardMaterial.prototype, "_opacityTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], StandardMaterial.prototype, "opacityTexture", void 0);
    __decorate([
      serializeAsTexture("reflectionTexture")
    ], StandardMaterial.prototype, "_reflectionTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
      serializeAsTexture("emissiveTexture")
    ], StandardMaterial.prototype, "_emissiveTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "emissiveTexture", void 0);
    __decorate([
      serializeAsTexture("specularTexture")
    ], StandardMaterial.prototype, "_specularTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "specularTexture", void 0);
    __decorate([
      serializeAsTexture("bumpTexture")
    ], StandardMaterial.prototype, "_bumpTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "bumpTexture", void 0);
    __decorate([
      serializeAsTexture("lightmapTexture")
    ], StandardMaterial.prototype, "_lightmapTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "lightmapTexture", void 0);
    __decorate([
      serializeAsTexture("refractionTexture")
    ], StandardMaterial.prototype, "_refractionTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "refractionTexture", void 0);
    __decorate([
      serializeAsColor3("ambient")
    ], StandardMaterial.prototype, "ambientColor", void 0);
    __decorate([
      serializeAsColor3("diffuse")
    ], StandardMaterial.prototype, "diffuseColor", void 0);
    __decorate([
      serializeAsColor3("specular")
    ], StandardMaterial.prototype, "specularColor", void 0);
    __decorate([
      serializeAsColor3("emissive")
    ], StandardMaterial.prototype, "emissiveColor", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "specularPower", void 0);
    __decorate([
      serialize("useAlphaFromDiffuseTexture")
    ], StandardMaterial.prototype, "_useAlphaFromDiffuseTexture", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], StandardMaterial.prototype, "useAlphaFromDiffuseTexture", void 0);
    __decorate([
      serialize("useEmissiveAsIllumination")
    ], StandardMaterial.prototype, "_useEmissiveAsIllumination", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useEmissiveAsIllumination", void 0);
    __decorate([
      serialize("linkEmissiveWithDiffuse")
    ], StandardMaterial.prototype, "_linkEmissiveWithDiffuse", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "linkEmissiveWithDiffuse", void 0);
    __decorate([
      serialize("useSpecularOverAlpha")
    ], StandardMaterial.prototype, "_useSpecularOverAlpha", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useSpecularOverAlpha", void 0);
    __decorate([
      serialize("useReflectionOverAlpha")
    ], StandardMaterial.prototype, "_useReflectionOverAlpha", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useReflectionOverAlpha", void 0);
    __decorate([
      serialize("disableLighting")
    ], StandardMaterial.prototype, "_disableLighting", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], StandardMaterial.prototype, "disableLighting", void 0);
    __decorate([
      serialize("useObjectSpaceNormalMap")
    ], StandardMaterial.prototype, "_useObjectSpaceNormalMap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useObjectSpaceNormalMap", void 0);
    __decorate([
      serialize("useParallax")
    ], StandardMaterial.prototype, "_useParallax", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useParallax", void 0);
    __decorate([
      serialize("useParallaxOcclusion")
    ], StandardMaterial.prototype, "_useParallaxOcclusion", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useParallaxOcclusion", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "parallaxScaleBias", void 0);
    __decorate([
      serialize("roughness")
    ], StandardMaterial.prototype, "_roughness", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "roughness", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "indexOfRefraction", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "invertRefractionY", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
      serialize("useLightmapAsShadowmap")
    ], StandardMaterial.prototype, "_useLightmapAsShadowmap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useLightmapAsShadowmap", void 0);
    __decorate([
      serializeAsFresnelParameters("diffuseFresnelParameters")
    ], StandardMaterial.prototype, "_diffuseFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "diffuseFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("opacityFresnelParameters")
    ], StandardMaterial.prototype, "_opacityFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelAndMiscDirty")
    ], StandardMaterial.prototype, "opacityFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("reflectionFresnelParameters")
    ], StandardMaterial.prototype, "_reflectionFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "reflectionFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("refractionFresnelParameters")
    ], StandardMaterial.prototype, "_refractionFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "refractionFresnelParameters", void 0);
    __decorate([
      serializeAsFresnelParameters("emissiveFresnelParameters")
    ], StandardMaterial.prototype, "_emissiveFresnelParameters", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "emissiveFresnelParameters", void 0);
    __decorate([
      serialize("useReflectionFresnelFromSpecular")
    ], StandardMaterial.prototype, "_useReflectionFresnelFromSpecular", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsFresnelDirty")
    ], StandardMaterial.prototype, "useReflectionFresnelFromSpecular", void 0);
    __decorate([
      serialize("useGlossinessFromSpecularMapAlpha")
    ], StandardMaterial.prototype, "_useGlossinessFromSpecularMapAlpha", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "useGlossinessFromSpecularMapAlpha", void 0);
    __decorate([
      serialize("maxSimultaneousLights")
    ], StandardMaterial.prototype, "_maxSimultaneousLights", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], StandardMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize("invertNormalMapX")
    ], StandardMaterial.prototype, "_invertNormalMapX", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
      serialize("invertNormalMapY")
    ], StandardMaterial.prototype, "_invertNormalMapY", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
      serialize("twoSidedLighting")
    ], StandardMaterial.prototype, "_twoSidedLighting", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], StandardMaterial.prototype, "twoSidedLighting", void 0);
    __decorate([
      serialize("applyDecalMapAfterDetailMap")
    ], StandardMaterial.prototype, "_applyDecalMapAfterDetailMap", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], StandardMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
    __decorate([
      serialize()
    ], StandardMaterial.prototype, "useLogarithmicDepth", null);
    RegisterClass("BABYLON.StandardMaterial", StandardMaterial);
    Scene.DefaultMaterialFactory = (scene) => {
      return new StandardMaterial("default material", scene);
    };
  }
});

// node_modules/@babylonjs/core/Materials/shaderMaterial.js
var onCreatedEffectParameters2, ShaderMaterial;
var init_shaderMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/shaderMaterial.js"() {
    init_decorators();
    init_math_vector();
    init_buffer();
    init_texture();
    init_materialHelper();
    init_typeStore();
    init_math_color();
    init_effectFallbacks();
    init_webRequest();
    init_pushMaterial();
    init_engineStore();
    init_clipPlaneMaterialHelper();
    onCreatedEffectParameters2 = { effect: null, subMesh: null };
    ShaderMaterial = class extends PushMaterial {
      constructor(name109, scene, shaderPath, options = {}, storeEffectOnSubMeshes = true) {
        super(name109, scene, storeEffectOnSubMeshes);
        this._textures = {};
        this._textureArrays = {};
        this._externalTextures = {};
        this._floats = {};
        this._ints = {};
        this._uints = {};
        this._floatsArrays = {};
        this._colors3 = {};
        this._colors3Arrays = {};
        this._colors4 = {};
        this._colors4Arrays = {};
        this._vectors2 = {};
        this._vectors3 = {};
        this._vectors4 = {};
        this._quaternions = {};
        this._quaternionsArrays = {};
        this._matrices = {};
        this._matrixArrays = {};
        this._matrices3x3 = {};
        this._matrices2x2 = {};
        this._vectors2Arrays = {};
        this._vectors3Arrays = {};
        this._vectors4Arrays = {};
        this._uniformBuffers = {};
        this._textureSamplers = {};
        this._storageBuffers = {};
        this._cachedWorldViewMatrix = new Matrix();
        this._cachedWorldViewProjectionMatrix = new Matrix();
        this._multiview = false;
        this._materialHelperNeedsPreviousMatrices = false;
        this._shaderPath = shaderPath;
        this._options = Object.assign({ needAlphaBlending: false, needAlphaTesting: false, attributes: ["position", "normal", "uv"], uniforms: ["worldViewProjection"], uniformBuffers: [], samplers: [], externalTextures: [], samplerObjects: [], storageBuffers: [], defines: [], useClipPlane: false }, options);
      }
      get shaderPath() {
        return this._shaderPath;
      }
      set shaderPath(shaderPath) {
        this._shaderPath = shaderPath;
      }
      get options() {
        return this._options;
      }
      get isMultiview() {
        return this._multiview;
      }
      getClassName() {
        return "ShaderMaterial";
      }
      needAlphaBlending() {
        return this.alpha < 1 || this._options.needAlphaBlending;
      }
      needAlphaTesting() {
        return this._options.needAlphaTesting;
      }
      _checkUniform(uniformName) {
        if (this._options.uniforms.indexOf(uniformName) === -1) {
          this._options.uniforms.push(uniformName);
        }
      }
      setTexture(name109, texture) {
        if (this._options.samplers.indexOf(name109) === -1) {
          this._options.samplers.push(name109);
        }
        this._textures[name109] = texture;
        return this;
      }
      setTextureArray(name109, textures) {
        if (this._options.samplers.indexOf(name109) === -1) {
          this._options.samplers.push(name109);
        }
        this._checkUniform(name109);
        this._textureArrays[name109] = textures;
        return this;
      }
      setExternalTexture(name109, texture) {
        if (this._options.externalTextures.indexOf(name109) === -1) {
          this._options.externalTextures.push(name109);
        }
        this._externalTextures[name109] = texture;
        return this;
      }
      setFloat(name109, value) {
        this._checkUniform(name109);
        this._floats[name109] = value;
        return this;
      }
      setInt(name109, value) {
        this._checkUniform(name109);
        this._ints[name109] = value;
        return this;
      }
      setUInt(name109, value) {
        this._checkUniform(name109);
        this._uints[name109] = value;
        return this;
      }
      setFloats(name109, value) {
        this._checkUniform(name109);
        this._floatsArrays[name109] = value;
        return this;
      }
      setColor3(name109, value) {
        this._checkUniform(name109);
        this._colors3[name109] = value;
        return this;
      }
      setColor3Array(name109, value) {
        this._checkUniform(name109);
        this._colors3Arrays[name109] = value.reduce((arr, color) => {
          color.toArray(arr, arr.length);
          return arr;
        }, []);
        return this;
      }
      setColor4(name109, value) {
        this._checkUniform(name109);
        this._colors4[name109] = value;
        return this;
      }
      setColor4Array(name109, value) {
        this._checkUniform(name109);
        this._colors4Arrays[name109] = value.reduce((arr, color) => {
          color.toArray(arr, arr.length);
          return arr;
        }, []);
        return this;
      }
      setVector2(name109, value) {
        this._checkUniform(name109);
        this._vectors2[name109] = value;
        return this;
      }
      setVector3(name109, value) {
        this._checkUniform(name109);
        this._vectors3[name109] = value;
        return this;
      }
      setVector4(name109, value) {
        this._checkUniform(name109);
        this._vectors4[name109] = value;
        return this;
      }
      setQuaternion(name109, value) {
        this._checkUniform(name109);
        this._quaternions[name109] = value;
        return this;
      }
      setQuaternionArray(name109, value) {
        this._checkUniform(name109);
        this._quaternionsArrays[name109] = value.reduce((arr, quaternion) => {
          quaternion.toArray(arr, arr.length);
          return arr;
        }, []);
        return this;
      }
      setMatrix(name109, value) {
        this._checkUniform(name109);
        this._matrices[name109] = value;
        return this;
      }
      setMatrices(name109, value) {
        this._checkUniform(name109);
        const float32Array = new Float32Array(value.length * 16);
        for (let index = 0; index < value.length; index++) {
          const matrix = value[index];
          matrix.copyToArray(float32Array, index * 16);
        }
        this._matrixArrays[name109] = float32Array;
        return this;
      }
      setMatrix3x3(name109, value) {
        this._checkUniform(name109);
        this._matrices3x3[name109] = value;
        return this;
      }
      setMatrix2x2(name109, value) {
        this._checkUniform(name109);
        this._matrices2x2[name109] = value;
        return this;
      }
      setArray2(name109, value) {
        this._checkUniform(name109);
        this._vectors2Arrays[name109] = value;
        return this;
      }
      setArray3(name109, value) {
        this._checkUniform(name109);
        this._vectors3Arrays[name109] = value;
        return this;
      }
      setArray4(name109, value) {
        this._checkUniform(name109);
        this._vectors4Arrays[name109] = value;
        return this;
      }
      setUniformBuffer(name109, buffer) {
        if (this._options.uniformBuffers.indexOf(name109) === -1) {
          this._options.uniformBuffers.push(name109);
        }
        this._uniformBuffers[name109] = buffer;
        return this;
      }
      setTextureSampler(name109, sampler) {
        if (this._options.samplerObjects.indexOf(name109) === -1) {
          this._options.samplerObjects.push(name109);
        }
        this._textureSamplers[name109] = sampler;
        return this;
      }
      setStorageBuffer(name109, buffer) {
        if (this._options.storageBuffers.indexOf(name109) === -1) {
          this._options.storageBuffers.push(name109);
        }
        this._storageBuffers[name109] = buffer;
        return this;
      }
      setDefine(define, value) {
        const defineName = define.trimEnd() + " ";
        const existingDefineIdx = this.options.defines.findIndex((x) => x === define || x.startsWith(defineName));
        if (existingDefineIdx >= 0) {
          this.options.defines.splice(existingDefineIdx, 1);
        }
        if (typeof value !== "boolean" || value) {
          this.options.defines.push(defineName + value);
        }
        return this;
      }
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        return this.isReady(mesh, useInstances, subMesh);
      }
      isReady(mesh, useInstances, subMesh) {
        var _a, _b, _c, _d;
        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
        if (this.isFrozen) {
          if (storeEffectOnSubMeshes) {
            if (subMesh.effect && subMesh.effect._wasPreviouslyReady) {
              return true;
            }
          } else {
            const effect2 = this._drawWrapper.effect;
            if (effect2 && effect2._wasPreviouslyReady && effect2._wasPreviouslyUsingInstances === useInstances) {
              return true;
            }
          }
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        const defines = [];
        const attribs = [];
        const fallbacks = new EffectFallbacks();
        let shaderName = this._shaderPath, uniforms = this._options.uniforms, uniformBuffers = this._options.uniformBuffers, samplers = this._options.samplers;
        if (engine.getCaps().multiview && scene.activeCamera && scene.activeCamera.outputRenderTarget && scene.activeCamera.outputRenderTarget.getViewCount() > 1) {
          this._multiview = true;
          defines.push("#define MULTIVIEW");
          if (this._options.uniforms.indexOf("viewProjection") !== -1 && this._options.uniforms.indexOf("viewProjectionR") === -1) {
            this._options.uniforms.push("viewProjectionR");
          }
        }
        for (let index = 0; index < this._options.defines.length; index++) {
          const defineToAdd = this._options.defines[index].indexOf("#define") === 0 ? this._options.defines[index] : `#define ${this._options.defines[index]}`;
          defines.push(defineToAdd);
        }
        for (let index = 0; index < this._options.attributes.length; index++) {
          attribs.push(this._options.attributes[index]);
        }
        if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorKind)) {
          attribs.push(VertexBuffer.ColorKind);
          defines.push("#define VERTEXCOLOR");
        }
        if (useInstances) {
          defines.push("#define INSTANCES");
          MaterialHelper.PushAttributesForInstances(attribs, this._materialHelperNeedsPreviousMatrices);
          if (mesh === null || mesh === void 0 ? void 0 : mesh.hasThinInstances) {
            defines.push("#define THIN_INSTANCES");
            if (mesh && mesh.isVerticesDataPresent(VertexBuffer.ColorInstanceKind)) {
              attribs.push(VertexBuffer.ColorInstanceKind);
              defines.push("#define INSTANCESCOLOR");
            }
          }
        }
        if (mesh && mesh.useBones && mesh.computeBonesUsingShaders && mesh.skeleton) {
          attribs.push(VertexBuffer.MatricesIndicesKind);
          attribs.push(VertexBuffer.MatricesWeightsKind);
          if (mesh.numBoneInfluencers > 4) {
            attribs.push(VertexBuffer.MatricesIndicesExtraKind);
            attribs.push(VertexBuffer.MatricesWeightsExtraKind);
          }
          const skeleton = mesh.skeleton;
          defines.push("#define NUM_BONE_INFLUENCERS " + mesh.numBoneInfluencers);
          fallbacks.addCPUSkinningFallback(0, mesh);
          if (skeleton.isUsingTextureForMatrices) {
            defines.push("#define BONETEXTURE");
            if (this._options.uniforms.indexOf("boneTextureWidth") === -1) {
              this._options.uniforms.push("boneTextureWidth");
            }
            if (this._options.samplers.indexOf("boneSampler") === -1) {
              this._options.samplers.push("boneSampler");
            }
          } else {
            defines.push("#define BonesPerMesh " + (skeleton.bones.length + 1));
            if (this._options.uniforms.indexOf("mBones") === -1) {
              this._options.uniforms.push("mBones");
            }
          }
        } else {
          defines.push("#define NUM_BONE_INFLUENCERS 0");
        }
        let numInfluencers = 0;
        const manager = mesh ? mesh.morphTargetManager : null;
        if (manager) {
          const uv = manager.supportsUVs && defines.indexOf("#define UV1") !== -1;
          const tangent = manager.supportsTangents && defines.indexOf("#define TANGENT") !== -1;
          const normal = manager.supportsNormals && defines.indexOf("#define NORMAL") !== -1;
          numInfluencers = manager.numInfluencers;
          if (uv) {
            defines.push("#define MORPHTARGETS_UV");
          }
          if (tangent) {
            defines.push("#define MORPHTARGETS_TANGENT");
          }
          if (normal) {
            defines.push("#define MORPHTARGETS_NORMAL");
          }
          if (numInfluencers > 0) {
            defines.push("#define MORPHTARGETS");
          }
          if (manager.isUsingTextureForTargets) {
            defines.push("#define MORPHTARGETS_TEXTURE");
            if (this._options.uniforms.indexOf("morphTargetTextureIndices") === -1) {
              this._options.uniforms.push("morphTargetTextureIndices");
            }
            if (this._options.samplers.indexOf("morphTargets") === -1) {
              this._options.samplers.push("morphTargets");
            }
          }
          defines.push("#define NUM_MORPH_INFLUENCERS " + numInfluencers);
          for (let index = 0; index < numInfluencers; index++) {
            attribs.push(VertexBuffer.PositionKind + index);
            if (normal) {
              attribs.push(VertexBuffer.NormalKind + index);
            }
            if (tangent) {
              attribs.push(VertexBuffer.TangentKind + index);
            }
            if (uv) {
              attribs.push(VertexBuffer.UVKind + "_" + index);
            }
          }
          if (numInfluencers > 0) {
            uniforms = uniforms.slice();
            uniforms.push("morphTargetInfluences");
            uniforms.push("morphTargetTextureInfo");
            uniforms.push("morphTargetTextureIndices");
          }
        } else {
          defines.push("#define NUM_MORPH_INFLUENCERS 0");
        }
        if (mesh) {
          const bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            defines.push("#define BAKED_VERTEX_ANIMATION_TEXTURE");
            if (this._options.uniforms.indexOf("bakedVertexAnimationSettings") === -1) {
              this._options.uniforms.push("bakedVertexAnimationSettings");
            }
            if (this._options.uniforms.indexOf("bakedVertexAnimationTextureSizeInverted") === -1) {
              this._options.uniforms.push("bakedVertexAnimationTextureSizeInverted");
            }
            if (this._options.uniforms.indexOf("bakedVertexAnimationTime") === -1) {
              this._options.uniforms.push("bakedVertexAnimationTime");
            }
            if (this._options.samplers.indexOf("bakedVertexAnimationTexture") === -1) {
              this._options.samplers.push("bakedVertexAnimationTexture");
            }
          }
          MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        }
        for (const name109 in this._textures) {
          if (!this._textures[name109].isReady()) {
            return false;
          }
        }
        if (mesh && this._shouldTurnAlphaTestOn(mesh)) {
          defines.push("#define ALPHATEST");
        }
        if (this._options.useClipPlane !== false) {
          addClipPlaneUniforms(uniforms);
          prepareStringDefinesForClipPlanes(this, scene, defines);
        }
        if (this.customShaderNameResolve) {
          uniforms = uniforms.slice();
          uniformBuffers = uniformBuffers.slice();
          samplers = samplers.slice();
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs);
        }
        const drawWrapper = storeEffectOnSubMeshes ? subMesh._getDrawWrapper() : this._drawWrapper;
        const previousEffect = (_a = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.effect) !== null && _a !== void 0 ? _a : null;
        const previousDefines = (_b = drawWrapper === null || drawWrapper === void 0 ? void 0 : drawWrapper.defines) !== null && _b !== void 0 ? _b : null;
        const join = defines.join("\n");
        let effect = previousEffect;
        if (previousDefines !== join) {
          effect = engine.createEffect(shaderName, {
            attributes: attribs,
            uniformsNames: uniforms,
            uniformBuffersNames: uniformBuffers,
            samplers,
            defines: join,
            fallbacks,
            onCompiled: this.onCompiled,
            onError: this.onError,
            indexParameters: { maxSimultaneousMorphTargets: numInfluencers },
            shaderLanguage: this._options.shaderLanguage
          }, engine);
          if (storeEffectOnSubMeshes) {
            subMesh.setEffect(effect, join, this._materialContext);
          } else if (drawWrapper) {
            drawWrapper.setEffect(effect, join);
          }
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters2.effect = effect;
            onCreatedEffectParameters2.subMesh = (_c = subMesh !== null && subMesh !== void 0 ? subMesh : mesh === null || mesh === void 0 ? void 0 : mesh.subMeshes[0]) !== null && _c !== void 0 ? _c : null;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters2);
          }
        }
        effect._wasPreviouslyUsingInstances = !!useInstances;
        if ((_d = !(effect === null || effect === void 0 ? void 0 : effect.isReady())) !== null && _d !== void 0 ? _d : true) {
          return false;
        }
        if (previousEffect !== effect) {
          scene.resetCachedMaterial();
        }
        effect._wasPreviouslyReady = true;
        return true;
      }
      bindOnlyWorldMatrix(world, effectOverride) {
        const scene = this.getScene();
        const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : this.getEffect();
        if (!effect) {
          return;
        }
        if (this._options.uniforms.indexOf("world") !== -1) {
          effect.setMatrix("world", world);
        }
        if (this._options.uniforms.indexOf("worldView") !== -1) {
          world.multiplyToRef(scene.getViewMatrix(), this._cachedWorldViewMatrix);
          effect.setMatrix("worldView", this._cachedWorldViewMatrix);
        }
        if (this._options.uniforms.indexOf("worldViewProjection") !== -1) {
          world.multiplyToRef(scene.getTransformMatrix(), this._cachedWorldViewProjectionMatrix);
          effect.setMatrix("worldViewProjection", this._cachedWorldViewProjectionMatrix);
        }
      }
      bindForSubMesh(world, mesh, subMesh) {
        var _a;
        this.bind(world, mesh, (_a = subMesh._drawWrapperOverride) === null || _a === void 0 ? void 0 : _a.effect, subMesh);
      }
      bind(world, mesh, effectOverride, subMesh) {
        var _a;
        const storeEffectOnSubMeshes = subMesh && this._storeEffectOnSubMeshes;
        const effect = effectOverride !== null && effectOverride !== void 0 ? effectOverride : storeEffectOnSubMeshes ? subMesh.effect : this.getEffect();
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        this.bindOnlyWorldMatrix(world, effectOverride);
        const uniformBuffers = this._options.uniformBuffers;
        let useSceneUBO = false;
        if (effect && uniformBuffers && uniformBuffers.length > 0 && this.getScene().getEngine().supportsUniformBuffers) {
          for (let i = 0; i < uniformBuffers.length; ++i) {
            const bufferName = uniformBuffers[i];
            switch (bufferName) {
              case "Mesh":
                if (mesh) {
                  mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
                  mesh.transferToEffect(world);
                }
                break;
              case "Scene":
                MaterialHelper.BindSceneUniformBuffer(effect, this.getScene().getSceneUniformBuffer());
                this.getScene().finalizeSceneUbo();
                useSceneUBO = true;
                break;
            }
          }
        }
        const mustRebind = mesh && storeEffectOnSubMeshes ? this._mustRebind(this.getScene(), effect, mesh.visibility) : this.getScene().getCachedMaterial() !== this;
        if (effect && mustRebind) {
          if (!useSceneUBO && this._options.uniforms.indexOf("view") !== -1) {
            effect.setMatrix("view", this.getScene().getViewMatrix());
          }
          if (!useSceneUBO && this._options.uniforms.indexOf("projection") !== -1) {
            effect.setMatrix("projection", this.getScene().getProjectionMatrix());
          }
          if (!useSceneUBO && this._options.uniforms.indexOf("viewProjection") !== -1) {
            effect.setMatrix("viewProjection", this.getScene().getTransformMatrix());
            if (this._multiview) {
              effect.setMatrix("viewProjectionR", this.getScene()._transformMatrixR);
            }
          }
          if (this.getScene().activeCamera && this._options.uniforms.indexOf("cameraPosition") !== -1) {
            effect.setVector3("cameraPosition", this.getScene().activeCamera.globalPosition);
          }
          MaterialHelper.BindBonesParameters(mesh, effect);
          bindClipPlane(effect, this, this.getScene());
          let name109;
          for (name109 in this._textures) {
            effect.setTexture(name109, this._textures[name109]);
          }
          for (name109 in this._textureArrays) {
            effect.setTextureArray(name109, this._textureArrays[name109]);
          }
          for (name109 in this._externalTextures) {
            effect.setExternalTexture(name109, this._externalTextures[name109]);
          }
          for (name109 in this._ints) {
            effect.setInt(name109, this._ints[name109]);
          }
          for (name109 in this._uints) {
            effect.setUInt(name109, this._uints[name109]);
          }
          for (name109 in this._floats) {
            effect.setFloat(name109, this._floats[name109]);
          }
          for (name109 in this._floatsArrays) {
            effect.setArray(name109, this._floatsArrays[name109]);
          }
          for (name109 in this._colors3) {
            effect.setColor3(name109, this._colors3[name109]);
          }
          for (name109 in this._colors3Arrays) {
            effect.setArray3(name109, this._colors3Arrays[name109]);
          }
          for (name109 in this._colors4) {
            const color = this._colors4[name109];
            effect.setFloat4(name109, color.r, color.g, color.b, color.a);
          }
          for (name109 in this._colors4Arrays) {
            effect.setArray4(name109, this._colors4Arrays[name109]);
          }
          for (name109 in this._vectors2) {
            effect.setVector2(name109, this._vectors2[name109]);
          }
          for (name109 in this._vectors3) {
            effect.setVector3(name109, this._vectors3[name109]);
          }
          for (name109 in this._vectors4) {
            effect.setVector4(name109, this._vectors4[name109]);
          }
          for (name109 in this._quaternions) {
            effect.setQuaternion(name109, this._quaternions[name109]);
          }
          for (name109 in this._matrices) {
            effect.setMatrix(name109, this._matrices[name109]);
          }
          for (name109 in this._matrixArrays) {
            effect.setMatrices(name109, this._matrixArrays[name109]);
          }
          for (name109 in this._matrices3x3) {
            effect.setMatrix3x3(name109, this._matrices3x3[name109]);
          }
          for (name109 in this._matrices2x2) {
            effect.setMatrix2x2(name109, this._matrices2x2[name109]);
          }
          for (name109 in this._vectors2Arrays) {
            effect.setArray2(name109, this._vectors2Arrays[name109]);
          }
          for (name109 in this._vectors3Arrays) {
            effect.setArray3(name109, this._vectors3Arrays[name109]);
          }
          for (name109 in this._vectors4Arrays) {
            effect.setArray4(name109, this._vectors4Arrays[name109]);
          }
          for (name109 in this._quaternionsArrays) {
            effect.setArray4(name109, this._quaternionsArrays[name109]);
          }
          for (name109 in this._uniformBuffers) {
            const buffer = this._uniformBuffers[name109].getBuffer();
            if (buffer) {
              effect.bindUniformBuffer(buffer, name109);
            }
          }
          for (name109 in this._textureSamplers) {
            effect.setTextureSampler(name109, this._textureSamplers[name109]);
          }
          for (name109 in this._storageBuffers) {
            effect.setStorageBuffer(name109, this._storageBuffers[name109]);
          }
        }
        if (effect && mesh && (mustRebind || !this.isFrozen)) {
          const manager = mesh.morphTargetManager;
          if (manager && manager.numInfluencers > 0) {
            MaterialHelper.BindMorphTargetParameters(mesh, effect);
          }
          const bvaManager = mesh.bakedVertexAnimationManager;
          if (bvaManager && bvaManager.isEnabled) {
            (_a = mesh.bakedVertexAnimationManager) === null || _a === void 0 ? void 0 : _a.bind(effect, !!effect._wasPreviouslyUsingInstances);
          }
        }
        this._afterBind(mesh, effect);
      }
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        for (const name109 in this._textures) {
          activeTextures.push(this._textures[name109]);
        }
        for (const name109 in this._textureArrays) {
          const array = this._textureArrays[name109];
          for (let index = 0; index < array.length; index++) {
            activeTextures.push(array[index]);
          }
        }
        return activeTextures;
      }
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        for (const name109 in this._textures) {
          if (this._textures[name109] === texture) {
            return true;
          }
        }
        for (const name109 in this._textureArrays) {
          const array = this._textureArrays[name109];
          for (let index = 0; index < array.length; index++) {
            if (array[index] === texture) {
              return true;
            }
          }
        }
        return false;
      }
      clone(name109) {
        const result = SerializationHelper.Clone(() => new ShaderMaterial(name109, this.getScene(), this._shaderPath, this._options, this._storeEffectOnSubMeshes), this);
        result.name = name109;
        result.id = name109;
        if (typeof result._shaderPath === "object") {
          result._shaderPath = Object.assign({}, result._shaderPath);
        }
        this._options = Object.assign({}, this._options);
        Object.keys(this._options).forEach((propName) => {
          const propValue = this._options[propName];
          if (Array.isArray(propValue)) {
            this._options[propName] = propValue.slice(0);
          }
        });
        this.stencil.copyTo(result.stencil);
        for (const key in this._textures) {
          result.setTexture(key, this._textures[key]);
        }
        for (const key in this._textureArrays) {
          result.setTextureArray(key, this._textureArrays[key]);
        }
        for (const key in this._externalTextures) {
          result.setExternalTexture(key, this._externalTextures[key]);
        }
        for (const key in this._ints) {
          result.setInt(key, this._ints[key]);
        }
        for (const key in this._uints) {
          result.setUInt(key, this._uints[key]);
        }
        for (const key in this._floats) {
          result.setFloat(key, this._floats[key]);
        }
        for (const key in this._floatsArrays) {
          result.setFloats(key, this._floatsArrays[key]);
        }
        for (const key in this._colors3) {
          result.setColor3(key, this._colors3[key]);
        }
        for (const key in this._colors3Arrays) {
          result._colors3Arrays[key] = this._colors3Arrays[key];
        }
        for (const key in this._colors4) {
          result.setColor4(key, this._colors4[key]);
        }
        for (const key in this._colors4Arrays) {
          result._colors4Arrays[key] = this._colors4Arrays[key];
        }
        for (const key in this._vectors2) {
          result.setVector2(key, this._vectors2[key]);
        }
        for (const key in this._vectors3) {
          result.setVector3(key, this._vectors3[key]);
        }
        for (const key in this._vectors4) {
          result.setVector4(key, this._vectors4[key]);
        }
        for (const key in this._quaternions) {
          result.setQuaternion(key, this._quaternions[key]);
        }
        for (const key in this._quaternionsArrays) {
          result._quaternionsArrays[key] = this._quaternionsArrays[key];
        }
        for (const key in this._matrices) {
          result.setMatrix(key, this._matrices[key]);
        }
        for (const key in this._matrixArrays) {
          result._matrixArrays[key] = this._matrixArrays[key].slice();
        }
        for (const key in this._matrices3x3) {
          result.setMatrix3x3(key, this._matrices3x3[key]);
        }
        for (const key in this._matrices2x2) {
          result.setMatrix2x2(key, this._matrices2x2[key]);
        }
        for (const key in this._vectors2Arrays) {
          result.setArray2(key, this._vectors2Arrays[key]);
        }
        for (const key in this._vectors3Arrays) {
          result.setArray3(key, this._vectors3Arrays[key]);
        }
        for (const key in this._vectors4Arrays) {
          result.setArray4(key, this._vectors4Arrays[key]);
        }
        for (const key in this._uniformBuffers) {
          result.setUniformBuffer(key, this._uniformBuffers[key]);
        }
        for (const key in this._textureSamplers) {
          result.setTextureSampler(key, this._textureSamplers[key]);
        }
        for (const key in this._storageBuffers) {
          result.setStorageBuffer(key, this._storageBuffers[key]);
        }
        return result;
      }
      dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh) {
        if (forceDisposeTextures) {
          let name109;
          for (name109 in this._textures) {
            this._textures[name109].dispose();
          }
          for (name109 in this._textureArrays) {
            const array = this._textureArrays[name109];
            for (let index = 0; index < array.length; index++) {
              array[index].dispose();
            }
          }
        }
        this._textures = {};
        super.dispose(forceDisposeEffect, forceDisposeTextures, notBoundToMesh);
      }
      serialize() {
        const serializationObject = SerializationHelper.Serialize(this);
        serializationObject.customType = "BABYLON.ShaderMaterial";
        serializationObject.uniqueId = this.uniqueId;
        serializationObject.options = this._options;
        serializationObject.shaderPath = this._shaderPath;
        serializationObject.storeEffectOnSubMeshes = this._storeEffectOnSubMeshes;
        let name109;
        serializationObject.stencil = this.stencil.serialize();
        serializationObject.textures = {};
        for (name109 in this._textures) {
          serializationObject.textures[name109] = this._textures[name109].serialize();
        }
        serializationObject.textureArrays = {};
        for (name109 in this._textureArrays) {
          serializationObject.textureArrays[name109] = [];
          const array = this._textureArrays[name109];
          for (let index = 0; index < array.length; index++) {
            serializationObject.textureArrays[name109].push(array[index].serialize());
          }
        }
        serializationObject.ints = {};
        for (name109 in this._ints) {
          serializationObject.ints[name109] = this._ints[name109];
        }
        serializationObject.uints = {};
        for (name109 in this._uints) {
          serializationObject.uints[name109] = this._uints[name109];
        }
        serializationObject.floats = {};
        for (name109 in this._floats) {
          serializationObject.floats[name109] = this._floats[name109];
        }
        serializationObject.FloatArrays = {};
        for (name109 in this._floatsArrays) {
          serializationObject.FloatArrays[name109] = this._floatsArrays[name109];
        }
        serializationObject.colors3 = {};
        for (name109 in this._colors3) {
          serializationObject.colors3[name109] = this._colors3[name109].asArray();
        }
        serializationObject.colors3Arrays = {};
        for (name109 in this._colors3Arrays) {
          serializationObject.colors3Arrays[name109] = this._colors3Arrays[name109];
        }
        serializationObject.colors4 = {};
        for (name109 in this._colors4) {
          serializationObject.colors4[name109] = this._colors4[name109].asArray();
        }
        serializationObject.colors4Arrays = {};
        for (name109 in this._colors4Arrays) {
          serializationObject.colors4Arrays[name109] = this._colors4Arrays[name109];
        }
        serializationObject.vectors2 = {};
        for (name109 in this._vectors2) {
          serializationObject.vectors2[name109] = this._vectors2[name109].asArray();
        }
        serializationObject.vectors3 = {};
        for (name109 in this._vectors3) {
          serializationObject.vectors3[name109] = this._vectors3[name109].asArray();
        }
        serializationObject.vectors4 = {};
        for (name109 in this._vectors4) {
          serializationObject.vectors4[name109] = this._vectors4[name109].asArray();
        }
        serializationObject.quaternions = {};
        for (name109 in this._quaternions) {
          serializationObject.quaternions[name109] = this._quaternions[name109].asArray();
        }
        serializationObject.matrices = {};
        for (name109 in this._matrices) {
          serializationObject.matrices[name109] = this._matrices[name109].asArray();
        }
        serializationObject.matrixArray = {};
        for (name109 in this._matrixArrays) {
          serializationObject.matrixArray[name109] = this._matrixArrays[name109];
        }
        serializationObject.matrices3x3 = {};
        for (name109 in this._matrices3x3) {
          serializationObject.matrices3x3[name109] = this._matrices3x3[name109];
        }
        serializationObject.matrices2x2 = {};
        for (name109 in this._matrices2x2) {
          serializationObject.matrices2x2[name109] = this._matrices2x2[name109];
        }
        serializationObject.vectors2Arrays = {};
        for (name109 in this._vectors2Arrays) {
          serializationObject.vectors2Arrays[name109] = this._vectors2Arrays[name109];
        }
        serializationObject.vectors3Arrays = {};
        for (name109 in this._vectors3Arrays) {
          serializationObject.vectors3Arrays[name109] = this._vectors3Arrays[name109];
        }
        serializationObject.vectors4Arrays = {};
        for (name109 in this._vectors4Arrays) {
          serializationObject.vectors4Arrays[name109] = this._vectors4Arrays[name109];
        }
        serializationObject.quaternionsArrays = {};
        for (name109 in this._quaternionsArrays) {
          serializationObject.quaternionsArrays[name109] = this._quaternionsArrays[name109];
        }
        return serializationObject;
      }
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new ShaderMaterial(source.name, scene, source.shaderPath, source.options, source.storeEffectOnSubMeshes), source, scene, rootUrl);
        let name109;
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        for (name109 in source.textures) {
          material.setTexture(name109, Texture.Parse(source.textures[name109], scene, rootUrl));
        }
        for (name109 in source.textureArrays) {
          const array = source.textureArrays[name109];
          const textureArray = new Array();
          for (let index = 0; index < array.length; index++) {
            textureArray.push(Texture.Parse(array[index], scene, rootUrl));
          }
          material.setTextureArray(name109, textureArray);
        }
        for (name109 in source.ints) {
          material.setInt(name109, source.ints[name109]);
        }
        for (name109 in source.uints) {
          material.setUInt(name109, source.uints[name109]);
        }
        for (name109 in source.floats) {
          material.setFloat(name109, source.floats[name109]);
        }
        for (name109 in source.floatsArrays) {
          material.setFloats(name109, source.floatsArrays[name109]);
        }
        for (name109 in source.colors3) {
          material.setColor3(name109, Color3.FromArray(source.colors3[name109]));
        }
        for (name109 in source.colors3Arrays) {
          const colors = source.colors3Arrays[name109].reduce((arr, num, i) => {
            if (i % 3 === 0) {
              arr.push([num]);
            } else {
              arr[arr.length - 1].push(num);
            }
            return arr;
          }, []).map((color) => Color3.FromArray(color));
          material.setColor3Array(name109, colors);
        }
        for (name109 in source.colors4) {
          material.setColor4(name109, Color4.FromArray(source.colors4[name109]));
        }
        for (name109 in source.colors4Arrays) {
          const colors = source.colors4Arrays[name109].reduce((arr, num, i) => {
            if (i % 4 === 0) {
              arr.push([num]);
            } else {
              arr[arr.length - 1].push(num);
            }
            return arr;
          }, []).map((color) => Color4.FromArray(color));
          material.setColor4Array(name109, colors);
        }
        for (name109 in source.vectors2) {
          material.setVector2(name109, Vector2.FromArray(source.vectors2[name109]));
        }
        for (name109 in source.vectors3) {
          material.setVector3(name109, Vector3.FromArray(source.vectors3[name109]));
        }
        for (name109 in source.vectors4) {
          material.setVector4(name109, Vector4.FromArray(source.vectors4[name109]));
        }
        for (name109 in source.quaternions) {
          material.setQuaternion(name109, Quaternion.FromArray(source.quaternions[name109]));
        }
        for (name109 in source.matrices) {
          material.setMatrix(name109, Matrix.FromArray(source.matrices[name109]));
        }
        for (name109 in source.matrixArray) {
          material._matrixArrays[name109] = new Float32Array(source.matrixArray[name109]);
        }
        for (name109 in source.matrices3x3) {
          material.setMatrix3x3(name109, source.matrices3x3[name109]);
        }
        for (name109 in source.matrices2x2) {
          material.setMatrix2x2(name109, source.matrices2x2[name109]);
        }
        for (name109 in source.vectors2Arrays) {
          material.setArray2(name109, source.vectors2Arrays[name109]);
        }
        for (name109 in source.vectors3Arrays) {
          material.setArray3(name109, source.vectors3Arrays[name109]);
        }
        for (name109 in source.vectors4Arrays) {
          material.setArray4(name109, source.vectors4Arrays[name109]);
        }
        for (name109 in source.quaternionsArrays) {
          material.setArray4(name109, source.quaternionsArrays[name109]);
        }
        return material;
      }
      static ParseFromFileAsync(name109, url, scene, rootUrl = "") {
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const serializationObject = JSON.parse(request.responseText);
                const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                if (name109) {
                  output.name = name109;
                }
                resolve(output);
              } else {
                reject("Unable to load the ShaderMaterial");
              }
            }
          });
          request.open("GET", url);
          request.send();
        });
      }
      static ParseFromSnippetAsync(snippetId, scene, rootUrl = "") {
        return new Promise((resolve, reject) => {
          const request = new WebRequest();
          request.addEventListener("readystatechange", () => {
            if (request.readyState == 4) {
              if (request.status == 200) {
                const snippet = JSON.parse(JSON.parse(request.responseText).jsonPayload);
                const serializationObject = JSON.parse(snippet.shaderMaterial);
                const output = this.Parse(serializationObject, scene || EngineStore.LastCreatedScene, rootUrl);
                output.snippetId = snippetId;
                resolve(output);
              } else {
                reject("Unable to load the snippet " + snippetId);
              }
            }
          });
          request.open("GET", this.SnippetUrl + "/" + snippetId.replace(/#/g, "/"));
          request.send();
        });
      }
    };
    ShaderMaterial.SnippetUrl = `https://snippet.babylonjs.com`;
    ShaderMaterial.CreateFromSnippetAsync = ShaderMaterial.ParseFromSnippetAsync;
    RegisterClass("BABYLON.ShaderMaterial", ShaderMaterial);
  }
});

// node_modules/@babylonjs/core/Engines/constants.js
var Constants;
var init_constants = __esm({
  "node_modules/@babylonjs/core/Engines/constants.js"() {
    Constants = class {
    };
    Constants.ALPHA_DISABLE = 0;
    Constants.ALPHA_ADD = 1;
    Constants.ALPHA_COMBINE = 2;
    Constants.ALPHA_SUBTRACT = 3;
    Constants.ALPHA_MULTIPLY = 4;
    Constants.ALPHA_MAXIMIZED = 5;
    Constants.ALPHA_ONEONE = 6;
    Constants.ALPHA_PREMULTIPLIED = 7;
    Constants.ALPHA_PREMULTIPLIED_PORTERDUFF = 8;
    Constants.ALPHA_INTERPOLATE = 9;
    Constants.ALPHA_SCREENMODE = 10;
    Constants.ALPHA_ONEONE_ONEONE = 11;
    Constants.ALPHA_ALPHATOCOLOR = 12;
    Constants.ALPHA_REVERSEONEMINUS = 13;
    Constants.ALPHA_SRC_DSTONEMINUSSRCALPHA = 14;
    Constants.ALPHA_ONEONE_ONEZERO = 15;
    Constants.ALPHA_EXCLUSION = 16;
    Constants.ALPHA_LAYER_ACCUMULATE = 17;
    Constants.ALPHA_EQUATION_ADD = 0;
    Constants.ALPHA_EQUATION_SUBSTRACT = 1;
    Constants.ALPHA_EQUATION_REVERSE_SUBTRACT = 2;
    Constants.ALPHA_EQUATION_MAX = 3;
    Constants.ALPHA_EQUATION_MIN = 4;
    Constants.ALPHA_EQUATION_DARKEN = 5;
    Constants.DELAYLOADSTATE_NONE = 0;
    Constants.DELAYLOADSTATE_LOADED = 1;
    Constants.DELAYLOADSTATE_LOADING = 2;
    Constants.DELAYLOADSTATE_NOTLOADED = 4;
    Constants.NEVER = 512;
    Constants.ALWAYS = 519;
    Constants.LESS = 513;
    Constants.EQUAL = 514;
    Constants.LEQUAL = 515;
    Constants.GREATER = 516;
    Constants.GEQUAL = 518;
    Constants.NOTEQUAL = 517;
    Constants.KEEP = 7680;
    Constants.ZERO = 0;
    Constants.REPLACE = 7681;
    Constants.INCR = 7682;
    Constants.DECR = 7683;
    Constants.INVERT = 5386;
    Constants.INCR_WRAP = 34055;
    Constants.DECR_WRAP = 34056;
    Constants.TEXTURE_CLAMP_ADDRESSMODE = 0;
    Constants.TEXTURE_WRAP_ADDRESSMODE = 1;
    Constants.TEXTURE_MIRROR_ADDRESSMODE = 2;
    Constants.TEXTURE_CREATIONFLAG_STORAGE = 1;
    Constants.TEXTUREFORMAT_ALPHA = 0;
    Constants.TEXTUREFORMAT_LUMINANCE = 1;
    Constants.TEXTUREFORMAT_LUMINANCE_ALPHA = 2;
    Constants.TEXTUREFORMAT_RGB = 4;
    Constants.TEXTUREFORMAT_RGBA = 5;
    Constants.TEXTUREFORMAT_RED = 6;
    Constants.TEXTUREFORMAT_R = 6;
    Constants.TEXTUREFORMAT_RG = 7;
    Constants.TEXTUREFORMAT_RED_INTEGER = 8;
    Constants.TEXTUREFORMAT_R_INTEGER = 8;
    Constants.TEXTUREFORMAT_RG_INTEGER = 9;
    Constants.TEXTUREFORMAT_RGB_INTEGER = 10;
    Constants.TEXTUREFORMAT_RGBA_INTEGER = 11;
    Constants.TEXTUREFORMAT_BGRA = 12;
    Constants.TEXTUREFORMAT_DEPTH24_STENCIL8 = 13;
    Constants.TEXTUREFORMAT_DEPTH32_FLOAT = 14;
    Constants.TEXTUREFORMAT_DEPTH16 = 15;
    Constants.TEXTUREFORMAT_DEPTH24 = 16;
    Constants.TEXTUREFORMAT_DEPTH24UNORM_STENCIL8 = 17;
    Constants.TEXTUREFORMAT_DEPTH32FLOAT_STENCIL8 = 18;
    Constants.TEXTUREFORMAT_STENCIL8 = 19;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_BPTC_UNORM = 36492;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_BPTC_UNORM = 36493;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_UNSIGNED_FLOAT = 36495;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_BPTC_SIGNED_FLOAT = 36494;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT5 = 33779;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT5_EXT = 35919;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT3 = 33778;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT3_EXT = 35918;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_S3TC_DXT1 = 33777;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_S3TC_DXT1 = 33776;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_ALPHA_S3TC_DXT1_EXT = 35917;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB_S3TC_DXT1_EXT = 35916;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA_ASTC_4x4 = 37808;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ASTC_4x4_KHR = 37840;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB_ETC1_WEBGL = 36196;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB8_ETC2 = 37492;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ETC2 = 37493;
    Constants.TEXTUREFORMAT_COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495;
    Constants.TEXTUREFORMAT_COMPRESSED_RGBA8_ETC2_EAC = 37496;
    Constants.TEXTUREFORMAT_COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497;
    Constants.TEXTURETYPE_UNSIGNED_BYTE = 0;
    Constants.TEXTURETYPE_UNSIGNED_INT = 0;
    Constants.TEXTURETYPE_FLOAT = 1;
    Constants.TEXTURETYPE_HALF_FLOAT = 2;
    Constants.TEXTURETYPE_BYTE = 3;
    Constants.TEXTURETYPE_SHORT = 4;
    Constants.TEXTURETYPE_UNSIGNED_SHORT = 5;
    Constants.TEXTURETYPE_INT = 6;
    Constants.TEXTURETYPE_UNSIGNED_INTEGER = 7;
    Constants.TEXTURETYPE_UNSIGNED_SHORT_4_4_4_4 = 8;
    Constants.TEXTURETYPE_UNSIGNED_SHORT_5_5_5_1 = 9;
    Constants.TEXTURETYPE_UNSIGNED_SHORT_5_6_5 = 10;
    Constants.TEXTURETYPE_UNSIGNED_INT_2_10_10_10_REV = 11;
    Constants.TEXTURETYPE_UNSIGNED_INT_24_8 = 12;
    Constants.TEXTURETYPE_UNSIGNED_INT_10F_11F_11F_REV = 13;
    Constants.TEXTURETYPE_UNSIGNED_INT_5_9_9_9_REV = 14;
    Constants.TEXTURETYPE_FLOAT_32_UNSIGNED_INT_24_8_REV = 15;
    Constants.TEXTURETYPE_UNDEFINED = 16;
    Constants.TEXTURE_2D = 3553;
    Constants.TEXTURE_2D_ARRAY = 35866;
    Constants.TEXTURE_CUBE_MAP = 34067;
    Constants.TEXTURE_CUBE_MAP_ARRAY = 3735928559;
    Constants.TEXTURE_3D = 32879;
    Constants.TEXTURE_NEAREST_SAMPLINGMODE = 1;
    Constants.TEXTURE_NEAREST_NEAREST = 1;
    Constants.TEXTURE_BILINEAR_SAMPLINGMODE = 2;
    Constants.TEXTURE_LINEAR_LINEAR = 2;
    Constants.TEXTURE_TRILINEAR_SAMPLINGMODE = 3;
    Constants.TEXTURE_LINEAR_LINEAR_MIPLINEAR = 3;
    Constants.TEXTURE_NEAREST_NEAREST_MIPNEAREST = 4;
    Constants.TEXTURE_NEAREST_LINEAR_MIPNEAREST = 5;
    Constants.TEXTURE_NEAREST_LINEAR_MIPLINEAR = 6;
    Constants.TEXTURE_NEAREST_LINEAR = 7;
    Constants.TEXTURE_NEAREST_NEAREST_MIPLINEAR = 8;
    Constants.TEXTURE_LINEAR_NEAREST_MIPNEAREST = 9;
    Constants.TEXTURE_LINEAR_NEAREST_MIPLINEAR = 10;
    Constants.TEXTURE_LINEAR_LINEAR_MIPNEAREST = 11;
    Constants.TEXTURE_LINEAR_NEAREST = 12;
    Constants.TEXTURE_EXPLICIT_MODE = 0;
    Constants.TEXTURE_SPHERICAL_MODE = 1;
    Constants.TEXTURE_PLANAR_MODE = 2;
    Constants.TEXTURE_CUBIC_MODE = 3;
    Constants.TEXTURE_PROJECTION_MODE = 4;
    Constants.TEXTURE_SKYBOX_MODE = 5;
    Constants.TEXTURE_INVCUBIC_MODE = 6;
    Constants.TEXTURE_EQUIRECTANGULAR_MODE = 7;
    Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MODE = 8;
    Constants.TEXTURE_FIXED_EQUIRECTANGULAR_MIRRORED_MODE = 9;
    Constants.TEXTURE_FILTERING_QUALITY_OFFLINE = 4096;
    Constants.TEXTURE_FILTERING_QUALITY_HIGH = 64;
    Constants.TEXTURE_FILTERING_QUALITY_MEDIUM = 16;
    Constants.TEXTURE_FILTERING_QUALITY_LOW = 8;
    Constants.SCALEMODE_FLOOR = 1;
    Constants.SCALEMODE_NEAREST = 2;
    Constants.SCALEMODE_CEILING = 3;
    Constants.MATERIAL_TextureDirtyFlag = 1;
    Constants.MATERIAL_LightDirtyFlag = 2;
    Constants.MATERIAL_FresnelDirtyFlag = 4;
    Constants.MATERIAL_AttributesDirtyFlag = 8;
    Constants.MATERIAL_MiscDirtyFlag = 16;
    Constants.MATERIAL_PrePassDirtyFlag = 32;
    Constants.MATERIAL_AllDirtyFlag = 63;
    Constants.MATERIAL_TriangleFillMode = 0;
    Constants.MATERIAL_WireFrameFillMode = 1;
    Constants.MATERIAL_PointFillMode = 2;
    Constants.MATERIAL_PointListDrawMode = 3;
    Constants.MATERIAL_LineListDrawMode = 4;
    Constants.MATERIAL_LineLoopDrawMode = 5;
    Constants.MATERIAL_LineStripDrawMode = 6;
    Constants.MATERIAL_TriangleStripDrawMode = 7;
    Constants.MATERIAL_TriangleFanDrawMode = 8;
    Constants.MATERIAL_ClockWiseSideOrientation = 0;
    Constants.MATERIAL_CounterClockWiseSideOrientation = 1;
    Constants.ACTION_NothingTrigger = 0;
    Constants.ACTION_OnPickTrigger = 1;
    Constants.ACTION_OnLeftPickTrigger = 2;
    Constants.ACTION_OnRightPickTrigger = 3;
    Constants.ACTION_OnCenterPickTrigger = 4;
    Constants.ACTION_OnPickDownTrigger = 5;
    Constants.ACTION_OnDoublePickTrigger = 6;
    Constants.ACTION_OnPickUpTrigger = 7;
    Constants.ACTION_OnPickOutTrigger = 16;
    Constants.ACTION_OnLongPressTrigger = 8;
    Constants.ACTION_OnPointerOverTrigger = 9;
    Constants.ACTION_OnPointerOutTrigger = 10;
    Constants.ACTION_OnEveryFrameTrigger = 11;
    Constants.ACTION_OnIntersectionEnterTrigger = 12;
    Constants.ACTION_OnIntersectionExitTrigger = 13;
    Constants.ACTION_OnKeyDownTrigger = 14;
    Constants.ACTION_OnKeyUpTrigger = 15;
    Constants.PARTICLES_BILLBOARDMODE_Y = 2;
    Constants.PARTICLES_BILLBOARDMODE_ALL = 7;
    Constants.PARTICLES_BILLBOARDMODE_STRETCHED = 8;
    Constants.PARTICLES_BILLBOARDMODE_STRETCHED_LOCAL = 9;
    Constants.MESHES_CULLINGSTRATEGY_STANDARD = 0;
    Constants.MESHES_CULLINGSTRATEGY_BOUNDINGSPHERE_ONLY = 1;
    Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION = 2;
    Constants.MESHES_CULLINGSTRATEGY_OPTIMISTIC_INCLUSION_THEN_BSPHERE_ONLY = 3;
    Constants.SCENELOADER_NO_LOGGING = 0;
    Constants.SCENELOADER_MINIMAL_LOGGING = 1;
    Constants.SCENELOADER_SUMMARY_LOGGING = 2;
    Constants.SCENELOADER_DETAILED_LOGGING = 3;
    Constants.PREPASS_IRRADIANCE_TEXTURE_TYPE = 0;
    Constants.PREPASS_POSITION_TEXTURE_TYPE = 1;
    Constants.PREPASS_VELOCITY_TEXTURE_TYPE = 2;
    Constants.PREPASS_REFLECTIVITY_TEXTURE_TYPE = 3;
    Constants.PREPASS_COLOR_TEXTURE_TYPE = 4;
    Constants.PREPASS_DEPTH_TEXTURE_TYPE = 5;
    Constants.PREPASS_NORMAL_TEXTURE_TYPE = 6;
    Constants.PREPASS_ALBEDO_SQRT_TEXTURE_TYPE = 7;
    Constants.BUFFER_CREATIONFLAG_READ = 1;
    Constants.BUFFER_CREATIONFLAG_WRITE = 2;
    Constants.BUFFER_CREATIONFLAG_READWRITE = 3;
    Constants.BUFFER_CREATIONFLAG_UNIFORM = 4;
    Constants.BUFFER_CREATIONFLAG_VERTEX = 8;
    Constants.BUFFER_CREATIONFLAG_INDEX = 16;
    Constants.BUFFER_CREATIONFLAG_STORAGE = 32;
    Constants.RENDERPASS_MAIN = 0;
    Constants.INPUT_ALT_KEY = 18;
    Constants.INPUT_CTRL_KEY = 17;
    Constants.INPUT_META_KEY1 = 91;
    Constants.INPUT_META_KEY2 = 92;
    Constants.INPUT_META_KEY3 = 93;
    Constants.INPUT_SHIFT_KEY = 16;
    Constants.SNAPSHOTRENDERING_STANDARD = 0;
    Constants.SNAPSHOTRENDERING_FAST = 1;
    Constants.PERSPECTIVE_CAMERA = 0;
    Constants.ORTHOGRAPHIC_CAMERA = 1;
    Constants.FOVMODE_VERTICAL_FIXED = 0;
    Constants.FOVMODE_HORIZONTAL_FIXED = 1;
    Constants.RIG_MODE_NONE = 0;
    Constants.RIG_MODE_STEREOSCOPIC_ANAGLYPH = 10;
    Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_PARALLEL = 11;
    Constants.RIG_MODE_STEREOSCOPIC_SIDEBYSIDE_CROSSEYED = 12;
    Constants.RIG_MODE_STEREOSCOPIC_OVERUNDER = 13;
    Constants.RIG_MODE_STEREOSCOPIC_INTERLACED = 14;
    Constants.RIG_MODE_VR = 20;
    Constants.RIG_MODE_WEBVR = 21;
    Constants.RIG_MODE_CUSTOM = 22;
    Constants.MAX_SUPPORTED_UV_SETS = 6;
    Constants.GL_ALPHA_EQUATION_ADD = 32774;
    Constants.GL_ALPHA_EQUATION_MIN = 32775;
    Constants.GL_ALPHA_EQUATION_MAX = 32776;
    Constants.GL_ALPHA_EQUATION_SUBTRACT = 32778;
    Constants.GL_ALPHA_EQUATION_REVERSE_SUBTRACT = 32779;
    Constants.GL_ALPHA_FUNCTION_SRC = 768;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_COLOR = 769;
    Constants.GL_ALPHA_FUNCTION_SRC_ALPHA = 770;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_SRC_ALPHA = 771;
    Constants.GL_ALPHA_FUNCTION_DST_ALPHA = 772;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_ALPHA = 773;
    Constants.GL_ALPHA_FUNCTION_DST_COLOR = 774;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_DST_COLOR = 775;
    Constants.GL_ALPHA_FUNCTION_SRC_ALPHA_SATURATED = 776;
    Constants.GL_ALPHA_FUNCTION_CONSTANT_COLOR = 32769;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_COLOR = 32770;
    Constants.GL_ALPHA_FUNCTION_CONSTANT_ALPHA = 32771;
    Constants.GL_ALPHA_FUNCTION_ONE_MINUS_CONSTANT_ALPHA = 32772;
    Constants.SnippetUrl = "https://snippet.babylonjs.com";
  }
});

// node_modules/@babylonjs/core/Maths/math.js
var init_math = __esm({
  "node_modules/@babylonjs/core/Maths/math.js"() {
    init_math_axis();
    init_math_color();
    init_math_constants();
    init_math_frustum();
    init_math_path();
    init_math_plane();
    init_math_size();
    init_math_vector();
    init_math_vertexFormat();
    init_math_viewport();
  }
});

// node_modules/@babylonjs/core/Maths/sphericalPolynomial.js
var SH3ylmBasisConstants, SH3ylmBasisTrigonometricTerms, applySH3, SHCosKernelConvolution, SphericalHarmonics, SphericalPolynomial;
var init_sphericalPolynomial = __esm({
  "node_modules/@babylonjs/core/Maths/sphericalPolynomial.js"() {
    init_math_vector();
    init_math();
    SH3ylmBasisConstants = [
      Math.sqrt(1 / (4 * Math.PI)),
      -Math.sqrt(3 / (4 * Math.PI)),
      Math.sqrt(3 / (4 * Math.PI)),
      -Math.sqrt(3 / (4 * Math.PI)),
      Math.sqrt(15 / (4 * Math.PI)),
      -Math.sqrt(15 / (4 * Math.PI)),
      Math.sqrt(5 / (16 * Math.PI)),
      -Math.sqrt(15 / (4 * Math.PI)),
      Math.sqrt(15 / (16 * Math.PI))
    ];
    SH3ylmBasisTrigonometricTerms = [
      () => 1,
      (direction) => direction.y,
      (direction) => direction.z,
      (direction) => direction.x,
      (direction) => direction.x * direction.y,
      (direction) => direction.y * direction.z,
      (direction) => 3 * direction.z * direction.z - 1,
      (direction) => direction.x * direction.z,
      (direction) => direction.x * direction.x - direction.y * direction.y
    ];
    applySH3 = (lm, direction) => {
      return SH3ylmBasisConstants[lm] * SH3ylmBasisTrigonometricTerms[lm](direction);
    };
    SHCosKernelConvolution = [Math.PI, 2 * Math.PI / 3, 2 * Math.PI / 3, 2 * Math.PI / 3, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4, Math.PI / 4];
    SphericalHarmonics = class {
      constructor() {
        this.preScaled = false;
        this.l00 = Vector3.Zero();
        this.l1_1 = Vector3.Zero();
        this.l10 = Vector3.Zero();
        this.l11 = Vector3.Zero();
        this.l2_2 = Vector3.Zero();
        this.l2_1 = Vector3.Zero();
        this.l20 = Vector3.Zero();
        this.l21 = Vector3.Zero();
        this.l22 = Vector3.Zero();
      }
      addLight(direction, color, deltaSolidAngle) {
        TmpVectors.Vector3[0].set(color.r, color.g, color.b);
        const colorVector = TmpVectors.Vector3[0];
        const c = TmpVectors.Vector3[1];
        colorVector.scaleToRef(deltaSolidAngle, c);
        c.scaleToRef(applySH3(0, direction), TmpVectors.Vector3[2]);
        this.l00.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(1, direction), TmpVectors.Vector3[2]);
        this.l1_1.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(2, direction), TmpVectors.Vector3[2]);
        this.l10.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(3, direction), TmpVectors.Vector3[2]);
        this.l11.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(4, direction), TmpVectors.Vector3[2]);
        this.l2_2.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(5, direction), TmpVectors.Vector3[2]);
        this.l2_1.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(6, direction), TmpVectors.Vector3[2]);
        this.l20.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(7, direction), TmpVectors.Vector3[2]);
        this.l21.addInPlace(TmpVectors.Vector3[2]);
        c.scaleToRef(applySH3(8, direction), TmpVectors.Vector3[2]);
        this.l22.addInPlace(TmpVectors.Vector3[2]);
      }
      scaleInPlace(scale) {
        this.l00.scaleInPlace(scale);
        this.l1_1.scaleInPlace(scale);
        this.l10.scaleInPlace(scale);
        this.l11.scaleInPlace(scale);
        this.l2_2.scaleInPlace(scale);
        this.l2_1.scaleInPlace(scale);
        this.l20.scaleInPlace(scale);
        this.l21.scaleInPlace(scale);
        this.l22.scaleInPlace(scale);
      }
      convertIncidentRadianceToIrradiance() {
        this.l00.scaleInPlace(SHCosKernelConvolution[0]);
        this.l1_1.scaleInPlace(SHCosKernelConvolution[1]);
        this.l10.scaleInPlace(SHCosKernelConvolution[2]);
        this.l11.scaleInPlace(SHCosKernelConvolution[3]);
        this.l2_2.scaleInPlace(SHCosKernelConvolution[4]);
        this.l2_1.scaleInPlace(SHCosKernelConvolution[5]);
        this.l20.scaleInPlace(SHCosKernelConvolution[6]);
        this.l21.scaleInPlace(SHCosKernelConvolution[7]);
        this.l22.scaleInPlace(SHCosKernelConvolution[8]);
      }
      convertIrradianceToLambertianRadiance() {
        this.scaleInPlace(1 / Math.PI);
      }
      preScaleForRendering() {
        this.preScaled = true;
        this.l00.scaleInPlace(SH3ylmBasisConstants[0]);
        this.l1_1.scaleInPlace(SH3ylmBasisConstants[1]);
        this.l10.scaleInPlace(SH3ylmBasisConstants[2]);
        this.l11.scaleInPlace(SH3ylmBasisConstants[3]);
        this.l2_2.scaleInPlace(SH3ylmBasisConstants[4]);
        this.l2_1.scaleInPlace(SH3ylmBasisConstants[5]);
        this.l20.scaleInPlace(SH3ylmBasisConstants[6]);
        this.l21.scaleInPlace(SH3ylmBasisConstants[7]);
        this.l22.scaleInPlace(SH3ylmBasisConstants[8]);
      }
      updateFromArray(data) {
        Vector3.FromArrayToRef(data[0], 0, this.l00);
        Vector3.FromArrayToRef(data[1], 0, this.l1_1);
        Vector3.FromArrayToRef(data[2], 0, this.l10);
        Vector3.FromArrayToRef(data[3], 0, this.l11);
        Vector3.FromArrayToRef(data[4], 0, this.l2_2);
        Vector3.FromArrayToRef(data[5], 0, this.l2_1);
        Vector3.FromArrayToRef(data[6], 0, this.l20);
        Vector3.FromArrayToRef(data[7], 0, this.l21);
        Vector3.FromArrayToRef(data[8], 0, this.l22);
        return this;
      }
      updateFromFloatsArray(data) {
        Vector3.FromFloatsToRef(data[0], data[1], data[2], this.l00);
        Vector3.FromFloatsToRef(data[3], data[4], data[5], this.l1_1);
        Vector3.FromFloatsToRef(data[6], data[7], data[8], this.l10);
        Vector3.FromFloatsToRef(data[9], data[10], data[11], this.l11);
        Vector3.FromFloatsToRef(data[12], data[13], data[14], this.l2_2);
        Vector3.FromFloatsToRef(data[15], data[16], data[17], this.l2_1);
        Vector3.FromFloatsToRef(data[18], data[19], data[20], this.l20);
        Vector3.FromFloatsToRef(data[21], data[22], data[23], this.l21);
        Vector3.FromFloatsToRef(data[24], data[25], data[26], this.l22);
        return this;
      }
      static FromArray(data) {
        const sh = new SphericalHarmonics();
        return sh.updateFromArray(data);
      }
      static FromPolynomial(polynomial) {
        const result = new SphericalHarmonics();
        result.l00 = polynomial.xx.scale(0.376127).add(polynomial.yy.scale(0.376127)).add(polynomial.zz.scale(0.376126));
        result.l1_1 = polynomial.y.scale(0.977204);
        result.l10 = polynomial.z.scale(0.977204);
        result.l11 = polynomial.x.scale(0.977204);
        result.l2_2 = polynomial.xy.scale(1.16538);
        result.l2_1 = polynomial.yz.scale(1.16538);
        result.l20 = polynomial.zz.scale(1.34567).subtract(polynomial.xx.scale(0.672834)).subtract(polynomial.yy.scale(0.672834));
        result.l21 = polynomial.zx.scale(1.16538);
        result.l22 = polynomial.xx.scale(1.16538).subtract(polynomial.yy.scale(1.16538));
        result.l1_1.scaleInPlace(-1);
        result.l11.scaleInPlace(-1);
        result.l2_1.scaleInPlace(-1);
        result.l21.scaleInPlace(-1);
        result.scaleInPlace(Math.PI);
        return result;
      }
    };
    SphericalPolynomial = class {
      constructor() {
        this.x = Vector3.Zero();
        this.y = Vector3.Zero();
        this.z = Vector3.Zero();
        this.xx = Vector3.Zero();
        this.yy = Vector3.Zero();
        this.zz = Vector3.Zero();
        this.xy = Vector3.Zero();
        this.yz = Vector3.Zero();
        this.zx = Vector3.Zero();
      }
      get preScaledHarmonics() {
        if (!this._harmonics) {
          this._harmonics = SphericalHarmonics.FromPolynomial(this);
        }
        if (!this._harmonics.preScaled) {
          this._harmonics.preScaleForRendering();
        }
        return this._harmonics;
      }
      addAmbient(color) {
        TmpVectors.Vector3[0].copyFromFloats(color.r, color.g, color.b);
        const colorVector = TmpVectors.Vector3[0];
        this.xx.addInPlace(colorVector);
        this.yy.addInPlace(colorVector);
        this.zz.addInPlace(colorVector);
      }
      scaleInPlace(scale) {
        this.x.scaleInPlace(scale);
        this.y.scaleInPlace(scale);
        this.z.scaleInPlace(scale);
        this.xx.scaleInPlace(scale);
        this.yy.scaleInPlace(scale);
        this.zz.scaleInPlace(scale);
        this.yz.scaleInPlace(scale);
        this.zx.scaleInPlace(scale);
        this.xy.scaleInPlace(scale);
      }
      updateFromHarmonics(harmonics) {
        this._harmonics = harmonics;
        this.x.copyFrom(harmonics.l11);
        this.x.scaleInPlace(1.02333).scaleInPlace(-1);
        this.y.copyFrom(harmonics.l1_1);
        this.y.scaleInPlace(1.02333).scaleInPlace(-1);
        this.z.copyFrom(harmonics.l10);
        this.z.scaleInPlace(1.02333);
        this.xx.copyFrom(harmonics.l00);
        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.247708);
        TmpVectors.Vector3[1].copyFrom(harmonics.l22).scaleInPlace(0.429043);
        this.xx.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).addInPlace(TmpVectors.Vector3[1]);
        this.yy.copyFrom(harmonics.l00);
        this.yy.scaleInPlace(0.886277).subtractInPlace(TmpVectors.Vector3[0]).subtractInPlace(TmpVectors.Vector3[1]);
        this.zz.copyFrom(harmonics.l00);
        TmpVectors.Vector3[0].copyFrom(harmonics.l20).scaleInPlace(0.495417);
        this.zz.scaleInPlace(0.886277).addInPlace(TmpVectors.Vector3[0]);
        this.yz.copyFrom(harmonics.l2_1);
        this.yz.scaleInPlace(0.858086).scaleInPlace(-1);
        this.zx.copyFrom(harmonics.l21);
        this.zx.scaleInPlace(0.858086).scaleInPlace(-1);
        this.xy.copyFrom(harmonics.l2_2);
        this.xy.scaleInPlace(0.858086);
        this.scaleInPlace(1 / Math.PI);
        return this;
      }
      static FromHarmonics(harmonics) {
        const result = new SphericalPolynomial();
        return result.updateFromHarmonics(harmonics);
      }
      static FromArray(data) {
        const sp = new SphericalPolynomial();
        Vector3.FromArrayToRef(data[0], 0, sp.x);
        Vector3.FromArrayToRef(data[1], 0, sp.y);
        Vector3.FromArrayToRef(data[2], 0, sp.z);
        Vector3.FromArrayToRef(data[3], 0, sp.xx);
        Vector3.FromArrayToRef(data[4], 0, sp.yy);
        Vector3.FromArrayToRef(data[5], 0, sp.zz);
        Vector3.FromArrayToRef(data[6], 0, sp.yz);
        Vector3.FromArrayToRef(data[7], 0, sp.zx);
        Vector3.FromArrayToRef(data[8], 0, sp.xy);
        return sp;
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/textureTools.js
function CreateResizedCopy(texture, width, height, useBilinearMode = true) {
  const scene = texture.getScene();
  const engine = scene.getEngine();
  const rtt = new RenderTargetTexture("resized" + texture.name, { width, height }, scene, !texture.noMipmap, true, texture._texture.type, false, texture.samplingMode, false);
  rtt.wrapU = texture.wrapU;
  rtt.wrapV = texture.wrapV;
  rtt.uOffset = texture.uOffset;
  rtt.vOffset = texture.vOffset;
  rtt.uScale = texture.uScale;
  rtt.vScale = texture.vScale;
  rtt.uAng = texture.uAng;
  rtt.vAng = texture.vAng;
  rtt.wAng = texture.wAng;
  rtt.coordinatesIndex = texture.coordinatesIndex;
  rtt.level = texture.level;
  rtt.anisotropicFilteringLevel = texture.anisotropicFilteringLevel;
  rtt._texture.isReady = false;
  texture.wrapU = Texture.CLAMP_ADDRESSMODE;
  texture.wrapV = Texture.CLAMP_ADDRESSMODE;
  const passPostProcess = new PassPostProcess("pass", 1, null, useBilinearMode ? Texture.BILINEAR_SAMPLINGMODE : Texture.NEAREST_SAMPLINGMODE, engine, false, 0);
  passPostProcess.externalTextureSamplerBinding = true;
  passPostProcess.getEffect().executeWhenCompiled(() => {
    passPostProcess.onApply = function(effect) {
      effect.setTexture("textureSampler", texture);
    };
    const internalTexture = rtt.renderTarget;
    if (internalTexture) {
      scene.postProcessManager.directRender([passPostProcess], internalTexture);
      engine.unBindFramebuffer(internalTexture);
      rtt.disposeFramebufferObjects();
      passPostProcess.dispose();
      rtt.getInternalTexture().isReady = true;
    }
  });
  return rtt;
}
function ApplyPostProcess(postProcessName, internalTexture, scene, type, samplingMode, format, width, height) {
  const engine = internalTexture.getEngine();
  internalTexture.isReady = false;
  samplingMode = samplingMode !== null && samplingMode !== void 0 ? samplingMode : internalTexture.samplingMode;
  type = type !== null && type !== void 0 ? type : internalTexture.type;
  format = format !== null && format !== void 0 ? format : internalTexture.format;
  width = width !== null && width !== void 0 ? width : internalTexture.width;
  height = height !== null && height !== void 0 ? height : internalTexture.height;
  if (type === -1) {
    type = 0;
  }
  return new Promise((resolve) => {
    const postProcess = new PostProcess("postprocess", postProcessName, null, null, 1, null, samplingMode, engine, false, void 0, type, void 0, null, false, format);
    postProcess.externalTextureSamplerBinding = true;
    const encodedTexture = engine.createRenderTargetTexture({ width, height }, {
      generateDepthBuffer: false,
      generateMipMaps: false,
      generateStencilBuffer: false,
      samplingMode,
      type,
      format
    });
    postProcess.getEffect().executeWhenCompiled(() => {
      postProcess.onApply = (effect) => {
        effect._bindTexture("textureSampler", internalTexture);
        effect.setFloat2("scale", 1, 1);
      };
      scene.postProcessManager.directRender([postProcess], encodedTexture, true);
      engine.restoreDefaultFramebuffer();
      engine._releaseTexture(internalTexture);
      if (postProcess) {
        postProcess.dispose();
      }
      encodedTexture._swapAndDie(internalTexture);
      internalTexture.type = type;
      internalTexture.format = 5;
      internalTexture.isReady = true;
      resolve(internalTexture);
    });
  });
}
function ToHalfFloat(value) {
  if (!floatView) {
    floatView = new Float32Array(1);
    int32View = new Int32Array(floatView.buffer);
  }
  floatView[0] = value;
  const x = int32View[0];
  let bits = x >> 16 & 32768;
  let m = x >> 12 & 2047;
  const e = x >> 23 & 255;
  if (e < 103) {
    return bits;
  }
  if (e > 142) {
    bits |= 31744;
    bits |= (e == 255 ? 0 : 1) && x & 8388607;
    return bits;
  }
  if (e < 113) {
    m |= 2048;
    bits |= (m >> 114 - e) + (m >> 113 - e & 1);
    return bits;
  }
  bits |= e - 112 << 10 | m >> 1;
  bits += m & 1;
  return bits;
}
function FromHalfFloat(value) {
  const s = (value & 32768) >> 15;
  const e = (value & 31744) >> 10;
  const f = value & 1023;
  if (e === 0) {
    return (s ? -1 : 1) * Math.pow(2, -14) * (f / Math.pow(2, 10));
  } else if (e == 31) {
    return f ? NaN : (s ? -1 : 1) * Infinity;
  }
  return (s ? -1 : 1) * Math.pow(2, e - 15) * (1 + f / Math.pow(2, 10));
}
var floatView, int32View, TextureTools;
var init_textureTools = __esm({
  "node_modules/@babylonjs/core/Misc/textureTools.js"() {
    init_texture();
    init_renderTargetTexture();
    init_passPostProcess();
    init_postProcess();
    TextureTools = {
      CreateResizedCopy,
      ApplyPostProcess,
      ToHalfFloat,
      FromHalfFloat
    };
  }
});

// node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js
var name67, shader67;
var init_rgbdDecode_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/rgbdDecode.fragment.js"() {
    init_shaderStore();
    init_helperFunctions();
    name67 = "rgbdDecodePixelShader";
    shader67 = `varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=vec4(fromRGBD(texture2D(textureSampler,vUV)),1.0);}`;
    ShaderStore.ShadersStore[name67] = shader67;
  }
});

// node_modules/@babylonjs/core/Misc/rgbdTextureTools.js
var RGBDTextureTools;
var init_rgbdTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/rgbdTextureTools.js"() {
    init_postProcess();
    init_rgbdDecode_fragment();
    init_engine_renderTarget();
    init_textureTools();
    RGBDTextureTools = class {
      static ExpandRGBDTexture(texture) {
        const internalTexture = texture._texture;
        if (!internalTexture || !texture.isRGBD) {
          return;
        }
        const engine = internalTexture.getEngine();
        const caps = engine.getCaps();
        const isReady = internalTexture.isReady;
        let expandTexture = false;
        if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
          expandTexture = true;
          internalTexture.type = 2;
        } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
          expandTexture = true;
          internalTexture.type = 1;
        }
        if (expandTexture) {
          internalTexture.isReady = false;
          internalTexture._isRGBD = false;
          internalTexture.invertY = false;
        }
        const expandRGBDTexture = () => {
          if (expandTexture) {
            const rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, internalTexture.type, void 0, null, false);
            rgbdPostProcess.externalTextureSamplerBinding = true;
            const expandedTexture = engine.createRenderTargetTexture(internalTexture.width, {
              generateDepthBuffer: false,
              generateMipMaps: false,
              generateStencilBuffer: false,
              samplingMode: internalTexture.samplingMode,
              type: internalTexture.type,
              format: 5
            });
            rgbdPostProcess.getEffect().executeWhenCompiled(() => {
              rgbdPostProcess.onApply = (effect) => {
                effect._bindTexture("textureSampler", internalTexture);
                effect.setFloat2("scale", 1, 1);
              };
              texture.getScene().postProcessManager.directRender([rgbdPostProcess], expandedTexture, true);
              engine.restoreDefaultFramebuffer();
              engine._releaseTexture(internalTexture);
              if (rgbdPostProcess) {
                rgbdPostProcess.dispose();
              }
              expandedTexture._swapAndDie(internalTexture);
              internalTexture.isReady = true;
            });
          }
        };
        if (isReady) {
          expandRGBDTexture();
        } else {
          texture.onLoadObservable.addOnce(expandRGBDTexture);
        }
      }
      static EncodeTextureToRGBD(internalTexture, scene, outputTextureType = 0) {
        return ApplyPostProcess("rgbdEncode", internalTexture, scene, outputTextureType, 1, 5);
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js
var FileFaceOrientation, CubeMapToSphericalPolynomialTools;
var init_cubemapToSphericalPolynomial = __esm({
  "node_modules/@babylonjs/core/Misc/HighDynamicRange/cubemapToSphericalPolynomial.js"() {
    init_math_vector();
    init_math_scalar();
    init_sphericalPolynomial();
    init_math_constants();
    init_math_color();
    FileFaceOrientation = class {
      constructor(name109, worldAxisForNormal, worldAxisForFileX, worldAxisForFileY) {
        this.name = name109;
        this.worldAxisForNormal = worldAxisForNormal;
        this.worldAxisForFileX = worldAxisForFileX;
        this.worldAxisForFileY = worldAxisForFileY;
      }
    };
    CubeMapToSphericalPolynomialTools = class {
      static ConvertCubeMapTextureToSphericalPolynomial(texture) {
        var _a;
        if (!texture.isCube) {
          return null;
        }
        (_a = texture.getScene()) === null || _a === void 0 ? void 0 : _a.getEngine().flushFramebuffer();
        const size = texture.getSize().width;
        const rightPromise = texture.readPixels(0, void 0, void 0, false);
        const leftPromise = texture.readPixels(1, void 0, void 0, false);
        let upPromise;
        let downPromise;
        if (texture.isRenderTarget) {
          upPromise = texture.readPixels(3, void 0, void 0, false);
          downPromise = texture.readPixels(2, void 0, void 0, false);
        } else {
          upPromise = texture.readPixels(2, void 0, void 0, false);
          downPromise = texture.readPixels(3, void 0, void 0, false);
        }
        const frontPromise = texture.readPixels(4, void 0, void 0, false);
        const backPromise = texture.readPixels(5, void 0, void 0, false);
        const gammaSpace = texture.gammaSpace;
        const format = 5;
        let type = 0;
        if (texture.textureType == 1 || texture.textureType == 2) {
          type = 1;
        }
        return new Promise((resolve) => {
          Promise.all([leftPromise, rightPromise, upPromise, downPromise, frontPromise, backPromise]).then(([left, right, up, down, front, back]) => {
            const cubeInfo = {
              size,
              right,
              left,
              up,
              down,
              front,
              back,
              format,
              type,
              gammaSpace
            };
            resolve(this.ConvertCubeMapToSphericalPolynomial(cubeInfo));
          });
        });
      }
      static _AreaElement(x, y) {
        return Math.atan2(x * y, Math.sqrt(x * x + y * y + 1));
      }
      static ConvertCubeMapToSphericalPolynomial(cubeInfo) {
        const sphericalHarmonics = new SphericalHarmonics();
        let totalSolidAngle = 0;
        const du = 2 / cubeInfo.size;
        const dv = du;
        const halfTexel = 0.5 * du;
        const minUV = halfTexel - 1;
        for (let faceIndex = 0; faceIndex < 6; faceIndex++) {
          const fileFace = this._FileFaces[faceIndex];
          const dataArray = cubeInfo[fileFace.name];
          let v = minUV;
          const stride = cubeInfo.format === 5 ? 4 : 3;
          for (let y = 0; y < cubeInfo.size; y++) {
            let u = minUV;
            for (let x = 0; x < cubeInfo.size; x++) {
              const worldDirection = fileFace.worldAxisForFileX.scale(u).add(fileFace.worldAxisForFileY.scale(v)).add(fileFace.worldAxisForNormal);
              worldDirection.normalize();
              const deltaSolidAngle = this._AreaElement(u - halfTexel, v - halfTexel) - this._AreaElement(u - halfTexel, v + halfTexel) - this._AreaElement(u + halfTexel, v - halfTexel) + this._AreaElement(u + halfTexel, v + halfTexel);
              let r = dataArray[y * cubeInfo.size * stride + x * stride + 0];
              let g = dataArray[y * cubeInfo.size * stride + x * stride + 1];
              let b = dataArray[y * cubeInfo.size * stride + x * stride + 2];
              if (isNaN(r)) {
                r = 0;
              }
              if (isNaN(g)) {
                g = 0;
              }
              if (isNaN(b)) {
                b = 0;
              }
              if (cubeInfo.type === 0) {
                r /= 255;
                g /= 255;
                b /= 255;
              }
              if (cubeInfo.gammaSpace) {
                r = Math.pow(Scalar.Clamp(r), ToLinearSpace);
                g = Math.pow(Scalar.Clamp(g), ToLinearSpace);
                b = Math.pow(Scalar.Clamp(b), ToLinearSpace);
              }
              const max = this.MAX_HDRI_VALUE;
              if (this.PRESERVE_CLAMPED_COLORS) {
                const currentMax = Math.max(r, g, b);
                if (currentMax > max) {
                  const factor = max / currentMax;
                  r *= factor;
                  g *= factor;
                  b *= factor;
                }
              } else {
                r = Scalar.Clamp(r, 0, max);
                g = Scalar.Clamp(g, 0, max);
                b = Scalar.Clamp(b, 0, max);
              }
              const color = new Color3(r, g, b);
              sphericalHarmonics.addLight(worldDirection, color, deltaSolidAngle);
              totalSolidAngle += deltaSolidAngle;
              u += du;
            }
            v += dv;
          }
        }
        const sphereSolidAngle = 4 * Math.PI;
        const facesProcessed = 6;
        const expectedSolidAngle = sphereSolidAngle * facesProcessed / 6;
        const correctionFactor = expectedSolidAngle / totalSolidAngle;
        sphericalHarmonics.scaleInPlace(correctionFactor);
        sphericalHarmonics.convertIncidentRadianceToIrradiance();
        sphericalHarmonics.convertIrradianceToLambertianRadiance();
        return SphericalPolynomial.FromHarmonics(sphericalHarmonics);
      }
    };
    CubeMapToSphericalPolynomialTools._FileFaces = [
      new FileFaceOrientation("right", new Vector3(1, 0, 0), new Vector3(0, 0, -1), new Vector3(0, -1, 0)),
      new FileFaceOrientation("left", new Vector3(-1, 0, 0), new Vector3(0, 0, 1), new Vector3(0, -1, 0)),
      new FileFaceOrientation("up", new Vector3(0, 1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, 1)),
      new FileFaceOrientation("down", new Vector3(0, -1, 0), new Vector3(1, 0, 0), new Vector3(0, 0, -1)),
      new FileFaceOrientation("front", new Vector3(0, 0, 1), new Vector3(1, 0, 0), new Vector3(0, -1, 0)),
      new FileFaceOrientation("back", new Vector3(0, 0, -1), new Vector3(-1, 0, 0), new Vector3(0, -1, 0))
    ];
    CubeMapToSphericalPolynomialTools.MAX_HDRI_VALUE = 4096;
    CubeMapToSphericalPolynomialTools.PRESERVE_CLAMPED_COLORS = false;
  }
});

// node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js
var init_baseTexture_polynomial = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/baseTexture.polynomial.js"() {
    init_cubemapToSphericalPolynomial();
    init_baseTexture();
    BaseTexture.prototype.forceSphericalPolynomialsRecompute = function() {
      if (this._texture) {
        this._texture._sphericalPolynomial = null;
        this._texture._sphericalPolynomialPromise = null;
        this._texture._sphericalPolynomialComputed = false;
      }
    };
    Object.defineProperty(BaseTexture.prototype, "sphericalPolynomial", {
      get: function() {
        if (this._texture) {
          if (this._texture._sphericalPolynomial || this._texture._sphericalPolynomialComputed) {
            return this._texture._sphericalPolynomial;
          }
          if (this._texture.isReady) {
            if (!this._texture._sphericalPolynomialPromise) {
              this._texture._sphericalPolynomialPromise = CubeMapToSphericalPolynomialTools.ConvertCubeMapTextureToSphericalPolynomial(this);
              if (this._texture._sphericalPolynomialPromise === null) {
                this._texture._sphericalPolynomialComputed = true;
              } else {
                this._texture._sphericalPolynomialPromise.then((sphericalPolynomial) => {
                  this._texture._sphericalPolynomial = sphericalPolynomial;
                  this._texture._sphericalPolynomialComputed = true;
                });
              }
            }
            return null;
          }
        }
        return null;
      },
      set: function(value) {
        if (this._texture) {
          this._texture._sphericalPolynomial = value;
        }
      },
      enumerable: true,
      configurable: true
    });
  }
});

// node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js
var name68, shader68;
var init_rgbdEncode_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/rgbdEncode.fragment.js"() {
    init_shaderStore();
    init_helperFunctions();
    name68 = "rgbdEncodePixelShader";
    shader68 = `varying vec2 vUV;uniform sampler2D textureSampler;
#include<helperFunctions>
#define CUSTOM_FRAGMENT_DEFINITIONS
void main(void) 
{gl_FragColor=toRGBD(texture2D(textureSampler,vUV).rgb);}`;
    ShaderStore.ShadersStore[name68] = shader68;
  }
});

// node_modules/@babylonjs/core/Misc/environmentTextureTools.js
function GetEnvInfo(data) {
  const dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
  let pos = 0;
  for (let i = 0; i < MagicBytes.length; i++) {
    if (dataView.getUint8(pos++) !== MagicBytes[i]) {
      Logger.Error("Not a babylon environment map");
      return null;
    }
  }
  let manifestString = "";
  let charCode = 0;
  while (charCode = dataView.getUint8(pos++)) {
    manifestString += String.fromCharCode(charCode);
  }
  let manifest = JSON.parse(manifestString);
  manifest = normalizeEnvInfo(manifest);
  if (manifest.specular) {
    manifest.specular.specularDataPosition = pos;
    manifest.specular.lodGenerationScale = manifest.specular.lodGenerationScale || 0.8;
  }
  return manifest;
}
function normalizeEnvInfo(info) {
  if (info.version > CurrentVersion) {
    throw new Error(`Unsupported babylon environment map version "${info.version}". Latest supported version is "${CurrentVersion}".`);
  }
  if (info.version === 2) {
    return info;
  }
  info = Object.assign(Object.assign({}, info), { version: 2, imageType: DefaultEnvironmentTextureImageType });
  return info;
}
async function CreateEnvTextureAsync(texture, options = {}) {
  var _a, _b;
  const internalTexture = texture.getInternalTexture();
  if (!internalTexture) {
    return Promise.reject("The cube texture is invalid.");
  }
  const imageType = (_a = options.imageType) !== null && _a !== void 0 ? _a : DefaultEnvironmentTextureImageType;
  const engine = internalTexture.getEngine();
  if (texture.textureType !== 2 && texture.textureType !== 1 && texture.textureType !== 0 && texture.textureType !== 0 && texture.textureType !== 7 && texture.textureType !== -1) {
    return Promise.reject("The cube texture should allow HDR (Full Float or Half Float).");
  }
  let textureType = 1;
  if (!engine.getCaps().textureFloatRender) {
    textureType = 2;
    if (!engine.getCaps().textureHalfFloatRender) {
      return Promise.reject("Env texture can only be created when the browser supports half float or full float rendering.");
    }
  }
  texture.sphericalPolynomial;
  const sphericalPolynomialPromise = (_b = texture.getInternalTexture()) === null || _b === void 0 ? void 0 : _b._sphericalPolynomialPromise;
  const cubeWidth = internalTexture.width;
  const hostingScene = new Scene(engine);
  const specularTextures = {};
  engine.flushFramebuffer();
  const mipmapsCount = Scalar.ILog2(internalTexture.width);
  for (let i = 0; i <= mipmapsCount; i++) {
    const faceWidth = Math.pow(2, mipmapsCount - i);
    for (let face = 0; face < 6; face++) {
      let faceData = await texture.readPixels(face, i, void 0, false);
      if (faceData && faceData.byteLength === faceData.length) {
        const faceDataFloat = new Float32Array(faceData.byteLength * 4);
        for (let i2 = 0; i2 < faceData.byteLength; i2++) {
          faceDataFloat[i2] = faceData[i2] / 255;
          faceDataFloat[i2] = Math.pow(faceDataFloat[i2], 2.2);
        }
        faceData = faceDataFloat;
      } else if (faceData && texture.gammaSpace) {
        const floatData = faceData;
        for (let i2 = 0; i2 < floatData.length; i2++) {
          floatData[i2] = Math.pow(floatData[i2], 2.2);
        }
      }
      const tempTexture = engine.createRawTexture(faceData, faceWidth, faceWidth, 5, false, true, 1, null, textureType);
      await RGBDTextureTools.EncodeTextureToRGBD(tempTexture, hostingScene, textureType);
      const rgbdEncodedData = await engine._readTexturePixels(tempTexture, faceWidth, faceWidth);
      const imageEncodedData = await DumpTools.DumpDataAsync(faceWidth, faceWidth, rgbdEncodedData, imageType, void 0, false, true, options.imageQuality);
      specularTextures[i * 6 + face] = imageEncodedData;
      tempTexture.dispose();
    }
  }
  hostingScene.dispose();
  if (sphericalPolynomialPromise) {
    await sphericalPolynomialPromise;
  }
  const info = {
    version: CurrentVersion,
    width: cubeWidth,
    imageType,
    irradiance: _CreateEnvTextureIrradiance(texture),
    specular: {
      mipmaps: [],
      lodGenerationScale: texture.lodGenerationScale
    }
  };
  let position = 0;
  for (let i = 0; i <= mipmapsCount; i++) {
    for (let face = 0; face < 6; face++) {
      const byteLength = specularTextures[i * 6 + face].byteLength;
      info.specular.mipmaps.push({
        length: byteLength,
        position
      });
      position += byteLength;
    }
  }
  const infoString = JSON.stringify(info);
  const infoBuffer = new ArrayBuffer(infoString.length + 1);
  const infoView = new Uint8Array(infoBuffer);
  for (let i = 0, strLen = infoString.length; i < strLen; i++) {
    infoView[i] = infoString.charCodeAt(i);
  }
  infoView[infoString.length] = 0;
  const totalSize = MagicBytes.length + position + infoBuffer.byteLength;
  const finalBuffer = new ArrayBuffer(totalSize);
  const finalBufferView = new Uint8Array(finalBuffer);
  const dataView = new DataView(finalBuffer);
  let pos = 0;
  for (let i = 0; i < MagicBytes.length; i++) {
    dataView.setUint8(pos++, MagicBytes[i]);
  }
  finalBufferView.set(new Uint8Array(infoBuffer), pos);
  pos += infoBuffer.byteLength;
  for (let i = 0; i <= mipmapsCount; i++) {
    for (let face = 0; face < 6; face++) {
      const dataBuffer = specularTextures[i * 6 + face];
      finalBufferView.set(new Uint8Array(dataBuffer), pos);
      pos += dataBuffer.byteLength;
    }
  }
  return finalBuffer;
}
function _CreateEnvTextureIrradiance(texture) {
  const polynmials = texture.sphericalPolynomial;
  if (polynmials == null) {
    return null;
  }
  return {
    x: [polynmials.x.x, polynmials.x.y, polynmials.x.z],
    y: [polynmials.y.x, polynmials.y.y, polynmials.y.z],
    z: [polynmials.z.x, polynmials.z.y, polynmials.z.z],
    xx: [polynmials.xx.x, polynmials.xx.y, polynmials.xx.z],
    yy: [polynmials.yy.x, polynmials.yy.y, polynmials.yy.z],
    zz: [polynmials.zz.x, polynmials.zz.y, polynmials.zz.z],
    yz: [polynmials.yz.x, polynmials.yz.y, polynmials.yz.z],
    zx: [polynmials.zx.x, polynmials.zx.y, polynmials.zx.z],
    xy: [polynmials.xy.x, polynmials.xy.y, polynmials.xy.z]
  };
}
function CreateImageDataArrayBufferViews(data, info) {
  info = normalizeEnvInfo(info);
  const specularInfo = info.specular;
  let mipmapsCount = Scalar.Log2(info.width);
  mipmapsCount = Math.round(mipmapsCount) + 1;
  if (specularInfo.mipmaps.length !== 6 * mipmapsCount) {
    throw new Error(`Unsupported specular mipmaps number "${specularInfo.mipmaps.length}"`);
  }
  const imageData = new Array(mipmapsCount);
  for (let i = 0; i < mipmapsCount; i++) {
    imageData[i] = new Array(6);
    for (let face = 0; face < 6; face++) {
      const imageInfo = specularInfo.mipmaps[i * 6 + face];
      imageData[i][face] = new Uint8Array(data.buffer, data.byteOffset + specularInfo.specularDataPosition + imageInfo.position, imageInfo.length);
    }
  }
  return imageData;
}
function UploadEnvLevelsAsync(texture, data, info) {
  info = normalizeEnvInfo(info);
  const specularInfo = info.specular;
  if (!specularInfo) {
    return Promise.resolve();
  }
  texture._lodGenerationScale = specularInfo.lodGenerationScale;
  const imageData = CreateImageDataArrayBufferViews(data, info);
  return UploadLevelsAsync(texture, imageData, info.imageType);
}
function _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture) {
  return new Promise((resolve, reject) => {
    if (expandTexture) {
      const tempTexture = engine.createTexture(null, true, true, null, 1, null, (message) => {
        reject(message);
      }, image);
      rgbdPostProcess.getEffect().executeWhenCompiled(() => {
        rgbdPostProcess.externalTextureSamplerBinding = true;
        rgbdPostProcess.onApply = (effect) => {
          effect._bindTexture("textureSampler", tempTexture);
          effect.setFloat2("scale", 1, engine._features.needsInvertingBitmap && image instanceof ImageBitmap ? -1 : 1);
        };
        if (!engine.scenes.length) {
          return;
        }
        engine.scenes[0].postProcessManager.directRender([rgbdPostProcess], cubeRtt, true, face, i);
        engine.restoreDefaultFramebuffer();
        tempTexture.dispose();
        URL.revokeObjectURL(url);
        resolve();
      });
    } else {
      engine._uploadImageToTexture(texture, image, face, i);
      if (generateNonLODTextures) {
        const lodTexture = lodTextures[i];
        if (lodTexture) {
          engine._uploadImageToTexture(lodTexture._texture, image, face, 0);
        }
      }
      resolve();
    }
  });
}
function UploadLevelsAsync(texture, imageData, imageType = DefaultEnvironmentTextureImageType) {
  if (!Tools.IsExponentOfTwo(texture.width)) {
    throw new Error("Texture size must be a power of two");
  }
  const mipmapsCount = Scalar.ILog2(texture.width) + 1;
  const engine = texture.getEngine();
  let expandTexture = false;
  let generateNonLODTextures = false;
  let rgbdPostProcess = null;
  let cubeRtt = null;
  let lodTextures = null;
  const caps = engine.getCaps();
  texture.format = 5;
  texture.type = 0;
  texture.generateMipMaps = true;
  texture._cachedAnisotropicFilteringLevel = null;
  engine.updateTextureSamplingMode(3, texture);
  if (!caps.textureLOD) {
    expandTexture = false;
    generateNonLODTextures = true;
    lodTextures = {};
  } else if (!engine._features.supportRenderAndCopyToLodForFloatTextures) {
    expandTexture = false;
  } else if (caps.textureHalfFloatRender && caps.textureHalfFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 2;
  } else if (caps.textureFloatRender && caps.textureFloatLinearFiltering) {
    expandTexture = true;
    texture.type = 1;
  }
  if (expandTexture) {
    rgbdPostProcess = new PostProcess("rgbdDecode", "rgbdDecode", null, null, 1, null, 3, engine, false, void 0, texture.type, void 0, null, false);
    texture._isRGBD = false;
    texture.invertY = false;
    cubeRtt = engine.createRenderTargetCubeTexture(texture.width, {
      generateDepthBuffer: false,
      generateMipMaps: true,
      generateStencilBuffer: false,
      samplingMode: 3,
      type: texture.type,
      format: 5
    });
  } else {
    texture._isRGBD = true;
    texture.invertY = true;
    if (generateNonLODTextures) {
      const mipSlices = 3;
      const scale = texture._lodGenerationScale;
      const offset = texture._lodGenerationOffset;
      for (let i = 0; i < mipSlices; i++) {
        const smoothness = i / (mipSlices - 1);
        const roughness = 1 - smoothness;
        const minLODIndex = offset;
        const maxLODIndex = (mipmapsCount - 1) * scale + offset;
        const lodIndex = minLODIndex + (maxLODIndex - minLODIndex) * roughness;
        const mipmapIndex = Math.round(Math.min(Math.max(lodIndex, 0), maxLODIndex));
        const glTextureFromLod = new InternalTexture(engine, InternalTextureSource.Temp);
        glTextureFromLod.isCube = true;
        glTextureFromLod.invertY = true;
        glTextureFromLod.generateMipMaps = false;
        engine.updateTextureSamplingMode(2, glTextureFromLod);
        const lodTexture = new BaseTexture(null);
        lodTexture._isCube = true;
        lodTexture._texture = glTextureFromLod;
        lodTextures[mipmapIndex] = lodTexture;
        switch (i) {
          case 0:
            texture._lodTextureLow = lodTexture;
            break;
          case 1:
            texture._lodTextureMid = lodTexture;
            break;
          case 2:
            texture._lodTextureHigh = lodTexture;
            break;
        }
      }
    }
  }
  const promises = [];
  for (let i = 0; i < imageData.length; i++) {
    for (let face = 0; face < 6; face++) {
      const bytes = imageData[i][face];
      const blob = new Blob([bytes], { type: imageType });
      const url = URL.createObjectURL(blob);
      let promise;
      if (typeof Image === "undefined" || engine._features.forceBitmapOverHTMLImageElement) {
        promise = engine.createImageBitmap(blob, { premultiplyAlpha: "none" }).then((img) => {
          return _OnImageReadyAsync(img, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture);
        });
      } else {
        const image = new Image();
        image.src = url;
        promise = new Promise((resolve, reject) => {
          image.onload = () => {
            _OnImageReadyAsync(image, engine, expandTexture, rgbdPostProcess, url, face, i, generateNonLODTextures, lodTextures, cubeRtt, texture).then(() => resolve()).catch((reason) => {
              reject(reason);
            });
          };
          image.onerror = (error) => {
            reject(error);
          };
        });
      }
      promises.push(promise);
    }
  }
  if (imageData.length < mipmapsCount) {
    let data;
    const size = Math.pow(2, mipmapsCount - 1 - imageData.length);
    const dataLength = size * size * 4;
    switch (texture.type) {
      case 0: {
        data = new Uint8Array(dataLength);
        break;
      }
      case 2: {
        data = new Uint16Array(dataLength);
        break;
      }
      case 1: {
        data = new Float32Array(dataLength);
        break;
      }
    }
    for (let i = imageData.length; i < mipmapsCount; i++) {
      for (let face = 0; face < 6; face++) {
        engine._uploadArrayBufferViewToTexture(texture, data, face, i);
      }
    }
  }
  return Promise.all(promises).then(() => {
    if (cubeRtt) {
      engine._releaseTexture(texture);
      cubeRtt._swapAndDie(texture);
    }
    if (rgbdPostProcess) {
      rgbdPostProcess.dispose();
    }
    if (generateNonLODTextures) {
      if (texture._lodTextureHigh && texture._lodTextureHigh._texture) {
        texture._lodTextureHigh._texture.isReady = true;
      }
      if (texture._lodTextureMid && texture._lodTextureMid._texture) {
        texture._lodTextureMid._texture.isReady = true;
      }
      if (texture._lodTextureLow && texture._lodTextureLow._texture) {
        texture._lodTextureLow._texture.isReady = true;
      }
    }
  });
}
function UploadEnvSpherical(texture, info) {
  info = normalizeEnvInfo(info);
  const irradianceInfo = info.irradiance;
  if (!irradianceInfo) {
    return;
  }
  const sp = new SphericalPolynomial();
  Vector3.FromArrayToRef(irradianceInfo.x, 0, sp.x);
  Vector3.FromArrayToRef(irradianceInfo.y, 0, sp.y);
  Vector3.FromArrayToRef(irradianceInfo.z, 0, sp.z);
  Vector3.FromArrayToRef(irradianceInfo.xx, 0, sp.xx);
  Vector3.FromArrayToRef(irradianceInfo.yy, 0, sp.yy);
  Vector3.FromArrayToRef(irradianceInfo.zz, 0, sp.zz);
  Vector3.FromArrayToRef(irradianceInfo.yz, 0, sp.yz);
  Vector3.FromArrayToRef(irradianceInfo.zx, 0, sp.zx);
  Vector3.FromArrayToRef(irradianceInfo.xy, 0, sp.xy);
  texture._sphericalPolynomial = sp;
}
function _UpdateRGBDAsync(internalTexture, data, sphericalPolynomial, lodScale, lodOffset) {
  const proxy = internalTexture.getEngine().createRawCubeTexture(null, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
  const proxyPromise = UploadLevelsAsync(proxy, data).then(() => internalTexture);
  internalTexture.onRebuildCallback = (_internalTexture) => {
    return {
      proxy: proxyPromise,
      isReady: true,
      isAsync: true
    };
  };
  internalTexture._source = InternalTextureSource.CubeRawRGBD;
  internalTexture._bufferViewArrayArray = data;
  internalTexture._lodGenerationScale = lodScale;
  internalTexture._lodGenerationOffset = lodOffset;
  internalTexture._sphericalPolynomial = sphericalPolynomial;
  return UploadLevelsAsync(internalTexture, data).then(() => {
    internalTexture.isReady = true;
    return internalTexture;
  });
}
var DefaultEnvironmentTextureImageType, CurrentVersion, MagicBytes, EnvironmentTextureTools;
var init_environmentTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/environmentTextureTools.js"() {
    init_tools();
    init_math_vector();
    init_math_scalar();
    init_sphericalPolynomial();
    init_internalTexture();
    init_baseTexture();
    init_scene();
    init_postProcess();
    init_logger();
    init_rgbdTextureTools();
    init_engine_renderTargetCube();
    init_engine_readTexture();
    init_baseTexture_polynomial();
    init_rgbdEncode_fragment();
    init_rgbdDecode_fragment();
    init_dumpTools();
    DefaultEnvironmentTextureImageType = "image/png";
    CurrentVersion = 2;
    MagicBytes = [134, 22, 135, 150, 246, 214, 150, 54];
    EnvironmentTextureTools = {
      GetEnvInfo,
      CreateEnvTextureAsync,
      CreateImageDataArrayBufferViews,
      UploadEnvLevelsAsync,
      UploadLevelsAsync,
      UploadEnvSpherical
    };
  }
});

// node_modules/@babylonjs/core/Lights/shadowLight.js
var ShadowLight;
var init_shadowLight = __esm({
  "node_modules/@babylonjs/core/Lights/shadowLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_light();
    init_math_axis();
    ShadowLight = class extends Light {
      constructor() {
        super(...arguments);
        this._needProjectionMatrixCompute = true;
      }
      _setPosition(value) {
        this._position = value;
      }
      get position() {
        return this._position;
      }
      set position(value) {
        this._setPosition(value);
      }
      _setDirection(value) {
        this._direction = value;
      }
      get direction() {
        return this._direction;
      }
      set direction(value) {
        this._setDirection(value);
      }
      get shadowMinZ() {
        return this._shadowMinZ;
      }
      set shadowMinZ(value) {
        this._shadowMinZ = value;
        this.forceProjectionMatrixCompute();
      }
      get shadowMaxZ() {
        return this._shadowMaxZ;
      }
      set shadowMaxZ(value) {
        this._shadowMaxZ = value;
        this.forceProjectionMatrixCompute();
      }
      computeTransformedInformation() {
        if (this.parent && this.parent.getWorldMatrix) {
          if (!this.transformedPosition) {
            this.transformedPosition = Vector3.Zero();
          }
          Vector3.TransformCoordinatesToRef(this.position, this.parent.getWorldMatrix(), this.transformedPosition);
          if (this.direction) {
            if (!this.transformedDirection) {
              this.transformedDirection = Vector3.Zero();
            }
            Vector3.TransformNormalToRef(this.direction, this.parent.getWorldMatrix(), this.transformedDirection);
          }
          return true;
        }
        return false;
      }
      getDepthScale() {
        return 50;
      }
      getShadowDirection(faceIndex) {
        return this.transformedDirection ? this.transformedDirection : this.direction;
      }
      getAbsolutePosition() {
        return this.transformedPosition ? this.transformedPosition : this.position;
      }
      setDirectionToTarget(target) {
        this.direction = Vector3.Normalize(target.subtract(this.position));
        return this.direction;
      }
      getRotation() {
        this.direction.normalize();
        const xaxis = Vector3.Cross(this.direction, Axis.Y);
        const yaxis = Vector3.Cross(xaxis, this.direction);
        return Vector3.RotationFromAxis(xaxis, yaxis, this.direction);
      }
      needCube() {
        return false;
      }
      needProjectionMatrixCompute() {
        return this._needProjectionMatrixCompute;
      }
      forceProjectionMatrixCompute() {
        this._needProjectionMatrixCompute = true;
      }
      _initCache() {
        super._initCache();
        this._cache.position = Vector3.Zero();
      }
      _isSynchronized() {
        if (!this._cache.position.equals(this.position)) {
          return false;
        }
        return true;
      }
      computeWorldMatrix(force) {
        if (!force && this.isSynchronized()) {
          this._currentRenderId = this.getScene().getRenderId();
          return this._worldMatrix;
        }
        this._updateCache();
        this._cache.position.copyFrom(this.position);
        if (!this._worldMatrix) {
          this._worldMatrix = Matrix.Identity();
        }
        Matrix.TranslationToRef(this.position.x, this.position.y, this.position.z, this._worldMatrix);
        if (this.parent && this.parent.getWorldMatrix) {
          this._worldMatrix.multiplyToRef(this.parent.getWorldMatrix(), this._worldMatrix);
          this._markSyncedWithParent();
        }
        this._worldMatrixDeterminantIsDirty = true;
        return this._worldMatrix;
      }
      getDepthMinZ(activeCamera) {
        return this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
      }
      getDepthMaxZ(activeCamera) {
        return this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
      }
      setShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        if (this.customProjectionMatrixBuilder) {
          this.customProjectionMatrixBuilder(viewMatrix, renderList, matrix);
        } else {
          this._setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
        return this;
      }
      _syncParentEnabledState() {
        super._syncParentEnabledState();
        if (!this.parent || !this.parent.getWorldMatrix) {
          this.transformedPosition = null;
          this.transformedDirection = null;
        }
      }
    };
    __decorate([
      serializeAsVector3()
    ], ShadowLight.prototype, "position", null);
    __decorate([
      serializeAsVector3()
    ], ShadowLight.prototype, "direction", null);
    __decorate([
      serialize()
    ], ShadowLight.prototype, "shadowMinZ", null);
    __decorate([
      serialize()
    ], ShadowLight.prototype, "shadowMaxZ", null);
  }
});

// node_modules/@babylonjs/core/Lights/directionalLight.js
var DirectionalLight;
var init_directionalLight = __esm({
  "node_modules/@babylonjs/core/Lights/directionalLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    Node.AddNodeConstructor("Light_Type_1", (name109, scene) => {
      return () => new DirectionalLight(name109, Vector3.Zero(), scene);
    });
    DirectionalLight = class extends ShadowLight {
      get shadowFrustumSize() {
        return this._shadowFrustumSize;
      }
      set shadowFrustumSize(value) {
        this._shadowFrustumSize = value;
        this.forceProjectionMatrixCompute();
      }
      get shadowOrthoScale() {
        return this._shadowOrthoScale;
      }
      set shadowOrthoScale(value) {
        this._shadowOrthoScale = value;
        this.forceProjectionMatrixCompute();
      }
      get orthoLeft() {
        return this._orthoLeft;
      }
      set orthoLeft(left) {
        this._orthoLeft = left;
      }
      get orthoRight() {
        return this._orthoRight;
      }
      set orthoRight(right) {
        this._orthoRight = right;
      }
      get orthoTop() {
        return this._orthoTop;
      }
      set orthoTop(top) {
        this._orthoTop = top;
      }
      get orthoBottom() {
        return this._orthoBottom;
      }
      set orthoBottom(bottom) {
        this._orthoBottom = bottom;
      }
      constructor(name109, direction, scene) {
        super(name109, scene);
        this._shadowFrustumSize = 0;
        this._shadowOrthoScale = 0.1;
        this.autoUpdateExtends = true;
        this.autoCalcShadowZBounds = false;
        this._orthoLeft = Number.MAX_VALUE;
        this._orthoRight = Number.MIN_VALUE;
        this._orthoTop = Number.MIN_VALUE;
        this._orthoBottom = Number.MAX_VALUE;
        this.position = direction.scale(-1);
        this.direction = direction;
      }
      getClassName() {
        return "DirectionalLight";
      }
      getTypeID() {
        return Light.LIGHTTYPEID_DIRECTIONALLIGHT;
      }
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        if (this.shadowFrustumSize > 0) {
          this._setDefaultFixedFrustumShadowProjectionMatrix(matrix);
        } else {
          this._setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList);
        }
      }
      _setDefaultFixedFrustumShadowProjectionMatrix(matrix) {
        const activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        Matrix.OrthoLHToRef(this.shadowFrustumSize, this.shadowFrustumSize, this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ, this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      }
      _setDefaultAutoExtendShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        if (this.autoUpdateExtends || this._orthoLeft === Number.MAX_VALUE) {
          const tempVector3 = Vector3.Zero();
          this._orthoLeft = Number.MAX_VALUE;
          this._orthoRight = -Number.MAX_VALUE;
          this._orthoTop = -Number.MAX_VALUE;
          this._orthoBottom = Number.MAX_VALUE;
          let shadowMinZ = Number.MAX_VALUE;
          let shadowMaxZ = -Number.MAX_VALUE;
          for (let meshIndex = 0; meshIndex < renderList.length; meshIndex++) {
            const mesh = renderList[meshIndex];
            if (!mesh) {
              continue;
            }
            const boundingInfo = mesh.getBoundingInfo();
            const boundingBox = boundingInfo.boundingBox;
            for (let index = 0; index < boundingBox.vectorsWorld.length; index++) {
              Vector3.TransformCoordinatesToRef(boundingBox.vectorsWorld[index], viewMatrix, tempVector3);
              if (tempVector3.x < this._orthoLeft) {
                this._orthoLeft = tempVector3.x;
              }
              if (tempVector3.y < this._orthoBottom) {
                this._orthoBottom = tempVector3.y;
              }
              if (tempVector3.x > this._orthoRight) {
                this._orthoRight = tempVector3.x;
              }
              if (tempVector3.y > this._orthoTop) {
                this._orthoTop = tempVector3.y;
              }
              if (this.autoCalcShadowZBounds) {
                if (tempVector3.z < shadowMinZ) {
                  shadowMinZ = tempVector3.z;
                }
                if (tempVector3.z > shadowMaxZ) {
                  shadowMaxZ = tempVector3.z;
                }
              }
            }
          }
          if (this.autoCalcShadowZBounds) {
            this._shadowMinZ = shadowMinZ;
            this._shadowMaxZ = shadowMaxZ;
          }
        }
        const xOffset = this._orthoRight - this._orthoLeft;
        const yOffset = this._orthoTop - this._orthoBottom;
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.OrthoOffCenterLHToRef(this._orthoLeft - xOffset * this.shadowOrthoScale, this._orthoRight + xOffset * this.shadowOrthoScale, this._orthoBottom - yOffset * this.shadowOrthoScale, this._orthoTop + yOffset * this.shadowOrthoScale, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, this.getScene().getEngine().isNDCHalfZRange);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      transferToEffect(effect, lightIndex) {
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z, 1, lightIndex);
          return this;
        }
        this._uniformBuffer.updateFloat4("vLightData", this.direction.x, this.direction.y, this.direction.z, 1, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedDirection.x, this.transformedDirection.y, this.transformedDirection.z);
          return this;
        }
        effect.setFloat3(lightDataUniformName, this.direction.x, this.direction.y, this.direction.z);
        return this;
      }
      getDepthMinZ(activeCamera) {
        const engine = this._scene.getEngine();
        return !engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      }
      getDepthMaxZ(activeCamera) {
        const engine = this._scene.getEngine();
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : 1;
      }
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["DIRLIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "shadowFrustumSize", null);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "shadowOrthoScale", null);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "autoUpdateExtends", void 0);
    __decorate([
      serialize()
    ], DirectionalLight.prototype, "autoCalcShadowZBounds", void 0);
    __decorate([
      serialize("orthoLeft")
    ], DirectionalLight.prototype, "_orthoLeft", void 0);
    __decorate([
      serialize("orthoRight")
    ], DirectionalLight.prototype, "_orthoRight", void 0);
    __decorate([
      serialize("orthoTop")
    ], DirectionalLight.prototype, "_orthoTop", void 0);
    __decorate([
      serialize("orthoBottom")
    ], DirectionalLight.prototype, "_orthoBottom", void 0);
  }
});

// node_modules/@babylonjs/core/Lights/spotLight.js
var SpotLight;
var init_spotLight = __esm({
  "node_modules/@babylonjs/core/Lights/spotLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    init_texture();
    Node.AddNodeConstructor("Light_Type_2", (name109, scene) => {
      return () => new SpotLight(name109, Vector3.Zero(), Vector3.Zero(), 0, 0, scene);
    });
    SpotLight = class extends ShadowLight {
      get angle() {
        return this._angle;
      }
      set angle(value) {
        this._angle = value;
        this._cosHalfAngle = Math.cos(value * 0.5);
        this._projectionTextureProjectionLightDirty = true;
        this.forceProjectionMatrixCompute();
        this._computeAngleValues();
      }
      get innerAngle() {
        return this._innerAngle;
      }
      set innerAngle(value) {
        this._innerAngle = value;
        this._computeAngleValues();
      }
      get shadowAngleScale() {
        return this._shadowAngleScale;
      }
      set shadowAngleScale(value) {
        this._shadowAngleScale = value;
        this.forceProjectionMatrixCompute();
      }
      get projectionTextureMatrix() {
        return this._projectionTextureMatrix;
      }
      get projectionTextureLightNear() {
        return this._projectionTextureLightNear;
      }
      set projectionTextureLightNear(value) {
        this._projectionTextureLightNear = value;
        this._projectionTextureProjectionLightDirty = true;
      }
      get projectionTextureLightFar() {
        return this._projectionTextureLightFar;
      }
      set projectionTextureLightFar(value) {
        this._projectionTextureLightFar = value;
        this._projectionTextureProjectionLightDirty = true;
      }
      get projectionTextureUpDirection() {
        return this._projectionTextureUpDirection;
      }
      set projectionTextureUpDirection(value) {
        this._projectionTextureUpDirection = value;
        this._projectionTextureProjectionLightDirty = true;
      }
      get projectionTexture() {
        return this._projectionTexture;
      }
      set projectionTexture(value) {
        if (this._projectionTexture === value) {
          return;
        }
        this._projectionTexture = value;
        this._projectionTextureDirty = true;
        if (this._projectionTexture && !this._projectionTexture.isReady()) {
          if (SpotLight._IsProceduralTexture(this._projectionTexture)) {
            this._projectionTexture.getEffect().executeWhenCompiled(() => {
              this._markMeshesAsLightDirty();
            });
          } else if (SpotLight._IsTexture(this._projectionTexture)) {
            this._projectionTexture.onLoadObservable.addOnce(() => {
              this._markMeshesAsLightDirty();
            });
          }
        }
      }
      static _IsProceduralTexture(texture) {
        return texture.onGeneratedObservable !== void 0;
      }
      static _IsTexture(texture) {
        return texture.onLoadObservable !== void 0;
      }
      get projectionTextureProjectionLightMatrix() {
        return this._projectionTextureProjectionLightMatrix;
      }
      set projectionTextureProjectionLightMatrix(projection) {
        this._projectionTextureProjectionLightMatrix = projection;
        this._projectionTextureProjectionLightDirty = false;
        this._projectionTextureDirty = true;
      }
      constructor(name109, position, direction, angle, exponent, scene) {
        super(name109, scene);
        this._innerAngle = 0;
        this._projectionTextureMatrix = Matrix.Zero();
        this._projectionTextureLightNear = 1e-6;
        this._projectionTextureLightFar = 1e3;
        this._projectionTextureUpDirection = Vector3.Up();
        this._projectionTextureViewLightDirty = true;
        this._projectionTextureProjectionLightDirty = true;
        this._projectionTextureDirty = true;
        this._projectionTextureViewTargetVector = Vector3.Zero();
        this._projectionTextureViewLightMatrix = Matrix.Zero();
        this._projectionTextureProjectionLightMatrix = Matrix.Zero();
        this._projectionTextureScalingMatrix = Matrix.FromValues(0.5, 0, 0, 0, 0, 0.5, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1);
        this.position = position;
        this.direction = direction;
        this.angle = angle;
        this.exponent = exponent;
      }
      getClassName() {
        return "SpotLight";
      }
      getTypeID() {
        return Light.LIGHTTYPEID_SPOTLIGHT;
      }
      _setDirection(value) {
        super._setDirection(value);
        this._projectionTextureViewLightDirty = true;
      }
      _setPosition(value) {
        super._setPosition(value);
        this._projectionTextureViewLightDirty = true;
      }
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        this._shadowAngleScale = this._shadowAngleScale || 1;
        const angle = this._shadowAngleScale * this._angle;
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.PerspectiveFovLHToRef(angle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
      }
      _computeProjectionTextureViewLightMatrix() {
        this._projectionTextureViewLightDirty = false;
        this._projectionTextureDirty = true;
        this.getAbsolutePosition().addToRef(this.direction, this._projectionTextureViewTargetVector);
        Matrix.LookAtLHToRef(this.getAbsolutePosition(), this._projectionTextureViewTargetVector, this._projectionTextureUpDirection, this._projectionTextureViewLightMatrix);
      }
      _computeProjectionTextureProjectionLightMatrix() {
        this._projectionTextureProjectionLightDirty = false;
        this._projectionTextureDirty = true;
        const lightFar = this.projectionTextureLightFar;
        const lightNear = this.projectionTextureLightNear;
        const P = lightFar / (lightFar - lightNear);
        const Q = -P * lightNear;
        const S = 1 / Math.tan(this._angle / 2);
        const A = 1;
        Matrix.FromValuesToRef(S / A, 0, 0, 0, 0, S, 0, 0, 0, 0, P, 1, 0, 0, Q, 0, this._projectionTextureProjectionLightMatrix);
      }
      _computeProjectionTextureMatrix() {
        this._projectionTextureDirty = false;
        this._projectionTextureViewLightMatrix.multiplyToRef(this._projectionTextureProjectionLightMatrix, this._projectionTextureMatrix);
        if (this._projectionTexture instanceof Texture) {
          const u = this._projectionTexture.uScale / 2;
          const v = this._projectionTexture.vScale / 2;
          Matrix.FromValuesToRef(u, 0, 0, 0, 0, v, 0, 0, 0, 0, 0.5, 0, 0.5, 0.5, 0.5, 1, this._projectionTextureScalingMatrix);
        }
        this._projectionTextureMatrix.multiplyToRef(this._projectionTextureScalingMatrix, this._projectionTextureMatrix);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightDirection", 3);
        this._uniformBuffer.addUniform("vLightFalloff", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      _computeAngleValues() {
        this._lightAngleScale = 1 / Math.max(1e-3, Math.cos(this._innerAngle * 0.5) - this._cosHalfAngle);
        this._lightAngleOffset = -this._cosHalfAngle * this._lightAngleScale;
      }
      transferTexturesToEffect(effect, lightIndex) {
        if (this.projectionTexture && this.projectionTexture.isReady()) {
          if (this._projectionTextureViewLightDirty) {
            this._computeProjectionTextureViewLightMatrix();
          }
          if (this._projectionTextureProjectionLightDirty) {
            this._computeProjectionTextureProjectionLightMatrix();
          }
          if (this._projectionTextureDirty) {
            this._computeProjectionTextureMatrix();
          }
          effect.setMatrix("textureProjectionMatrix" + lightIndex, this._projectionTextureMatrix);
          effect.setTexture("projectionLightSampler" + lightIndex, this.projectionTexture);
        }
        return this;
      }
      transferToEffect(effect, lightIndex) {
        let normalizeDirection;
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, this.exponent, lightIndex);
          normalizeDirection = Vector3.Normalize(this.transformedDirection);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, this.exponent, lightIndex);
          normalizeDirection = Vector3.Normalize(this.direction);
        }
        this._uniformBuffer.updateFloat4("vLightDirection", normalizeDirection.x, normalizeDirection.y, normalizeDirection.z, this._cosHalfAngle, lightIndex);
        this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, this._lightAngleScale, this._lightAngleOffset, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        let normalizeDirection;
        if (this.computeTransformedInformation()) {
          normalizeDirection = Vector3.Normalize(this.transformedDirection);
        } else {
          normalizeDirection = Vector3.Normalize(this.direction);
        }
        if (this.getScene().useRightHandedSystem) {
          effect.setFloat3(lightDataUniformName, -normalizeDirection.x, -normalizeDirection.y, -normalizeDirection.z);
        } else {
          effect.setFloat3(lightDataUniformName, normalizeDirection.x, normalizeDirection.y, normalizeDirection.z);
        }
        return this;
      }
      dispose() {
        super.dispose();
        if (this._projectionTexture) {
          this._projectionTexture.dispose();
        }
      }
      getDepthMinZ(activeCamera) {
        const engine = this._scene.getEngine();
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? minZ : this._scene.getEngine().isNDCHalfZRange ? 0 : minZ;
      }
      getDepthMaxZ(activeCamera) {
        const engine = this._scene.getEngine();
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        return engine.useReverseDepthBuffer && engine.isNDCHalfZRange ? 0 : maxZ;
      }
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["SPOTLIGHT" + lightIndex] = true;
        defines["PROJECTEDLIGHTTEXTURE" + lightIndex] = this.projectionTexture && this.projectionTexture.isReady() ? true : false;
      }
    };
    __decorate([
      serialize()
    ], SpotLight.prototype, "angle", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "innerAngle", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "shadowAngleScale", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "exponent", void 0);
    __decorate([
      serialize()
    ], SpotLight.prototype, "projectionTextureLightNear", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "projectionTextureLightFar", null);
    __decorate([
      serialize()
    ], SpotLight.prototype, "projectionTextureUpDirection", null);
    __decorate([
      serializeAsTexture("projectedLightTexture")
    ], SpotLight.prototype, "_projectionTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js
var init_engine_cubeTexture = __esm({
  "node_modules/@babylonjs/core/Engines/Extensions/engine.cubeTexture.js"() {
    init_thinEngine();
    init_internalTexture();
    init_logger();
    init_fileTools();
    init_guid();
    ThinEngine.prototype._createDepthStencilCubeTexture = function(size, options, rtWrapper) {
      const internalTexture = new InternalTexture(this, InternalTextureSource.DepthStencil);
      internalTexture.isCube = true;
      if (this.webGLVersion === 1) {
        Logger.Error("Depth cube texture is not supported by WebGL 1.");
        return internalTexture;
      }
      const internalOptions = Object.assign({ bilinearFiltering: false, comparisonFunction: 0, generateStencil: false }, options);
      const gl = this._gl;
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, internalTexture, true);
      this._setupDepthStencilTexture(internalTexture, size, internalOptions.generateStencil, internalOptions.bilinearFiltering, internalOptions.comparisonFunction);
      rtWrapper._depthStencilTexture = internalTexture;
      rtWrapper._depthStencilTextureWithStencil = internalOptions.generateStencil;
      for (let face = 0; face < 6; face++) {
        if (internalOptions.generateStencil) {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH24_STENCIL8, size, size, 0, gl.DEPTH_STENCIL, gl.UNSIGNED_INT_24_8, null);
        } else {
          gl.texImage2D(gl.TEXTURE_CUBE_MAP_POSITIVE_X + face, 0, gl.DEPTH_COMPONENT24, size, size, 0, gl.DEPTH_COMPONENT, gl.UNSIGNED_INT, null);
        }
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
      this._internalTexturesCache.push(internalTexture);
      return internalTexture;
    };
    ThinEngine.prototype._partialLoadFile = function(url, index, loadedFiles, onfinish, onErrorCallBack = null) {
      const onload = (data) => {
        loadedFiles[index] = data;
        loadedFiles._internalCount++;
        if (loadedFiles._internalCount === 6) {
          onfinish(loadedFiles);
        }
      };
      const onerror = (request, exception) => {
        if (onErrorCallBack && request) {
          onErrorCallBack(request.status + " " + request.statusText, exception);
        }
      };
      this._loadFile(url, onload, void 0, void 0, true, onerror);
    };
    ThinEngine.prototype._cascadeLoadFiles = function(scene, onfinish, files, onError = null) {
      const loadedFiles = [];
      loadedFiles._internalCount = 0;
      for (let index = 0; index < 6; index++) {
        this._partialLoadFile(files[index], index, loadedFiles, onfinish, onError);
      }
    };
    ThinEngine.prototype._cascadeLoadImgs = function(scene, texture, onfinish, files, onError = null, mimeType) {
      const loadedImages = [];
      loadedImages._internalCount = 0;
      for (let index = 0; index < 6; index++) {
        this._partialLoadImg(files[index], index, loadedImages, scene, texture, onfinish, onError, mimeType);
      }
    };
    ThinEngine.prototype._partialLoadImg = function(url, index, loadedImages, scene, texture, onfinish, onErrorCallBack = null, mimeType) {
      const tokenPendingData = RandomGUID();
      const onload = (img) => {
        loadedImages[index] = img;
        loadedImages._internalCount++;
        if (scene) {
          scene.removePendingData(tokenPendingData);
        }
        if (loadedImages._internalCount === 6 && onfinish) {
          onfinish(texture, loadedImages);
        }
      };
      const onerror = (message, exception) => {
        if (scene) {
          scene.removePendingData(tokenPendingData);
        }
        if (onErrorCallBack) {
          onErrorCallBack(message, exception);
        }
      };
      LoadImage(url, onload, onerror, scene ? scene.offlineProvider : null, mimeType);
      if (scene) {
        scene.addPendingData(tokenPendingData);
      }
    };
    ThinEngine.prototype._setCubeMapTextureParams = function(texture, loadMipmap, maxLevel) {
      const gl = this._gl;
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MIN_FILTER, loadMipmap ? gl.LINEAR_MIPMAP_LINEAR : gl.LINEAR);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
      gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
      texture.samplingMode = loadMipmap ? 3 : 2;
      if (loadMipmap && this.getCaps().textureMaxLevel && maxLevel !== void 0 && maxLevel > 0) {
        gl.texParameteri(gl.TEXTURE_CUBE_MAP, gl.TEXTURE_MAX_LEVEL, maxLevel);
        texture._maxLodLevel = maxLevel;
      }
      this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, null);
    };
    ThinEngine.prototype.createCubeTextureBase = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, beforeLoadCubeDataCallback = null, imageHandler = null, useSRGBBuffer = false) {
      const texture = fallback ? fallback : new InternalTexture(this, InternalTextureSource.Cube);
      texture.isCube = true;
      texture.url = rootUrl;
      texture.generateMipMaps = !noMipmap;
      texture._lodGenerationScale = lodScale;
      texture._lodGenerationOffset = lodOffset;
      texture._useSRGBBuffer = !!useSRGBBuffer && this._caps.supportSRGBBuffers && (this.webGLVersion > 1 || this.isWebGPU || !!noMipmap);
      if (texture !== fallback) {
        texture.label = rootUrl.substring(0, 60);
      }
      if (!this._doNotHandleContextLost) {
        texture._extension = forcedExtension;
        texture._files = files;
      }
      const originalRootUrl = rootUrl;
      if (this._transformTextureUrl && !fallback) {
        rootUrl = this._transformTextureUrl(rootUrl);
      }
      const rootUrlWithoutUriParams = rootUrl.split("?")[0];
      const lastDot = rootUrlWithoutUriParams.lastIndexOf(".");
      const extension = forcedExtension ? forcedExtension : lastDot > -1 ? rootUrlWithoutUriParams.substring(lastDot).toLowerCase() : "";
      let loader = null;
      for (const availableLoader of ThinEngine._TextureLoaders) {
        if (availableLoader.canLoad(extension)) {
          loader = availableLoader;
          break;
        }
      }
      const onInternalError = (request, exception) => {
        if (rootUrl === originalRootUrl) {
          if (onError && request) {
            onError(request.status + " " + request.statusText, exception);
          }
        } else {
          Logger.Warn(`Failed to load ${rootUrl}, falling back to the ${originalRootUrl}`);
          this.createCubeTextureBase(originalRootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, texture, beforeLoadCubeDataCallback, imageHandler, useSRGBBuffer);
        }
      };
      if (loader) {
        const onloaddata = (data) => {
          if (beforeLoadCubeDataCallback) {
            beforeLoadCubeDataCallback(texture, data);
          }
          loader.loadCubeData(data, texture, createPolynomials, onLoad, onError);
        };
        if (files && files.length === 6) {
          if (loader.supportCascades) {
            this._cascadeLoadFiles(scene, (images) => onloaddata(images.map((image) => new Uint8Array(image))), files, onError);
          } else {
            if (onError) {
              onError("Textures type does not support cascades.");
            } else {
              Logger.Warn("Texture loader does not support cascades.");
            }
          }
        } else {
          this._loadFile(rootUrl, (data) => onloaddata(new Uint8Array(data)), void 0, void 0, true, onInternalError);
        }
      } else {
        if (!files) {
          throw new Error("Cannot load cubemap because files were not defined");
        }
        this._cascadeLoadImgs(scene, texture, (texture2, imgs) => {
          if (imageHandler) {
            imageHandler(texture2, imgs);
          }
        }, files, onError);
      }
      this._internalTexturesCache.push(texture);
      return texture;
    };
    ThinEngine.prototype.createCubeTexture = function(rootUrl, scene, files, noMipmap, onLoad = null, onError = null, format, forcedExtension = null, createPolynomials = false, lodScale = 0, lodOffset = 0, fallback = null, loaderOptions, useSRGBBuffer = false) {
      const gl = this._gl;
      return this.createCubeTextureBase(rootUrl, scene, files, !!noMipmap, onLoad, onError, format, forcedExtension, createPolynomials, lodScale, lodOffset, fallback, (texture) => this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true), (texture, imgs) => {
        const width = this.needPOTTextures ? ThinEngine.GetExponentOfTwo(imgs[0].width, this._caps.maxCubemapTextureSize) : imgs[0].width;
        const height = width;
        const faces = [
          gl.TEXTURE_CUBE_MAP_POSITIVE_X,
          gl.TEXTURE_CUBE_MAP_POSITIVE_Y,
          gl.TEXTURE_CUBE_MAP_POSITIVE_Z,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_X,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_Y,
          gl.TEXTURE_CUBE_MAP_NEGATIVE_Z
        ];
        this._bindTextureDirectly(gl.TEXTURE_CUBE_MAP, texture, true);
        this._unpackFlipY(false);
        const internalFormat = format ? this._getInternalFormat(format, texture._useSRGBBuffer) : texture._useSRGBBuffer ? this._glSRGBExtensionValues.SRGB8_ALPHA8 : gl.RGBA;
        let texelFormat = format ? this._getInternalFormat(format) : gl.RGBA;
        if (texture._useSRGBBuffer && this.webGLVersion === 1) {
          texelFormat = internalFormat;
        }
        for (let index = 0; index < faces.length; index++) {
          if (imgs[index].width !== width || imgs[index].height !== height) {
            this._prepareWorkingCanvas();
            if (!this._workingCanvas || !this._workingContext) {
              Logger.Warn("Cannot create canvas to resize texture.");
              return;
            }
            this._workingCanvas.width = width;
            this._workingCanvas.height = height;
            this._workingContext.drawImage(imgs[index], 0, 0, imgs[index].width, imgs[index].height, 0, 0, width, height);
            gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, this._workingCanvas);
          } else {
            gl.texImage2D(faces[index], 0, internalFormat, texelFormat, gl.UNSIGNED_BYTE, imgs[index]);
          }
        }
        if (!noMipmap) {
          gl.generateMipmap(gl.TEXTURE_CUBE_MAP);
        }
        this._setCubeMapTextureParams(texture, !noMipmap);
        texture.width = width;
        texture.height = height;
        texture.isReady = true;
        if (format) {
          texture.format = format;
        }
        texture.onLoadedObservable.notifyObservers(texture);
        texture.onLoadedObservable.clear();
        if (onLoad) {
          onLoad();
        }
      }, !!useSRGBBuffer);
    };
  }
});

// node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js
var CubeTexture;
var init_cubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/cubeTexture.js"() {
    init_tslib_es6();
    init_decorators();
    init_tools();
    init_math_vector();
    init_baseTexture();
    init_texture();
    init_typeStore();
    init_engine_cubeTexture();
    init_observable();
    CubeTexture = class extends BaseTexture {
      set boundingBoxSize(value) {
        if (this._boundingBoxSize && this._boundingBoxSize.equals(value)) {
          return;
        }
        this._boundingBoxSize = value;
        const scene = this.getScene();
        if (scene) {
          scene.markAllMaterialsAsDirty(1);
        }
      }
      get boundingBoxSize() {
        return this._boundingBoxSize;
      }
      set rotationY(value) {
        this._rotationY = value;
        this.setReflectionTextureMatrix(Matrix.RotationY(this._rotationY));
      }
      get rotationY() {
        return this._rotationY;
      }
      get noMipmap() {
        return this._noMipmap;
      }
      get forcedExtension() {
        return this._forcedExtension;
      }
      static CreateFromImages(files, scene, noMipmap) {
        let rootUrlKey = "";
        files.forEach((url) => rootUrlKey += url);
        return new CubeTexture(rootUrlKey, scene, null, noMipmap, files);
      }
      static CreateFromPrefilteredData(url, scene, forcedExtension = null, createPolynomials = true) {
        const oldValue = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const result = new CubeTexture(url, scene, null, false, null, null, null, void 0, true, forcedExtension, createPolynomials);
        scene.useDelayedTextureLoading = oldValue;
        return result;
      }
      constructor(rootUrl, sceneOrEngine, extensions = null, noMipmap = false, files = null, onLoad = null, onError = null, format = 5, prefiltered = false, forcedExtension = null, createPolynomials = false, lodScale = 0.8, lodOffset = 0, loaderOptions, useSRGBBuffer) {
        var _a;
        super(sceneOrEngine);
        this._lodScale = 0.8;
        this._lodOffset = 0;
        this.onLoadObservable = new Observable();
        this.boundingBoxPosition = Vector3.Zero();
        this._rotationY = 0;
        this._files = null;
        this._forcedExtension = null;
        this._extensions = null;
        this._textureMatrixRefraction = new Matrix();
        this.name = rootUrl;
        this.url = rootUrl;
        this._noMipmap = noMipmap;
        this.hasAlpha = false;
        this._format = format;
        this.isCube = true;
        this._textureMatrix = Matrix.Identity();
        this._createPolynomials = createPolynomials;
        this.coordinatesMode = Texture.CUBIC_MODE;
        this._extensions = extensions;
        this._files = files;
        this._forcedExtension = forcedExtension;
        this._loaderOptions = loaderOptions;
        this._useSRGBBuffer = useSRGBBuffer;
        this._lodScale = lodScale;
        this._lodOffset = lodOffset;
        if (!rootUrl && !files) {
          return;
        }
        this.updateURL(rootUrl, forcedExtension, onLoad, prefiltered, onError, extensions, (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.useDelayedTextureLoading, files);
      }
      getClassName() {
        return "CubeTexture";
      }
      updateURL(url, forcedExtension, onLoad = null, prefiltered = false, onError = null, extensions = null, delayLoad = false, files = null) {
        if (!this.name || this.name.startsWith("data:")) {
          this.name = url;
        }
        this.url = url;
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        const lastDot = url.lastIndexOf(".");
        const extension = forcedExtension ? forcedExtension : lastDot > -1 ? url.substring(lastDot).toLowerCase() : "";
        const isDDS = extension.indexOf(".dds") === 0;
        const isEnv = extension.indexOf(".env") === 0;
        const isBasis = extension.indexOf(".basis") === 0;
        if (isEnv) {
          this.gammaSpace = false;
          this._prefiltered = false;
          this.anisotropicFilteringLevel = 1;
        } else {
          this._prefiltered = prefiltered;
          if (prefiltered) {
            this.gammaSpace = false;
            this.anisotropicFilteringLevel = 1;
          }
        }
        if (files) {
          this._files = files;
        } else {
          if (!isBasis && !isEnv && !isDDS && !extensions) {
            extensions = ["_px.jpg", "_py.jpg", "_pz.jpg", "_nx.jpg", "_ny.jpg", "_nz.jpg"];
          }
          this._files = this._files || [];
          this._files.length = 0;
          if (extensions) {
            for (let index = 0; index < extensions.length; index++) {
              this._files.push(url + extensions[index]);
            }
            this._extensions = extensions;
          }
        }
        if (delayLoad) {
          this.delayLoadState = 4;
          this._delayedOnLoad = onLoad;
          this._delayedOnError = onError;
        } else {
          this._loadTexture(onLoad, onError);
        }
      }
      delayLoad(forcedExtension) {
        if (this.delayLoadState !== 4) {
          return;
        }
        if (forcedExtension) {
          this._forcedExtension = forcedExtension;
        }
        this.delayLoadState = 1;
        this._loadTexture(this._delayedOnLoad, this._delayedOnError);
      }
      getReflectionTextureMatrix() {
        return this._textureMatrix;
      }
      setReflectionTextureMatrix(value) {
        var _a, _b;
        if (value.updateFlag === this._textureMatrix.updateFlag) {
          return;
        }
        if (value.isIdentity() !== this._textureMatrix.isIdentity()) {
          (_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.markAllMaterialsAsDirty(1, (mat) => mat.getActiveTextures().indexOf(this) !== -1);
        }
        this._textureMatrix = value;
        if (!((_b = this.getScene()) === null || _b === void 0 ? void 0 : _b.useRightHandedSystem)) {
          return;
        }
        const scale = TmpVectors.Vector3[0];
        const quat = TmpVectors.Quaternion[0];
        const trans = TmpVectors.Vector3[1];
        this._textureMatrix.decompose(scale, quat, trans);
        quat.z *= -1;
        quat.w *= -1;
        Matrix.ComposeToRef(scale, quat, trans, this._textureMatrixRefraction);
      }
      getRefractionTextureMatrix() {
        var _a;
        return ((_a = this.getScene()) === null || _a === void 0 ? void 0 : _a.useRightHandedSystem) ? this._textureMatrixRefraction : this._textureMatrix;
      }
      _loadTexture(onLoad = null, onError = null) {
        var _a;
        const scene = this.getScene();
        const oldTexture = this._texture;
        this._texture = this._getFromCache(this.url, this._noMipmap, void 0, void 0, this._useSRGBBuffer, this.isCube);
        const onLoadProcessing = () => {
          var _a2;
          this.onLoadObservable.notifyObservers(this);
          if (oldTexture) {
            oldTexture.dispose();
            (_a2 = this.getScene()) === null || _a2 === void 0 ? void 0 : _a2.markAllMaterialsAsDirty(1);
          }
          if (onLoad) {
            onLoad();
          }
        };
        const errorHandler = (message, exception) => {
          this._loadingError = true;
          this._errorObject = { message, exception };
          if (onError) {
            onError(message, exception);
          }
          Texture.OnTextureLoadErrorObservable.notifyObservers(this);
        };
        if (!this._texture) {
          if (this._prefiltered) {
            this._texture = this._getEngine().createPrefilteredCubeTexture(this.url, scene, this._lodScale, this._lodOffset, onLoad, errorHandler, this._format, this._forcedExtension, this._createPolynomials);
          } else {
            this._texture = this._getEngine().createCubeTexture(this.url, scene, this._files, this._noMipmap, onLoad, errorHandler, this._format, this._forcedExtension, false, this._lodScale, this._lodOffset, null, this._loaderOptions, !!this._useSRGBBuffer);
          }
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.onLoadedObservable.add(() => this.onLoadObservable.notifyObservers(this));
        } else {
          if (this._texture.isReady) {
            Tools.SetImmediate(() => onLoadProcessing());
          } else {
            this._texture.onLoadedObservable.add(() => onLoadProcessing());
          }
        }
      }
      static Parse(parsedTexture, scene, rootUrl) {
        const texture = SerializationHelper.Parse(() => {
          var _a;
          let prefiltered = false;
          if (parsedTexture.prefiltered) {
            prefiltered = parsedTexture.prefiltered;
          }
          return new CubeTexture(rootUrl + ((_a = parsedTexture.url) !== null && _a !== void 0 ? _a : parsedTexture.name), scene, parsedTexture.extensions, false, parsedTexture.files || null, null, null, void 0, prefiltered, parsedTexture.forcedExtension);
        }, parsedTexture, scene);
        if (parsedTexture.boundingBoxPosition) {
          texture.boundingBoxPosition = Vector3.FromArray(parsedTexture.boundingBoxPosition);
        }
        if (parsedTexture.boundingBoxSize) {
          texture.boundingBoxSize = Vector3.FromArray(parsedTexture.boundingBoxSize);
        }
        if (parsedTexture.animations) {
          for (let animationIndex = 0; animationIndex < parsedTexture.animations.length; animationIndex++) {
            const parsedAnimation = parsedTexture.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              texture.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
        }
        return texture;
      }
      clone() {
        let uniqueId = 0;
        const newCubeTexture = SerializationHelper.Clone(() => {
          const cubeTexture = new CubeTexture(this.url, this.getScene() || this._getEngine(), this._extensions, this._noMipmap, this._files);
          uniqueId = cubeTexture.uniqueId;
          return cubeTexture;
        }, this);
        newCubeTexture.uniqueId = uniqueId;
        return newCubeTexture;
      }
    };
    __decorate([
      serialize()
    ], CubeTexture.prototype, "url", void 0);
    __decorate([
      serializeAsVector3()
    ], CubeTexture.prototype, "boundingBoxPosition", void 0);
    __decorate([
      serializeAsVector3()
    ], CubeTexture.prototype, "boundingBoxSize", null);
    __decorate([
      serialize("rotationY")
    ], CubeTexture.prototype, "rotationY", null);
    __decorate([
      serialize("files")
    ], CubeTexture.prototype, "_files", void 0);
    __decorate([
      serialize("forcedExtension")
    ], CubeTexture.prototype, "_forcedExtension", void 0);
    __decorate([
      serialize("extensions")
    ], CubeTexture.prototype, "_extensions", void 0);
    __decorate([
      serializeAsMatrix("textureMatrix")
    ], CubeTexture.prototype, "_textureMatrix", void 0);
    __decorate([
      serializeAsMatrix("textureMatrixRefraction")
    ], CubeTexture.prototype, "_textureMatrixRefraction", void 0);
    Texture._CubeTextureParser = CubeTexture.Parse;
    RegisterClass("BABYLON.CubeTexture", CubeTexture);
  }
});

// node_modules/@babylonjs/core/Misc/brdfTextureTools.js
var _environmentBRDFBase64Texture, _instanceNumber, GetEnvironmentBRDFTexture, BRDFTextureTools;
var init_brdfTextureTools = __esm({
  "node_modules/@babylonjs/core/Misc/brdfTextureTools.js"() {
    init_texture();
    init_rgbdTextureTools();
    init_tools();
    _environmentBRDFBase64Texture = "data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAQAAAAEACAYAAABccqhmAAAgAElEQVR42u29yY5tWXIlZnbuiSaTbZFUkZRKrCKhElASQA0EoQABgn6hJvoXzfUP+gP9hWb6Bg00IgRoQJaKqUxmZmTEe8/v0uB2u7Fm2T7HIyIrnz88uPvt3f2a2WrMbOvf/u3PvvzP/sUf/N6//i8vf/lv/3v5H//d//Sb//Uq/5u8yf8hV/m/5Cp/L1f5hVzlG7nKJ7mKyJuIXN/hPwqXI/g++zq6rPI5u8z+WqfLre+zy7PrVv9L8brsMiGvk8XLmM/sdfHXal4e3ad6GXPdyu2ij8u/+uv/5cuf/OSLfdtEfvUr+dnf/d0X//t3H/7bf/hP//N/928h/0Yg/4VA/kogfyGQP5Wr/IFAvhbIlwK5CGQTPP+9z5uPeePJSW+yo2+s/GtN30Rnv1E+f5zxof9R/lSXv/nr//mrr3+i+5dfyX7ZZQP07Tffys//8R/l/9TtX7790T/7r/8G8pdy+/8XAvnnAvkzgfwzgfyxQP5AIL8vkJ8K5KsmMVzu1U7p5PA5AXxOAJ8TwPf7sX/51ZeXfcemqnp9w/W77/S7X/6T/vzf/7383RWCX3/z05/9i3/13/0PX//eX/2FyP8tIv+PiPy9iPy/IvIzEfm5iPxCRH4lIt/c/393//9BRD6KyKf7f488fP74/PH544dJAF9cLl98IZfLBZtuqterXr/7Dt9982v95S9+Lv+gF/3i7Spv/8lf/vnf/vGf/dF/JfKnIvLnIvLvReQ/NEngn0TklyLy6/v/34jIt00iGJOBlxAsdvv54/PH5493SQCXy9t2ueh2ueimKorrFbjq9eNH+fDtb+TXv/ol/vHyhX4Fxfbx7euPf/Lnf/PfiPyeiPyhiPxxkwB+fk8AvxzQgJcIrGTwFsiAEXH4/PH54/PHUgLY7whgu2C7bLqpQgHB2xvePn6SDx8+6G9+84384vKF/IPu8iVU9Y/+7C/+jWxffiHytYj8VER+X0T+oEEBvxqQwCMJeIngo5EI3goIwVMIPn98/vj8ESaAbbtu2ybbvl8u2ybbdtluSECA65u8ffqIDx8+6G++/VZ/efkV/sO261dQXP7wT/7kX8vl8qXIFyLylbySwe/dE0CLAr65B/9vGn0gQwRMMqgmhM/J4fPH548eAezbZd/lsm3YtssNAYiqiogAAkCvb5/k46cP8u2HD/rrb7+R/2/b9Wu9yJe//8d/9Ney6S5yEZFdRL68/38khG/uKOCnAwoYkcCoEXwkEgGDDq7CeQfyOTl8/vhd1QCum26ybZtu2yabbrKpQvXue1yvuF6v+vbpTT5+/CDffviAX1++1V9sO77WXb/66R/+4V/dgkbllQi+aBLBV/dE8LWRALwkYCWCNyMZXElkwLTMeMkga/P4/PH547ccAVwuctkvdxSw6bbdtYDbTfSZBN7e8PHTR/3u4wf55vKd/nL7DX6mu3791U9//5+/gkNFZGuSgZUQvnKowKgLWLTAQgRtEniTuEfwaELw0MJvf3LQzynud+53uG+X6y3gN9kul+2y6XVT1U27JCDAFVc8ksAn/e7jR/nN5YP+avtWfq6Xy9f7Vz/9w1dgRYngiyYhfNkkgzYBWHTg44AEMmqQUYQKOmDaiCIa8TmsfmzB+DnZDQjgcpGLbti2y3bZHjRAdRMVvb/dcYU8kcDbPQlsH/CrbddfbF98+RPZfvLFnAQeieCRDC5DMvju/vmD4JkEvjRQgKULeGggowdHkAHTYxihg89vu88I5UeGAPSOAFTlrgPopiqbKPSmCKreUoAAkCcSePukHz590m8vH+WbD9/JP335k6/+tA86KxFchv8jMvhiogE4JQm8XhfKqOAqx5qRPyeGzx8/cgSwbXcUoLJtim27C4Oi93+4v6VxQwKAvl2v+Hj9pB8+fZJvt4/yzfbF9lPdv/wJnsE2BogmyeCRED40tGFvksIXiSbgiYSRRpDNDZ6BDI6ghM+J4fPHeyKAO+zX7cb9t4tedMMNAQju5V+f1uAtBSiu1zsduMrHy5t8ePsk3376KN98sX/xE5FPAnm7/782o0DiUINXMkCXCB7/P94/e87AWUmARQWVvgMuKej9t1RLBp+Tw+ePgwngsutFFdu26WXbbl+rSvdfbnqAiuA23QcBgCugV1zl7e1NPm5v+LC96XfbJ/1W9y++fgXjA3bDYXV+MuhRwSPwL3JLMFYC+HS/LU8HYrGwIhwyNOF12SvgM4SgztdifP85MXz+KGsA2C6X7aJ6bXSAOwrY5OYIqGy3d5uq4P5GhABXuV6veLvRAf10fZMPb2/y3b7vX7+g+9v98/WOBq7GG7RNAlYy+Dgkhhb+Xxp0sE8IAC4SGAP/TbgVJK/PoJPBnAiwPKxsXfbbnRg+i3s/JAK4Q/4b9NfLtomBAqCickMBjy7BuywAUVyv8na94tMjCVzf9KNcLl/0SeA6oAEYb1i9g+FtSALb/bKL8/+t+wxXFMyswqiHoK4ToIgKqslgpg1qUC0QoYbvJZg/B/q5v4szHmPX7YEAsD0CX25OwEUVm9xag1+agKg+nxQArnKjAtDr9U0+Xd/k4/UqH7bL5YsewrcBBiMJZPRAp6TwQgWfjM9vgRbgUYGL8AvLWH2gqhesCokeUmCSwPsnhs8fP2YNYMO2XeSmAWxy2VQaXeDmDIhApf33rD4PTUCuV+DtCn27XuXT5ir8VmCJ2G5BpBM8/r/dEcJb8/0lEQMtJHA5TAlqNuLRhJChhEpSqFabH3di+G1AGj+W1/dyAR4IYJNNnuLf6+tWC9CHHiAtFhAIFLjK2/Uqn65X+SS67aK+3QeTDoy/IG2ogQ7fb/dAtz5vBgrYGqrwNtCHsVfgIvwK07OTQBURVNCBFpKCOjqCHn5L/67TgTN+fpySAC56nwSUi256kXsSuFGAVyLoUIDo8/Pz7fdoErr/v17lk162HbgHvFpIYDfoAJJfW4sGPjkU4VNAF8ZEcLmLhdc7kljdY1y1Dq9yLiI4IiRqcLujb138KIPn80ejATwRwIbtBvn1cqv+2J78/5EI5N4cJA8qIPcmwRsKAHDF9WYP6mV7VmrgLuTpxYTcMEW0LAmoQxFsuvAI8tv/a/C5fV2ZMMiKg++FCM7RDPRu8ebWY7VG6VJi+Bzk35MI2LsAckMAgwvQ0gC5DQjd3ABg2HQLAPpEAlZ1Bu7VV7MGHDFRAbo3VKsTbAY9sPWC/uvx86gBbDK3D1eEQS8pbAeSgSwmhepnJb6uBv/o/PzHLzxWA/X7TH77De5j6AGQi6o0CUGfCOD2X7cXAlCFQABtEsGLDtxuOyQB2UTQBKZe5GUPXgkUYCUAbZJRhBDeuq8xBf+bgwbehDm+BFQi2IJksOocvA8ysIMfxluVcRsY/eB3JzH8GFDAXQO48X/dcIf9jyDHptIigDsFkEe066tBSETQUYF7ElDdYEBytN4+rk9UcBPfrKaZqFHWcw3i4J8/X4ev2//bSXqAhwTay6OEIPLD2Ipt8OtAGzxkwLw9WVFRjTc/qC6H3+YK/b1oAA0KuOizHfieCLaHHiAb5NYTIC9EMEbZrVEQt1xwhVy1UfBh8PUOquMizwaap3tQXfY5B//tea/NZdfhsvbz+PURQTDSGWB87VX/7WSd4KxjUqrIgE0IUkoKGnhIvwvawpGf6eECXJ7tv4qbA7DJgwpsKthEmmYgfaAAffYF3HLxo0vwNjJ0SwRWMG4db4eh1gPNm18vQ+us/0eGmxDemu/fnM/X4evq/8342ksGHgLY5LyT/zg0wM8lcMjgGFXwqIOVFJBQw99eCvF9oZL9Mfl3QwAvIXDsBRC9R+fz8x0FPBLB0xJEpwUobrfAkARgIAF41h3wQgP6QAmX5E/7eI43IxGwwf/moIkRyWRJQIPgt9CA9b39nzt4bYUWjAlCjWDPgv8IEjgLJfzuaAsrv9VdVG4OwOXW/fdoA35qAdL0BDwvf6AAUVHd8LIEu94A3K+Q+2YxaB84MOH62P//qoo38fCRDERE2zf0JfmDa+MieElAjcDPKz+mRKCOtdgGtXaBjgNJ4H2owSpNeAW/rRH4CaHSpMwnBYYycjgSJwfie9CR6mPu20Uv8kABF206AvXlBMiIBPSlB9wjBW1fwEuSb94296VCqgMaGCt/G1BbExi3IG+r3a3J6P48Gv/J0YmEYoiGY7V/SxwFCwGoE/xa0AJ0CEiV9QPCJb1OJ5F1VTjEY2/MO9AEJvj1BJTQpqLfTlGwjABuzT962e4IoKnyrdh3+/6mzDVJ4PHOxj0JqGKoy20+wBMN6D1gLWi9NQHfVP5MEEPzjGYy8BMAOnTAJgEr8HUIejRo5xrA5xkR5AngmiSHs+zDDAmMgWzTg55GSJEmHE8IvWPAoYTfhWak/Wn/bQ0CGLSAjv83SUEfKp5q24LXuQICpzrjrgWoza8xVE00CQCORdhMJuTUT/rjuls0gO4Iby8BIEgK6gS7BsGuTtDrScH/fR68biUHNVGBnxjeNyHEvQe/ve3LZQqgG3rof6cEclsNflG9J4KtaQ8WHcVBHS1BtHE4QP9OBMS98mpbKTeDW7dJwRsnHpMBTFJpV4I+b0kY/NqInVFSyBLANbnMSgBM8F+Fqfxq/h657/Up+GaBnwV9hRqc9bZ/vA6vu+T9E8KPJWns94UfTeCj2QXwCHS9dNL8Xf3Ho/rfewSeFODGDV69AU0y6NFAE1DP3qK++rdB7/1HRxf86gT376zOr99T/h/ioBiXWQkgQgVeIrCC/WomhDmQK+hASI2ARQZKooHMLdCJwGEBBXC3+uERwg+VOHZ9ioAt9H80AI06wGgJ3nQA3BoCut6AhxYwgcPOFnxuFnrphk+NIKIGrWPQtgz3b0i7Y6D5rs1GKqTop0nQX52vmQC4BkjA+r4a7Kx9WLENGeegkhSETBCrNXIMdi/444Rw1n6E96ry7OPuj8UfLxtQ78NA2iSBbg7gIiIbdDLsb5agPhLC3RkYKv8NDbS2YGsatNRAG2oQwf9ZIOydgy1MAzBkAw8UwEEIDzSAqdPQ6za0PkeJAMH3Z0wXniUSZoHvBXU2mcjQgv56TedIKglCpIoQfgwCIjOytd8WgN0bfxoR8Fn9Gx0Aj5Zgq0lIZbsH/ibSJoFnS+C98g9ooHEELI3gliy25yONIiE6pb0NfBlyNEYyENoodkKwgl6I6s8kARgJ4ZoEfuYWHLEJa0LhSBXm7kImGeSfVdoJ1DO2G7WXsehAptupSOoyrCSF904k+6vt98X/ZcM98Hsd4JYIXhQAIg3/f9AAUYhsLQKAtkHVBnzjCKhOoYl2ym+iBtvzDzQ2DLXJ4PUmbJHAVnBQX4jkxfvHhNDqAdHXGQJgv0aSDGItgOseHIU+K9hXnIJzkoGlEKzNHagTdJ6VWEUH4iCKH4fd2AwDPaYBm4Wgng4gQ9V/CoGiuNmD04AQtNGMGzSAAQ2I2pzfogY9LRh7BrbOh4+D30sAencljFu2CUFrwY8UAWRfWwGvVOVfbx2uIILM0pwDv082dUTw8hYs8L+uIWiHGpWgClnAa1lMPJogovvvbePPs/q3Xr++kgCsfgB5oQF9WYKPJqEn6G+OE3i5AqouF59FQOmahQC8rlPLj38kg1c2f30vw+XaoIX24/pMGIgSBoZqoH3wo0sIIGlA9PWcCPrAtpPB8eBf6x1o6cHra+2+tpIFP4PgBfxZtZUJfo4qxELT948D9ucK8Mt9+ccjIQw6QJcEbrD/1g340ATuDgDkFfx6twSf1f9xvuBECYxq/7ythQQGm+5JDx6Brw4CkMGT3wgscCUoQ4sU2t6DR2ciBjTgtcpenQoZVX9NuL4Owc+dVaDursYVkVALX+shjSBKBuvCYDUZjE5BdNkxdHAUBexyHwB6NP7Iyw7sxUDViwge1t+mz8B/LAvVx/c3PeBBCToB8IUGOgqA3iV4yUg6UAOxaUFHDx6CYS8SorMOue0CCJGAf5YfRhoAI+A1CvwxqNkAY5yAIx2EQmkFfeWOXi+nEdSQQA0ZHMEItiagJArQxDXIrj8nCfQi4HZPAttrIahso9oPQ/2/JwV5JQU8zw+7I4D7/sBn4EO6rjw0FR+i3Z9fHtahzsFvJgM0X+tmVH5vaYiNDGAigewAz+gyNLThnjCURQFR1b9d3lZvnVqmj9mEPDKIUIC4KCCjBXywS4N+otp/Hk3QVthOkwEKlV9PQwXjT7s/zwF4Qf9toAAzFdjuaEB6S7D1//U5FIQu2MevO0rQQH8ZmoXE6B/IkgE60XCjVoq8gt2iCG0S8L5GdxkM1cGsfsCMArSCAnrr7dzAZxCEEpepvB8tqHJ/q+bmJGGts/AcAXFOMMeTwC7Pw0B6CtCtA2vWgonqBQJFSwH0JQK29OB2kvgj2HHXAoyeAIsCQO0kMNECAhFMqCBf8mElAkyBbX1tJQP2RJ/ha0gpAfS9l+/5n00CkrQpq0MZbOdAuxmMvHswog62jZj7BnYQe19b14kxNq2D/ehX/p68HEcF+x3yP7z/V/A/q/5DA3i5A/dzA5pdgbKp3v3/wQF4Bb70WkCTHGRAA6+KL0bFl6FJaFw0ImZwm6igSwbbwPn9RMBWf3sN2JgA/BVh/Rg0kQBgePf6HglAHLFQwqQQOwDjbdVxNZjR4iM6Qa3WxwvNxh0JFb3g/WzFQQS8b/ttKcDWoABtUMAd8j9hf0MB2uDXhzX4CHj03L9DBU3Qjz0C0l4mLSLQPicOOwZoVCB6P6dA7nDbGkVuxcNr8PU2JQO4wX5trEqmccZaHU4q8oCDFOpzAnOwqyMIMktNNNAHouDGxO37DgArQZzlmp/14W1QlqHTMaIIx7SCx0+5yza7AKJ3IXBrNAHVDcMZAU/BT/vgv/ULPOA+XiLggAREDF2g0ci6xNDRglegd7P7TWWH5oJfayliEg7bScQRBVgI4Ookg/F6rvpLWP29swREqA3CaG8/FpKqS8DTAV4TiBqIqtxfzaQRLys5I0XEFIFrPbZRQb+16Fgi2LvJv8EFUPW1gGfQv1T/F/d/HBnccP7rAwnIIyHI4ArgWeGbU4eHy6Tx/EeTZIb5bo/BsMBjmjBE08f/RB0PHYBd9eVRAGY7cHRwiBf8WeCPHY1bgBTa9xKTELzEkQX9CPtl0gJiqsAmCT7I8xbjivh3JGFI+D2nBcSJQJ8agDX+O9iBL7UfG4bzAkcaICrbtYHz1ycSmGmAjJfL3CMgT3tQpmrfB7gxSzC1DnvdhQMieG47u75+kTouKNkM8c/+vq/Q7ZYjO/hhVvRq8F/9gGfhP8aqE9EIdR6LTwJ1h0BItyDqB8iFwuNqASscRnYioxOg9ApvnYA35f8e9Ohbfe8J4rknoFkO0lmA2gmAG0YK0DkB4ieEjiLoMD8wBzom27ANZkzIoU8EMHk/uo1mzeVoEoRWKn8L/62EYAX/lsB7D/LXg74uAMr9oGivJ0CNJCGD6i9DhZdQF+gtOp4S+NODRzsDVbhdgv4BqTMNyIL9SCKwL9/FGPp5oQKxIf8A/UX6r231H7YIqLML0Ae2GtrADOvRQH5b/MPE9dt9BGLNG8jVTAQvIaK5TtvvvWQgDvyXIClUA78S9Nfg7VtIBlO7cbsEYkQDMot+ygQ7QwmOawTHnAM2XUSnJvPIYRYMmYPS+sv3J+cfP3d04JYIXsF/EwMbBKB9Q9AY+BiSwFj9mzrSXmcJhFPVHySTbgHJCPvRQ/z7G/SVUETsg0ZF+i3CRoCjhf7y1A9mOiDD7TwdwEoEXjLwAv+avLE2B7Jnb+OqDpBoAchoQJskxKnss0vu7Q2YhcDv4ySeLOg9GsCKiUIihP7yfW7zbTsBh0TQfN0iAWn9f72Z56/Ax9P7j5OAH/Qvv3/QxKfk0DgDuP+R3USg3bzBC7bO/QT9Eeh9QvDPG7glBQzJwK740lAFFgFk8P88CqDGAa223YckWYhr+c0BPdwetl2ocnsfzePAWcVnnAIp6gDVhDLyfV4nqFEDPxHsbWD3k4BDkN+pARqKMLYBPzYEvxp9xmCHQQdgWH/9EtH2TIFpu3AH/cdGydv1j0TQbRrq+D/mLcX3ZACZ15bF378CG0My6Kq/zoGOQwhASDFwFbxyNGBuSxbCEhQ/uEPe/6gAERWQObCVVfjPpQX+rexxYhYFxIkgpgX7Y/vPs+Pvxf9vwt8kAs7i32t3QCP+3SPaTwIytQXP38u0PESm+YER+o9B3vr8mETAUfDrEkPI80ck0FZ0dXh9U+HRbhey0cAc2H7A4y4egoD6y8JfkBiigLdFP8v2W00E8deT2IeAKujZ/QAVKpAtKI20gLWksHedfgPcb+0+NEHefd9vB9rayi8h7J91gBbaw20MsnWAF5xHkyDUCOoXp+yrOwwxcKj0aL6fFppaaKDv6OpHR5sgx5BAlK/+fYhuP1D196o8e7lFBaKqv5YIMnFQpd0FGVR35RJCnCDaABaXBtgbiSwtICMtalKC+1JQ6bx/PLcDPQL91QFodQNKpwOgF/9eqcBxBBqRcKAAVk+ArQOMx1RYGgB6naDhlK+uQQwJYx4meQbxtNnYQwMjt/d4f3M9ZE4UOld1LAh99fbfzOxiEkKFCkTJIUIMUeVnJ/9sDt8/e1NEJOi9oVHDGYhgnSLss9DX2IAqw1zALUncKcDr0FB5NP+0cBQNrEezDiyiADPkt9qGpwoPdL0AGPx/NOKeyf3b9WJNdfcFv6bKd2cLMJVfJ6Y3B6wB9WFUfWWEwKMfGiQL+3bz9XGQz2EHKhF41GCtZyDi/gUCsNhYoAr3UNJ58YidHKqnMb/6AB5J4N73/4L+t7mAkeeP3P+1LNSB/l0SkMEd8DcEuUlguEw6t2AU/PCE/q++Akw6QFf1u6SBrj1ZnnhG50AfkoGIdf7gJv1KcSfgzWWkQ9U33Z3tHXYASKJ9e/YhU90rvD+q9Ej69/wxYJVs506Eg/r3DkMDzEdDBRGgcZay49XihLA30P+l8N+hf1f57/0AoxbQbwYaan/rBMirE9Dk+sBzTkC8JNDEUlv5McB8PP19Y01Gayep+hC/2zvQ/2HGLAurowsNGlA1cnqGGzeH5weiYLZm7h3QQC4O2tXdhvMMk1ZS5ebpgI8eMrPvPGkwaxayk8Yc6PMOBPEdC1XZ+2UfbfOPtxLMQQAG9BcZFoF0gp/RKjxe7+oAw9T7ZPWhgedodgz0gf5KBtrtIZhQAZpAV1Bi36w6t98qVfH7hqGI318lLCjLCUFlxRHwqYEH9a2qb4XjWvDT7kBwfbZA5P0+PNuRuW1yf4yNQH3zzwv6b70QOJ0G9OT/dhoYRUGT15uQH/71MjQLtQlxfDuiCXrtM+SkA+icQdH6sU/xz7Ze7FlubV4TpoTQ2osdpaEjtqADmEU7OkBEFoLeC3IWFFeswJXKXzkboNL+wzcFHU8hTGKIboO7CLi1/P+5F+gydQhuvRbwEgxvtACmANikhLTbj0gCYk8KdlYgmj+4Ymaod7TwahwadICuX0Cm2fE5iNHPK0x/CDV66Kyg1MnqjNFBnhBoLQCgUULfaVe5nq/6EQWY67bXCszUb+7232fVPz51iGB12owK9peyP1T4raMFF/OEYJP792mgXYfZ04GHMAhBkCSmSj+dKqRPgVFGHbpLEGMiGFeQWfSgrY52VxaeDUPSNJI0P7NoisG729HHl78z6hxfs9rV3m4JjgM/lsui2qmThjCfDFSb+I9vwUqG5wwL55U7C+6ot8B+7N2o6r3q37T9trfpjgmTvv7PSQATLLeRAOZhIJHBQfDQQJPBdUwEbVW3+L08EcEE/9G4ANrCeWcnPKRHDupbNynMx5AA9IRYLmrc/YLSiD5EaEBS/s/TgnU9ILcH19n+CpHwegLejx7Mn/d25fdN+e9U/1vgb7bqf08MOtf8EXxaoh+GY8L6gDfhvs4i6HQ7seYI2sv1GchdMsBIG3xlvxcCRzdgCPTn+6q/TW00VE8Q9FaFv+R2VlOM1vm/hhjhDCdgNflVKME5B47I9xT8z0YgPAJ8myb/LqHy36j/Mwqw9AALxuO1JVjiuQAYLcFzIhiEPe05fk8tRjGw7yWQbsfuLAT2VqOId1osnr0F49VM8INACPHDoBz4B5mqqSnUgyh3ArjXxfQH5BbgUS8gP7aU+w0zHD9GGD0CGHf+P1p/DeivlhU4BbxR9a2kYFR58YaDZCUR2P0DMmgED2eg77puegy6PgDphEB0CwlG/i9d+/Hs34pBEQrBn0W51mqGnJAk3ACCHeiqkQ1XFQA5AlKH7Lk8yJKWY3/nym14h2C3JvxeMwD9ZVMz0BPMi1n1RbKl1cYhIVblF3G0ATsRiCMUvoK9//OgcwYMoe+ZKOLlC6/Xk50br9NFz9fanqA8UIYSpCwlBO4kHc4WLLBfBHVaKwKgLQjmP4Un61Vq+3s7Bsyi0WztmLjJwJwFeE0I2vD/1Q6MVwefxfUf32skCPbCnxQqf+QMPEUDHZ7vGeyj020JgkPXXwsldA7SYR1RE3h94NvNtugswcgxXEkIcBPCGZ1rmrgDC0A4K88nm2fn/eTnpQtWyZfybRoK8Dro4zYDIMGsf7saTBzvX0SMbkAD6o9CYbsfMK38cJKD9l2FJt9/VGs0h5Gib33pxMKWNsigFUh3G2un+/N1WUglI/EEx8fq27vUNnwsiOoKecL7kQS8VnWAGCFUgn6dBtQhv40CmIYggwK0uwDHRGAuBXVdfwzHUjZzATLMAoyJ4FmBhzaWBlrHld9CCWpPHRqofBqMReMGTJ78q9rDes1Tv7/0m0v0AFHXNR6P6g30SHivin7V1BOhh3iWPwvps/yE836L2XiwnUT8x2iHgfqhnwn667QHEE8oLQjEvtEW7GYBZDrDVkwNIO4G5GiBDf9fGoFM6n+vbEtzXwP6u9AduaWnGYSLAlVdl/AU+ikrSeEIKgwdaZ4AACAASURBVKj4/wtgHcHtdO2nWKcBkPfxcvnNQvsj2Me9f02r76T8q0IBn9OLKfz1HX8yVXQYGoAB/2UeBQ5/5kCL6+H/OGGoRnLSwdd3oH8r7KkGTbgIxEwVWvnF8KOpHnyzfF9Jod5Px+IF1h8owyitDw/XEgRb5bPqbt1uvn7qBIQ16vtS/u+DP3cR7CH0WWJgd5mTJKYgNzoGjQrfvu99NDBC+bnyW1x/qhTatv2OaMKgJWPvv5kwnMgxHYGFRtJW8VMl3uP+MgoqSZyWFKr7+KIDw1d6+IiOgZI4+d5iYL3imzbgyO+tph9t2oSBxOM3ugHtPoFZ1LM0hF4kXNEBssvVgPdjdXZWK7uKvyS3q1Xb1WQwtVDqSUggq+Vw3t56JA2cz7PXOwGNW1ecwxPhfe3QEUsDsFaAz8jg0nf+iZMAHNg/XSazDuC18Iq1HBRrOsAQ8NLB+16g614jmuSgs3bROxE55D+WDDQNA4ivdMJ9M1b309UqknaDU8ObV9/PwmMPATvTMAxpABLBzugUtV9bLdhNDQA+7B9tQJ06/7QNDHGSwtgZOCIA47InIoDdROQGtt0U1HI3GaoUnCnC/rzBMQJteN17+VaAzYNA7e+PFqHQUyXPUYB7iQYa5ZFjq1Zqpx8Uqu/XT7+6BWC1Xaj0GlBIwMoHu7UzcI/6/Acb8KIq+hzmGWmAYnADrIpvKP7TZeLaf0LAeQkGgebbq9FToI44p654F47tekKkI0L5PQNZPsDwPBpy/ni+wKMN76Vav4+2cFZFf8+JwAraMt0DFB7beA/u4Zz/a+RXx0M/ct4/jwaNAS8G17eSwmta0Fhx0VRxJkHMivso+onMXr+YwdWKbgioy1jp4x4AzIKg5lEA7wvHEYCRmdx11TAuT6lDLVl4KvXkAET9P4RT8H2u+lg9EPQIpw+/NpJ7RwE8HaDv/Mu4f3OdNkq/EfAiEiOANjEALvcWL9gfFV4NZbgbQc6qPky4Pm35QZxtH1f4j+P/jXuaYPcWwIEH/fmEPBoAO4m4LGxV3txOQqDU+dXgey+UwSzuqP++uImO/u/6ogCb7wTc1n61sL+vZi87rxnrNas+giTg6QLzaUCjIp6JfhwtGI7AjBBB9JjDY4ePYVR6ZPgN4owVv6Q2N5hhVHwNeYrM+w6dN6K1sMHZm/Ce7bHe3dzKr1xw1w4JrSQMZtgnoQHlr18fzunAszD4qurNUg/TDqzx/lfCaO6t4tACMUQ6P6htWjDPC1hCoZ8kpODzJ70MUR9AODcgwyqyPhmE+wfHYB/hvSqt6qeXUShhXH+d9SR8DzrDaZZdpSp/HxqLMQuATgDU/qDPRgOIeT8cvz/h/XC6BtE7ACLOWPE0KIS4UUjmZaJ2grBphiWgT41BUVWZfP3AnEIT6OrfoF122l2rMycBoU5i/OXoUZ4/aglsXwLzHNU++FVF3qikOj5HXm2PBitT1WuvJRAB+6O//W0/PY8vQH5IrAsMs/WuVmAdHBrQgrbOxJShXwRSsu08h8JMBpo0+aDTALwV4tbswgzHrftG/dJKIAQb5h9KCssWIMeto+GYqG12/HWGjx8kzqNJaa0noMWOr2KwW01AMwJoNvhMQda2/RKQP/3ecABM3g9uD6BY68Ntz9+nDOMb5iV+hIE+dP/Zs/wwJhJ9mgBnohBuStABUXjugF3hkXF9ZZJAjefKdHZCc389LoStKvIl7QIEb1d9RyciQgFDI9Cjyccc/23Aam7/PZJBhgDgin5CtQvbCzX8ip9YgIFtOAt+w0owp/hOiCWgEGbVHuYjRigPGR/YOnEoqPDoV5z5YqB3mRq2ox5ICmSSgAP1Ne+XV2NE+/vuFbCTRADxtS70VRBCjgBk2OyDUQiUgfl77b7DwaHm2rAZ7osRSOOUoHgKfNBSLI767+oDYrfwZvqChSpGfj3pFwZFsCJg2jeIQQBUiyI4WgD68ww4qO8khuWkkIuDrxWv2nv+UTBpJYiPd0KemTA8qqFiuUF1jWS3BoG6pADJq751JqBI0wvAVPyMQvjcX1zbELltKK+zBiXRFiRxG+b7q3M9xuLdzR8g0gCGNzSM5gNYfqGO9CBT8OHct6oB3KsSDBisUnwsFuISQaRHxDSv0vptt2oeLHMERfRn/FG/Cx01EpgIQG8LP+/i37PKw53xn6sYCM4/JwSRrCnIeB1ZkLsawDhaPKv/njU3wnZ/dBdGE8+YTHSG8+ofGgIjsC19YnwdM/KAnTSsqj6ig7uGgIPw3nYFzhhIIvriAxFP9CQd4HSlnzgxONIdrE7A8ZDPx9fjib8ifgegNIliRgdx95+E1T7+3nQVNNhEzDgGA3T2rEDLduwtPpuuouPcs8swwXFjdTaMKt+jA5gUAQPcf95KJQxYU0cYxEDvsBSmYuukp7AwnqniC9Afa5z8vboI68ImT0t26CvwBzSggkj447r9IojvCn7U92J/Hw0QSdwZKNNjxPCfSxRqnATkdwpOwh88oc4J8KTSm/wdbZjrc+4iFP8YO0/5JJDCfaijK5xVXevqfg6zGRrQf83chvX4aRfAE//6vv5+6490U4ADdO7QgM/5bcHP/n4OtCQhBEFeDWSvos8DPq8/IwzLzjpa8/U6MMSkBklDm8e0mn3QIY7XG1Om8wzN48y7HwhOK3P0/ZwUQHHv4psbdoVeb9VlAjChBCdtDDpOKTh9ZfcagOYq31RFjN4/gwBYzp8lAwYNwBELhZoxECeZxMlAzWGdCRV0fQWGHo8+8Kx+AAxnCIzowAxy9KvNepWfsfp4RR9kUrD88CPVTuXRybhqqTHcnxEGndsgub1Gdug8yz9fHt3Hpl57x/mfCOC29FOSQ7/noAZR5W3Ob24UMpuPYAYiQrQgk1gnFoUIKr4vKFpV15pHUJO3Y5rfH3UFHU4bGkU+NKJ9f2hJyOMxDBDpjAgwiYqvk5TqNl9EH2Arb6fA3yaA4cBtPWewhkEcIQJBlGzYp6zRmr1v+e3Fv27xpzvyI44NGDkCIi7CGNV9Dw0M8NtHC2vUwHINumCGNG8erxOwtQINsW88Tlwdoc+F85nI559ngEDpt2F/Uu3hiXYrkN/pBFS26hYDAkFgErMK67y9mGBA3L5ore5izf8b3n805MOq/t7XU4WHv1DUF/5gugCSOAIW/59uMwl6CHWAib8bvfxWl9/rBGEMTTwDfG+ezEYG4yk6FvRPuPwE+wvc39IRjENWM+/cm5b0W4Pf4WuKUnw/vD6eDbB1ETs5vl77Dhnm/51g6wPWwQAqxnivgQaeS3gy/u/1H4hpTPrIgHAN0mSgXUX13YP5PMIuQAfBr/f70cdeE+QoCX3i8nFMLcAjInBoAIYqt1LhC1WdtvmSab28AYffaeivCB+ohdYQgfUa/WS4ToMsNLHLc9nnvPZLwn1/EefPVf+U/xvnCVSEQEkEQEnEQJO7S7RvYDxNeNYKrG7DKMhtsQ8cMmhgPKKKj+F7CiHYFR5KIIPxOmg5IVAtu3ACQSPh7CzUQOgAej5CWEkIe3vgxz0ROGO//qYfz/dnLT+ZxDr4QW0eNCJBorCFOVC312Ec2TiY5Bk0cAaQmiA1VH1MOwDHQ0kHdEDDf+2UTWhS4Z8diQMicLx8MLBfverLcP/jQzF0P8EJj5+NGK9RCz755S6F/f1+X/gxeP+Wsedv+vF8/54aSPJYFjIQd624MDz/UDLQnr8HU3ztKHRf8Qeno1vyAQJBaLcMtTV3cvgP56COCqd/QP9xLgBkH4BxO13n4hNUDtACC6G1S3zqooZ6Ba4lp/zcAFb7iERKQwQcF39IFJjdXECGADw0IE4gg674pYAnk4HoHPx54tD5daO5vxrugSkMjgiiqc7TVKAT6AT8R4ckbHEQCYR/IZBxJgA+XZjsR7vaoRpIxWqeqfXuGC2CxwudicwePEB1kNkaZCuwyF0DuKv/4sz9mzP/Qxdg3BDkBTMC8Q+loD6UGBzx0Kz6eAX/KArOQTlPHFoI4vVtf4rNuLrca9edRn4xBP7k8w+9AgZCgBfEUZWfEs8iFNZ3UO7TqmkjCO/rWdgco/yIqHcQWaC2EGTzgz5y/iXQAvyx3riyxxV/JeBriaGB9OrTA5g9/eokM+37GszqfA/UZk9iW5UnCtBqBl3XoNN6Ag/+zy6A5evPAp+TIFDn15gQw9rjrOzFX0s2JBVAxa/nP1a6AsNWYGjPNGPLTQgBsNUFvOA3Ht9o/rGDN0tWOCcxJGp+f7++kkP7PxcGv1+GjkaLt/fawpwwerQxBJNW4b+PJsYEgiAYYdEAGIlDNaAbRkIgK3ut0jKByp+8yz23X6GttmBmjwDvChgiYLP5V/zhH6/110sGcKo5CkggCngxnIPoPja0j2B+1BRkiYJiviaLJqghDI63G2nAgAxMCuDdnoD0wIQm+urMB3VuAwbBrFGgGgnhAFqg9+ujKsLxB3qGCQNEEtPinIQlAj4WgIw7/iXc9V/x/yUWFs2KH504bAh4aYWf4TrTLGTy9YbftyLeVOWNfYNyt/ji29mQnqMAltU3ioTtbX343yv/1u0YPUBz6zB702tQucnX0gWaFh6DgPdmhXaapGotw0SFz1qDiTMdd8h45HfcqCPRUhA3+NmKz1l9teCPaMd4urGaewRitNBDdahR5c3AfQmDCFT9vmtQEwqAYXX4XI2n23Z9B/Yb1FL+LWox6wHGbZSo6FR1LzyG+3hriSZvWT6jfXhl2cmQZJDrAbuYAqAHo1GA/EOgD8eGcU7A8eDvH4fQBuAhBL/Zp/vamPTrRENDGLTV/7E1WEPLDlP/PwzU4YhusIMUgfIPAr6Dhv5R4y2r8ldFwiFoYHnmr8TAHbhRQSZOctH598ZYhqt6wP7q/ouqe77RJxvzFYaji/z4vna4v5cUMDXqDAJ5ytktqtBDckyjvJg04hl16LB0xFfyMfD77PZjErGQRRjYIfSvoAXntks0ok8MsUC4KARWnYPlJBeIgLeFrUgDOHYCag0/XNAbWgRwQuLAsaQwIhC1g7+jCNKuT38JfnYSyTi+QQEwwHeT4/dWHYxJPxfOj5oAnRQqgU3YgGZSOaDyK3n/qkDYBKptzR3oD6B4fyRKjp2AzSl80YR/3P+/1vBjX18Jbu+YsrMRgbqPP8zrDLTAaupphfeZtyPs9BPztpLSBZjowF3woYRwBwOWaqbev15b7X4RWsiqYiY6ZkFEIoUwUA2OrkeEQE8HYNyD/rl3m88jCGgO/nPW3xy8x4Q/HBcM1dYg5q8N+B/SBSYhtD0EY1PRGLDoKIBHF3yLz4H/gSYQJRETgqeB2d4vC8L2NVnQn4PoVJJAcP0inahAfdXVI8CFszjRagCTtRdV7Sr895NBpRKXIT64RMFw/iw5eChhEvmmyUIH+k+Qu3cLzOAN6ILlFvgWnx3YWFDz0f38ze9GlfP6UQ3ojEY0gtqRIEbA5/WgQFhsEuIeL75uTzvqHktAWfj/OD6sQXssROcGiRgFn0QVkld7OznMDT7CJKzhMIqxW9B+LCOQdH4uyxIcE49VTSeLj0wKjzcp2oDXQA8YoDEGBLMW0BJw+eAxXejPV/IXd59/tp5rVyYXDw5BlRetSpQAcvgfOwVM8ObzBq/AQ2wX4lwkQV3vNhYFfn2LFgaoDU1ogqsfqGkJYmrj9Tr22KQwBLzbLuzDeA9yzyJjVRfwegWq0H+FThDPA6ZhZwX2M2Kh4waovCzAWJTzD/qY00c+6PM8coz08VNqglzx54LfHuTJK7z2rwX35ABLg1DzsZ7Qv7l/f2yXDlbf4C/irg0MJ0aCuD0wP74MrxfdFlX7tq+vtRdCpvt599EG9Yz3V+P+Oj/n4zLruZHcJ7oMt/MNp9eD6HEeFb6/TMfbWo85Pb79HJo8t3371/PuIAZqMvjPC34nVV6ZB4hEuA7AzA5cfU0y2n6ux89D/35/n2/vWY5Bf0qwf3tPLISO1Tap9qzFB6eap/beqI94NCCbGwgqOItY3CGl446CaQ8i2Q9g0AvmgJOnBoAA0gu17tsKtKS7D4udgCYERy2QIceCX/P7mBW+g/7D9S6Mn50CS0eAoQPDcBjopIA5+EcxEjLweRjXq0UbLIjcBxsGx2IZvlf0ATjz/6qypAmY7bhrk4ahsIis6ccXKHdueAfUgk+RWPCLh42c6zEeKyJpRTdRAOqBbl/Wq/uT+q+Fx3FoTIuCzc6+hN8j4veGjuAnhSE5gKnco3A3XwYlq2sq+lmP4yEOpqEoG0M+mGDYuYT0pKCFHgLHKt3T7T9p8GcWH+n1UwGa8X6kQt2x4CeqPexegT6o/Z4Cr313PHdgrsS2ZReLfpKIf+IMFnmVmwxQ9AhithYT73+p2s+JIVfrjwiHnpAZrSsr9CMstQXP1+1+510N/q8E/YoekMN9OMFvi5LvkRDsy9rgFCOoPdpgaQIWBZjf5KCSQszZJ1ivTvLokpen6tsJAVND0NFqb6GUGg2Im4Dyx9Pn7/0dm4pADAslJzTv+dKNrAPQ0wyySm7bj1RQgbAXsRa4R+mBJzpaQmHLmy0BLoL+Nh2ZRca8uUc6P37k97n451fvTieAE8BdZ2ItqFEK6oOJIYPsiU4woo140Oh+H/UC++gatHYcOFT+2y3AYvD1rM/fpxdUcsAi70c0OxAEP45X/hymE9XeoC0zfYhbcqfbhs09HpwnKMDR6g0mmYyKth/UcLl9ITGQ8N1S6s+gA1HvQCc2pluPvN2Br8SyZyfyxPP/VhCi1L1HWX2CQCuAE8TIq/sBYdANZmTIwqq0sb0HIzhhugBeUpBZLFyA8y+EErsBUYDZHYN9QAAooQwOws+uQlhdESSSqk5Qsh8LSYI6LDS1AbmOvLlRBqQIeITvM36+TP63VfE5hFClCTr9zEyVFwS3STQBy66DMHB+PJWIrfgGnYBx2dTboPa2X49GaBVlePA7CFx4iaGi4ns0aLVjMGvtPTDtmO4XEE8E5Kb/8qYai+NHl60LgAICcUCoJPVeiYG6Pxw/X9VFNVbFn9FNPzXoIRDTyzcpREYB5Fm1EQQn3KRi9wKApR8Tz48SwxnV3qM0q7ZhpdKvr0zfY+gO4oQf+EGPFYW/Xf5hwWsUgxiBbShGoGIx+D2eH1h2EeR3UQMH4zMaUKr4033nzkSkfQADelFbLOQCalxdxvN8mInhPas9bxtGJw29Fx3Y8429MAS0fL33Oeo7qFZeiToCC3B/VSNYuU0fgDnkhxGgMFdxiYEY7MYel+OHPH30IMeVFK1C79l+QdXVpFqHlMAXEf3EYDyfkkGdNvJ8f3RAXU0jpgM7jMNA5yCrtfzOicKG/M9bgEkEjqqPPDEcDfqVwGZv6zcO9avDfOhf4OmLFd9OLBHHdxp51HvOBlnAoQksYjASA1xnIhPsapTCPjbsGB2YevpPpgM73EYeSYIftgPgte6CWesVBB9QEgfnWYMgoeC8ql69bWoRIqYHvSIv/u26bj/jdqZ9KSGk74JRo6QS9PuTiSHm6Z62kLUGH0UO4rwWrhtRETkR4iKRdI8giJ2D2nUCMjsA0TXiVDb98NAf/rCMlajA9wesWHZrAe1dlwRyVI2jx4KkyUHSx7YDe6YD4tOC6XW01puEdAJwaEJzf1uATHi6ZlSCpBQscsh6C1xRcWEG4bCFeKcAVhVlDu54JQIkTT21hptIT/Afk0kMcS9BKfjBJozcDXCrtgbWXxbMAw3INQIxtQJPAGwXmYaBbYh4SCsuKwLOAQ5awKskCMmRg8P3xwlBfbosQaDqyZqBkyQe1CLQACoTgN4qbyHsPwkTiF2pYaj6MAXBmUosQHnUEYCsBL3MW39SNKMJ5PfoBsT33DVJCEbFnBCMOkHfvj6Xq8uw+dgRIhGgAiUqf5QgKDFyhe8nnYrlqn9sG1GoAfirubygX4H+8IM1CmQrMFAJ5ExzKIp54nPoVU2Auh6eBShDlTV4u5c4HE/fVvjFrsII0Ik6QX+Iq68jB19ziLoKC27FYe0gC+j1RSS+BgB7AvAM3m8HLdy5fV60C8RMVuhD1ieQB32MCCq0QPJuvuw5IHF/geMKwOPdpmsxBwVEfGEOgeincJqNmuSFIPhPq/xM81CWIIi+gCFBqDX3QPYd2OcCRo6GZBoA3AM+00aesAOQ7/2Pe/vBCXoguD4OBD1WfPwClzcui12AuH+gC0gEwW72KfjBCQRBr05D0IQc7N8PzOCMehPWK384MPVDJQim7yDdoiRTItzzFV/ZOX9sYFetP0fsQzb6O7wOoFjxk89YoQXv+BmSN+yYHYO+BsDRAXHhuJXsEFbdIEGZQWUkNVNzGA9NZUVBIQL7jASR0AclE4Pb7JN3BO72mG92+o8UG3nybj+mASh0FsLKn9GPxDrEcS2Au35BzHO1BksriIJdpqWjKR1wlpR4fN977rZqI+XbYjYDgVDpcYQalOYKMiuQbB3G6Pu/HlMbi9a0EMkksXtjvvXTfgMKAEZRN/i/O7yD8Da2S2Bdh3ICWfp8yuMkYl5a4df4vVWt4UF0yyqEnaT6swYyWB8/j111Y1ERS9oB0SLMtBGDEBD1PEHwtdjUEAHnqmoHU4wCDAoAS+lHwtu9eQLUAgmxVvAuMB9cELMV3m8EUtcBYYI9nkNIEEJYrQeUHfnzzRyC39j8CgSkir/E0P2odnAmAqDnDIhqrtV9BDNS2POjv/0pwKr6z1h/PMz3uf9ykFYq9TtoAXSwpz0HljdvBCVAPY6t7osv6gFhMpkX13rcfXQMIpuTsfTibkfOPRAC2meLRipI4mDPwMD5x+v3+Ey+qEfACwoUEkKQSMZxYJDz9R68PyP43yvo2aYf881rNQbZgRU/jp80QnW/hdXqJxMvCFxXQSNHpE8QiF4XI+wFfQcw7VL2Md7RRajsKgh2D+6SLAKPF356+/7yXYBTUgFy/38StUjFHweD+iiHh8/LV/i/TSvGk4L5x7F6AsIKbgb4C0YjgdGRIToGUx7cgS3JKP8pRcgak95BJGQbjaJdBYQ1qHYnYHL8F45QgHx2gLMQ2cDxBD/4SeR0LSDi5XzPQNjM4ySE/HGG6g+ugltLNSARn281BPtNO72eJLjdX4ITSEgpQvJYFEUg24f1qAYQNQdxx6Q/RcB85j9f+03zf2QV33IDPHegNgPABTfqFR8cZK9TA7/ll0EQbUUHW8Gr1d+MSadia+LRHwhunv87yWoJ3h/pRDwJAbDNQQFd2P2mH4kP/wDT/ZeN3CK3+ZjvgVpw4r20AMafb58j4N1UMknuj6iCx883PU9g2VHVH5JX2eEcPghSgRBCKPzK0Q3fknwPN0Hk0CyC0zBkz//7duEetgFjVtypASDI4CsknYJgYDhqsBxxy29+eyxrAZX75EEf8f+CkOcijMDDHx4ASYGGu8WHgPwpHJc0qOG8FgFTuVk0cRZVePFwHEIUEu8xSHoL5qWg4I7/HgOKXe2dcnu2SSdCGIDTA+AcxY1zYL6Q6AAFu+/1GvjKPSeEoJV3NiM4Dz9C6oWkEav+NWjPWXNOIkKgNTi2I8LeBgaZHJxqrC4oNXoB9pzzMws/OW3ghSyQJgjbygOVEDhoj4nHLld8HPD6UUMFVLIgKrTL7cFoBRLQgEdXIseZ2/HhFPKbk4d5tYWwwR0nIFQSD2P5gQhs6meVfB+Bkyz2fOIvX/zxqsSODuAGIOLtPNnmIPCrv6Kqvgz3q4tCwNl9lWYfnsdHj2HTgQw5IBHwULmfSu1jEV3gDFSxTBmqSEVqiYK2IkWcRiAkwV/cyW9YhqHXDw9dkNQAcO6HFNJT7oChfrPUYc3KY17zAd+evAwF2w5SCKLV4EuCEKsKfjBVWHu9Q9Arh4CoBqEMWYBsNX7YgKP/69uC3M7/mOOz232QT+ox4iCyJGEFP4oBHd+GVvXBwX35nqp7qeIbV6L6tdZub3ueJ+gBIKgC6S5gOQFxDoGr+Bv2nzqbknd7ph/EmXzO0o+kZdc/wqvQkAOUffVMzKtYgx5Vob1/+HAfCdzHSiXHenX35/2JTr3KZ9Ruj2lYiMhLIFoNyMq9hFroeYMTE0bSLbhb4l3YlFPa6hMd2jk8dmrDgdQCnC4/+ANFlYTB6ATlx2GDGXP1rvL+SnWHw+cJes5/rRWt4H2pw9GklD4uSMpwasIQiaYR92gIyFX5S8dtRZt/nCAH48VXW3hRE/HKOsGquj8EM85Q9cfeAV4XwNGAlmIFIwPYrfLKuxV476RRetzcdeAsRSZhiHizCKEIOHn3EMOWy5X4uIJnXX6sFiBFLaBm/THOQAkVJK9j6TKwiSDTBWpwHkSPQJX7U959uAkoaTUuug6oQCBz1Zlxm0OJSIoIw04M+7zCGuYiznCfHww9AN6Ir+HXA7lfn2oBSJ2FOOh8SzINfmcAyITq8JX/sOMPx6A9LeYtVfwgCBZhdu25OB9/XmWWNPUEPD5dUuJ68wd1AqD2+w1PI9KxE9BW5t3z/igdYGWiL7L+wPv9jgVY8f0ZcbCKCuLAHN+c5wa69Zpr0J9t2KnpAGzyiAIPiFalJ8/xXrrA6Y+/8NoDnWCPNwFJzf5DpVkHte8hx76P+HU1+HEytEeSEIzAsu5r6wPJGu6oLz8VrKofXLce+ywIHhNa/Dmw8LrptWXZ4NKZm4pr/QQ7Qk8ehMrPtAF7PQCD309QgRgRZMKgAbFREAfBBXNalbHA9cEHMo4IgIUuPjjBWEUFEQpYTkhVO43eRiynJw9Jjj8TOUIlJExK+0wA4gWgQvcFBHAc7P4/u78/Ff4CC5ATB3P3oUwFClYgcALcxzp/B9Ez4DUV8RjBbsCBrMH4dLNwIDaCGhA6o3pXksdBvYBsktrXDgNJKAFy1Z+ZGIy5NXgXoBT8a3ZgVSPIUAMV6DjLxhsV8wX4n4ibbONObHNyCr8Z4FinNFjg8ziiF5zSV8A99u7Zdf5OisvVaAAAG3VJREFU/kIPAJLWX3hUIFD6o7MD4WkHIMXBk4IftSrPNBJVk0OoC7ice8HGS8XBKDoz/YFBLaQi392lGpCMJfhD9xVkx5Xbj73P9V4m1j0v73x9FjDDPlYvATkgFAVWcdNvJBamliOjAwRV0EpeRymAe717kMYRyy/j5FwFBX0fP7Dyx8gq8wn2ZXi8GfGYR+lFcGJSxa3Y84WgzBHetlU4cvKY44Ps4iP9fsgsPGEhQTAcHqwwGCj61SoPexKwasXFqtxq8qhD9SixoBBYcJEDNzmIoi3J7QkoJActVHocTVpPBCDhElAvMDK1PT/Sq3DwB/ygmyB9GNhYDH4so4Foy48kkPtZfZEv1PQTxYpyX0EI3Bu+/5krcN8fgwVdwWu2JNVNWAk+PcOOPMNdGFyAZ5Aj6gicgzNfwuHZg0HrLxBWfjSRl88fVCo/apX/IBrIvf65ZxtEoK9Bec4KZIPLe76osQns46NwW0pUPCPAyMc4A/KXOwZzFLGbAqD5xhhbgBcWfoJBAlarcCSQgdQJ+Movnih4gjZQTw51rz588y/ZgxVUEAQ8soCfX8OR26JwujCLGFAMsOjnwGrlPuQw9D/PPv8BYVR7pG/eeFtQpsLzR2KFI8SwKj9KlX++HeLOPuSBKrKeHBi7L4b+Kx184+ptAp4Trcscv69oARVYzWgaK01H1X0K3zNSmARKtxXYHvwJuT+8gLGGWgpHcWOmBeljFB2Ckg6wiAYOqfxEK3GMCAj6kIiTWdCBCXhkjUKMgJcLk271N9uLSbtvvK0S69OXAvoA5z94VsFubbmZvx4QAnXgBnJxENyQjy38wef81uPhxMpPJIQzr5ckuUTKe0wZyN57iFTWga8GvCwlh5UqvYgmaNV9XSxEVWs40kkosFwA70RgNOu8mLZfR6wDiwRa35y7j08NksqPQhcfkRBK/J8R75Iz+9C8gJpqzwiIeZII3QnYOkJWbVEI5jNuA+o2BwK82ifwnpSgHwaC+GNAdmW2VXfC+vPu6wR6lBj84C9WfvivZyUhZMJlJhjSukDlFJ3g4AvGJfC1iEpQJ/CaEd7G9wds7p71+odruKrHip/C7RdsxeVjzIxhoNkFGOW/+sk/YVAGtltfzZAIfzix8gcHhZCXpcGN2u69qWqD9OlRFAy7x2fQBhHUiETB+DocqvArYt98f+AEAXApsEmEcNLC0t2uPHCqPQIXwHYDfI4/9+8LMpchqr5HK39MJSrBXwnutNqjovjHFdq+fcHLp7YLR4mGgduW5hFpAXUoL4cTTuW5HJSkB5PC0S7A+8c+837DyoM1J9iv/po/o3BunlDqPjOSO/YbLFd+FGy9sxKFeT8b+nLNPrkAyD53FtT27yUS32yqUaEGTMBiASGcZ0FmK8nWxbvjC1q6WQC4VdWdAcBY8eFoAzIrC0b7Wt8wlPcIdE1FhUWeKU1Igv8Q/0dl4k/NnYSxdlDon8diUDeuQB4c8XVzcahRgyyZmNC+LAgeCfSVALde8/t1DCYawNoePGT83wlOpFUdOZKwxn89OsMEf0X8CxJCBN/dwKbFwkSMgx0ACJJDJD4iC1JEYh6XcEqVHpx4+J4I4UiAl26r5x64sttvSlAn3LBuQCz6edU8C+J5epBrC4YP52EFDgHrCw1B0eU9bOaTgh3wmYvQV3Oqqcf53XnVNXUBELX1xtSgFrirlII5d3HFulxBCNEfZx0h7K2f34XwdHpuYQcguN189Ow/nPXclaUcqMH5leCXjKOjbv3F0a7i2ZaRHmBe5zwnhA9S736ZC8AH8LHkg/T5znYgmES1dtuzGo92qwHIquiWX+4KgVLd8utv9Ml1BQNhEJW/FOgweiTguCUoQHkEwYhjfQIgm8eAzPKzHqAG5xGiiPyxeGRRaYetUpDVpHVC1T9bHGyaknb/TQTnuG7rDYwYCUT7/cMjtILzA+Go/FPw581F/mWeTkDuBsBCAK8ki+A29nMzPn4Rzjv6QV7xWW4fzQFUxb9jQQ1qc28kMi4mDl1NBr4usIsz5ltZqNm7AeJXfuTHd7nioLEyPBISU+8/tP1AC4Il/n+YGmjg2NiBRdl6yCw//zG5ph7bqaBuz8B4VMU/TqSsNPbwCeZA1cdxyG9SgKzRZPL+GXFOiH1/SFZ9wX8M3zUgvH8a4rMBjZj/h1W9MrwTiN6MlsCKiI4gycBzgV/xUaQGjGDHwHiYi0VIzeEAasCpNuL76AC7BIEl7i4AIxnAfoMxk35eJbZ68wWEUChs8IPz/EEE9BkUoNA4RCWSLJkY1h0Y/dG9bVCtUVPe7QRhtStXG4nOECDfUxc4Uw/Ik8JkA9o9+a83IrfHH11EdFUWc4phNgVFWkPsIHBnCvCCYBSgqEN9qtoXuwHhByYoJJA7BxIkkRwpDGgAHo+vQ3ZGOwCFJCJKUAx4MBpFZWvReeLgtBBkDDQu2OJxXa7SE/P4ZiUPHABjY1DsFIhPAaygWewiXK72hHjow/k8gCL6gKES8qcDZ7A+EhYlWCPGCX1wXIwzkQEKt8cP6iqkC0FEhFj/ZYtvXCtwuBLcDT5wXN+9H6ZEIkTwV/x/s78fXFX3siWHEKrC3tw7EFZ31Ll7ttknQyEMGgAqCaVe1bGk8r8nFWCQQR0h7CY0dsU/mIeIuA1AGCo02Q0YVXxub36sG1Qgfo0CBBUXxap+ECFEycQVyViBEBFPt14TK9rZHB9EwMG7DPXOv0OVHkdtx7OSCXfb3av4CFZGTwQBwT7/hKPHE4PzpJ4L4+FM9r1n8B+B+9R9I4Fu9brYUZgCunZWNxdQgIs8mASBQ4F8hJpEiaf4GPihk8FdAxin/kybjZjTj+mAQy6ihZ9whDvHAWB6BKrBXQr+5SBfqPaINwiz12UIwoTmbPACZY/fshBBBKNlW8ZCHwH/cVKSOZMm4Mxk4OwE9JeB+EFkn1IzcPQoiSB4vGgNeJSoik1A7m0TCmE/HrggB+/1M12C1Z18ACGoIeH1pH2IhAqFWgBq+kDFEWAvA3X8tpW0cnSD5WAOriOHhnYraF1eLTkS8P/QsHUBdtMPnOrMaANJE9AZiaKWII5Ue/8PTHn/UcCSTgIF2xN4zdmAQYIAKeBFl6FiO0aKfq5jcImHfPwTxcEdRmD3LcFoAva1Hdjm9UgGggI9YOoPkOBYLsT8HlG3nucMDGkOOJ8CkNOELdSO7D5qqAeJYBb2GpABgRi2gxLITgrOQ9C937HgB+0i7MeRx3gfPWCXLtgbLJAu/gCFBPzRX8eADJqCvA3FViC/BlOQC4LZyrBq8BdQAOUKoKjqR7v7EFfVFMojPgEoSlJesNIePyLHwW9NRgq7E6HvUN8A0yj0wyWDHRZ3J2A1jHdMyu3hCGwSDwdRir7h9VP7AKLgPoMCgKziOFLtrUm8aIFHlgxYfz8WBYUU55iAXauo+evJaIK/NTgRJM9sUcZRzcCnMdNKMJc7usnAyrpxHYkTRHK+n1HxS01LheAHqRWwKIDqLvQC0+PupHZgBawfVGsiniTVHwZHRqbUI/D4Cd+ftgyLAR1ehkIiqaKFw7MJEwUIuK5zsu4svoFYCFKgBJZACBuppOId2RDkPZas8H9kULcA9a0KTCQDGtpnzT+RMJiOGseHl4BQ1C29AWUXIIf/OIwwqoNEK3SCuA7FRiBrE9B4/PcrGJ1OQNj83F4Xbol/TgVHfMiIZLAdcaVkgh8sLrd+liNQH/FqsNTfj15m1J0X+ffZuq/gTY7QnvIfJz6UzBJLs83ItQpt3RfZz5iuGfNPajpngUm0R8DoA5jDlzsOTAwZjzsC3Jjxg7H914PjlcskGdghgx9HG4OOQH34uwQyzz61/0qiYNQjXxECuWYbGM/DrjtPH/Mw/K+gBLLSA+cEfPr4MroArzcDuybbr8Zc72i2UnzeHnTgzD4Ug78SzIvCoARVOQxaFFR3TzWnkkHUVFShEuqKxZnKz4p4YYcf8ZhYhuu8wFgSHcuuwCJagI4bgchJQK/qe9c/RT6nGcg6KGREJpb+MI0EY/b0jcsni3AJBeCQNsBOFVYoApcM2Aom4VFgIRdHpeIG8D3YaxBD+qCiQ+rBOSVnci8hzkAG1t/pgHA4uwDzmu8xFKkkkIqCfkIRs204r/hiDgutoAAcowBMZ9+KS0CcXVBOHCvJw2jMQSJyeoeExF2DuTuRcuWAo9sefyUQ6/oBaIjPtiRH1KvQKvygAHb171d+vc4GRMDPoxN/kL5pwlVh1mBQ1quQJAJ5j0TgOAis+h8d3mnC8xTKE34+8sDNjyVXE6nFMN+H39TQDmocHScENvN74LoGScGU4f7g6IG3n3C3qnG6JBS+Z5tHOOzRYQx+u7MZmAl0OSsRLAS/VIKfRAWU92+12aaVPksGDBWQuCMvgNy2M2Mt8EwqbjosZAec5xLEAmXmcFTHiOWARWglpNpjdEtBQRxJJU5VL5/7F1X86XntXgUK4q+KggsUoIIK8oA+kgy4+zLaACqQGTVOX6MBWdehL6BxHn+tlyBMDGAqufd7WOX5WTJwKYDfXJJP2GXDPk7Tj5Ed7BOG7DMFaBRAJgI/+H2Ngeb2SKb0zkoGlQBHkefDr7xMA5HZeJPtKIzyApI9gmnPgf1c3mulfhe0gFekDCdNFnrOwi4Gs6eTACNjB+Uegcgojog4V25P8bctRYY6RL8AJklE9ACFAGZdBEahd4d4CmghFhbzcwaXYH5qTlS6DY+KfNH5Avzjo2JJ0poDkSCMxLn73H/eB+ifvgvyIFCWAji7BWC8hd0qj0FziMdrS70BlVbgamIgcmotGZDNPwm0L9l5iHv7WRoAFx57ScFS2r2iwot8oKu8l+TOCOg2mZ2nFdjTgOFQENzKkJ8OjEnsE8f6AzyXwT6MNF3RDRnuj0Lwo6wTlBMDIyqaz6G+RiLJMg/KUrQV/rh9uH0tWduwoxmky0kSMQ+rnXxZsGadgnxfgk1pCnsIsGYltvfdzTOBIclIsN8MLAGcz5gBwj94AE8DuC9Molip/JGwB57nRyJiyD3pyk6q5ij+3TzRLohcqyqCEQBTepF15+WVmW8SEr5jMUUkx3oMIsrH3ndwAQganKzyMpOJNxMQooGBYwcByw7axIhgPRGEr6GSGJhkAELoQ1YRg+dPeD5IIRDIqq5PA2Jh0Rq0YcS8XBi0ghGRFpCtWTdum5+yLOsQf2EuYY8AfnbQZDgCjHxBSKwTGpt8QCIDVH3/4H5OwEvldhliINwAFLsEyyIfGKV+vm3eEehVqKTdNxtDiPoLHCRiuwTJxCECxMDqDjTvZ63KaPKvRgV2i/F3ohm88V8LN8hgJcXD5pVGIPPNn9EBqSQC0I4AMxBUcQNCkarkFgSn/oCs9GCVep4eUG5BRAOcQOCWlGSc3If0IFqRfURQGRrKewPKEJ9sLnIowKCcw+f48N6UHjqYtgInaCCkBbPSj8VEkCr2g8U43wY1xX/BNkwreQrzg+oaJghOCGTU8RBxuIp6VFOGoEXgEsBLIgV6gBgxoLSI5CgiYNT+GBHsU01GthrceiMUtv9KgAYktgVNeGrBbtiOQVi9x8WjiAW7UNUnm4Vet7WtsFgDCDYEwQ/EVL1PnQf/xCDLTowTh4c4HPRDoQaiwhKIAae4B7xgCBydI/CDPOrevK0FR4p6w3VfoXgQiB3T1N8Y1PCD0X19JqcHGfzB5WkQE4p/kdeXBcEVUXEIFqSij82lMyrWq/7c+LFHA7z5/dwOHHg8s/Y8C2CmhbmALtare+4UWLfb25BmXABKABTniC8gRAP2yvDAiUAsElnrxFzITQa/sAFecAOY7zPV/8jMQHSbWAiUPGkQNABhw85xrSCv+mMSzFR8+7mjw01A8f4F8S/td4jnDHYxpT8/OEyV3gz2+GTfdAeAszswfJNGlQhEIjB0Bls0BKn4Iw7WKu9f1gmSagmvqleEwJwnZwjO7npz1HdCJ1hS/mlBcRXyF3i/M7NxqJFoeH27z7nnJaBmpUZKHsTbGUc1ALEoIGsGYl9ixS50gjAT/VhB8IzvGTrBVfWEz1MzAkRFTtecW731VdjNQPukVdhdn0Y8d/a7WYH6i/TBPBzUFwAlHwtGHOQISrgb1AMUgDETTA3+THAdeRJhg59V/Ektofa9I8wxVICkC7QQSAd2O3cftzPzdMK6aA4iZI4ILfYRbb9RgqICt2AxVnYZ4kkBvHOBxT/zN9ybHx/f5Ql2fkGCX6ANm6F8WCfqAS+Eq5AGcHJd2IFHagTMHAAj+mWBnDXuc81CjhsAi5dL2K8QCYI1aJ/PJtSSxEFXASv7C2I3ZB9/a0j/7nDn/j1pHsz9Jr8fNpxPBUAUUYD4wz5GBlmyAiORjtAIGDFwzSUwqiNZ1d1tPiB7/Q9VeI9KeJU16/knkEeQJEALjY4rkp74fCZiMDSA/PgvT/aT2gYgp5E/P29AKBQAo6TRth5T4VesQFb0i4K7RA2MZpgyFXCEQHCOixuYMPgy2L7+45ezSSKt2oUkURlpXkEMOLSiXPuDQZjk63N5bmzOSxQdLHX7AhwUEA0BAeQPJIQzkAuFlOK/GtyLdiGDKEBdllQ7YouxV2Xdwza9So4Kp5Z0yAgUhTlJgFzSFrznIHYIwKcCu2/L3LsCg6UI1b1/CA+ApIV5/32HqOIjdQusE4azip5Wc1b0q/QGIAlaWEJbXP3r/L+AEipw/+BtkQVY9fIM2i/ZhgVEgJO6DZ1ksVtlYdoQAPhVO0oKmYBmnAYco4DRCRB3TwCziptaE0auER9/VzRqKNOEYINOQg2m1l9GpGNQAhh1v6UmxNQh2M4+LmlUzll0OTjYQOaGlZAEMCrdhmBphaMBwBADrSQQc3//He8KgFETT7p6BHnjj2X9EXsDjrgBS6ihoAmcSQVYmE4JgYWFpp1waAQRoqDzxDhU+HxSnZHz/9JEY6Y5MJA+cwoWrt99+U3Mc/9g/NQTFaigAEtwB1yBzwzucZSX7RZEILhR1d5GDCsBLVUdIQvsldZfEJt5i/MHx2hGJZFkVVyK242iFeh58oBUFqIQbkfp2DV2X0CkAYgv1sU+P+I/HmBu8nErugdRnUWhfp+A/ddlbEH3uQlBsNobUEMHasK1HOYn8BEEvCUaiuigXRIKj+sGOPA4KAWz9/s7WxcgB4+a6/fI2osEwv4yOENAiPf+wQhbc/5f0gGisWuQaRFmGoIqguARWsBQgTTocDLMT5OJUQnhqdCEig+/EShKSEgTVV0MBMnz04BcshPnLk/+OaV0/dwKzB4QUt1NB6uTDfGOP+cNm9mEsBAFiM7AQh9AKVEU75vy68jeOxrUC4mDEuYO0oLqoSdHaEF2eXYYSm0V+oEOwpLmYFOF3Z4CmAeBTIGueiIw2xoKPzDBJVBXQ5g5O8/twwA+QguIjJt3+g0NQEcDfUXgO5gsqlTBLkQLdl86K3CWneitQ8sg/5oWAUJP2C3V3RoEyji5n4b9lB4t9pz2CA+cAFn1Z9I/uzYsU/ELtEBOCHYQQqGcFejV+yeuRJX31zsKV5IGjway9z6PLDxKwNEPsBuOEiqw57jGgOtZ1Y++T50AuMFl7hPIbhskiOwsATtRoc7rS7dXrpcgrMCGJca6ELJo+Y0be0BW5ZKGcFz4y8W9BduwcDnK9iO5fagsKpp9ANnvDPxeP8THNyIVFo1AMas8Qk5v2Ytm0LCCYAXqn+wQsPTBh/5Bcnne14Os3uCQt28vsK1WUESJFviBgAW//3u9PLxusXchcCR2WsNzv/ImvgZzzkUByDUAIrjTvmSHAowpJBQE4SUlxMxnARlQbIqkArVAJ6pBBvELCCKlkyCDAP45BYfEPfcUpfMch3Vn4bheYK4E66BxAxHSVd5INgEPgU/NBCDfNQ8Ho1CoINAPQAW/QT8OCIZlNFCB84XhoDChFByHGjx35v9BLgyhmojqHYb5QYXnuAecvua0hZe6BV9f7v4ibvgvamrmAc1TmaEir0LQ9h97eYAYVoM/nWA60i8Q3Ifezha9BqaaL3zvqd6IAuwwLSCCuCLuJWch4h30giPtyiAphKEBcCu9BV5wwzkMxID8rhMwdwMhcSFgrBT3RUTQboAUg3+p+Qe1IGarOioVnazmefV3lHpwA0AcLWCahUiXwePHWJsP+GH1gnp/we5KfOhJAbsj0H/BIEb04TbrTPsAyb2LLu93KwfCvn5PLAwrOXAa72eEQRo1CNdw5IprsAZ3hApy9zlcITG2vpCihsRSYxNS+J4vdBZ6B52eqRcQ/QXmSjAWSfa/5GA5qEg4iJFtm624AqXLrSA2gx8p1Mdqcghv41S0lSp/xAYs9gakQc4Ie2RTUYwYgt748mV+FU1Xgp14eW3XYZ6cdqGTNHwHICTwEeTPl0jEZwIgP9gDEaogeg5IHWCF+1eoAhvEKPB/EAeTRsM/pSAP5wjWEUMM1/NJRhwJbpJSgK7S7zF3EOsI5jBQBK9DV80Z8Y0COzvmWzJXgDl40KEC6cqvqgi4OB5cpgLFYK/1CvDiItXqC6/S87wfAUfPtxqfGNzlYaOjlf1IsHPPvffHgDAoEeEST4ZLZUd/RSo91/BjXY5ggWgQ4In3fyj4mUqPrInHOCLKO3wUwRsfyXpt1nEIRLrqcWeTuk7bigsbid1zD4iDRQtnIdQsyIXnFCn1I9D7ADgxEhOvR5AJosoUbu1FkJyYCi9OhQERoIx+4AX/YqUXQhtYEwKN4Cy1HntLMmtaAQpqfrT/UCoLSxeswjA5UWPPi0mjajUWxMTdVusNvt/ChMdmILK5IRMFu90BMEzFYHdg2GAgeYVHMMJIBTA7EFTx/5fpgTFXz9w/en0ZjD8kCDoKPNGwlB01BmoWQbh+AxR689mBponGJOr9OwmMu3dtJ/ylW1Tik4ElUPmR9RqII+pVhD9ychABMQ51gOIZg+/G+5mGIzLB1JJC5WhzYjhJ7IWmLDpA8jzsAafUPkB2WnFBF4iSxkq1ty7f25rv/+EQLOxs2oUdTSA9HIR9swdBlCcFe9owPC3XWDDC0ISVzsEVbSCF/sWdA5Fu4HJqankp2SeQCYYrImNalfmhpVxYrGkUS4LeSUjg8dD7+D7w/ybIfy7vlB9/HJ978zr7/45Qgajzj+4EjIK/ULHPRAOlKr/aG0AFcqCyu0GcW45Igh6JMJmhA49/U+cEssHNJhtXDC1MOya3j/sAiAGcrEtqtgjBD6wEzSDc7D8o6C8rIqAZyPk+NQoNLAZ1hR64Yl1FBY648smUYKnSg1Xwk/0DyRyArByMUobyByhCcPnOaPyoegREFS4jNfYAw+IHCjdC1J2WDZBke/OyN85J24WiXwDYPoJyYuCD238ulvuzwt6KgHf0shWKsqCFFGjB/w8HU8eeTED9wAAAAABJRU5ErkJggg==";
    _instanceNumber = 0;
    GetEnvironmentBRDFTexture = (scene) => {
      if (!scene.environmentBRDFTexture) {
        const useDelayedTextureLoading = scene.useDelayedTextureLoading;
        scene.useDelayedTextureLoading = false;
        const previousState = scene._blockEntityCollection;
        scene._blockEntityCollection = false;
        const texture = Texture.CreateFromBase64String(_environmentBRDFBase64Texture, "EnvironmentBRDFTexture" + _instanceNumber++, scene, true, false, Texture.BILINEAR_SAMPLINGMODE);
        scene._blockEntityCollection = previousState;
        const texturesCache = scene.getEngine().getLoadedTexturesCache();
        const index = texturesCache.indexOf(texture.getInternalTexture());
        if (index !== -1) {
          texturesCache.splice(index, 1);
        }
        texture.isRGBD = true;
        texture.wrapU = Texture.CLAMP_ADDRESSMODE;
        texture.wrapV = Texture.CLAMP_ADDRESSMODE;
        scene.environmentBRDFTexture = texture;
        scene.useDelayedTextureLoading = useDelayedTextureLoading;
        RGBDTextureTools.ExpandRGBDTexture(texture);
        const observer2 = scene.getEngine().onContextRestoredObservable.add(() => {
          texture.isRGBD = true;
          const checkReady = () => {
            if (texture.isReady()) {
              RGBDTextureTools.ExpandRGBDTexture(texture);
            } else {
              Tools.SetImmediate(checkReady);
            }
          };
          checkReady();
        });
        scene.onDisposeObservable.add(() => {
          scene.getEngine().onContextRestoredObservable.remove(observer2);
        });
      }
      return scene.environmentBRDFTexture;
    };
    BRDFTextureTools = {
      GetEnvironmentBRDFTexture
    };
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js
var MaterialClearCoatDefines, PBRClearCoatConfiguration;
var init_pbrClearCoatConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrClearCoatConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialClearCoatDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.CLEARCOAT = false;
        this.CLEARCOAT_DEFAULTIOR = false;
        this.CLEARCOAT_TEXTURE = false;
        this.CLEARCOAT_TEXTURE_ROUGHNESS = false;
        this.CLEARCOAT_TEXTUREDIRECTUV = 0;
        this.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
        this.CLEARCOAT_BUMP = false;
        this.CLEARCOAT_BUMPDIRECTUV = 0;
        this.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
        this.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
        this.CLEARCOAT_REMAP_F0 = false;
        this.CLEARCOAT_TINT = false;
        this.CLEARCOAT_TINT_TEXTURE = false;
        this.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
        this.CLEARCOAT_TINT_GAMMATEXTURE = false;
      }
    };
    PBRClearCoatConfiguration = class extends MaterialPluginBase {
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRClearCoat", 100, new MaterialClearCoatDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.roughness = 0;
        this._indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;
        this.indexOfRefraction = PBRClearCoatConfiguration._DefaultIndexOfRefraction;
        this._texture = null;
        this.texture = null;
        this._useRoughnessFromMainTexture = true;
        this.useRoughnessFromMainTexture = true;
        this._textureRoughness = null;
        this.textureRoughness = null;
        this._remapF0OnInterfaceChange = true;
        this.remapF0OnInterfaceChange = true;
        this._bumpTexture = null;
        this.bumpTexture = null;
        this._isTintEnabled = false;
        this.isTintEnabled = false;
        this.tintColor = Color3.White();
        this.tintColorAtDistance = 1;
        this.tintThickness = 1;
        this._tintTexture = null;
        this.tintTexture = null;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene, engine) {
        if (!this._isEnabled) {
          return true;
        }
        const disableBumpMap = this._material._disableBumpMap;
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
              if (!this._tintTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        var _a;
        if (this._isEnabled) {
          defines.CLEARCOAT = true;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
          defines.CLEARCOAT_REMAP_F0 = this._remapF0OnInterfaceChange;
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "CLEARCOAT_TEXTURE");
              } else {
                defines.CLEARCOAT_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.ClearCoatTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "CLEARCOAT_TEXTURE_ROUGHNESS");
              } else {
                defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
              }
              if (this._bumpTexture && MaterialFlags.ClearCoatBumpTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "CLEARCOAT_BUMP");
              } else {
                defines.CLEARCOAT_BUMP = false;
              }
              defines.CLEARCOAT_DEFAULTIOR = this._indexOfRefraction === PBRClearCoatConfiguration._DefaultIndexOfRefraction;
              if (this._isTintEnabled) {
                defines.CLEARCOAT_TINT = true;
                if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
                  MaterialHelper.PrepareDefinesForMergedUV(this._tintTexture, defines, "CLEARCOAT_TINT_TEXTURE");
                  defines.CLEARCOAT_TINT_GAMMATEXTURE = this._tintTexture.gammaSpace;
                } else {
                  defines.CLEARCOAT_TINT_TEXTURE = false;
                }
              } else {
                defines.CLEARCOAT_TINT = false;
                defines.CLEARCOAT_TINT_TEXTURE = false;
              }
            }
          }
        } else {
          defines.CLEARCOAT = false;
          defines.CLEARCOAT_TEXTURE = false;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS = false;
          defines.CLEARCOAT_BUMP = false;
          defines.CLEARCOAT_TINT = false;
          defines.CLEARCOAT_TINT_TEXTURE = false;
          defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL = false;
          defines.CLEARCOAT_DEFAULTIOR = false;
          defines.CLEARCOAT_TEXTUREDIRECTUV = 0;
          defines.CLEARCOAT_TEXTURE_ROUGHNESSDIRECTUV = 0;
          defines.CLEARCOAT_BUMPDIRECTUV = 0;
          defines.CLEARCOAT_REMAP_F0 = false;
          defines.CLEARCOAT_TINT_TEXTUREDIRECTUV = 0;
          defines.CLEARCOAT_TINT_GAMMATEXTURE = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const disableBumpMap = this._material._disableBumpMap;
        const invertNormalMapX = this._material._invertNormalMapX;
        const invertNormalMapY = this._material._invertNormalMapY;
        const identicalTextures = defines.CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (identicalTextures && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.updateFloat4("vClearCoatInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
          } else if ((this._texture || this._textureRoughness) && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.updateFloat4("vClearCoatInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
            if (this._texture) {
              MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "clearCoat");
            }
            if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "clearCoatRoughness");
            }
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatTextureEnabled && !disableBumpMap) {
            uniformBuffer.updateFloat2("vClearCoatBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level);
            MaterialHelper.BindTextureMatrix(this._bumpTexture, uniformBuffer, "clearCoatBump");
            if (scene._mirroredCameraPosition) {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? 1 : -1, invertNormalMapY ? 1 : -1);
            } else {
              uniformBuffer.updateFloat2("vClearCoatTangentSpaceParams", invertNormalMapX ? -1 : 1, invertNormalMapY ? -1 : 1);
            }
          }
          if (this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.updateFloat2("vClearCoatTintInfos", this._tintTexture.coordinatesIndex, this._tintTexture.level);
            MaterialHelper.BindTextureMatrix(this._tintTexture, uniformBuffer, "clearCoatTint");
          }
          uniformBuffer.updateFloat2("vClearCoatParams", this.intensity, this.roughness);
          const a = 1 - this._indexOfRefraction;
          const b = 1 + this._indexOfRefraction;
          const f0 = Math.pow(-a / b, 2);
          const eta = 1 / this._indexOfRefraction;
          uniformBuffer.updateFloat4("vClearCoatRefractionParams", f0, eta, a, b);
          if (this._isTintEnabled) {
            uniformBuffer.updateFloat4("vClearCoatTintParams", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintThickness));
            uniformBuffer.updateFloat("clearCoatColorAtDistance", Math.max(1e-5, this.tintColorAtDistance));
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatSampler", this._texture);
          }
          if (this._textureRoughness && !identicalTextures && !defines.CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.ClearCoatTextureEnabled) {
            uniformBuffer.setTexture("clearCoatRoughnessSampler", this._textureRoughness);
          }
          if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.ClearCoatBumpTextureEnabled && !disableBumpMap) {
            uniformBuffer.setTexture("clearCoatBumpSampler", this._bumpTexture);
          }
          if (this._isTintEnabled && this._tintTexture && MaterialFlags.ClearCoatTintTextureEnabled) {
            uniformBuffer.setTexture("clearCoatTintSampler", this._tintTexture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._tintTexture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._tintTexture) {
          activeTextures.push(this._tintTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          animatables.push(this._bumpTexture);
        }
        if (this._tintTexture && this._tintTexture.animations && this._tintTexture.animations.length > 0) {
          animatables.push(this._tintTexture);
        }
      }
      dispose(forceDisposeTextures) {
        var _a, _b, _c, _d;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
          (_c = this._bumpTexture) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._tintTexture) === null || _d === void 0 ? void 0 : _d.dispose();
        }
      }
      getClassName() {
        return "PBRClearCoatConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.CLEARCOAT_BUMP) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_BUMP");
        }
        if (defines.CLEARCOAT_TINT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT_TINT");
        }
        if (defines.CLEARCOAT) {
          fallbacks.addFallback(currentRank++, "CLEARCOAT");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("clearCoatSampler", "clearCoatRoughnessSampler", "clearCoatBumpSampler", "clearCoatTintSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vClearCoatParams", size: 2, type: "vec2" },
            { name: "vClearCoatRefractionParams", size: 4, type: "vec4" },
            { name: "vClearCoatInfos", size: 4, type: "vec4" },
            { name: "clearCoatMatrix", size: 16, type: "mat4" },
            { name: "clearCoatRoughnessMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatBumpInfos", size: 2, type: "vec2" },
            { name: "vClearCoatTangentSpaceParams", size: 2, type: "vec2" },
            { name: "clearCoatBumpMatrix", size: 16, type: "mat4" },
            { name: "vClearCoatTintParams", size: 4, type: "vec4" },
            { name: "clearCoatColorAtDistance", size: 1, type: "float" },
            { name: "vClearCoatTintInfos", size: 2, type: "vec2" },
            { name: "clearCoatTintMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRClearCoatConfiguration._DefaultIndexOfRefraction = 1.5;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "roughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "textureRoughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "remapF0OnInterfaceChange", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "bumpTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "isTintEnabled", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRClearCoatConfiguration.prototype, "tintColor", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "tintColorAtDistance", void 0);
    __decorate([
      serialize()
    ], PBRClearCoatConfiguration.prototype, "tintThickness", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRClearCoatConfiguration.prototype, "tintTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js
var MaterialIridescenceDefines, PBRIridescenceConfiguration;
var init_pbrIridescenceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrIridescenceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialIridescenceDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.IRIDESCENCE = false;
        this.IRIDESCENCE_TEXTURE = false;
        this.IRIDESCENCE_TEXTUREDIRECTUV = 0;
        this.IRIDESCENCE_THICKNESS_TEXTURE = false;
        this.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
        this.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;
      }
    };
    PBRIridescenceConfiguration = class extends MaterialPluginBase {
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRIridescence", 110, new MaterialIridescenceDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.minimumThickness = PBRIridescenceConfiguration._DefaultMinimumThickness;
        this.maximumThickness = PBRIridescenceConfiguration._DefaultMaximumThickness;
        this.indexOfRefraction = PBRIridescenceConfiguration._DefaultIndexOfRefraction;
        this._texture = null;
        this.texture = null;
        this._thicknessTexture = null;
        this.thicknessTexture = null;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        var _a;
        if (this._isEnabled) {
          defines.IRIDESCENCE = true;
          defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = this._texture !== null && this._texture._texture === ((_a = this._thicknessTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._thicknessTexture);
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "IRIDESCENCE_TEXTURE");
              } else {
                defines.IRIDESCENCE_TEXTURE = false;
              }
              if (!defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && this._thicknessTexture && MaterialFlags.IridescenceTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "IRIDESCENCE_THICKNESS_TEXTURE");
              } else {
                defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
              }
            }
          }
        } else {
          defines.IRIDESCENCE = false;
          defines.IRIDESCENCE_TEXTURE = false;
          defines.IRIDESCENCE_THICKNESS_TEXTURE = false;
          defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE = false;
          defines.IRIDESCENCE_TEXTUREDIRECTUV = 0;
          defines.IRIDESCENCE_THICKNESS_TEXTUREDIRECTUV = 0;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const identicalTextures = defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (identicalTextures && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.updateFloat4("vIridescenceInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
          } else if ((this._texture || this._thicknessTexture) && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.updateFloat4("vIridescenceInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._thicknessTexture) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._thicknessTexture) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
            if (this._texture) {
              MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "iridescence");
            }
            if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE) {
              MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "iridescenceThickness");
            }
          }
          uniformBuffer.updateFloat4("vIridescenceParams", this.intensity, this.indexOfRefraction, this.minimumThickness, this.maximumThickness);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceSampler", this._texture);
          }
          if (this._thicknessTexture && !identicalTextures && !defines.IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE && MaterialFlags.IridescenceTextureEnabled) {
            uniformBuffer.setTexture("iridescenceThicknessSampler", this._thicknessTexture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._thicknessTexture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
      }
      dispose(forceDisposeTextures) {
        var _a, _b;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._thicknessTexture) === null || _b === void 0 ? void 0 : _b.dispose();
        }
      }
      getClassName() {
        return "PBRIridescenceConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.IRIDESCENCE) {
          fallbacks.addFallback(currentRank++, "IRIDESCENCE");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("iridescenceSampler", "iridescenceThicknessSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vIridescenceParams", size: 4, type: "vec4" },
            { name: "vIridescenceInfos", size: 4, type: "vec4" },
            { name: "iridescenceMatrix", size: 16, type: "mat4" },
            { name: "iridescenceThicknessMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    PBRIridescenceConfiguration._DefaultMinimumThickness = 100;
    PBRIridescenceConfiguration._DefaultMaximumThickness = 400;
    PBRIridescenceConfiguration._DefaultIndexOfRefraction = 1.3;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "intensity", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "minimumThickness", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "maximumThickness", void 0);
    __decorate([
      serialize()
    ], PBRIridescenceConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "texture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRIridescenceConfiguration.prototype, "thicknessTexture", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js
var MaterialAnisotropicDefines, PBRAnisotropicConfiguration;
var init_pbrAnisotropicConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrAnisotropicConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_buffer();
    init_math_vector();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialAnisotropicDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.ANISOTROPIC = false;
        this.ANISOTROPIC_TEXTURE = false;
        this.ANISOTROPIC_TEXTUREDIRECTUV = 0;
        this.ANISOTROPIC_LEGACY = false;
        this.MAINUV1 = false;
      }
    };
    PBRAnisotropicConfiguration = class extends MaterialPluginBase {
      set angle(value) {
        this.direction.x = Math.cos(value);
        this.direction.y = Math.sin(value);
      }
      get angle() {
        return Math.atan2(this.direction.y, this.direction.x);
      }
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      _markAllSubMeshesAsMiscDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsMiscDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRAnisotropic", 110, new MaterialAnisotropicDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this.intensity = 1;
        this.direction = new Vector2(1, 0);
        this._texture = null;
        this.texture = null;
        this._legacy = false;
        this.legacy = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene, mesh) {
        if (this._isEnabled) {
          defines.ANISOTROPIC = this._isEnabled;
          if (this._isEnabled && !mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
            defines._needUVs = true;
            defines.MAINUV1 = true;
          }
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "ANISOTROPIC_TEXTURE");
              } else {
                defines.ANISOTROPIC_TEXTURE = false;
              }
            }
          }
          if (defines._areMiscDirty) {
            defines.ANISOTROPIC_LEGACY = this._legacy;
          }
        } else {
          defines.ANISOTROPIC = false;
          defines.ANISOTROPIC_TEXTURE = false;
          defines.ANISOTROPIC_TEXTUREDIRECTUV = 0;
          defines.ANISOTROPIC_LEGACY = false;
        }
      }
      bindForSubMesh(uniformBuffer, scene) {
        if (!this._isEnabled) {
          return;
        }
        const isFrozen = this._material.isFrozen;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.updateFloat2("vAnisotropyInfos", this._texture.coordinatesIndex, this._texture.level);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "anisotropy");
          }
          uniformBuffer.updateFloat3("vAnisotropy", this.direction.x, this.direction.y, this.intensity);
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.AnisotropicTextureEnabled) {
            uniformBuffer.setTexture("anisotropySampler", this._texture);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._texture) {
            this._texture.dispose();
          }
        }
      }
      getClassName() {
        return "PBRAnisotropicConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.ANISOTROPIC) {
          fallbacks.addFallback(currentRank++, "ANISOTROPIC");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("anisotropySampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vAnisotropy", size: 3, type: "vec3" },
            { name: "vAnisotropyInfos", size: 2, type: "vec2" },
            { name: "anisotropyMatrix", size: 16, type: "mat4" }
          ]
        };
      }
      parse(source, scene, rootUrl) {
        super.parse(source, scene, rootUrl);
        if (source.legacy === void 0) {
          this.legacy = true;
        }
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRAnisotropicConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize()
    ], PBRAnisotropicConfiguration.prototype, "intensity", void 0);
    __decorate([
      serializeAsVector2()
    ], PBRAnisotropicConfiguration.prototype, "direction", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRAnisotropicConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRAnisotropicConfiguration.prototype, "legacy", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js
var MaterialSheenDefines, PBRSheenConfiguration;
var init_pbrSheenConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSheenConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialHelper();
    init_materialPluginBase();
    init_materialDefines();
    MaterialSheenDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.SHEEN = false;
        this.SHEEN_TEXTURE = false;
        this.SHEEN_GAMMATEXTURE = false;
        this.SHEEN_TEXTURE_ROUGHNESS = false;
        this.SHEEN_TEXTUREDIRECTUV = 0;
        this.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        this.SHEEN_LINKWITHALBEDO = false;
        this.SHEEN_ROUGHNESS = false;
        this.SHEEN_ALBEDOSCALING = false;
        this.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
        this.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
      }
    };
    PBRSheenConfiguration = class extends MaterialPluginBase {
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "Sheen", 120, new MaterialSheenDefines(), addToPluginList);
        this._isEnabled = false;
        this.isEnabled = false;
        this._linkSheenWithAlbedo = false;
        this.linkSheenWithAlbedo = false;
        this.intensity = 1;
        this.color = Color3.White();
        this._texture = null;
        this.texture = null;
        this._useRoughnessFromMainTexture = true;
        this.useRoughnessFromMainTexture = true;
        this._roughness = null;
        this.roughness = null;
        this._textureRoughness = null;
        this.textureRoughness = null;
        this._albedoScaling = false;
        this.albedoScaling = false;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._texture && MaterialFlags.SheenTextureEnabled) {
              if (!this._texture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
              if (!this._textureRoughness.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        var _a;
        if (this._isEnabled) {
          defines.SHEEN = true;
          defines.SHEEN_LINKWITHALBEDO = this._linkSheenWithAlbedo;
          defines.SHEEN_ROUGHNESS = this._roughness !== null;
          defines.SHEEN_ALBEDOSCALING = this._albedoScaling;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = this._useRoughnessFromMainTexture;
          defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = this._texture !== null && this._texture._texture === ((_a = this._textureRoughness) === null || _a === void 0 ? void 0 : _a._texture) && this._texture.checkTransformsAreIdentical(this._textureRoughness);
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._texture && MaterialFlags.SheenTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._texture, defines, "SHEEN_TEXTURE");
                defines.SHEEN_GAMMATEXTURE = this._texture.gammaSpace;
              } else {
                defines.SHEEN_TEXTURE = false;
              }
              if (this._textureRoughness && MaterialFlags.SheenTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._textureRoughness, defines, "SHEEN_TEXTURE_ROUGHNESS");
              } else {
                defines.SHEEN_TEXTURE_ROUGHNESS = false;
              }
            }
          }
        } else {
          defines.SHEEN = false;
          defines.SHEEN_TEXTURE = false;
          defines.SHEEN_TEXTURE_ROUGHNESS = false;
          defines.SHEEN_LINKWITHALBEDO = false;
          defines.SHEEN_ROUGHNESS = false;
          defines.SHEEN_ALBEDOSCALING = false;
          defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE = false;
          defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL = false;
          defines.SHEEN_GAMMATEXTURE = false;
          defines.SHEEN_TEXTUREDIRECTUV = 0;
          defines.SHEEN_TEXTURE_ROUGHNESSDIRECTUV = 0;
        }
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        var _a, _b, _c, _d, _e, _f, _g, _h;
        if (!this._isEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const identicalTextures = defines.SHEEN_TEXTURE_ROUGHNESS_IDENTICAL;
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (identicalTextures && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.updateFloat4("vSheenInfos", this._texture.coordinatesIndex, this._texture.level, -1, -1);
            MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
          } else if ((this._texture || this._textureRoughness) && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.updateFloat4("vSheenInfos", (_b = (_a = this._texture) === null || _a === void 0 ? void 0 : _a.coordinatesIndex) !== null && _b !== void 0 ? _b : 0, (_d = (_c = this._texture) === null || _c === void 0 ? void 0 : _c.level) !== null && _d !== void 0 ? _d : 0, (_f = (_e = this._textureRoughness) === null || _e === void 0 ? void 0 : _e.coordinatesIndex) !== null && _f !== void 0 ? _f : 0, (_h = (_g = this._textureRoughness) === null || _g === void 0 ? void 0 : _g.level) !== null && _h !== void 0 ? _h : 0);
            if (this._texture) {
              MaterialHelper.BindTextureMatrix(this._texture, uniformBuffer, "sheen");
            }
            if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE) {
              MaterialHelper.BindTextureMatrix(this._textureRoughness, uniformBuffer, "sheenRoughness");
            }
          }
          uniformBuffer.updateFloat4("vSheenColor", this.color.r, this.color.g, this.color.b, this.intensity);
          if (this._roughness !== null) {
            uniformBuffer.updateFloat("vSheenRoughness", this._roughness);
          }
        }
        if (scene.texturesEnabled) {
          if (this._texture && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenSampler", this._texture);
          }
          if (this._textureRoughness && !identicalTextures && !defines.SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE && MaterialFlags.SheenTextureEnabled) {
            uniformBuffer.setTexture("sheenRoughnessSampler", this._textureRoughness);
          }
        }
      }
      hasTexture(texture) {
        if (this._texture === texture) {
          return true;
        }
        if (this._textureRoughness === texture) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._texture) {
          activeTextures.push(this._texture);
        }
        if (this._textureRoughness) {
          activeTextures.push(this._textureRoughness);
        }
      }
      getAnimatables(animatables) {
        if (this._texture && this._texture.animations && this._texture.animations.length > 0) {
          animatables.push(this._texture);
        }
        if (this._textureRoughness && this._textureRoughness.animations && this._textureRoughness.animations.length > 0) {
          animatables.push(this._textureRoughness);
        }
      }
      dispose(forceDisposeTextures) {
        var _a, _b;
        if (forceDisposeTextures) {
          (_a = this._texture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._textureRoughness) === null || _b === void 0 ? void 0 : _b.dispose();
        }
      }
      getClassName() {
        return "PBRSheenConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.SHEEN) {
          fallbacks.addFallback(currentRank++, "SHEEN");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("sheenSampler", "sheenRoughnessSampler");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vSheenColor", size: 4, type: "vec4" },
            { name: "vSheenRoughness", size: 1, type: "float" },
            { name: "vSheenInfos", size: 4, type: "vec4" },
            { name: "sheenMatrix", size: 16, type: "mat4" },
            { name: "sheenRoughnessMatrix", size: 16, type: "mat4" }
          ]
        };
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "isEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "linkSheenWithAlbedo", void 0);
    __decorate([
      serialize()
    ], PBRSheenConfiguration.prototype, "intensity", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSheenConfiguration.prototype, "color", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "texture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "useRoughnessFromMainTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "roughness", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "textureRoughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSheenConfiguration.prototype, "albedoScaling", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js
var MaterialSubSurfaceDefines, PBRSubSurfaceConfiguration;
var init_pbrSubSurfaceConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrSubSurfaceConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_color();
    init_materialFlags();
    init_materialHelper();
    init_math_scalar();
    init_math_vector();
    init_materialPluginBase();
    init_materialDefines();
    MaterialSubSurfaceDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.SUBSURFACE = false;
        this.SS_REFRACTION = false;
        this.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
        this.SS_TRANSLUCENCY = false;
        this.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
        this.SS_SCATTERING = false;
        this.SS_THICKNESSANDMASK_TEXTURE = false;
        this.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
        this.SS_HAS_THICKNESS = false;
        this.SS_REFRACTIONINTENSITY_TEXTURE = false;
        this.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
        this.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
        this.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
        this.SS_REFRACTIONMAP_3D = false;
        this.SS_REFRACTIONMAP_OPPOSITEZ = false;
        this.SS_LODINREFRACTIONALPHA = false;
        this.SS_GAMMAREFRACTION = false;
        this.SS_RGBDREFRACTION = false;
        this.SS_LINEARSPECULARREFRACTION = false;
        this.SS_LINKREFRACTIONTOTRANSPARENCY = false;
        this.SS_ALBEDOFORREFRACTIONTINT = false;
        this.SS_ALBEDOFORTRANSLUCENCYTINT = false;
        this.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
        this.SS_USE_THICKNESS_AS_DEPTH = false;
        this.SS_MASK_FROM_THICKNESS_TEXTURE = false;
        this.SS_USE_GLTF_TEXTURES = false;
      }
    };
    PBRSubSurfaceConfiguration = class extends MaterialPluginBase {
      get scatteringDiffusionProfile() {
        if (!this._scene.subSurfaceConfiguration) {
          return null;
        }
        return this._scene.subSurfaceConfiguration.ssDiffusionProfileColors[this._scatteringDiffusionProfileIndex];
      }
      set scatteringDiffusionProfile(c) {
        if (!this._scene.enableSubSurfaceForPrePass()) {
          return;
        }
        if (c) {
          this._scatteringDiffusionProfileIndex = this._scene.subSurfaceConfiguration.addDiffusionProfile(c);
        }
      }
      get volumeIndexOfRefraction() {
        if (this._volumeIndexOfRefraction >= 1) {
          return this._volumeIndexOfRefraction;
        }
        return this._indexOfRefraction;
      }
      set volumeIndexOfRefraction(value) {
        if (value >= 1) {
          this._volumeIndexOfRefraction = value;
        } else {
          this._volumeIndexOfRefraction = -1;
        }
      }
      _markAllSubMeshesAsTexturesDirty() {
        this._enable(this._isRefractionEnabled || this._isTranslucencyEnabled || this._isScatteringEnabled);
        this._internalMarkAllSubMeshesAsTexturesDirty();
      }
      _markScenePrePassDirty() {
        this._internalMarkAllSubMeshesAsTexturesDirty();
        this._internalMarkScenePrePassDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRSubSurface", 130, new MaterialSubSurfaceDefines(), addToPluginList);
        this._isRefractionEnabled = false;
        this.isRefractionEnabled = false;
        this._isTranslucencyEnabled = false;
        this.isTranslucencyEnabled = false;
        this._isScatteringEnabled = false;
        this.isScatteringEnabled = false;
        this._scatteringDiffusionProfileIndex = 0;
        this.refractionIntensity = 1;
        this.translucencyIntensity = 1;
        this.useAlbedoToTintRefraction = false;
        this.useAlbedoToTintTranslucency = false;
        this._thicknessTexture = null;
        this.thicknessTexture = null;
        this._refractionTexture = null;
        this.refractionTexture = null;
        this._indexOfRefraction = 1.5;
        this.indexOfRefraction = 1.5;
        this._volumeIndexOfRefraction = -1;
        this._invertRefractionY = false;
        this.invertRefractionY = false;
        this._linkRefractionWithTransparency = false;
        this.linkRefractionWithTransparency = false;
        this.minimumThickness = 0;
        this.maximumThickness = 1;
        this.useThicknessAsDepth = false;
        this.tintColor = Color3.White();
        this.tintColorAtDistance = 1;
        this.diffusionDistance = Color3.White();
        this._useMaskFromThicknessTexture = false;
        this.useMaskFromThicknessTexture = false;
        this._refractionIntensityTexture = null;
        this.refractionIntensityTexture = null;
        this._translucencyIntensityTexture = null;
        this.translucencyIntensityTexture = null;
        this._useGltfStyleTextures = false;
        this.useGltfStyleTextures = false;
        this._scene = material.getScene();
        this.registerForExtraEvents = true;
        this._internalMarkAllSubMeshesAsTexturesDirty = material._dirtyCallbacks[1];
        this._internalMarkScenePrePassDirty = material._dirtyCallbacks[32];
      }
      isReadyForSubMesh(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return true;
        }
        if (defines._areTexturesDirty) {
          if (scene.texturesEnabled) {
            if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
              if (!this._thicknessTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            const refractionTexture = this._getRefractionTexture(scene);
            if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
              if (!refractionTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
          }
        }
        return true;
      }
      prepareDefinesBeforeAttributes(defines, scene) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          defines.SUBSURFACE = false;
          defines.SS_TRANSLUCENCY = false;
          defines.SS_SCATTERING = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_THICKNESSANDMASK_TEXTUREDIRECTUV = 0;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTUREDIRECTUV = 0;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTUREDIRECTUV = 0;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          return;
        }
        if (defines._areTexturesDirty) {
          defines.SUBSURFACE = true;
          defines.SS_TRANSLUCENCY = this._isTranslucencyEnabled;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = false;
          defines.SS_SCATTERING = this._isScatteringEnabled;
          defines.SS_THICKNESSANDMASK_TEXTURE = false;
          defines.SS_REFRACTIONINTENSITY_TEXTURE = false;
          defines.SS_TRANSLUCENCYINTENSITY_TEXTURE = false;
          defines.SS_HAS_THICKNESS = false;
          defines.SS_MASK_FROM_THICKNESS_TEXTURE = false;
          defines.SS_USE_GLTF_TEXTURES = false;
          defines.SS_REFRACTION = false;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = false;
          defines.SS_REFRACTIONMAP_3D = false;
          defines.SS_GAMMAREFRACTION = false;
          defines.SS_RGBDREFRACTION = false;
          defines.SS_LINEARSPECULARREFRACTION = false;
          defines.SS_REFRACTIONMAP_OPPOSITEZ = false;
          defines.SS_LODINREFRACTIONALPHA = false;
          defines.SS_LINKREFRACTIONTOTRANSPARENCY = false;
          defines.SS_ALBEDOFORREFRACTIONTINT = false;
          defines.SS_ALBEDOFORTRANSLUCENCYTINT = false;
          defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = false;
          defines.SS_USE_THICKNESS_AS_DEPTH = false;
          const refractionIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._refractionIntensityTexture && this._refractionIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._refractionIntensityTexture._texture === this._thicknessTexture._texture;
          const translucencyIntensityTextureIsThicknessTexture = !!this._thicknessTexture && !!this._translucencyIntensityTexture && this._translucencyIntensityTexture.checkTransformsAreIdentical(this._thicknessTexture) && this._translucencyIntensityTexture._texture === this._thicknessTexture._texture;
          const useOnlyThicknessTexture = (refractionIntensityTextureIsThicknessTexture || !this._refractionIntensityTexture) && (translucencyIntensityTextureIsThicknessTexture || !this._translucencyIntensityTexture);
          if (defines._areTexturesDirty) {
            if (scene.texturesEnabled) {
              if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
                MaterialHelper.PrepareDefinesForMergedUV(this._thicknessTexture, defines, "SS_THICKNESSANDMASK_TEXTURE");
              }
              if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && !useOnlyThicknessTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._refractionIntensityTexture, defines, "SS_REFRACTIONINTENSITY_TEXTURE");
              }
              if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && !useOnlyThicknessTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._translucencyIntensityTexture, defines, "SS_TRANSLUCENCYINTENSITY_TEXTURE");
              }
            }
          }
          defines.SS_HAS_THICKNESS = this.maximumThickness - this.minimumThickness !== 0;
          defines.SS_MASK_FROM_THICKNESS_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;
          defines.SS_USE_GLTF_TEXTURES = this._useGltfStyleTextures;
          defines.SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._refractionIntensityTexture) && useOnlyThicknessTexture;
          defines.SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE = (this._useMaskFromThicknessTexture || !!this._translucencyIntensityTexture) && useOnlyThicknessTexture;
          if (this._isRefractionEnabled) {
            if (scene.texturesEnabled) {
              const refractionTexture = this._getRefractionTexture(scene);
              if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
                defines.SS_REFRACTION = true;
                defines.SS_REFRACTIONMAP_3D = refractionTexture.isCube;
                defines.SS_GAMMAREFRACTION = refractionTexture.gammaSpace;
                defines.SS_RGBDREFRACTION = refractionTexture.isRGBD;
                defines.SS_LINEARSPECULARREFRACTION = refractionTexture.linearSpecularLOD;
                defines.SS_REFRACTIONMAP_OPPOSITEZ = this._scene.useRightHandedSystem && refractionTexture.isCube ? !refractionTexture.invertZ : refractionTexture.invertZ;
                defines.SS_LODINREFRACTIONALPHA = refractionTexture.lodLevelInAlpha;
                defines.SS_LINKREFRACTIONTOTRANSPARENCY = this._linkRefractionWithTransparency;
                defines.SS_ALBEDOFORREFRACTIONTINT = this.useAlbedoToTintRefraction;
                defines.SS_USE_LOCAL_REFRACTIONMAP_CUBIC = refractionTexture.isCube && refractionTexture.boundingBoxSize;
                defines.SS_USE_THICKNESS_AS_DEPTH = this.useThicknessAsDepth;
              }
            }
          }
          if (this._isTranslucencyEnabled) {
            defines.SS_ALBEDOFORTRANSLUCENCYTINT = this.useAlbedoToTintTranslucency;
          }
        }
      }
      hardBindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        subMesh.getRenderingMesh().getWorldMatrix().decompose(TmpVectors.Vector3[0]);
        const thicknessScale = Math.max(Math.abs(TmpVectors.Vector3[0].x), Math.abs(TmpVectors.Vector3[0].y), Math.abs(TmpVectors.Vector3[0].z));
        uniformBuffer.updateFloat2("vThicknessParam", this.minimumThickness * thicknessScale, (this.maximumThickness - this.minimumThickness) * thicknessScale);
      }
      bindForSubMesh(uniformBuffer, scene, engine, subMesh) {
        if (!this._isRefractionEnabled && !this._isTranslucencyEnabled && !this._isScatteringEnabled) {
          return;
        }
        const defines = subMesh.materialDefines;
        const isFrozen = this._material.isFrozen;
        const realTimeFiltering = this._material.realTimeFiltering;
        const lodBasedMicrosurface = defines.LODBASEDMICROSFURACE;
        const refractionTexture = this._getRefractionTexture(scene);
        if (!uniformBuffer.useUbo || !isFrozen || !uniformBuffer.isSync) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.updateFloat2("vThicknessInfos", this._thicknessTexture.coordinatesIndex, this._thicknessTexture.level);
            MaterialHelper.BindTextureMatrix(this._thicknessTexture, uniformBuffer, "thickness");
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vRefractionIntensityInfos", this._refractionIntensityTexture.coordinatesIndex, this._refractionIntensityTexture.level);
            MaterialHelper.BindTextureMatrix(this._refractionIntensityTexture, uniformBuffer, "refractionIntensity");
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.updateFloat2("vTranslucencyIntensityInfos", this._translucencyIntensityTexture.coordinatesIndex, this._translucencyIntensityTexture.level);
            MaterialHelper.BindTextureMatrix(this._translucencyIntensityTexture, uniformBuffer, "translucencyIntensity");
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            uniformBuffer.updateMatrix("refractionMatrix", refractionTexture.getRefractionTextureMatrix());
            let depth = 1;
            if (!refractionTexture.isCube) {
              if (refractionTexture.depth) {
                depth = refractionTexture.depth;
              }
            }
            const width = refractionTexture.getSize().width;
            const refractionIor = this.volumeIndexOfRefraction;
            uniformBuffer.updateFloat4("vRefractionInfos", refractionTexture.level, 1 / refractionIor, depth, this._invertRefractionY ? -1 : 1);
            uniformBuffer.updateFloat4("vRefractionMicrosurfaceInfos", width, refractionTexture.lodGenerationScale, refractionTexture.lodGenerationOffset, 1 / this.indexOfRefraction);
            if (realTimeFiltering) {
              uniformBuffer.updateFloat2("vRefractionFilteringInfo", width, Scalar.Log2(width));
            }
            if (refractionTexture.boundingBoxSize) {
              const cubeTexture = refractionTexture;
              uniformBuffer.updateVector3("vRefractionPosition", cubeTexture.boundingBoxPosition);
              uniformBuffer.updateVector3("vRefractionSize", cubeTexture.boundingBoxSize);
            }
          }
          if (this._isScatteringEnabled) {
            uniformBuffer.updateFloat("scatteringDiffusionProfile", this._scatteringDiffusionProfileIndex);
          }
          uniformBuffer.updateColor3("vDiffusionDistance", this.diffusionDistance);
          uniformBuffer.updateFloat4("vTintColor", this.tintColor.r, this.tintColor.g, this.tintColor.b, Math.max(1e-5, this.tintColorAtDistance));
          uniformBuffer.updateFloat3("vSubSurfaceIntensity", this.refractionIntensity, this.translucencyIntensity, 0);
        }
        if (scene.texturesEnabled) {
          if (this._thicknessTexture && MaterialFlags.ThicknessTextureEnabled) {
            uniformBuffer.setTexture("thicknessSampler", this._thicknessTexture);
          }
          if (this._refractionIntensityTexture && MaterialFlags.RefractionIntensityTextureEnabled && defines.SS_REFRACTIONINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("refractionIntensitySampler", this._refractionIntensityTexture);
          }
          if (this._translucencyIntensityTexture && MaterialFlags.TranslucencyIntensityTextureEnabled && defines.SS_TRANSLUCENCYINTENSITY_TEXTURE) {
            uniformBuffer.setTexture("translucencyIntensitySampler", this._translucencyIntensityTexture);
          }
          if (refractionTexture && MaterialFlags.RefractionTextureEnabled) {
            if (lodBasedMicrosurface) {
              uniformBuffer.setTexture("refractionSampler", refractionTexture);
            } else {
              uniformBuffer.setTexture("refractionSampler", refractionTexture._lodTextureMid || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerLow", refractionTexture._lodTextureLow || refractionTexture);
              uniformBuffer.setTexture("refractionSamplerHigh", refractionTexture._lodTextureHigh || refractionTexture);
            }
          }
        }
      }
      _getRefractionTexture(scene) {
        if (this._refractionTexture) {
          return this._refractionTexture;
        }
        if (this._isRefractionEnabled) {
          return scene.environmentTexture;
        }
        return null;
      }
      get disableAlphaBlending() {
        return this._isRefractionEnabled && this._linkRefractionWithTransparency;
      }
      fillRenderTargetTextures(renderTargets) {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          renderTargets.push(this._refractionTexture);
        }
      }
      hasTexture(texture) {
        if (this._thicknessTexture === texture) {
          return true;
        }
        if (this._refractionTexture === texture) {
          return true;
        }
        return false;
      }
      hasRenderTargetTextures() {
        if (MaterialFlags.RefractionTextureEnabled && this._refractionTexture && this._refractionTexture.isRenderTarget) {
          return true;
        }
        return false;
      }
      getActiveTextures(activeTextures) {
        if (this._thicknessTexture) {
          activeTextures.push(this._thicknessTexture);
        }
        if (this._refractionTexture) {
          activeTextures.push(this._refractionTexture);
        }
      }
      getAnimatables(animatables) {
        if (this._thicknessTexture && this._thicknessTexture.animations && this._thicknessTexture.animations.length > 0) {
          animatables.push(this._thicknessTexture);
        }
        if (this._refractionTexture && this._refractionTexture.animations && this._refractionTexture.animations.length > 0) {
          animatables.push(this._refractionTexture);
        }
      }
      dispose(forceDisposeTextures) {
        if (forceDisposeTextures) {
          if (this._thicknessTexture) {
            this._thicknessTexture.dispose();
          }
          if (this._refractionTexture) {
            this._refractionTexture.dispose();
          }
        }
      }
      getClassName() {
        return "PBRSubSurfaceConfiguration";
      }
      addFallbacks(defines, fallbacks, currentRank) {
        if (defines.SS_SCATTERING) {
          fallbacks.addFallback(currentRank++, "SS_SCATTERING");
        }
        if (defines.SS_TRANSLUCENCY) {
          fallbacks.addFallback(currentRank++, "SS_TRANSLUCENCY");
        }
        return currentRank;
      }
      getSamplers(samplers) {
        samplers.push("thicknessSampler", "refractionIntensitySampler", "translucencyIntensitySampler", "refractionSampler", "refractionSamplerLow", "refractionSamplerHigh");
      }
      getUniforms() {
        return {
          ubo: [
            { name: "vRefractionMicrosurfaceInfos", size: 4, type: "vec4" },
            { name: "vRefractionFilteringInfo", size: 2, type: "vec2" },
            { name: "vTranslucencyIntensityInfos", size: 2, type: "vec2" },
            { name: "vRefractionInfos", size: 4, type: "vec4" },
            { name: "refractionMatrix", size: 16, type: "mat4" },
            { name: "vThicknessInfos", size: 2, type: "vec2" },
            { name: "vRefractionIntensityInfos", size: 2, type: "vec2" },
            { name: "thicknessMatrix", size: 16, type: "mat4" },
            { name: "refractionIntensityMatrix", size: 16, type: "mat4" },
            { name: "translucencyIntensityMatrix", size: 16, type: "mat4" },
            { name: "vThicknessParam", size: 2, type: "vec2" },
            { name: "vDiffusionDistance", size: 3, type: "vec3" },
            { name: "vTintColor", size: 4, type: "vec4" },
            { name: "vSubSurfaceIntensity", size: 3, type: "vec3" },
            { name: "vRefractionPosition", size: 3, type: "vec3" },
            { name: "vRefractionSize", size: 3, type: "vec3" },
            { name: "scatteringDiffusionProfile", size: 1, type: "float" }
          ]
        };
      }
    };
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isRefractionEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isTranslucencyEnabled", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markScenePrePassDirty")
    ], PBRSubSurfaceConfiguration.prototype, "isScatteringEnabled", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "_scatteringDiffusionProfileIndex", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "refractionIntensity", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "translucencyIntensity", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintRefraction", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useAlbedoToTintTranslucency", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "thicknessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "refractionTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "indexOfRefraction", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "_volumeIndexOfRefraction", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "volumeIndexOfRefraction", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "invertRefractionY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "linkRefractionWithTransparency", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "minimumThickness", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "maximumThickness", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "useThicknessAsDepth", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "tintColor", void 0);
    __decorate([
      serialize()
    ], PBRSubSurfaceConfiguration.prototype, "tintColorAtDistance", void 0);
    __decorate([
      serializeAsColor3()
    ], PBRSubSurfaceConfiguration.prototype, "diffusionDistance", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useMaskFromThicknessTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "refractionIntensityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "translucencyIntensityTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRSubSurfaceConfiguration.prototype, "useGltfStyleTextures", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js
var MaterialBRDFDefines, PBRBRDFConfiguration;
var init_pbrBRDFConfiguration = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBRDFConfiguration.js"() {
    init_tslib_es6();
    init_decorators();
    init_materialDefines();
    init_materialPluginBase();
    MaterialBRDFDefines = class extends MaterialDefines {
      constructor() {
        super(...arguments);
        this.BRDF_V_HEIGHT_CORRELATED = false;
        this.MS_BRDF_ENERGY_CONSERVATION = false;
        this.SPHERICAL_HARMONICS = false;
        this.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = false;
      }
    };
    PBRBRDFConfiguration = class extends MaterialPluginBase {
      _markAllSubMeshesAsMiscDirty() {
        this._internalMarkAllSubMeshesAsMiscDirty();
      }
      constructor(material, addToPluginList = true) {
        super(material, "PBRBRDF", 90, new MaterialBRDFDefines(), addToPluginList);
        this._useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
        this.useEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION;
        this._useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        this.useSmithVisibilityHeightCorrelated = PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED;
        this._useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
        this.useSphericalHarmonics = PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS;
        this._useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        this.useSpecularGlossinessInputEnergyConservation = PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION;
        this._internalMarkAllSubMeshesAsMiscDirty = material._dirtyCallbacks[16];
        this._enable(true);
      }
      prepareDefines(defines) {
        defines.BRDF_V_HEIGHT_CORRELATED = this._useSmithVisibilityHeightCorrelated;
        defines.MS_BRDF_ENERGY_CONSERVATION = this._useEnergyConservation && this._useSmithVisibilityHeightCorrelated;
        defines.SPHERICAL_HARMONICS = this._useSphericalHarmonics;
        defines.SPECULAR_GLOSSINESS_ENERGY_CONSERVATION = this._useSpecularGlossinessInputEnergyConservation;
      }
      getClassName() {
        return "PBRBRDFConfiguration";
      }
    };
    PBRBRDFConfiguration.DEFAULT_USE_ENERGY_CONSERVATION = true;
    PBRBRDFConfiguration.DEFAULT_USE_SMITH_VISIBILITY_HEIGHT_CORRELATED = true;
    PBRBRDFConfiguration.DEFAULT_USE_SPHERICAL_HARMONICS = true;
    PBRBRDFConfiguration.DEFAULT_USE_SPECULAR_GLOSSINESS_INPUT_ENERGY_CONSERVATION = true;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useEnergyConservation", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSmithVisibilityHeightCorrelated", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSphericalHarmonics", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBRDFConfiguration.prototype, "useSpecularGlossinessInputEnergyConservation", void 0);
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js
var name69, shader69;
var init_pbrFragmentDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentDeclaration.js"() {
    init_shaderStore();
    init_decalFragmentDeclaration();
    name69 = "pbrFragmentDeclaration";
    shader69 = `uniform vec4 vEyePosition;uniform vec3 vReflectionColor;uniform vec4 vAlbedoColor;uniform vec4 vLightingIntensity;uniform vec4 vReflectivityColor;uniform vec4 vMetallicReflectanceFactors;uniform vec3 vEmissiveColor;uniform float visibility;uniform vec3 vAmbientColor;
#ifdef ALBEDO
uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform vec4 vAmbientInfos;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform vec2 vTangentSpaceParams;
#endif
#ifdef OPACITY
uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;
#endif
#ifdef REFLECTIVITY
uniform vec3 vReflectivityInfos;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;
#endif
#if defined(REFLECTIONMAP_SPHERICAL) || defined(REFLECTIONMAP_PROJECTION) || defined(SS_REFRACTION) || defined(PREPASS)
uniform mat4 view;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;
#ifdef REALTIME_FILTERING
uniform vec2 vReflectionFilteringInfo;
#endif
uniform mat4 reflectionMatrix;uniform vec3 vReflectionMicrosurfaceInfos;
#if defined(USE_LOCAL_REFLECTIONMAP_CUBIC) && defined(REFLECTIONMAP_CUBIC)
uniform vec3 vReflectionPosition;uniform vec3 vReflectionSize; 
#endif
#endif
#if defined(SS_REFRACTION) && defined(SS_USE_LOCAL_REFRACTIONMAP_CUBIC)
uniform vec3 vRefractionPosition;uniform vec3 vRefractionSize; 
#endif
#ifdef CLEARCOAT
uniform vec2 vClearCoatParams;uniform vec4 vClearCoatRefractionParams;
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform vec2 vClearCoatTangentSpaceParams;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT
uniform vec4 vClearCoatTintParams;uniform float clearCoatColorAtDistance;
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#endif
#ifdef IRIDESCENCE
uniform vec4 vIridescenceParams;
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
uniform vec3 vAnisotropy;
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
uniform vec4 vSheenColor;
#ifdef SHEEN_ROUGHNESS
uniform float vSheenRoughness;
#endif
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionMicrosurfaceInfos;uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#ifdef REALTIME_FILTERING
uniform vec2 vRefractionFilteringInfo;
#endif
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
uniform vec2 vThicknessParam;uniform vec3 vDiffusionDistance;uniform vec4 vTintColor;uniform vec3 vSubSurfaceIntensity;
#endif
#ifdef PREPASS
#ifdef SS_SCATTERING
uniform float scatteringDiffusionProfile;
#endif
#endif
#if DEBUGMODE>0
uniform vec2 vDebugMode;
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;
#endif
#include<decalFragmentDeclaration>
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#define ADDITIONAL_FRAGMENT_DECLARATION
`;
    ShaderStore.IncludesShadersStore[name69] = shader69;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js
var name70, shader70;
var init_pbrUboDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrUboDeclaration.js"() {
    init_shaderStore();
    init_sceneUboDeclaration();
    init_meshUboDeclaration();
    name70 = "pbrUboDeclaration";
    shader70 = `layout(std140,column_major) uniform;uniform Material {vec2 vAlbedoInfos;vec4 vAmbientInfos;vec2 vOpacityInfos;vec2 vEmissiveInfos;vec2 vLightmapInfos;vec3 vReflectivityInfos;vec2 vMicroSurfaceSamplerInfos;vec2 vReflectionInfos;vec2 vReflectionFilteringInfo;vec3 vReflectionPosition;vec3 vReflectionSize;vec3 vBumpInfos;mat4 albedoMatrix;mat4 ambientMatrix;mat4 opacityMatrix;mat4 emissiveMatrix;mat4 lightmapMatrix;mat4 reflectivityMatrix;mat4 microSurfaceSamplerMatrix;mat4 bumpMatrix;vec2 vTangentSpaceParams;mat4 reflectionMatrix;vec3 vReflectionColor;vec4 vAlbedoColor;vec4 vLightingIntensity;vec3 vReflectionMicrosurfaceInfos;float pointSize;vec4 vReflectivityColor;vec3 vEmissiveColor;vec3 vAmbientColor;vec2 vDebugMode;vec4 vMetallicReflectanceFactors;vec2 vMetallicReflectanceInfos;mat4 metallicReflectanceMatrix;vec2 vReflectanceInfos;mat4 reflectanceMatrix;vec3 vSphericalL00;vec3 vSphericalL1_1;vec3 vSphericalL10;vec3 vSphericalL11;vec3 vSphericalL2_2;vec3 vSphericalL2_1;vec3 vSphericalL20;vec3 vSphericalL21;vec3 vSphericalL22;vec3 vSphericalX;vec3 vSphericalY;vec3 vSphericalZ;vec3 vSphericalXX_ZZ;vec3 vSphericalYY_ZZ;vec3 vSphericalZZ;vec3 vSphericalXY;vec3 vSphericalYZ;vec3 vSphericalZX;
#define ADDITIONAL_UBO_DECLARATION
};
#include<sceneUboDeclaration>
#include<meshUboDeclaration>
`;
    ShaderStore.IncludesShadersStore[name70] = shader70;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js
var name71, shader71;
var init_pbrFragmentExtraDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentExtraDeclaration.js"() {
    init_shaderStore();
    init_mainUVVaryingDeclaration();
    name71 = "pbrFragmentExtraDeclaration";
    shader71 = `varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#include<mainUVVaryingDeclaration>[1..7]
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
`;
    ShaderStore.IncludesShadersStore[name71] = shader71;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js
var name72, shader72;
var init_samplerFragmentAlternateDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/samplerFragmentAlternateDeclaration.js"() {
    init_shaderStore();
    name72 = "samplerFragmentAlternateDeclaration";
    shader72 = `#ifdef _DEFINENAME_
#if _DEFINENAME_DIRECTUV==1
#define v_VARYINGNAME_UV vMainUV1
#elif _DEFINENAME_DIRECTUV==2
#define v_VARYINGNAME_UV vMainUV2
#elif _DEFINENAME_DIRECTUV==3
#define v_VARYINGNAME_UV vMainUV3
#elif _DEFINENAME_DIRECTUV==4
#define v_VARYINGNAME_UV vMainUV4
#elif _DEFINENAME_DIRECTUV==5
#define v_VARYINGNAME_UV vMainUV5
#elif _DEFINENAME_DIRECTUV==6
#define v_VARYINGNAME_UV vMainUV6
#else
varying vec2 v_VARYINGNAME_UV;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name72] = shader72;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js
var name73, shader73;
var init_pbrFragmentSamplersDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrFragmentSamplersDeclaration.js"() {
    init_shaderStore();
    init_samplerFragmentDeclaration();
    init_samplerFragmentAlternateDeclaration();
    name73 = "pbrFragmentSamplersDeclaration";
    shader73 = `#include<samplerFragmentDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_SAMPLERNAME_,albedo)
#include<samplerFragmentDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_SAMPLERNAME_,ambient)
#include<samplerFragmentDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_SAMPLERNAME_,opacity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_SAMPLERNAME_,emissive)
#include<samplerFragmentDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_SAMPLERNAME_,lightmap)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_SAMPLERNAME_,reflectivity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_SAMPLERNAME_,microSurface)
#include<samplerFragmentDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_SAMPLERNAME_,metallicReflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_SAMPLERNAME_,reflectance)
#include<samplerFragmentDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_SAMPLERNAME_,decal)
#ifdef CLEARCOAT
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_SAMPLERNAME_,clearCoat)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D clearCoatRoughnessSampler;
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_SAMPLERNAME_,clearCoatBump)
#include<samplerFragmentDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_SAMPLERNAME_,clearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_SAMPLERNAME_,iridescence)
#include<samplerFragmentDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_SAMPLERNAME_,iridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerFragmentDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_SAMPLERNAME_,sheen)
#include<samplerFragmentAlternateDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL)
uniform sampler2D sheenRoughnessSampler;
#endif
#endif
#ifdef ANISOTROPIC
#include<samplerFragmentDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_SAMPLERNAME_,anisotropy)
#endif
#ifdef REFLECTION
#ifdef REFLECTIONMAP_3D
#define sampleReflection(s,c) textureCube(s,c)
uniform samplerCube reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube reflectionSamplerLow;uniform samplerCube reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform samplerCube irradianceSampler;
#endif
#else
#define sampleReflection(s,c) texture2D(s,c)
uniform sampler2D reflectionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleReflectionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D reflectionSamplerLow;uniform sampler2D reflectionSamplerHigh;
#endif
#ifdef USEIRRADIANCEMAP
uniform sampler2D irradianceSampler;
#endif
#endif
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#else
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#endif
#endif
#ifdef ENVIRONMENTBRDF
uniform sampler2D environmentBrdfSampler;
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
#ifdef SS_REFRACTIONMAP_3D
#define sampleRefraction(s,c) textureCube(s,c)
uniform samplerCube refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) textureCubeLodEXT(s,c,l)
#else
uniform samplerCube refractionSamplerLow;uniform samplerCube refractionSamplerHigh;
#endif
#else
#define sampleRefraction(s,c) texture2D(s,c)
uniform sampler2D refractionSampler;
#ifdef LODBASEDMICROSFURACE
#define sampleRefractionLod(s,c,l) texture2DLodEXT(s,c,l)
#else
uniform sampler2D refractionSamplerLow;uniform sampler2D refractionSamplerHigh;
#endif
#endif
#endif
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_SAMPLERNAME_,thickness)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_SAMPLERNAME_,refractionIntensity)
#include<samplerFragmentDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_SAMPLERNAME_,translucencyIntensity)
#endif
`;
    ShaderStore.IncludesShadersStore[name73] = shader73;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js
var name74, shader74;
var init_subSurfaceScatteringFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/subSurfaceScatteringFunctions.js"() {
    init_shaderStore();
    name74 = "subSurfaceScatteringFunctions";
    shader74 = `bool testLightingForSSS(float diffusionProfile)
{return diffusionProfile<1.;}`;
    ShaderStore.IncludesShadersStore[name74] = shader74;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js
var name75, shader75;
var init_importanceSampling = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/importanceSampling.js"() {
    init_shaderStore();
    name75 = "importanceSampling";
    shader75 = `vec3 hemisphereCosSample(vec2 u) {float phi=2.*PI*u.x;float cosTheta2=1.-u.y;float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDggx(vec2 u,float a) {float phi=2.*PI*u.x;float cosTheta2=(1.-u.y)/(1.+(a+1.)*((a-1.)*u.y));float cosTheta=sqrt(cosTheta2);float sinTheta=sqrt(1.-cosTheta2);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}
vec3 hemisphereImportanceSampleDCharlie(vec2 u,float a) { 
float phi=2.*PI*u.x;float sinTheta=pow(u.y,a/(2.*a+1.));float cosTheta=sqrt(1.-sinTheta*sinTheta);return vec3(sinTheta*cos(phi),sinTheta*sin(phi),cosTheta);}`;
    ShaderStore.IncludesShadersStore[name75] = shader75;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js
var name76, shader76;
var init_pbrHelperFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrHelperFunctions.js"() {
    init_shaderStore();
    name76 = "pbrHelperFunctions";
    shader76 = `#define RECIPROCAL_PI2 0.15915494
#define RECIPROCAL_PI 0.31830988618
#define MINIMUMVARIANCE 0.0005
float convertRoughnessToAverageSlope(float roughness)
{return square(roughness)+MINIMUMVARIANCE;}
float fresnelGrazingReflectance(float reflectance0) {float reflectance90=saturate(reflectance0*25.0);return reflectance90;}
vec2 getAARoughnessFactors(vec3 normalVector) {
#ifdef SPECULARAA
vec3 nDfdx=dFdx(normalVector.xyz);vec3 nDfdy=dFdy(normalVector.xyz);float slopeSquare=max(dot(nDfdx,nDfdx),dot(nDfdy,nDfdy));float geometricRoughnessFactor=pow(saturate(slopeSquare),0.333);float geometricAlphaGFactor=sqrt(slopeSquare);geometricAlphaGFactor*=0.75;return vec2(geometricRoughnessFactor,geometricAlphaGFactor);
#else
return vec2(0.);
#endif
}
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_LEGACY
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(alphaG*(1.0+anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG*(1.0-anisotropy),MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 anisotropicFrameDirection=anisotropy>=0.0 ? B : T;vec3 anisotropicFrameTangent=cross(normalize(anisotropicFrameDirection),V);vec3 anisotropicFrameNormal=cross(anisotropicFrameTangent,anisotropicFrameDirection);vec3 anisotropicNormal=normalize(mix(N,anisotropicFrameNormal,abs(anisotropy)));return anisotropicNormal;}
#else
vec2 getAnisotropicRoughness(float alphaG,float anisotropy) {float alphaT=max(mix(alphaG,1.0,anisotropy*anisotropy),MINIMUMVARIANCE);float alphaB=max(alphaG,MINIMUMVARIANCE);return vec2(alphaT,alphaB);}
vec3 getAnisotropicBentNormals(const vec3 T,const vec3 B,const vec3 N,const vec3 V,float anisotropy,float roughness) {vec3 bentNormal=cross(B,V);bentNormal=normalize(cross(bentNormal,B));float a=square(square(1.0-anisotropy*(1.0-roughness)));bentNormal=normalize(mix(bentNormal,N,a));return bentNormal;}
#endif
#endif
#if defined(CLEARCOAT) || defined(SS_REFRACTION)
vec3 cocaLambert(vec3 alpha,float distance) {return exp(-alpha*distance);}
vec3 cocaLambert(float NdotVRefract,float NdotLRefract,vec3 alpha,float thickness) {return cocaLambert(alpha,(thickness*((NdotLRefract+NdotVRefract)/(NdotLRefract*NdotVRefract))));}
vec3 computeColorAtDistanceInMedia(vec3 color,float distance) {return -log(color)/distance;}
vec3 computeClearCoatAbsorption(float NdotVRefract,float NdotLRefract,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 clearCoatAbsorption=mix(vec3(1.0),
cocaLambert(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness),
clearCoatIntensity);return clearCoatAbsorption;}
#endif
#ifdef MICROSURFACEAUTOMATIC
float computeDefaultMicroSurface(float microSurface,vec3 reflectivityColor)
{const float kReflectivityNoAlphaWorkflow_SmoothnessMax=0.95;float reflectivityLuminance=getLuminance(reflectivityColor);float reflectivityLuma=sqrt(reflectivityLuminance);microSurface=reflectivityLuma*kReflectivityNoAlphaWorkflow_SmoothnessMax;return microSurface;}
#endif
`;
    ShaderStore.IncludesShadersStore[name76] = shader76;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js
var name77, shader77;
var init_harmonicsFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/harmonicsFunctions.js"() {
    init_shaderStore();
    name77 = "harmonicsFunctions";
    shader77 = `#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
vec3 computeEnvironmentIrradiance(vec3 normal) {return vSphericalL00
+ vSphericalL1_1*(normal.y)
+ vSphericalL10*(normal.z)
+ vSphericalL11*(normal.x)
+ vSphericalL2_2*(normal.y*normal.x)
+ vSphericalL2_1*(normal.y*normal.z)
+ vSphericalL20*((3.0*normal.z*normal.z)-1.0)
+ vSphericalL21*(normal.z*normal.x)
+ vSphericalL22*(normal.x*normal.x-(normal.y*normal.y));}
#else
vec3 computeEnvironmentIrradiance(vec3 normal) {float Nx=normal.x;float Ny=normal.y;float Nz=normal.z;vec3 C1=vSphericalZZ.rgb;vec3 Cx=vSphericalX.rgb;vec3 Cy=vSphericalY.rgb;vec3 Cz=vSphericalZ.rgb;vec3 Cxx_zz=vSphericalXX_ZZ.rgb;vec3 Cyy_zz=vSphericalYY_ZZ.rgb;vec3 Cxy=vSphericalXY.rgb;vec3 Cyz=vSphericalYZ.rgb;vec3 Czx=vSphericalZX.rgb;vec3 a1=Cyy_zz*Ny+Cy;vec3 a2=Cyz*Nz+a1;vec3 b1=Czx*Nz+Cx;vec3 b2=Cxy*Ny+b1;vec3 b3=Cxx_zz*Nx+b2;vec3 t1=Cz *Nz+C1;vec3 t2=a2 *Ny+t1;vec3 t3=b3 *Nx+t2;return t3;}
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name77] = shader77;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js
var name78, shader78;
var init_pbrDirectLightingSetupFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingSetupFunctions.js"() {
    init_shaderStore();
    name78 = "pbrDirectLightingSetupFunctions";
    shader78 = `struct preLightingInfo
{vec3 lightOffset;float lightDistanceSquared;float lightDistance;float attenuation;vec3 L;vec3 H;float NdotV;float NdotLUnclamped;float NdotL;float VdotH;float roughness;
#ifdef IRIDESCENCE
float iridescenceIntensity;
#endif
};preLightingInfo computePointAndSpotPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightOffset=lightData.xyz-vPositionW;result.lightDistanceSquared=dot(result.lightOffset,result.lightOffset);result.lightDistance=sqrt(result.lightDistanceSquared);result.L=normalize(result.lightOffset);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeDirectionalPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.lightDistance=length(-lightData.xyz);result.L=normalize(-lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));result.NdotLUnclamped=dot(N,result.L);result.NdotL=saturateEps(result.NdotLUnclamped);return result;}
preLightingInfo computeHemisphericPreLightingInfo(vec4 lightData,vec3 V,vec3 N) {preLightingInfo result;result.NdotL=dot(N,lightData.xyz)*0.5+0.5;result.NdotL=saturateEps(result.NdotL);result.NdotLUnclamped=result.NdotL;
#ifdef SPECULARTERM
result.L=normalize(lightData.xyz);result.H=normalize(V+result.L);result.VdotH=saturate(dot(V,result.H));
#endif
return result;}`;
    ShaderStore.IncludesShadersStore[name78] = shader78;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js
var name79, shader79;
var init_pbrDirectLightingFalloffFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFalloffFunctions.js"() {
    init_shaderStore();
    name79 = "pbrDirectLightingFalloffFunctions";
    shader79 = `float computeDistanceLightFalloff_Standard(vec3 lightOffset,float range)
{return max(0.,1.0-length(lightOffset)/range);}
float computeDistanceLightFalloff_Physical(float lightDistanceSquared)
{return 1.0/maxEps(lightDistanceSquared);}
float computeDistanceLightFalloff_GLTF(float lightDistanceSquared,float inverseSquaredRange)
{float lightDistanceFalloff=1.0/maxEps(lightDistanceSquared);float factor=lightDistanceSquared*inverseSquaredRange;float attenuation=saturate(1.0-factor*factor);attenuation*=attenuation;lightDistanceFalloff*=attenuation;return lightDistanceFalloff;}
float computeDistanceLightFalloff(vec3 lightOffset,float lightDistanceSquared,float range,float inverseSquaredRange)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDistanceLightFalloff_Physical(lightDistanceSquared);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDistanceLightFalloff_GLTF(lightDistanceSquared,inverseSquaredRange);
#else
return computeDistanceLightFalloff_Standard(lightOffset,range);
#endif
}
float computeDirectionalLightFalloff_Standard(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent)
{float falloff=0.0;float cosAngle=maxEps(dot(-lightDirection,directionToLightCenterW));if (cosAngle>=cosHalfAngle)
{falloff=max(0.,pow(cosAngle,exponent));}
return falloff;}
float computeDirectionalLightFalloff_Physical(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle)
{const float kMinusLog2ConeAngleIntensityRatio=6.64385618977; 
float concentrationKappa=kMinusLog2ConeAngleIntensityRatio/(1.0-cosHalfAngle);vec4 lightDirectionSpreadSG=vec4(-lightDirection*concentrationKappa,-concentrationKappa);float falloff=exp2(dot(vec4(directionToLightCenterW,1.0),lightDirectionSpreadSG));return falloff;}
float computeDirectionalLightFalloff_GLTF(vec3 lightDirection,vec3 directionToLightCenterW,float lightAngleScale,float lightAngleOffset)
{float cd=dot(-lightDirection,directionToLightCenterW);float falloff=saturate(cd*lightAngleScale+lightAngleOffset);falloff*=falloff;return falloff;}
float computeDirectionalLightFalloff(vec3 lightDirection,vec3 directionToLightCenterW,float cosHalfAngle,float exponent,float lightAngleScale,float lightAngleOffset)
{
#ifdef USEPHYSICALLIGHTFALLOFF
return computeDirectionalLightFalloff_Physical(lightDirection,directionToLightCenterW,cosHalfAngle);
#elif defined(USEGLTFLIGHTFALLOFF)
return computeDirectionalLightFalloff_GLTF(lightDirection,directionToLightCenterW,lightAngleScale,lightAngleOffset);
#else
return computeDirectionalLightFalloff_Standard(lightDirection,directionToLightCenterW,cosHalfAngle,exponent);
#endif
}`;
    ShaderStore.IncludesShadersStore[name79] = shader79;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js
var name80, shader80;
var init_pbrBRDFFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBRDFFunctions.js"() {
    init_shaderStore();
    name80 = "pbrBRDFFunctions";
    shader80 = `#define FRESNEL_MAXIMUM_ON_ROUGH 0.25
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 getEnergyConservationFactor(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {return 1.0+specularEnvironmentR0*(1.0/environmentBrdf.y-1.0);}
#endif
#ifdef ENVIRONMENTBRDF
vec3 getBRDFLookup(float NdotV,float perceptualRoughness) {vec2 UV=vec2(NdotV,perceptualRoughness);vec4 brdfLookup=texture2D(environmentBrdfSampler,UV);
#ifdef ENVIRONMENTBRDF_RGBD
brdfLookup.rgb=fromRGBD(brdfLookup.rgba);
#endif
return brdfLookup.rgb;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 specularEnvironmentR90,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=(specularEnvironmentR90-specularEnvironmentR0)*environmentBrdf.x+specularEnvironmentR0*environmentBrdf.y;
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+specularEnvironmentR90*environmentBrdf.y;
#endif
return reflectance;}
vec3 getReflectanceFromBRDFLookup(const vec3 specularEnvironmentR0,const vec3 environmentBrdf) {
#ifdef BRDF_V_HEIGHT_CORRELATED
vec3 reflectance=mix(environmentBrdf.xxx,environmentBrdf.yyy,specularEnvironmentR0);
#else
vec3 reflectance=specularEnvironmentR0*environmentBrdf.x+environmentBrdf.y;
#endif
return reflectance;}
#endif
/* NOT USED
#if defined(SHEEN) && defined(SHEEN_SOFTER)
float getBRDFLookupCharlieSheen(float NdotV,float perceptualRoughness)
{float c=1.0-NdotV;float c3=c*c*c;return 0.65584461*c3+1.0/(4.16526551+exp(-7.97291361*perceptualRoughness+6.33516894));}
#endif
*/
#if !defined(ENVIRONMENTBRDF) || defined(REFLECTIONMAP_SKYBOX) || defined(ALPHAFRESNEL)
vec3 getReflectanceFromAnalyticalBRDFLookup_Jones(float VdotN,vec3 reflectance0,vec3 reflectance90,float smoothness)
{float weight=mix(FRESNEL_MAXIMUM_ON_ROUGH,1.0,smoothness);return reflectance0+weight*(reflectance90-reflectance0)*pow5(saturate(1.0-VdotN));}
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
/**
* The sheen BRDF not containing F can be easily stored in the blue channel of the BRDF texture.
* The blue channel contains DCharlie*VAshikhmin*NdotL as a lokkup table
*/
vec3 getSheenReflectanceFromBRDFLookup(const vec3 reflectance0,const vec3 environmentBrdf) {vec3 sheenEnvironmentReflectance=reflectance0*environmentBrdf.b;return sheenEnvironmentReflectance;}
#endif
vec3 fresnelSchlickGGX(float VdotH,vec3 reflectance0,vec3 reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
float fresnelSchlickGGX(float VdotH,float reflectance0,float reflectance90)
{return reflectance0+(reflectance90-reflectance0)*pow5(1.0-VdotH);}
#ifdef CLEARCOAT
vec3 getR0RemappedForClearCoat(vec3 f0) {
#ifdef CLEARCOAT_DEFAULTIOR
#ifdef MOBILE
return saturate(f0*(f0*0.526868+0.529324)-0.0482256);
#else
return saturate(f0*(f0*(0.941892-0.263008*f0)+0.346479)-0.0285998);
#endif
#else
vec3 s=sqrt(f0);vec3 t=(vClearCoatRefractionParams.z+vClearCoatRefractionParams.w*s)/(vClearCoatRefractionParams.w+vClearCoatRefractionParams.z*s);return square(t);
#endif
}
#endif
#ifdef IRIDESCENCE
const mat3 XYZ_TO_REC709=mat3(
3.2404542,-0.9692660, 0.0556434,
-1.5371385, 1.8760108,-0.2040259,
-0.4985314, 0.0415560, 1.0572252
);vec3 getIORTfromAirToSurfaceR0(vec3 f0) {vec3 sqrtF0=sqrt(f0);return (1.+sqrtF0)/(1.-sqrtF0);}
vec3 getR0fromIORs(vec3 iorT,float iorI) {return square((iorT-vec3(iorI))/(iorT+vec3(iorI)));}
float getR0fromIORs(float iorT,float iorI) {return square((iorT-iorI)/(iorT+iorI));}
vec3 evalSensitivity(float opd,vec3 shift) {float phase=2.0*PI*opd*1.0e-9;const vec3 val=vec3(5.4856e-13,4.4201e-13,5.2481e-13);const vec3 pos=vec3(1.6810e+06,1.7953e+06,2.2084e+06);const vec3 var=vec3(4.3278e+09,9.3046e+09,6.6121e+09);vec3 xyz=val*sqrt(2.0*PI*var)*cos(pos*phase+shift)*exp(-square(phase)*var);xyz.x+=9.7470e-14*sqrt(2.0*PI*4.5282e+09)*cos(2.2399e+06*phase+shift[0])*exp(-4.5282e+09*square(phase));xyz/=1.0685e-7;vec3 srgb=XYZ_TO_REC709*xyz;return srgb;}
vec3 evalIridescence(float outsideIOR,float eta2,float cosTheta1,float thinFilmThickness,vec3 baseF0) {vec3 I=vec3(1.0);float iridescenceIOR=mix(outsideIOR,eta2,smoothstep(0.0,0.03,thinFilmThickness));float sinTheta2Sq=square(outsideIOR/iridescenceIOR)*(1.0-square(cosTheta1));float cosTheta2Sq=1.0-sinTheta2Sq;if (cosTheta2Sq<0.0) {return I;}
float cosTheta2=sqrt(cosTheta2Sq);float R0=getR0fromIORs(iridescenceIOR,outsideIOR);float R12=fresnelSchlickGGX(cosTheta1,R0,1.);float R21=R12;float T121=1.0-R12;float phi12=0.0;if (iridescenceIOR<outsideIOR) phi12=PI;float phi21=PI-phi12;vec3 baseIOR=getIORTfromAirToSurfaceR0(clamp(baseF0,0.0,0.9999)); 
vec3 R1=getR0fromIORs(baseIOR,iridescenceIOR);vec3 R23=fresnelSchlickGGX(cosTheta2,R1,vec3(1.));vec3 phi23=vec3(0.0);if (baseIOR[0]<iridescenceIOR) phi23[0]=PI;if (baseIOR[1]<iridescenceIOR) phi23[1]=PI;if (baseIOR[2]<iridescenceIOR) phi23[2]=PI;float opd=2.0*iridescenceIOR*thinFilmThickness*cosTheta2;vec3 phi=vec3(phi21)+phi23;vec3 R123=clamp(R12*R23,1e-5,0.9999);vec3 r123=sqrt(R123);vec3 Rs=square(T121)*R23/(vec3(1.0)-R123);vec3 C0=R12+Rs;I=C0;vec3 Cm=Rs-T121;for (int m=1; m<=2; ++m)
{Cm*=r123;vec3 Sm=2.0*evalSensitivity(float(m)*opd,float(m)*phi);I+=Cm*Sm;}
return max(I,vec3(0.0));}
#endif
float normalDistributionFunction_TrowbridgeReitzGGX(float NdotH,float alphaG)
{float a2=square(alphaG);float d=NdotH*NdotH*(a2-1.0)+1.0;return a2/(PI*d*d);}
#ifdef SHEEN
float normalDistributionFunction_CharlieSheen(float NdotH,float alphaG)
{float invR=1./alphaG;float cos2h=NdotH*NdotH;float sin2h=1.-cos2h;return (2.+invR)*pow(sin2h,invR*.5)/(2.*PI);}
#endif
#ifdef ANISOTROPIC
float normalDistributionFunction_BurleyGGX_Anisotropic(float NdotH,float TdotH,float BdotH,const vec2 alphaTB) {float a2=alphaTB.x*alphaTB.y;vec3 v=vec3(alphaTB.y*TdotH,alphaTB.x *BdotH,a2*NdotH);float v2=dot(v,v);float w2=a2/v2;return a2*w2*w2*RECIPROCAL_PI;}
#endif
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility_GGXCorrelated(float NdotL,float NdotV,float alphaG) {
#ifdef MOBILE
float GGXV=NdotL*(NdotV*(1.0-alphaG)+alphaG);float GGXL=NdotV*(NdotL*(1.0-alphaG)+alphaG);return 0.5/(GGXV+GGXL);
#else
float a2=alphaG*alphaG;float GGXV=NdotL*sqrt(NdotV*(NdotV-a2*NdotV)+a2);float GGXL=NdotV*sqrt(NdotL*(NdotL-a2*NdotL)+a2);return 0.5/(GGXV+GGXL);
#endif
}
#else
float smithVisibilityG1_TrowbridgeReitzGGXFast(float dot,float alphaG)
{
#ifdef MOBILE
return 1.0/(dot+alphaG+(1.0-alphaG)*dot ));
#else
float alphaSquared=alphaG*alphaG;return 1.0/(dot+sqrt(alphaSquared+(1.0-alphaSquared)*dot*dot));
#endif
}
float smithVisibility_TrowbridgeReitzGGXFast(float NdotL,float NdotV,float alphaG)
{float visibility=smithVisibilityG1_TrowbridgeReitzGGXFast(NdotL,alphaG)*smithVisibilityG1_TrowbridgeReitzGGXFast(NdotV,alphaG);return visibility;}
#endif
#ifdef ANISOTROPIC
float smithVisibility_GGXCorrelated_Anisotropic(float NdotL,float NdotV,float TdotV,float BdotV,float TdotL,float BdotL,const vec2 alphaTB) {float lambdaV=NdotL*length(vec3(alphaTB.x*TdotV,alphaTB.y*BdotV,NdotV));float lambdaL=NdotV*length(vec3(alphaTB.x*TdotL,alphaTB.y*BdotL,NdotL));float v=0.5/(lambdaV+lambdaL);return v;}
#endif
#ifdef CLEARCOAT
float visibility_Kelemen(float VdotH) {return 0.25/(VdotH*VdotH); }
#endif
#ifdef SHEEN
float visibility_Ashikhmin(float NdotL,float NdotV)
{return 1./(4.*(NdotL+NdotV-NdotL*NdotV));}
/* NOT USED
#ifdef SHEEN_SOFTER
float l(float x,float alphaG)
{float oneMinusAlphaSq=(1.0-alphaG)*(1.0-alphaG);float a=mix(21.5473,25.3245,oneMinusAlphaSq);float b=mix(3.82987,3.32435,oneMinusAlphaSq);float c=mix(0.19823,0.16801,oneMinusAlphaSq);float d=mix(-1.97760,-1.27393,oneMinusAlphaSq);float e=mix(-4.32054,-4.85967,oneMinusAlphaSq);return a/(1.0+b*pow(x,c))+d*x+e;}
float lambdaSheen(float cosTheta,float alphaG)
{return abs(cosTheta)<0.5 ? exp(l(cosTheta,alphaG)) : exp(2.0*l(0.5,alphaG)-l(1.0-cosTheta,alphaG));}
float visibility_CharlieSheen(float NdotL,float NdotV,float alphaG)
{float G=1.0/(1.0+lambdaSheen(NdotV,alphaG)+lambdaSheen(NdotL,alphaG));return G/(4.0*NdotV*NdotL);}
#endif
*/
#endif
float diffuseBRDF_Burley(float NdotL,float NdotV,float VdotH,float roughness) {float diffuseFresnelNV=pow5(saturateEps(1.0-NdotL));float diffuseFresnelNL=pow5(saturateEps(1.0-NdotV));float diffuseFresnel90=0.5+2.0*VdotH*VdotH*roughness;float fresnel =
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNL) *
(1.0+(diffuseFresnel90-1.0)*diffuseFresnelNV);return fresnel/PI;}
#ifdef SS_TRANSLUCENCY
vec3 transmittanceBRDF_Burley(const vec3 tintColor,const vec3 diffusionDistance,float thickness) {vec3 S=1./maxEps(diffusionDistance);vec3 temp=exp((-0.333333333*thickness)*S);return tintColor.rgb*0.25*(temp*temp*temp+3.0*temp);}
float computeWrappedDiffuseNdotL(float NdotL,float w) {float t=1.0+w;float invt2=1.0/square(t);return saturate((NdotL+w)*invt2);}
#endif
`;
    ShaderStore.IncludesShadersStore[name80] = shader80;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js
var name81, shader81;
var init_hdrFilteringFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/hdrFilteringFunctions.js"() {
    init_shaderStore();
    name81 = "hdrFilteringFunctions";
    shader81 = `#ifdef NUM_SAMPLES
#if NUM_SAMPLES>0
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
float radicalInverse_VdC(uint bits) 
{bits=(bits<<16u) | (bits>>16u);bits=((bits & 0x55555555u)<<1u) | ((bits & 0xAAAAAAAAu)>>1u);bits=((bits & 0x33333333u)<<2u) | ((bits & 0xCCCCCCCCu)>>2u);bits=((bits & 0x0F0F0F0Fu)<<4u) | ((bits & 0xF0F0F0F0u)>>4u);bits=((bits & 0x00FF00FFu)<<8u) | ((bits & 0xFF00FF00u)>>8u);return float(bits)*2.3283064365386963e-10; }
vec2 hammersley(uint i,uint N)
{return vec2(float(i)/float(N),radicalInverse_VdC(i));}
#else
float vanDerCorpus(int n,int base)
{float invBase=1.0/float(base);float denom =1.0;float result =0.0;for(int i=0; i<32; ++i)
{if(n>0)
{denom =mod(float(n),2.0);result+=denom*invBase;invBase=invBase/2.0;n =int(float(n)/2.0);}}
return result;}
vec2 hammersley(int i,int N)
{return vec2(float(i)/float(N),vanDerCorpus(i,2));}
#endif
float log4(float x) {return log2(x)/2.;}
const float NUM_SAMPLES_FLOAT=float(NUM_SAMPLES);const float NUM_SAMPLES_FLOAT_INVERSED=1./NUM_SAMPLES_FLOAT;const float K=4.;
#define inline
vec3 irradiance(samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);vec3 result=vec3(0.0);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 Ls=hemisphereCosSample(Xi);Ls=normalize(Ls);vec3 Ns=vec3(0.,0.,1.);float NoL=dot(Ns,Ls);if (NoL>0.) {float pdf_inversed=PI/NoL;float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(l,0.0,maxLevel);vec3 c=textureCubeLodEXT(inputTexture,tbn*Ls,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c;}}
result=result*NUM_SAMPLES_FLOAT_INVERSED;return result;}
#define inline
vec3 radiance(float alphaG,samplerCube inputTexture,vec3 inputN,vec2 filteringInfo)
{vec3 n=normalize(inputN);if (alphaG==0.) {vec3 c=textureCube(inputTexture,n).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
return c;} else {vec3 result=vec3(0.);vec3 tangent=abs(n.z)<0.999 ? vec3(0.,0.,1.) : vec3(1.,0.,0.);tangent=normalize(cross(tangent,n));vec3 bitangent=cross(n,tangent);mat3 tbn=mat3(tangent,bitangent,n);float maxLevel=filteringInfo.y;float dim0=filteringInfo.x;float omegaP=(4.*PI)/(6.*dim0*dim0);float weight=0.;
#if defined(WEBGL2) || defined(WEBGPU) || defined(NATIVE)
for(uint i=0u; i<NUM_SAMPLES; ++i)
#else
for(int i=0; i<NUM_SAMPLES; ++i)
#endif
{vec2 Xi=hammersley(i,NUM_SAMPLES);vec3 H=hemisphereImportanceSampleDggx(Xi,alphaG);float NoV=1.;float NoH=H.z;float NoH2=H.z*H.z;float NoL=2.*NoH2-1.;vec3 L=vec3(2.*NoH*H.x,2.*NoH*H.y,NoL);L=normalize(L);if (NoL>0.) {float pdf_inversed=4./normalDistributionFunction_TrowbridgeReitzGGX(NoH,alphaG);float omegaS=NUM_SAMPLES_FLOAT_INVERSED*pdf_inversed;float l=log4(omegaS)-log4(omegaP)+log4(K);float mipLevel=clamp(float(l),0.0,maxLevel);weight+=NoL;vec3 c=textureCubeLodEXT(inputTexture,tbn*L,mipLevel).rgb;
#ifdef GAMMA_INPUT
c=toLinearSpace(c);
#endif
result+=c*NoL;}}
result=result/weight;return result;}}
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name81] = shader81;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js
var name82, shader82;
var init_pbrDirectLightingFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDirectLightingFunctions.js"() {
    init_shaderStore();
    name82 = "pbrDirectLightingFunctions";
    shader82 = `#define CLEARCOATREFLECTANCE90 1.0
struct lightingInfo
{vec3 diffuse;
#ifdef SPECULARTERM
vec3 specular;
#endif
#ifdef CLEARCOAT
vec4 clearCoat;
#endif
#ifdef SHEEN
vec3 sheen;
#endif
};float adjustRoughnessFromLightProperties(float roughness,float lightRadius,float lightDistance) {
#if defined(USEPHYSICALLIGHTFALLOFF) || defined(USEGLTFLIGHTFALLOFF)
float lightRoughness=lightRadius/lightDistance;float totalRoughness=saturate(lightRoughness+roughness);return totalRoughness;
#else
return roughness;
#endif
}
vec3 computeHemisphericDiffuseLighting(preLightingInfo info,vec3 lightColor,vec3 groundColor) {return mix(groundColor,lightColor,info.NdotL);}
vec3 computeDiffuseLighting(preLightingInfo info,vec3 lightColor) {float diffuseTerm=diffuseBRDF_Burley(info.NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*info.attenuation*info.NdotL*lightColor;}
#define inline
vec3 computeProjectionTextureDiffuseLighting(sampler2D projectionLightSampler,mat4 textureProjectionMatrix){vec4 strq=textureProjectionMatrix*vec4(vPositionW,1.0);strq/=strq.w;vec3 textureColor=texture2D(projectionLightSampler,strq.xy).rgb;return toLinearSpace(textureColor);}
#ifdef SS_TRANSLUCENCY
vec3 computeDiffuseAndTransmittedLighting(preLightingInfo info,vec3 lightColor,vec3 transmittance) {float NdotL=absEps(info.NdotLUnclamped);float wrapNdotL=computeWrappedDiffuseNdotL(NdotL,0.02);float trAdapt=step(0.,info.NdotLUnclamped);vec3 transmittanceNdotL=mix(transmittance*wrapNdotL,vec3(wrapNdotL),trAdapt);float diffuseTerm=diffuseBRDF_Burley(NdotL,info.NdotV,info.VdotH,info.roughness);return diffuseTerm*transmittanceNdotL*info.attenuation*lightColor;}
#endif
#ifdef SPECULARTERM
vec3 computeSpecularLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NdotH,alphaG);
#ifdef BRDF_V_HEIGHT_CORRELATED
float smithVisibility=smithVisibility_GGXCorrelated(info.NdotL,info.NdotV,alphaG);
#else
float smithVisibility=smithVisibility_TrowbridgeReitzGGXFast(info.NdotL,info.NdotV,alphaG);
#endif
vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef ANISOTROPIC
vec3 computeAnisotropicSpecularLighting(preLightingInfo info,vec3 V,vec3 N,vec3 T,vec3 B,float anisotropy,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float TdotH=dot(T,info.H);float BdotH=dot(B,info.H);float TdotV=dot(T,V);float BdotV=dot(B,V);float TdotL=dot(T,info.L);float BdotL=dot(B,info.L);float alphaG=convertRoughnessToAverageSlope(info.roughness);vec2 alphaTB=getAnisotropicRoughness(alphaG,anisotropy);alphaTB=max(alphaTB,square(geometricRoughnessFactor));vec3 fresnel=fresnelSchlickGGX(info.VdotH,reflectance0,reflectance90);
#ifdef IRIDESCENCE
fresnel=mix(fresnel,reflectance0,info.iridescenceIntensity);
#endif
float distribution=normalDistributionFunction_BurleyGGX_Anisotropic(NdotH,TdotH,BdotH,alphaTB);float smithVisibility=smithVisibility_GGXCorrelated_Anisotropic(info.NdotL,info.NdotV,TdotV,BdotV,TdotL,BdotL,alphaTB);vec3 specTerm=fresnel*distribution*smithVisibility;return specTerm*info.attenuation*info.NdotL*lightColor;}
#endif
#ifdef CLEARCOAT
vec4 computeClearCoatLighting(preLightingInfo info,vec3 Ncc,float geometricRoughnessFactor,float clearCoatIntensity,vec3 lightColor) {float NccdotL=saturateEps(dot(Ncc,info.L));float NccdotH=saturateEps(dot(Ncc,info.H));float clearCoatRoughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(clearCoatRoughness);float fresnel=fresnelSchlickGGX(info.VdotH,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnel*=clearCoatIntensity;float distribution=normalDistributionFunction_TrowbridgeReitzGGX(NccdotH,alphaG);float kelemenVisibility=visibility_Kelemen(info.VdotH);float clearCoatTerm=fresnel*distribution*kelemenVisibility;return vec4(
clearCoatTerm*info.attenuation*NccdotL*lightColor,
1.0-fresnel
);}
vec3 computeClearCoatLightingAbsorption(float NdotVRefract,vec3 L,vec3 Ncc,vec3 clearCoatColor,float clearCoatThickness,float clearCoatIntensity) {vec3 LRefract=-refract(L,Ncc,vClearCoatRefractionParams.y);float NdotLRefract=saturateEps(dot(Ncc,LRefract));vec3 absorption=computeClearCoatAbsorption(NdotVRefract,NdotLRefract,clearCoatColor,clearCoatThickness,clearCoatIntensity);return absorption;}
#endif
#ifdef SHEEN
vec3 computeSheenLighting(preLightingInfo info,vec3 N,vec3 reflectance0,vec3 reflectance90,float geometricRoughnessFactor,vec3 lightColor) {float NdotH=saturateEps(dot(N,info.H));float roughness=max(info.roughness,geometricRoughnessFactor);float alphaG=convertRoughnessToAverageSlope(roughness);float fresnel=1.;float distribution=normalDistributionFunction_CharlieSheen(NdotH,alphaG);/*#ifdef SHEEN_SOFTER
float visibility=visibility_CharlieSheen(info.NdotL,info.NdotV,alphaG);
#else */
float visibility=visibility_Ashikhmin(info.NdotL,info.NdotV);/* #endif */
float sheenTerm=fresnel*distribution*visibility;return sheenTerm*info.attenuation*info.NdotL*lightColor;}
#endif
`;
    ShaderStore.IncludesShadersStore[name82] = shader82;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js
var name83, shader83;
var init_pbrIBLFunctions = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrIBLFunctions.js"() {
    init_shaderStore();
    name83 = "pbrIBLFunctions";
    shader83 = `#if defined(REFLECTION) || defined(SS_REFRACTION)
float getLodFromAlphaG(float cubeMapDimensionPixels,float microsurfaceAverageSlope) {float microsurfaceAverageSlopeTexels=cubeMapDimensionPixels*microsurfaceAverageSlope;float lod=log2(microsurfaceAverageSlopeTexels);return lod;}
float getLinearLodFromRoughness(float cubeMapDimensionPixels,float roughness) {float lod=log2(cubeMapDimensionPixels)*roughness;return lod;}
#endif
#if defined(ENVIRONMENTBRDF) && defined(RADIANCEOCCLUSION)
float environmentRadianceOcclusion(float ambientOcclusion,float NdotVUnclamped) {float temp=NdotVUnclamped+ambientOcclusion;return saturate(square(temp)-1.0+ambientOcclusion);}
#endif
#if defined(ENVIRONMENTBRDF) && defined(HORIZONOCCLUSION)
float environmentHorizonOcclusion(vec3 view,vec3 normal,vec3 geometricNormal) {vec3 reflection=reflect(view,normal);float temp=saturate(1.0+1.1*dot(reflection,geometricNormal));return square(temp);}
#endif
#if defined(LODINREFLECTIONALPHA) || defined(SS_LODINREFRACTIONALPHA)
#define UNPACK_LOD(x) (1.0-x)*255.0
float getLodFromAlphaG(float cubeMapDimensionPixels,float alphaG,float NdotV) {float microsurfaceAverageSlope=alphaG;microsurfaceAverageSlope*=sqrt(abs(NdotV));return getLodFromAlphaG(cubeMapDimensionPixels,microsurfaceAverageSlope);}
#endif
`;
    ShaderStore.IncludesShadersStore[name83] = shader83;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js
var name84, shader84;
var init_pbrBlockAlbedoOpacity = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlbedoOpacity.js"() {
    init_shaderStore();
    init_decalFragment();
    name84 = "pbrBlockAlbedoOpacity";
    shader84 = `struct albedoOpacityOutParams
{vec3 surfaceAlbedo;float alpha;};
#define pbr_inline
void albedoOpacityBlock(
in vec4 vAlbedoColor,
#ifdef ALBEDO
in vec4 albedoTexture,
in vec2 albedoInfos,
#endif
#ifdef OPACITY
in vec4 opacityMap,
in vec2 vOpacityInfos,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
#ifdef DECAL
in vec4 decalColor,
in vec4 vDecalInfos,
#endif
out albedoOpacityOutParams outParams
)
{vec3 surfaceAlbedo=vAlbedoColor.rgb;float alpha=vAlbedoColor.a;
#ifdef ALBEDO
#if defined(ALPHAFROMALBEDO) || defined(ALPHATEST)
alpha*=albedoTexture.a;
#endif
#ifdef GAMMAALBEDO
surfaceAlbedo*=toLinearSpace(albedoTexture.rgb);
#else
surfaceAlbedo*=albedoTexture.rgb;
#endif
surfaceAlbedo*=albedoInfos.y;
#endif
#ifndef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
surfaceAlbedo*=vColor.rgb;
#endif
#ifdef DETAIL
float detailAlbedo=2.0*mix(0.5,detailColor.r,vDetailInfos.y);surfaceAlbedo.rgb=surfaceAlbedo.rgb*detailAlbedo*detailAlbedo; 
#endif
#ifdef DECAL_AFTER_DETAIL
#include<decalFragment>
#endif
#define CUSTOM_FRAGMENT_UPDATE_ALBEDO
#ifdef OPACITY
#ifdef OPACITYRGB
alpha=getLuminance(opacityMap.rgb);
#else
alpha*=opacityMap.a;
#endif
alpha*=vOpacityInfos.y;
#endif
#if defined(VERTEXALPHA) || defined(INSTANCESCOLOR) && defined(INSTANCES)
alpha*=vColor.a;
#endif
#if !defined(SS_LINKREFRACTIONTOTRANSPARENCY) && !defined(ALPHAFRESNEL)
#ifdef ALPHATEST 
#if DEBUGMODE != 88
if (alpha<ALPHATESTVALUE)
discard;
#endif
#ifndef ALPHABLEND
alpha=1.0;
#endif
#endif
#endif
outParams.surfaceAlbedo=surfaceAlbedo;outParams.alpha=alpha;}
`;
    ShaderStore.IncludesShadersStore[name84] = shader84;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js
var name85, shader85;
var init_pbrBlockReflectivity = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectivity.js"() {
    init_shaderStore();
    name85 = "pbrBlockReflectivity";
    shader85 = `struct reflectivityOutParams
{float microSurface;float roughness;vec3 surfaceReflectivityColor;
#ifdef METALLICWORKFLOW
vec3 surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
vec3 ambientOcclusionColor;
#endif
#if DEBUGMODE>0
#ifdef METALLICWORKFLOW
vec2 metallicRoughness;
#ifdef REFLECTIVITY
vec4 surfaceMetallicColorMap;
#endif
#ifndef FROSTBITE_REFLECTANCE
vec3 metallicF0;
#endif
#else
#ifdef REFLECTIVITY
vec4 surfaceReflectivityColorMap;
#endif
#endif
#endif
};
#define pbr_inline
void reflectivityBlock(
in vec4 vReflectivityColor,
#ifdef METALLICWORKFLOW
in vec3 surfaceAlbedo,
in vec4 metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
in vec3 reflectivityInfos,
in vec4 surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
in vec3 ambientOcclusionColorIn,
#endif
#ifdef MICROSURFACEMAP
in vec4 microSurfaceTexel,
#endif
#ifdef DETAIL
in vec4 detailColor,
in vec4 vDetailInfos,
#endif
out reflectivityOutParams outParams
)
{float microSurface=vReflectivityColor.a;vec3 surfaceReflectivityColor=vReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec2 metallicRoughness=surfaceReflectivityColor.rg;
#ifdef REFLECTIVITY
#if DEBUGMODE>0
outParams.surfaceMetallicColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef AOSTOREINMETALMAPRED
vec3 aoStoreInMetalMap=vec3(surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r,surfaceMetallicOrReflectivityColorMap.r);outParams.ambientOcclusionColor=mix(ambientOcclusionColorIn,aoStoreInMetalMap,reflectivityInfos.z);
#endif
#ifdef METALLNESSSTOREINMETALMAPBLUE
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.b;
#else
metallicRoughness.r*=surfaceMetallicOrReflectivityColorMap.r;
#endif
#ifdef ROUGHNESSSTOREINMETALMAPALPHA
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.a;
#else
#ifdef ROUGHNESSSTOREINMETALMAPGREEN
metallicRoughness.g*=surfaceMetallicOrReflectivityColorMap.g;
#endif
#endif
#endif
#ifdef DETAIL
float detailRoughness=mix(0.5,detailColor.b,vDetailInfos.w);float loLerp=mix(0.,metallicRoughness.g,detailRoughness*2.);float hiLerp=mix(metallicRoughness.g,1.,(detailRoughness-0.5)*2.);metallicRoughness.g=mix(loLerp,hiLerp,step(detailRoughness,0.5));
#endif
#ifdef MICROSURFACEMAP
metallicRoughness.g*=microSurfaceTexel.r;
#endif
#if DEBUGMODE>0
outParams.metallicRoughness=metallicRoughness;
#endif
#define CUSTOM_FRAGMENT_UPDATE_METALLICROUGHNESS
microSurface=1.0-metallicRoughness.g;vec3 baseColor=surfaceAlbedo;
#ifdef FROSTBITE_REFLECTANCE
outParams.surfaceAlbedo=baseColor.rgb*(1.0-metallicRoughness.r);surfaceReflectivityColor=mix(0.16*reflectance*reflectance,baseColor,metallicRoughness.r);
#else
vec3 metallicF0=metallicReflectanceFactors.rgb;
#if DEBUGMODE>0
outParams.metallicF0=metallicF0;
#endif
outParams.surfaceAlbedo=mix(baseColor.rgb*(1.0-metallicF0),vec3(0.,0.,0.),metallicRoughness.r);surfaceReflectivityColor=mix(metallicF0,baseColor,metallicRoughness.r);
#endif
#else
#ifdef REFLECTIVITY
surfaceReflectivityColor*=surfaceMetallicOrReflectivityColorMap.rgb;
#if DEBUGMODE>0
outParams.surfaceReflectivityColorMap=surfaceMetallicOrReflectivityColorMap;
#endif
#ifdef MICROSURFACEFROMREFLECTIVITYMAP
microSurface*=surfaceMetallicOrReflectivityColorMap.a;microSurface*=reflectivityInfos.z;
#else
#ifdef MICROSURFACEAUTOMATIC
microSurface*=computeDefaultMicroSurface(microSurface,surfaceReflectivityColor);
#endif
#ifdef MICROSURFACEMAP
microSurface*=microSurfaceTexel.r;
#endif
#define CUSTOM_FRAGMENT_UPDATE_MICROSURFACE
#endif
#endif
#endif
microSurface=saturate(microSurface);float roughness=1.-microSurface;outParams.microSurface=microSurface;outParams.roughness=roughness;outParams.surfaceReflectivityColor=surfaceReflectivityColor;}
`;
    ShaderStore.IncludesShadersStore[name85] = shader85;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js
var name86, shader86;
var init_pbrBlockAmbientOcclusion = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAmbientOcclusion.js"() {
    init_shaderStore();
    name86 = "pbrBlockAmbientOcclusion";
    shader86 = `struct ambientOcclusionOutParams
{vec3 ambientOcclusionColor;
#if DEBUGMODE>0 && defined(AMBIENT)
vec3 ambientOcclusionColorMap;
#endif
};
#define pbr_inline
void ambientOcclusionBlock(
#ifdef AMBIENT
in vec3 ambientOcclusionColorMap_,
in vec4 vAmbientInfos,
#endif
out ambientOcclusionOutParams outParams
)
{vec3 ambientOcclusionColor=vec3(1.,1.,1.);
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=ambientOcclusionColorMap_*vAmbientInfos.y;
#ifdef AMBIENTINGRAYSCALE
ambientOcclusionColorMap=vec3(ambientOcclusionColorMap.r,ambientOcclusionColorMap.r,ambientOcclusionColorMap.r);
#endif
ambientOcclusionColor=mix(ambientOcclusionColor,ambientOcclusionColorMap,vAmbientInfos.z);
#if DEBUGMODE>0
outParams.ambientOcclusionColorMap=ambientOcclusionColorMap;
#endif
#endif
outParams.ambientOcclusionColor=ambientOcclusionColor;}
`;
    ShaderStore.IncludesShadersStore[name86] = shader86;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js
var name87, shader87;
var init_pbrBlockAlphaFresnel = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAlphaFresnel.js"() {
    init_shaderStore();
    name87 = "pbrBlockAlphaFresnel";
    shader87 = `#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
struct alphaFresnelOutParams
{float alpha;};
#define pbr_inline
void alphaFresnelBlock(
in vec3 normalW,
in vec3 viewDirectionW,
in float alpha,
in float microSurface,
out alphaFresnelOutParams outParams
)
{float opacityPerceptual=alpha;
#ifdef LINEARALPHAFRESNEL
float opacity0=opacityPerceptual;
#else
float opacity0=opacityPerceptual*opacityPerceptual;
#endif
float opacity90=fresnelGrazingReflectance(opacity0);vec3 normalForward=faceforward(normalW,-viewDirectionW,normalW);outParams.alpha=getReflectanceFromAnalyticalBRDFLookup_Jones(saturate(dot(viewDirectionW,normalForward)),vec3(opacity0),vec3(opacity90),sqrt(microSurface)).x;
#ifdef ALPHATEST
if (outParams.alpha<ALPHATESTVALUE)
discard;
#ifndef ALPHABLEND
outParams.alpha=1.0;
#endif
#endif
}
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name87] = shader87;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js
var name88, shader88;
var init_pbrBlockAnisotropic = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockAnisotropic.js"() {
    init_shaderStore();
    name88 = "pbrBlockAnisotropic";
    shader88 = `#ifdef ANISOTROPIC
struct anisotropicOutParams
{float anisotropy;vec3 anisotropicTangent;vec3 anisotropicBitangent;vec3 anisotropicNormal;
#if DEBUGMODE>0 && defined(ANISOTROPIC_TEXTURE)
vec3 anisotropyMapData;
#endif
};
#define pbr_inline
void anisotropicBlock(
in vec3 vAnisotropy,
in float roughness,
#ifdef ANISOTROPIC_TEXTURE
in vec3 anisotropyMapData,
#endif
in mat3 TBN,
in vec3 normalW,
in vec3 viewDirectionW,
out anisotropicOutParams outParams
)
{float anisotropy=vAnisotropy.b;vec3 anisotropyDirection=vec3(vAnisotropy.xy,0.);
#ifdef ANISOTROPIC_TEXTURE
anisotropy*=anisotropyMapData.b;
#if DEBUGMODE>0
outParams.anisotropyMapData=anisotropyMapData;
#endif
anisotropyMapData.rg=anisotropyMapData.rg*2.0-1.0;
#ifdef ANISOTROPIC_LEGACY
anisotropyDirection.rg*=anisotropyMapData.rg;
#else
anisotropyDirection.xy=mat2(anisotropyDirection.x,anisotropyDirection.y,-anisotropyDirection.y,anisotropyDirection.x)*normalize(anisotropyMapData.rg);
#endif
#endif
mat3 anisoTBN=mat3(normalize(TBN[0]),normalize(TBN[1]),normalize(TBN[2]));vec3 anisotropicTangent=normalize(anisoTBN*anisotropyDirection);vec3 anisotropicBitangent=normalize(cross(anisoTBN[2],anisotropicTangent));outParams.anisotropy=anisotropy;outParams.anisotropicTangent=anisotropicTangent;outParams.anisotropicBitangent=anisotropicBitangent;outParams.anisotropicNormal=getAnisotropicBentNormals(anisotropicTangent,anisotropicBitangent,normalW,viewDirectionW,anisotropy,roughness);}
#endif
`;
    ShaderStore.IncludesShadersStore[name88] = shader88;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js
var name89, shader89;
var init_pbrBlockReflection = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflection.js"() {
    init_shaderStore();
    name89 = "pbrBlockReflection";
    shader89 = `#ifdef REFLECTION
struct reflectionOutParams
{vec4 environmentRadiance;vec3 environmentIrradiance;
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords;
#else
vec2 reflectionCoords;
#endif
#ifdef SS_TRANSLUCENCY
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
vec3 irradianceVector;
#endif
#endif
#endif
};
#define pbr_inline
void createReflectionCoords(
in vec3 vPositionW,
in vec3 normalW,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REFLECTIONMAP_3D
out vec3 reflectionCoords
#else
out vec2 reflectionCoords
#endif
)
{
#ifdef ANISOTROPIC
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),anisotropicOut.anisotropicNormal);
#else
vec3 reflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),normalW);
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
reflectionCoords=reflectionVector;
#else
reflectionCoords=reflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
reflectionCoords/=reflectionVector.z;
#endif
reflectionCoords.y=1.0-reflectionCoords.y;
#endif
}
#define pbr_inline
#define inline
void sampleReflectionTexture(
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
const vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
const vec2 reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out vec4 environmentRadiance
)
{
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG,NdotVUnclamped);
#elif defined(LINEARSPECULARREFLECTION)
float reflectionLOD=getLinearLodFromRoughness(vReflectionMicrosurfaceInfos.x,roughness);
#else
float reflectionLOD=getLodFromAlphaG(vReflectionMicrosurfaceInfos.x,alphaG);
#endif
#ifdef LODBASEDMICROSFURACE
reflectionLOD=reflectionLOD*vReflectionMicrosurfaceInfos.y+vReflectionMicrosurfaceInfos.z;
#ifdef LODINREFLECTIONALPHA
float automaticReflectionLOD=UNPACK_LOD(sampleReflection(reflectionSampler,reflectionCoords).a);float requestedReflectionLOD=max(automaticReflectionLOD,reflectionLOD);
#else
float requestedReflectionLOD=reflectionLOD;
#endif
#ifdef REALTIME_FILTERING
environmentRadiance=vec4(radiance(alphaG,reflectionSampler,reflectionCoords,vReflectionFilteringInfo),1.0);
#else
environmentRadiance=sampleReflectionLod(reflectionSampler,reflectionCoords,reflectionLOD);
#endif
#else
float lodReflectionNormalized=saturate(reflectionLOD/log2(vReflectionMicrosurfaceInfos.x));float lodReflectionNormalizedDoubled=lodReflectionNormalized*2.0;vec4 environmentMid=sampleReflection(reflectionSampler,reflectionCoords);if (lodReflectionNormalizedDoubled<1.0){environmentRadiance=mix(
sampleReflection(reflectionSamplerHigh,reflectionCoords),
environmentMid,
lodReflectionNormalizedDoubled
);} else {environmentRadiance=mix(
environmentMid,
sampleReflection(reflectionSamplerLow,reflectionCoords),
lodReflectionNormalizedDoubled-1.0
);}
#endif
#ifdef RGBDREFLECTION
environmentRadiance.rgb=fromRGBD(environmentRadiance);
#endif
#ifdef GAMMAREFLECTION
environmentRadiance.rgb=toLinearSpace(environmentRadiance.rgb);
#endif
environmentRadiance.rgb*=vReflectionInfos.x;environmentRadiance.rgb*=vReflectionColor.rgb;}
#define pbr_inline
#define inline
void reflectionBlock(
in vec3 vPositionW,
in vec3 normalW,
in float alphaG,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
in float NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
in float roughness,
#endif
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
in vec3 vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in mat4 reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
out reflectionOutParams outParams
)
{vec4 environmentRadiance=vec4(0.,0.,0.,0.);
#ifdef REFLECTIONMAP_3D
vec3 reflectionCoords=vec3(0.);
#else
vec2 reflectionCoords=vec2(0.);
#endif
createReflectionCoords(
vPositionW,
normalW,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
reflectionCoords
);sampleReflectionTexture(
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
#ifdef REFLECTIONMAP_3D
reflectionSampler,
reflectionCoords,
#else
reflectionSampler,
reflectionCoords,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentRadiance
);vec3 environmentIrradiance=vec3(0.,0.,0.);
#ifdef USESPHERICALFROMREFLECTIONMAP
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
environmentIrradiance=vEnvironmentIrradiance;
#else
#ifdef ANISOTROPIC
vec3 irradianceVector=vec3(reflectionMatrix*vec4(anisotropicOut.anisotropicNormal,0)).xyz;
#else
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#endif
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#if defined(REALTIME_FILTERING)
environmentIrradiance=irradiance(reflectionSampler,irradianceVector,vReflectionFilteringInfo);
#else
environmentIrradiance=computeEnvironmentIrradiance(irradianceVector);
#endif
#ifdef SS_TRANSLUCENCY
outParams.irradianceVector=irradianceVector;
#endif
#endif
#elif defined(USEIRRADIANCEMAP)
vec4 environmentIrradiance4=sampleReflection(irradianceSampler,reflectionCoords);environmentIrradiance=environmentIrradiance4.rgb;
#ifdef RGBDREFLECTION
environmentIrradiance.rgb=fromRGBD(environmentIrradiance4);
#endif
#ifdef GAMMAREFLECTION
environmentIrradiance.rgb=toLinearSpace(environmentIrradiance.rgb);
#endif
#endif
environmentIrradiance*=vReflectionColor.rgb;outParams.environmentRadiance=environmentRadiance;outParams.environmentIrradiance=environmentIrradiance;outParams.reflectionCoords=reflectionCoords;}
#endif
`;
    ShaderStore.IncludesShadersStore[name89] = shader89;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js
var name90, shader90;
var init_pbrBlockSheen = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSheen.js"() {
    init_shaderStore();
    name90 = "pbrBlockSheen";
    shader90 = `#ifdef SHEEN
struct sheenOutParams
{float sheenIntensity;vec3 sheenColor;float sheenRoughness;
#ifdef SHEEN_LINKWITHALBEDO
vec3 surfaceAlbedo;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
float sheenAlbedoScaling;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 finalSheenRadianceScaled;
#endif
#if DEBUGMODE>0
#ifdef SHEEN_TEXTURE
vec4 sheenMapData;
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
vec3 sheenEnvironmentReflectance;
#endif
#endif
};
#define pbr_inline
#define inline
void sheenBlock(
in vec4 vSheenColor,
#ifdef SHEEN_ROUGHNESS
in float vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 sheenMapRoughnessData,
#endif
#endif
in float roughness,
#ifdef SHEEN_TEXTURE
in vec4 sheenMapData,
in float sheenMapLevel,
#endif
in float reflectance,
#ifdef SHEEN_LINKWITHALBEDO
in vec3 baseColor,
in vec3 surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
in float NdotV,
in vec3 environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
in vec2 AARoughnessFactors,
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
in vec3 reflectionCoords,
#else
in sampler2D reflectionSampler,
in vec2 reflectionCoords,
#endif
in float NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
in float seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
in float eho,
#endif
#endif
out sheenOutParams outParams
)
{float sheenIntensity=vSheenColor.a;
#ifdef SHEEN_TEXTURE
#if DEBUGMODE>0
outParams.sheenMapData=sheenMapData;
#endif
#endif
#ifdef SHEEN_LINKWITHALBEDO
float sheenFactor=pow5(1.0-sheenIntensity);vec3 sheenColor=baseColor.rgb*(1.0-sheenFactor);float sheenRoughness=sheenIntensity;outParams.surfaceAlbedo=surfaceAlbedo*sheenFactor;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#else
vec3 sheenColor=vSheenColor.rgb;
#ifdef SHEEN_TEXTURE
#ifdef SHEEN_GAMMATEXTURE
sheenColor.rgb*=toLinearSpace(sheenMapData.rgb);
#else
sheenColor.rgb*=sheenMapData.rgb;
#endif
sheenColor.rgb*=sheenMapLevel;
#endif
#ifdef SHEEN_ROUGHNESS
float sheenRoughness=vSheenRoughness;
#ifdef SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE
#if defined(SHEEN_TEXTURE)
sheenRoughness*=sheenMapData.a;
#endif
#elif defined(SHEEN_TEXTURE_ROUGHNESS)
#ifdef SHEEN_TEXTURE_ROUGHNESS_IDENTICAL
sheenRoughness*=sheenMapData.a;
#else
sheenRoughness*=sheenMapRoughnessData.a;
#endif
#endif
#else
float sheenRoughness=roughness;
#ifdef SHEEN_TEXTURE
sheenIntensity*=sheenMapData.a;
#endif
#endif
#if !defined(SHEEN_ALBEDOSCALING)
sheenIntensity*=(1.-reflectance);
#endif
sheenColor*=sheenIntensity;
#endif
#ifdef ENVIRONMENTBRDF
/*#ifdef SHEEN_SOFTER
vec3 environmentSheenBrdf=vec3(0.,0.,getBRDFLookupCharlieSheen(NdotV,sheenRoughness));
#else*/
#ifdef SHEEN_ROUGHNESS
vec3 environmentSheenBrdf=getBRDFLookup(NdotV,sheenRoughness);
#else
vec3 environmentSheenBrdf=environmentBrdf;
#endif
/*#endif*/
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
float sheenAlphaG=convertRoughnessToAverageSlope(sheenRoughness);
#ifdef SPECULARAA
sheenAlphaG+=AARoughnessFactors.y;
#endif
vec4 environmentSheenRadiance=vec4(0.,0.,0.,0.);sampleReflectionTexture(
sheenAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
sheenRoughness,
#endif
reflectionSampler,
reflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentSheenRadiance
);vec3 sheenEnvironmentReflectance=getSheenReflectanceFromBRDFLookup(sheenColor,environmentSheenBrdf);
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
sheenEnvironmentReflectance*=seo;
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
sheenEnvironmentReflectance*=eho;
#endif
#if DEBUGMODE>0
outParams.sheenEnvironmentReflectance=sheenEnvironmentReflectance;
#endif
outParams.finalSheenRadianceScaled=
environmentSheenRadiance.rgb *
sheenEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
outParams.sheenAlbedoScaling=1.0-sheenIntensity*max(max(sheenColor.r,sheenColor.g),sheenColor.b)*environmentSheenBrdf.b;
#endif
outParams.sheenIntensity=sheenIntensity;outParams.sheenColor=sheenColor;outParams.sheenRoughness=sheenRoughness;}
#endif
`;
    ShaderStore.IncludesShadersStore[name90] = shader90;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js
var name91, shader91;
var init_pbrBlockClearcoat = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockClearcoat.js"() {
    init_shaderStore();
    name91 = "pbrBlockClearcoat";
    shader91 = `struct clearcoatOutParams
{vec3 specularEnvironmentR0;float conservationFactor;vec3 clearCoatNormalW;vec2 clearCoatAARoughnessFactors;float clearCoatIntensity;float clearCoatRoughness;
#ifdef REFLECTION
vec3 finalClearCoatRadianceScaled;
#endif
#ifdef CLEARCOAT_TINT
vec3 absorption;float clearCoatNdotVRefract;vec3 clearCoatColor;float clearCoatThickness;
#endif
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
vec3 energyConservationFactorClearCoat;
#endif
#if DEBUGMODE>0
#ifdef CLEARCOAT_BUMP
mat3 TBNClearCoat;
#endif
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData;
#endif
#ifdef REFLECTION
vec4 environmentClearCoatRadiance;vec3 clearCoatEnvironmentReflectance;
#endif
float clearCoatNdotV;
#endif
};
#ifdef CLEARCOAT
#define pbr_inline
#define inline
void clearcoatBlock(
in vec3 vPositionW,
in vec3 geometricNormalW,
in vec3 viewDirectionW,
in vec2 vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
in vec4 clearCoatMapRoughnessData,
#endif
in vec3 specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
in vec4 vClearCoatTintParams,
in float clearCoatColorAtDistance,
in vec4 vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
in vec4 clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
in vec2 vClearCoatBumpInfos,
in vec4 clearCoatBumpMapData,
in vec2 vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
in mat3 vTBN,
#else
in vec2 vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
in mat4 normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
in vec3 faceNormal,
#endif
#ifdef REFLECTION
in vec3 vReflectionMicrosurfaceInfos,
in vec2 vReflectionInfos,
in vec3 vReflectionColor,
in vec4 vLightingIntensity,
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSampler,
#else
in sampler2D reflectionSampler,
#endif
#ifndef LODBASEDMICROSFURACE
#ifdef REFLECTIONMAP_3D
in samplerCube reflectionSamplerLow,
in samplerCube reflectionSamplerHigh,
#else
in sampler2D reflectionSamplerLow,
in sampler2D reflectionSamplerHigh,
#endif
#endif
#ifdef REALTIME_FILTERING
in vec2 vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
in float ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
in float frontFacingMultiplier,
#endif
out clearcoatOutParams outParams
)
{float clearCoatIntensity=vClearCoatParams.x;float clearCoatRoughness=vClearCoatParams.y;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#ifdef CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE
clearCoatRoughness*=clearCoatMapData.y;
#endif
#if DEBUGMODE>0
outParams.clearCoatMapData=clearCoatMapData;
#endif
#endif
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL
clearCoatRoughness*=clearCoatMapData.y;
#else
clearCoatRoughness*=clearCoatMapRoughnessData.y;
#endif
#endif
outParams.clearCoatIntensity=clearCoatIntensity;outParams.clearCoatRoughness=clearCoatRoughness;
#ifdef CLEARCOAT_TINT
vec3 clearCoatColor=vClearCoatTintParams.rgb;float clearCoatThickness=vClearCoatTintParams.a;
#ifdef CLEARCOAT_TINT_TEXTURE
#ifdef CLEARCOAT_TINT_GAMMATEXTURE
clearCoatColor*=toLinearSpace(clearCoatTintMapData.rgb);
#else
clearCoatColor*=clearCoatTintMapData.rgb;
#endif
clearCoatThickness*=clearCoatTintMapData.a;
#if DEBUGMODE>0
outParams.clearCoatTintMapData=clearCoatTintMapData;
#endif
#endif
outParams.clearCoatColor=computeColorAtDistanceInMedia(clearCoatColor,clearCoatColorAtDistance);outParams.clearCoatThickness=clearCoatThickness;
#endif
#ifdef CLEARCOAT_REMAP_F0
vec3 specularEnvironmentR0Updated=getR0RemappedForClearCoat(specularEnvironmentR0);
#else
vec3 specularEnvironmentR0Updated=specularEnvironmentR0;
#endif
outParams.specularEnvironmentR0=mix(specularEnvironmentR0,specularEnvironmentR0Updated,clearCoatIntensity);vec3 clearCoatNormalW=geometricNormalW;
#ifdef CLEARCOAT_BUMP
#ifdef NORMALXYSCALE
float clearCoatNormalScale=1.0;
#else
float clearCoatNormalScale=vClearCoatBumpInfos.y;
#endif
#if defined(TANGENT) && defined(NORMAL)
mat3 TBNClearCoat=vTBN;
#else
vec2 TBNClearCoatUV=vClearCoatBumpUV*frontFacingMultiplier;mat3 TBNClearCoat=cotangent_frame(clearCoatNormalW*clearCoatNormalScale,vPositionW,TBNClearCoatUV,vClearCoatTangentSpaceParams);
#endif
#if DEBUGMODE>0
outParams.TBNClearCoat=TBNClearCoat;
#endif
#ifdef OBJECTSPACE_NORMALMAP
clearCoatNormalW=normalize(clearCoatBumpMapData.xyz *2.0-1.0);clearCoatNormalW=normalize(mat3(normalMatrix)*clearCoatNormalW);
#else
clearCoatNormalW=perturbNormal(TBNClearCoat,clearCoatBumpMapData.xyz,vClearCoatBumpInfos.y);
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
clearCoatNormalW*=sign(dot(clearCoatNormalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
clearCoatNormalW=clearCoatNormalW*frontFacingMultiplier;
#endif
outParams.clearCoatNormalW=clearCoatNormalW;outParams.clearCoatAARoughnessFactors=getAARoughnessFactors(clearCoatNormalW.xyz);float clearCoatNdotVUnclamped=dot(clearCoatNormalW,viewDirectionW);float clearCoatNdotV=absEps(clearCoatNdotVUnclamped);
#if DEBUGMODE>0
outParams.clearCoatNdotV=clearCoatNdotV;
#endif
#ifdef CLEARCOAT_TINT
vec3 clearCoatVRefract=refract(-viewDirectionW,clearCoatNormalW,vClearCoatRefractionParams.y);outParams.clearCoatNdotVRefract=absEps(dot(clearCoatNormalW,clearCoatVRefract));
#endif
#if defined(ENVIRONMENTBRDF) && (!defined(REFLECTIONMAP_SKYBOX) || defined(MS_BRDF_ENERGY_CONSERVATION))
vec3 environmentClearCoatBrdf=getBRDFLookup(clearCoatNdotV,clearCoatRoughness);
#endif
#if defined(REFLECTION)
float clearCoatAlphaG=convertRoughnessToAverageSlope(clearCoatRoughness);
#ifdef SPECULARAA
clearCoatAlphaG+=outParams.clearCoatAARoughnessFactors.y;
#endif
vec4 environmentClearCoatRadiance=vec4(0.,0.,0.,0.);vec3 clearCoatReflectionVector=computeReflectionCoords(vec4(vPositionW,1.0),clearCoatNormalW);
#ifdef REFLECTIONMAP_OPPOSITEZ
clearCoatReflectionVector.z*=-1.0;
#endif
#ifdef REFLECTIONMAP_3D
vec3 clearCoatReflectionCoords=clearCoatReflectionVector;
#else
vec2 clearCoatReflectionCoords=clearCoatReflectionVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
clearCoatReflectionCoords/=clearCoatReflectionVector.z;
#endif
clearCoatReflectionCoords.y=1.0-clearCoatReflectionCoords.y;
#endif
sampleReflectionTexture(
clearCoatAlphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
clearCoatNdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
clearCoatRoughness,
#endif
reflectionSampler,
clearCoatReflectionCoords,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
environmentClearCoatRadiance
);
#if DEBUGMODE>0
outParams.environmentClearCoatRadiance=environmentClearCoatRadiance;
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 clearCoatEnvironmentReflectance=getReflectanceFromBRDFLookup(vec3(vClearCoatRefractionParams.x),environmentClearCoatBrdf);
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float clearCoatEho=environmentHorizonOcclusion(-viewDirectionW,clearCoatNormalW,geometricNormalW);clearCoatEnvironmentReflectance*=clearCoatEho;
#endif
#endif
#endif
#else
vec3 clearCoatEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(clearCoatNdotV,vec3(1.),vec3(1.),sqrt(1.-clearCoatRoughness));
#endif
clearCoatEnvironmentReflectance*=clearCoatIntensity;
#if DEBUGMODE>0
outParams.clearCoatEnvironmentReflectance=clearCoatEnvironmentReflectance;
#endif
outParams.finalClearCoatRadianceScaled=
environmentClearCoatRadiance.rgb *
clearCoatEnvironmentReflectance *
vLightingIntensity.z;
#endif
#if defined(CLEARCOAT_TINT)
outParams.absorption=computeClearCoatAbsorption(outParams.clearCoatNdotVRefract,outParams.clearCoatNdotVRefract,outParams.clearCoatColor,clearCoatThickness,clearCoatIntensity);
#endif
float fresnelIBLClearCoat=fresnelSchlickGGX(clearCoatNdotV,vClearCoatRefractionParams.x,CLEARCOATREFLECTANCE90);fresnelIBLClearCoat*=clearCoatIntensity;outParams.conservationFactor=(1.-fresnelIBLClearCoat);
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
outParams.energyConservationFactorClearCoat=getEnergyConservationFactor(outParams.specularEnvironmentR0,environmentClearCoatBrdf);
#endif
}
#endif
`;
    ShaderStore.IncludesShadersStore[name91] = shader91;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js
var name92, shader92;
var init_pbrBlockIridescence = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockIridescence.js"() {
    init_shaderStore();
    name92 = "pbrBlockIridescence";
    shader92 = `struct iridescenceOutParams
{float iridescenceIntensity;float iridescenceIOR;float iridescenceThickness;vec3 specularEnvironmentR0;};
#ifdef IRIDESCENCE
#define pbr_inline
#define inline
void iridescenceBlock(
in vec4 vIridescenceParams,
in float viewAngle,
in vec3 specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
in vec2 iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
in vec2 iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
in float NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
in vec2 clearCoatMapData,
#endif
#endif
out iridescenceOutParams outParams
)
{float iridescenceIntensity=vIridescenceParams.x;float iridescenceIOR=vIridescenceParams.y;float iridescenceThicknessMin=vIridescenceParams.z;float iridescenceThicknessMax=vIridescenceParams.w;float iridescenceThicknessWeight=1.;
#ifdef IRIDESCENCE_TEXTURE
iridescenceIntensity*=iridescenceMapData.x;
#ifdef IRIDESCENCE_USE_THICKNESS_FROM_MAINTEXTURE
iridescenceThicknessWeight=iridescenceMapData.g;
#endif
#endif
#if defined(IRIDESCENCE_THICKNESS_TEXTURE)
iridescenceThicknessWeight=iridescenceThicknessMapData.g;
#endif
float iridescenceThickness=mix(iridescenceThicknessMin,iridescenceThicknessMax,iridescenceThicknessWeight);float topIor=1.; 
#ifdef CLEARCOAT
float clearCoatIntensity=vClearCoatParams.x;
#ifdef CLEARCOAT_TEXTURE
clearCoatIntensity*=clearCoatMapData.x;
#endif
topIor=mix(1.0,vClearCoatRefractionParams.w-1.,clearCoatIntensity);viewAngle=sqrt(1.0+square(1.0/topIor)*(square(NdotVUnclamped)-1.0));
#endif
vec3 iridescenceFresnel=evalIridescence(topIor,iridescenceIOR,viewAngle,iridescenceThickness,specularEnvironmentR0);outParams.specularEnvironmentR0=mix(specularEnvironmentR0,iridescenceFresnel,iridescenceIntensity);outParams.iridescenceIntensity=iridescenceIntensity;outParams.iridescenceThickness=iridescenceThickness;outParams.iridescenceIOR=iridescenceIOR;}
#endif
`;
    ShaderStore.IncludesShadersStore[name92] = shader92;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js
var name93, shader93;
var init_pbrBlockSubSurface = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockSubSurface.js"() {
    init_shaderStore();
    name93 = "pbrBlockSubSurface";
    shader93 = `struct subSurfaceOutParams
{vec3 specularEnvironmentReflectance;
#ifdef SS_REFRACTION
vec3 finalRefraction;vec3 surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
float alpha;
#endif
#ifdef REFLECTION
float refractionFactorForIrradiance;
#endif
#endif
#ifdef SS_TRANSLUCENCY
vec3 transmittance;float translucencyIntensity;
#ifdef REFLECTION
vec3 refractionIrradiance;
#endif
#endif
#if DEBUGMODE>0
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction;vec3 refractionTransmittance;
#endif
#endif
};
#ifdef SUBSURFACE
#define pbr_inline
#define inline
void subSurfaceBlock(
in vec3 vSubSurfaceIntensity,
in vec2 vThicknessParam,
in vec4 vTintColor,
in vec3 normalW,
in vec3 specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
in vec4 thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
in vec4 refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
in vec4 translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
in mat4 reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
in vec3 irradianceVector_,
#endif
#if defined(REALTIME_FILTERING)
in samplerCube reflectionSampler,
in vec2 vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
#ifdef REFLECTIONMAP_3D
in samplerCube irradianceSampler,
#else
in sampler2D irradianceSampler,
#endif
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
in vec3 surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
in vec3 vPositionW,
in vec3 viewDirectionW,
in mat4 view,
in vec4 vRefractionInfos,
in mat4 refractionMatrix,
in vec4 vRefractionMicrosurfaceInfos,
in vec4 vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
in float alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
in float NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
in float roughness,
#endif
in float alphaG,
#ifdef SS_REFRACTIONMAP_3D
in samplerCube refractionSampler,
#ifndef LODBASEDMICROSFURACE
in samplerCube refractionSamplerLow,
in samplerCube refractionSamplerHigh,
#endif
#else
in sampler2D refractionSampler,
#ifndef LODBASEDMICROSFURACE
in sampler2D refractionSamplerLow,
in sampler2D refractionSamplerHigh,
#endif
#endif
#ifdef ANISOTROPIC
in anisotropicOutParams anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
in vec2 vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
in vec3 refractionPosition,
in vec3 refractionSize,
#endif
#endif
#ifdef SS_TRANSLUCENCY
in vec3 vDiffusionDistance,
#endif
out subSurfaceOutParams outParams
)
{outParams.specularEnvironmentReflectance=specularEnvironmentReflectance;
#ifdef SS_REFRACTION
float refractionIntensity=vSubSurfaceIntensity.x;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
refractionIntensity*=(1.0-alpha);outParams.alpha=1.0;
#endif
#endif
#ifdef SS_TRANSLUCENCY
float translucencyIntensity=vSubSurfaceIntensity.y;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
#if defined(SS_USE_GLTF_TEXTURES)
float thickness=thicknessMap.g*vThicknessParam.y+vThicknessParam.x;
#else
float thickness=thicknessMap.r*vThicknessParam.y+vThicknessParam.x;
#endif
#if DEBUGMODE>0
outParams.thicknessMap=thicknessMap;
#endif
#ifdef SS_MASK_FROM_THICKNESS_TEXTURE
#if defined(SS_REFRACTION) && defined(SS_REFRACTION_USE_INTENSITY_FROM_TEXTURE)
#if defined(SS_USE_GLTF_TEXTURES)
refractionIntensity*=thicknessMap.r;
#else
refractionIntensity*=thicknessMap.g;
#endif
#endif
#if defined(SS_TRANSLUCENCY) && defined(SS_TRANSLUCENCY_USE_INTENSITY_FROM_TEXTURE)
translucencyIntensity*=thicknessMap.b;
#endif
#endif
#else
float thickness=vThicknessParam.y;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
#ifdef SS_USE_GLTF_TEXTURES
refractionIntensity*=refractionIntensityMap.r;
#else
refractionIntensity*=refractionIntensityMap.g;
#endif
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensity*=translucencyIntensityMap.b;
#endif
#ifdef SS_TRANSLUCENCY
thickness=maxEps(thickness);vec3 transmittance=transmittanceBRDF_Burley(vTintColor.rgb,vDiffusionDistance,thickness);transmittance*=translucencyIntensity;outParams.transmittance=transmittance;outParams.translucencyIntensity=translucencyIntensity;
#endif
#ifdef SS_REFRACTION
vec4 environmentRefraction=vec4(0.,0.,0.,0.);
#ifdef ANISOTROPIC
vec3 refractionVector=refract(-viewDirectionW,anisotropicOut.anisotropicNormal,vRefractionInfos.y);
#else
vec3 refractionVector=refract(-viewDirectionW,normalW,vRefractionInfos.y);
#endif
#ifdef SS_REFRACTIONMAP_OPPOSITEZ
refractionVector.z*=-1.0;
#endif
#ifdef SS_REFRACTIONMAP_3D
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
refractionVector=parallaxCorrectNormal(vPositionW,refractionVector,refractionSize,refractionPosition);
#endif
refractionVector.y=refractionVector.y*vRefractionInfos.w;vec3 refractionCoords=refractionVector;refractionCoords=vec3(refractionMatrix*vec4(refractionCoords,0));
#else
#ifdef SS_USE_THICKNESS_AS_DEPTH
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*thickness,1.0)));
#else
vec3 vRefractionUVW=vec3(refractionMatrix*(view*vec4(vPositionW+refractionVector*vRefractionInfos.z,1.0)));
#endif
vec2 refractionCoords=vRefractionUVW.xy/vRefractionUVW.z;refractionCoords.y=1.0-refractionCoords.y;
#endif
#ifdef SS_HAS_THICKNESS
float ior=vRefractionInfos.y;
#else
float ior=vRefractionMicrosurfaceInfos.w;
#endif
#ifdef SS_LODINREFRACTIONALPHA
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG,NdotVUnclamped);
#elif defined(SS_LINEARSPECULARREFRACTION)
float refractionRoughness=alphaG;refractionRoughness=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLinearLodFromRoughness(vRefractionMicrosurfaceInfos.x,refractionRoughness);
#else
float refractionAlphaG=alphaG;refractionAlphaG=mix(alphaG,0.0,clamp(ior*3.0-2.0,0.0,1.0));float refractionLOD=getLodFromAlphaG(vRefractionMicrosurfaceInfos.x,refractionAlphaG);
#endif
#ifdef LODBASEDMICROSFURACE
refractionLOD=refractionLOD*vRefractionMicrosurfaceInfos.y+vRefractionMicrosurfaceInfos.z;
#ifdef SS_LODINREFRACTIONALPHA
float automaticRefractionLOD=UNPACK_LOD(sampleRefraction(refractionSampler,refractionCoords).a);float requestedRefractionLOD=max(automaticRefractionLOD,refractionLOD);
#else
float requestedRefractionLOD=refractionLOD;
#endif
#if defined(REALTIME_FILTERING) && defined(SS_REFRACTIONMAP_3D)
environmentRefraction=vec4(radiance(alphaG,refractionSampler,refractionCoords,vRefractionFilteringInfo),1.0);
#else
environmentRefraction=sampleRefractionLod(refractionSampler,refractionCoords,requestedRefractionLOD);
#endif
#else
float lodRefractionNormalized=saturate(refractionLOD/log2(vRefractionMicrosurfaceInfos.x));float lodRefractionNormalizedDoubled=lodRefractionNormalized*2.0;vec4 environmentRefractionMid=sampleRefraction(refractionSampler,refractionCoords);if (lodRefractionNormalizedDoubled<1.0){environmentRefraction=mix(
sampleRefraction(refractionSamplerHigh,refractionCoords),
environmentRefractionMid,
lodRefractionNormalizedDoubled
);} else {environmentRefraction=mix(
environmentRefractionMid,
sampleRefraction(refractionSamplerLow,refractionCoords),
lodRefractionNormalizedDoubled-1.0
);}
#endif
#ifdef SS_RGBDREFRACTION
environmentRefraction.rgb=fromRGBD(environmentRefraction);
#endif
#ifdef SS_GAMMAREFRACTION
environmentRefraction.rgb=toLinearSpace(environmentRefraction.rgb);
#endif
environmentRefraction.rgb*=vRefractionInfos.x;
#endif
#ifdef SS_REFRACTION
vec3 refractionTransmittance=vec3(refractionIntensity);
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,thickness);
#elif defined(SS_LINKREFRACTIONTOTRANSPARENCY)
float maxChannel=max(max(surfaceAlbedo.r,surfaceAlbedo.g),surfaceAlbedo.b);vec3 volumeAlbedo=saturate(maxChannel*surfaceAlbedo);environmentRefraction.rgb*=volumeAlbedo;
#else
vec3 volumeAlbedo=computeColorAtDistanceInMedia(vTintColor.rgb,vTintColor.w);refractionTransmittance*=cocaLambert(volumeAlbedo,vThicknessParam.y);
#endif
#ifdef SS_ALBEDOFORREFRACTIONTINT
environmentRefraction.rgb*=surfaceAlbedo.rgb;
#endif
outParams.surfaceAlbedo=surfaceAlbedo*(1.-refractionIntensity);
#ifdef REFLECTION
outParams.refractionFactorForIrradiance=(1.-refractionIntensity);
#endif
#ifdef UNUSED_MULTIPLEBOUNCES
vec3 bounceSpecularEnvironmentReflectance=(2.0*specularEnvironmentReflectance)/(1.0+specularEnvironmentReflectance);outParams.specularEnvironmentReflectance=mix(bounceSpecularEnvironmentReflectance,specularEnvironmentReflectance,refractionIntensity);
#endif
refractionTransmittance*=1.0-outParams.specularEnvironmentReflectance;
#if DEBUGMODE>0
outParams.refractionTransmittance=refractionTransmittance;
#endif
outParams.finalRefraction=environmentRefraction.rgb*refractionTransmittance*vLightingIntensity.z;
#if DEBUGMODE>0
outParams.environmentRefraction=environmentRefraction;
#endif
#endif
#if defined(REFLECTION) && defined(SS_TRANSLUCENCY)
#if defined(NORMAL) && defined(USESPHERICALINVERTEX) || !defined(USESPHERICALFROMREFLECTIONMAP)
vec3 irradianceVector=vec3(reflectionMatrix*vec4(normalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
irradianceVector.z*=-1.0;
#endif
#ifdef INVERTCUBICMAP
irradianceVector.y*=-1.0;
#endif
#else
vec3 irradianceVector=irradianceVector_;
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP)
#if defined(REALTIME_FILTERING)
vec3 refractionIrradiance=irradiance(reflectionSampler,-irradianceVector,vReflectionFilteringInfo);
#else
vec3 refractionIrradiance=computeEnvironmentIrradiance(-irradianceVector);
#endif
#elif defined(USEIRRADIANCEMAP)
#ifdef REFLECTIONMAP_3D
vec3 irradianceCoords=irradianceVector;
#else
vec2 irradianceCoords=irradianceVector.xy;
#ifdef REFLECTIONMAP_PROJECTION
irradianceCoords/=irradianceVector.z;
#endif
irradianceCoords.y=1.0-irradianceCoords.y;
#endif
vec4 refractionIrradiance=sampleReflection(irradianceSampler,-irradianceCoords);
#ifdef RGBDREFLECTION
refractionIrradiance.rgb=fromRGBD(refractionIrradiance);
#endif
#ifdef GAMMAREFLECTION
refractionIrradiance.rgb=toLinearSpace(refractionIrradiance.rgb);
#endif
#else
vec4 refractionIrradiance=vec4(0.);
#endif
refractionIrradiance.rgb*=transmittance;
#ifdef SS_ALBEDOFORTRANSLUCENCYTINT
refractionIrradiance.rgb*=surfaceAlbedo.rgb;
#endif
outParams.refractionIrradiance=refractionIrradiance.rgb;
#endif
}
#endif
`;
    ShaderStore.IncludesShadersStore[name93] = shader93;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js
var name94, shader94;
var init_pbrBlockNormalGeometric = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalGeometric.js"() {
    init_shaderStore();
    name94 = "pbrBlockNormalGeometric";
    shader94 = `vec3 viewDirectionW=normalize(vEyePosition.xyz-vPositionW);
#ifdef NORMAL
vec3 normalW=normalize(vNormalW);
#else
vec3 normalW=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#endif
vec3 geometricNormalW=normalW;
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
geometricNormalW=gl_FrontFacing ? geometricNormalW : -geometricNormalW;
#endif
`;
    ShaderStore.IncludesShadersStore[name94] = shader94;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js
var name95, shader95;
var init_pbrBlockNormalFinal = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockNormalFinal.js"() {
    init_shaderStore();
    name95 = "pbrBlockNormalFinal";
    shader95 = `#if defined(FORCENORMALFORWARD) && defined(NORMAL)
vec3 faceNormal=normalize(cross(dFdx(vPositionW),dFdy(vPositionW)))*vEyePosition.w;
#if defined(TWOSIDEDLIGHTING)
faceNormal=gl_FrontFacing ? faceNormal : -faceNormal;
#endif
normalW*=sign(dot(normalW,faceNormal));
#endif
#if defined(TWOSIDEDLIGHTING) && defined(NORMAL)
normalW=gl_FrontFacing ? normalW : -normalW;
#endif
`;
    ShaderStore.IncludesShadersStore[name95] = shader95;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js
var name96, shader96;
var init_pbrBlockLightmapInit = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockLightmapInit.js"() {
    init_shaderStore();
    name96 = "pbrBlockLightmapInit";
    shader96 = `#ifdef LIGHTMAP
vec4 lightmapColor=texture2D(lightmapSampler,vLightmapUV+uvOffset);
#ifdef RGBDLIGHTMAP
lightmapColor.rgb=fromRGBD(lightmapColor);
#endif
#ifdef GAMMALIGHTMAP
lightmapColor.rgb=toLinearSpace(lightmapColor.rgb);
#endif
lightmapColor.rgb*=vLightmapInfos.y;
#endif
`;
    ShaderStore.IncludesShadersStore[name96] = shader96;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js
var name97, shader97;
var init_pbrBlockGeometryInfo = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockGeometryInfo.js"() {
    init_shaderStore();
    name97 = "pbrBlockGeometryInfo";
    shader97 = `float NdotVUnclamped=dot(normalW,viewDirectionW);float NdotV=absEps(NdotVUnclamped);float alphaG=convertRoughnessToAverageSlope(roughness);vec2 AARoughnessFactors=getAARoughnessFactors(normalW.xyz);
#ifdef SPECULARAA
alphaG+=AARoughnessFactors.y;
#endif
#if defined(ENVIRONMENTBRDF)
vec3 environmentBrdf=getBRDFLookup(NdotV,roughness);
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
#ifdef AMBIENTINGRAYSCALE
float ambientMonochrome=aoOut.ambientOcclusionColor.r;
#else
float ambientMonochrome=getLuminance(aoOut.ambientOcclusionColor);
#endif
float seo=environmentRadianceOcclusion(ambientMonochrome,NdotVUnclamped);
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
float eho=environmentHorizonOcclusion(-viewDirectionW,normalW,geometricNormalW);
#endif
#endif
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name97] = shader97;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js
var name98, shader98;
var init_pbrBlockReflectance0 = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance0.js"() {
    init_shaderStore();
    name98 = "pbrBlockReflectance0";
    shader98 = `float reflectance=max(max(reflectivityOut.surfaceReflectivityColor.r,reflectivityOut.surfaceReflectivityColor.g),reflectivityOut.surfaceReflectivityColor.b);vec3 specularEnvironmentR0=reflectivityOut.surfaceReflectivityColor.rgb;
#ifdef METALLICWORKFLOW
vec3 specularEnvironmentR90=vec3(metallicReflectanceFactors.a);
#else 
vec3 specularEnvironmentR90=vec3(1.0,1.0,1.0);
#endif
#ifdef ALPHAFRESNEL
float reflectance90=fresnelGrazingReflectance(reflectance);specularEnvironmentR90=specularEnvironmentR90*reflectance90;
#endif
`;
    ShaderStore.IncludesShadersStore[name98] = shader98;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js
var name99, shader99;
var init_pbrBlockReflectance = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockReflectance.js"() {
    init_shaderStore();
    name99 = "pbrBlockReflectance";
    shader99 = `#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
vec3 specularEnvironmentReflectance=getReflectanceFromBRDFLookup(clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,environmentBrdf);
#ifdef RADIANCEOCCLUSION
specularEnvironmentReflectance*=seo;
#endif
#ifdef HORIZONOCCLUSION
#ifdef BUMP
#ifdef REFLECTIONMAP_3D
specularEnvironmentReflectance*=eho;
#endif
#endif
#endif
#else
vec3 specularEnvironmentReflectance=getReflectanceFromAnalyticalBRDFLookup_Jones(NdotV,clearcoatOut.specularEnvironmentR0,specularEnvironmentR90,sqrt(microSurface));
#endif
#ifdef CLEARCOAT
specularEnvironmentReflectance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
specularEnvironmentReflectance*=clearcoatOut.absorption;
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name99] = shader99;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js
var name100, shader100;
var init_pbrBlockDirectLighting = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockDirectLighting.js"() {
    init_shaderStore();
    name100 = "pbrBlockDirectLighting";
    shader100 = `vec3 diffuseBase=vec3(0.,0.,0.);
#ifdef SPECULARTERM
vec3 specularBase=vec3(0.,0.,0.);
#endif
#ifdef CLEARCOAT
vec3 clearCoatBase=vec3(0.,0.,0.);
#endif
#ifdef SHEEN
vec3 sheenBase=vec3(0.,0.,0.);
#endif
preLightingInfo preInfo;lightingInfo info;float shadow=1.; 
float aggShadow=0.;float numLights=0.;
#if defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
vec3 absorption=vec3(0.);
#endif
`;
    ShaderStore.IncludesShadersStore[name100] = shader100;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js
var name101, shader101;
var init_pbrBlockFinalLitComponents = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalLitComponents.js"() {
    init_shaderStore();
    name101 = "pbrBlockFinalLitComponents";
    shader101 = `aggShadow=aggShadow/numLights;
#if defined(ENVIRONMENTBRDF)
#ifdef MS_BRDF_ENERGY_CONSERVATION
vec3 energyConservationFactor=getEnergyConservationFactor(clearcoatOut.specularEnvironmentR0,environmentBrdf);
#endif
#endif
#ifndef METALLICWORKFLOW
#ifdef SPECULAR_GLOSSINESS_ENERGY_CONSERVATION
surfaceAlbedo.rgb=(1.-reflectance)*surfaceAlbedo.rgb;
#endif
#endif
#if defined(SHEEN) && defined(SHEEN_ALBEDOSCALING) && defined(ENVIRONMENTBRDF)
surfaceAlbedo.rgb=sheenOut.sheenAlbedoScaling*surfaceAlbedo.rgb;
#endif
#ifdef REFLECTION
vec3 finalIrradiance=reflectionOut.environmentIrradiance;
#if defined(CLEARCOAT)
finalIrradiance*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
finalIrradiance*=clearcoatOut.absorption;
#endif
#endif
#if defined(SS_REFRACTION)
finalIrradiance*=subSurfaceOut.refractionFactorForIrradiance;
#endif
#if defined(SS_TRANSLUCENCY)
finalIrradiance*=(1.0-subSurfaceOut.translucencyIntensity);finalIrradiance+=subSurfaceOut.refractionIrradiance;
#endif
finalIrradiance*=surfaceAlbedo.rgb;finalIrradiance*=vLightingIntensity.z;finalIrradiance*=aoOut.ambientOcclusionColor;
#endif
#ifdef SPECULARTERM
vec3 finalSpecular=specularBase;finalSpecular=max(finalSpecular,0.0);vec3 finalSpecularScaled=finalSpecular*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalSpecularScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalSpecularScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef REFLECTION
vec3 finalRadiance=reflectionOut.environmentRadiance.rgb;finalRadiance*=subSurfaceOut.specularEnvironmentReflectance;vec3 finalRadianceScaled=finalRadiance*vLightingIntensity.z;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalRadianceScaled*=energyConservationFactor;
#endif
#if defined(SHEEN) && defined(ENVIRONMENTBRDF) && defined(SHEEN_ALBEDOSCALING)
finalRadianceScaled*=sheenOut.sheenAlbedoScaling;
#endif
#endif
#ifdef SHEEN
vec3 finalSheen=sheenBase*sheenOut.sheenColor;finalSheen=max(finalSheen,0.0);vec3 finalSheenScaled=finalSheen*vLightingIntensity.x*vLightingIntensity.w;
#if defined(CLEARCOAT) && defined(REFLECTION) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.conservationFactor;
#if defined(CLEARCOAT_TINT)
sheenOut.finalSheenRadianceScaled*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef CLEARCOAT
vec3 finalClearCoat=clearCoatBase;finalClearCoat=max(finalClearCoat,0.0);vec3 finalClearCoatScaled=finalClearCoat*vLightingIntensity.x*vLightingIntensity.w;
#if defined(ENVIRONMENTBRDF) && defined(MS_BRDF_ENERGY_CONSERVATION)
finalClearCoatScaled*=clearcoatOut.energyConservationFactorClearCoat;
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction*=clearcoatOut.conservationFactor;
#ifdef CLEARCOAT_TINT
subSurfaceOut.finalRefraction*=clearcoatOut.absorption;
#endif
#endif
#endif
#ifdef ALPHABLEND
float luminanceOverAlpha=0.0;
#if defined(REFLECTION) && defined(RADIANCEOVERALPHA)
luminanceOverAlpha+=getLuminance(finalRadianceScaled);
#if defined(CLEARCOAT)
luminanceOverAlpha+=getLuminance(clearcoatOut.finalClearCoatRadianceScaled);
#endif
#endif
#if defined(SPECULARTERM) && defined(SPECULAROVERALPHA)
luminanceOverAlpha+=getLuminance(finalSpecularScaled);
#endif
#if defined(CLEARCOAT) && defined(CLEARCOATOVERALPHA)
luminanceOverAlpha+=getLuminance(finalClearCoatScaled);
#endif
#if defined(RADIANCEOVERALPHA) || defined(SPECULAROVERALPHA) || defined(CLEARCOATOVERALPHA)
alpha=saturate(alpha+luminanceOverAlpha*luminanceOverAlpha);
#endif
#endif
`;
    ShaderStore.IncludesShadersStore[name101] = shader101;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js
var name102, shader102;
var init_pbrBlockFinalUnlitComponents = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalUnlitComponents.js"() {
    init_shaderStore();
    name102 = "pbrBlockFinalUnlitComponents";
    shader102 = `vec3 finalDiffuse=diffuseBase;finalDiffuse*=surfaceAlbedo.rgb;finalDiffuse=max(finalDiffuse,0.0);finalDiffuse*=vLightingIntensity.x;vec3 finalAmbient=vAmbientColor;finalAmbient*=surfaceAlbedo.rgb;vec3 finalEmissive=vEmissiveColor;
#ifdef EMISSIVE
vec3 emissiveColorTex=texture2D(emissiveSampler,vEmissiveUV+uvOffset).rgb;
#ifdef GAMMAEMISSIVE
finalEmissive*=toLinearSpace(emissiveColorTex.rgb);
#else
finalEmissive*=emissiveColorTex.rgb;
#endif
finalEmissive*= vEmissiveInfos.y;
#endif
finalEmissive*=vLightingIntensity.y;
#ifdef AMBIENT
vec3 ambientOcclusionForDirectDiffuse=mix(vec3(1.),aoOut.ambientOcclusionColor,vAmbientInfos.w);
#else
vec3 ambientOcclusionForDirectDiffuse=aoOut.ambientOcclusionColor;
#endif
finalAmbient*=aoOut.ambientOcclusionColor;finalDiffuse*=ambientOcclusionForDirectDiffuse;
`;
    ShaderStore.IncludesShadersStore[name102] = shader102;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js
var name103, shader103;
var init_pbrBlockFinalColorComposition = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockFinalColorComposition.js"() {
    init_shaderStore();
    name103 = "pbrBlockFinalColorComposition";
    shader103 = `vec4 finalColor=vec4(
#ifndef UNLIT
#ifdef REFLECTION
finalIrradiance +
#endif
#ifdef SPECULARTERM
finalSpecularScaled +
#endif
#ifdef SHEEN
finalSheenScaled +
#endif
#ifdef CLEARCOAT
finalClearCoatScaled +
#endif
#ifdef REFLECTION
finalRadianceScaled +
#if defined(SHEEN) && defined(ENVIRONMENTBRDF)
sheenOut.finalSheenRadianceScaled +
#endif
#ifdef CLEARCOAT
clearcoatOut.finalClearCoatRadianceScaled +
#endif
#endif
#ifdef SS_REFRACTION
subSurfaceOut.finalRefraction +
#endif
#endif
finalAmbient +
finalDiffuse,
alpha);
#ifdef LIGHTMAP
#ifndef LIGHTMAPEXCLUDED
#ifdef USELIGHTMAPASSHADOWMAP
finalColor.rgb*=lightmapColor.rgb;
#else
finalColor.rgb+=lightmapColor.rgb;
#endif
#endif
#endif
finalColor.rgb+=finalEmissive;
#define CUSTOM_FRAGMENT_BEFORE_FOG
finalColor=max(finalColor,0.0);
`;
    ShaderStore.IncludesShadersStore[name103] = shader103;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js
var name104, shader104;
var init_pbrBlockImageProcessing = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrBlockImageProcessing.js"() {
    init_shaderStore();
    name104 = "pbrBlockImageProcessing";
    shader104 = `#if defined(IMAGEPROCESSINGPOSTPROCESS) || defined(SS_SCATTERING)
#if !defined(SKIPFINALCOLORCLAMP)
finalColor.rgb=clamp(finalColor.rgb,0.,30.0);
#endif
#else
finalColor=applyImageProcessing(finalColor);
#endif
finalColor.a*=visibility;
#ifdef PREMULTIPLYALPHA
finalColor.rgb*=finalColor.a;
#endif
`;
    ShaderStore.IncludesShadersStore[name104] = shader104;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js
var name105, shader105;
var init_pbrDebug = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrDebug.js"() {
    init_shaderStore();
    name105 = "pbrDebug";
    shader105 = `#if DEBUGMODE>0
if (vClipSpacePosition.x/vClipSpacePosition.w>=vDebugMode.x) {
#if DEBUGMODE==1
gl_FragColor.rgb=vPositionW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==2 && defined(NORMAL)
gl_FragColor.rgb=vNormalW.rgb;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==3 && defined(BUMP) || DEBUGMODE==3 && defined(PARALLAX) || DEBUGMODE==3 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==4 && defined(BUMP) || DEBUGMODE==4 && defined(PARALLAX) || DEBUGMODE==4 && defined(ANISOTROPIC)
gl_FragColor.rgb=TBN[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==5
gl_FragColor.rgb=normalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==6 && defined(MAINUV1)
gl_FragColor.rgb=vec3(vMainUV1,0.0);
#elif DEBUGMODE==7 && defined(MAINUV2)
gl_FragColor.rgb=vec3(vMainUV2,0.0);
#elif DEBUGMODE==8 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[0];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==9 && defined(CLEARCOAT) && defined(CLEARCOAT_BUMP)
gl_FragColor.rgb=clearcoatOut.TBNClearCoat[1];
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==10 && defined(CLEARCOAT)
gl_FragColor.rgb=clearcoatOut.clearCoatNormalW;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==11 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicNormal;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==12 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicTangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==13 && defined(ANISOTROPIC)
gl_FragColor.rgb=anisotropicOut.anisotropicBitangent;
#define DEBUGMODE_NORMALIZE
#elif DEBUGMODE==20 && defined(ALBEDO)
gl_FragColor.rgb=albedoTexture.rgb;
#ifndef GAMMAALBEDO
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==21 && defined(AMBIENT)
gl_FragColor.rgb=aoOut.ambientOcclusionColorMap.rgb;
#elif DEBUGMODE==22 && defined(OPACITY)
gl_FragColor.rgb=opacityMap.rgb;
#elif DEBUGMODE==23 && defined(EMISSIVE)
gl_FragColor.rgb=emissiveColorTex.rgb;
#ifndef GAMMAEMISSIVE
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==24 && defined(LIGHTMAP)
gl_FragColor.rgb=lightmapColor.rgb;
#ifndef GAMMALIGHTMAP
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==25 && defined(REFLECTIVITY) && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceMetallicColorMap.rgb;
#elif DEBUGMODE==26 && defined(REFLECTIVITY) && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.surfaceReflectivityColorMap.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==27 && defined(CLEARCOAT) && defined(CLEARCOAT_TEXTURE)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatMapData.rg,0.0);
#elif DEBUGMODE==28 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
gl_FragColor.rgb=clearcoatOut.clearCoatTintMapData.rgb;
#elif DEBUGMODE==29 && defined(SHEEN) && defined(SHEEN_TEXTURE)
gl_FragColor.rgb=sheenOut.sheenMapData.rgb;
#elif DEBUGMODE==30 && defined(ANISOTROPIC) && defined(ANISOTROPIC_TEXTURE)
gl_FragColor.rgb=anisotropicOut.anisotropyMapData.rgb;
#elif DEBUGMODE==31 && defined(SUBSURFACE) && defined(SS_THICKNESSANDMASK_TEXTURE)
gl_FragColor.rgb=subSurfaceOut.thicknessMap.rgb;
#elif DEBUGMODE==32 && defined(BUMP)
gl_FragColor.rgb=texture2D(bumpSampler,vBumpUV).rgb;
#elif DEBUGMODE==40 && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.environmentRefraction.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==41 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentRadiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==42 && defined(CLEARCOAT) && defined(REFLECTION)
gl_FragColor.rgb=clearcoatOut.environmentClearCoatRadiance.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==50
gl_FragColor.rgb=diffuseBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==51 && defined(SPECULARTERM)
gl_FragColor.rgb=specularBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==52 && defined(CLEARCOAT)
gl_FragColor.rgb=clearCoatBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==53 && defined(SHEEN)
gl_FragColor.rgb=sheenBase.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==54 && defined(REFLECTION)
gl_FragColor.rgb=reflectionOut.environmentIrradiance.rgb;
#ifndef GAMMAREFLECTION
#define DEBUGMODE_GAMMA
#endif
#elif DEBUGMODE==60
gl_FragColor.rgb=surfaceAlbedo.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==61
gl_FragColor.rgb=clearcoatOut.specularEnvironmentR0;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==62 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=vec3(reflectivityOut.metallicRoughness.r);
#elif DEBUGMODE==71 && defined(METALLICWORKFLOW)
gl_FragColor.rgb=reflectivityOut.metallicF0;
#elif DEBUGMODE==63
gl_FragColor.rgb=vec3(roughness);
#elif DEBUGMODE==64
gl_FragColor.rgb=vec3(alphaG);
#elif DEBUGMODE==65
gl_FragColor.rgb=vec3(NdotV);
#elif DEBUGMODE==66 && defined(CLEARCOAT) && defined(CLEARCOAT_TINT)
gl_FragColor.rgb=clearcoatOut.clearCoatColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==67 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatRoughness);
#elif DEBUGMODE==68 && defined(CLEARCOAT)
gl_FragColor.rgb=vec3(clearcoatOut.clearCoatNdotV);
#elif DEBUGMODE==69 && defined(SUBSURFACE) && defined(SS_TRANSLUCENCY)
gl_FragColor.rgb=subSurfaceOut.transmittance;
#elif DEBUGMODE==70 && defined(SUBSURFACE) && defined(SS_REFRACTION)
gl_FragColor.rgb=subSurfaceOut.refractionTransmittance;
#elif DEBUGMODE==72
gl_FragColor.rgb=vec3(microSurface);
#elif DEBUGMODE==73
gl_FragColor.rgb=vAlbedoColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==74 && !defined(METALLICWORKFLOW)
gl_FragColor.rgb=vReflectivityColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==75
gl_FragColor.rgb=vEmissiveColor.rgb;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==80 && defined(RADIANCEOCCLUSION)
gl_FragColor.rgb=vec3(seo);
#elif DEBUGMODE==81 && defined(HORIZONOCCLUSION)
gl_FragColor.rgb=vec3(eho);
#elif DEBUGMODE==82 && defined(MS_BRDF_ENERGY_CONSERVATION)
gl_FragColor.rgb=vec3(energyConservationFactor);
#elif DEBUGMODE==83 && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=specularEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==84 && defined(CLEARCOAT) && defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
gl_FragColor.rgb=clearcoatOut.clearCoatEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==85 && defined(SHEEN) && defined(REFLECTION)
gl_FragColor.rgb=sheenOut.sheenEnvironmentReflectance;
#define DEBUGMODE_GAMMA
#elif DEBUGMODE==86 && defined(ALPHABLEND)
gl_FragColor.rgb=vec3(luminanceOverAlpha);
#elif DEBUGMODE==87
gl_FragColor.rgb=vec3(alpha);
#elif DEBUGMODE==88 && defined(ALBEDO)
gl_FragColor.rgb=vec3(albedoTexture.a);
#else
float stripeWidth=30.;float stripePos=floor((gl_FragCoord.x+gl_FragCoord.y)/stripeWidth);float whichColor=mod(stripePos,2.);vec3 color1=vec3(.6,.2,.2);vec3 color2=vec3(.3,.1,.1);gl_FragColor.rgb=mix(color1,color2,whichColor);
#endif
gl_FragColor.rgb*=vDebugMode.y;
#ifdef DEBUGMODE_NORMALIZE
gl_FragColor.rgb=normalize(gl_FragColor.rgb)*0.5+0.5;
#endif
#ifdef DEBUGMODE_GAMMA
gl_FragColor.rgb=toGammaSpace(gl_FragColor.rgb);
#endif
gl_FragColor.a=1.0;
#ifdef PREPASS
gl_FragData[0]=toLinearSpace(gl_FragColor); 
gl_FragData[1]=vec4(0.,0.,0.,0.); 
#endif
#ifdef DEBUGMODE_FORCERETURN
return;
#endif
}
#endif
`;
    ShaderStore.IncludesShadersStore[name105] = shader105;
  }
});

// node_modules/@babylonjs/core/Shaders/pbr.fragment.js
var name106, shader106;
var init_pbr_fragment = __esm({
  "node_modules/@babylonjs/core/Shaders/pbr.fragment.js"() {
    init_shaderStore();
    init_prePassDeclaration();
    init_oitDeclaration();
    init_pbrFragmentDeclaration();
    init_pbrUboDeclaration();
    init_pbrFragmentExtraDeclaration();
    init_lightFragmentDeclaration();
    init_lightUboDeclaration();
    init_pbrFragmentSamplersDeclaration();
    init_imageProcessingDeclaration();
    init_clipPlaneFragmentDeclaration();
    init_logDepthDeclaration();
    init_fogFragmentDeclaration();
    init_helperFunctions();
    init_subSurfaceScatteringFunctions();
    init_importanceSampling();
    init_pbrHelperFunctions();
    init_imageProcessingFunctions();
    init_shadowsFragmentFunctions();
    init_harmonicsFunctions();
    init_pbrDirectLightingSetupFunctions();
    init_pbrDirectLightingFalloffFunctions();
    init_pbrBRDFFunctions();
    init_hdrFilteringFunctions();
    init_pbrDirectLightingFunctions();
    init_pbrIBLFunctions();
    init_bumpFragmentMainFunctions();
    init_bumpFragmentFunctions();
    init_reflectionFunction();
    init_pbrBlockAlbedoOpacity();
    init_pbrBlockReflectivity();
    init_pbrBlockAmbientOcclusion();
    init_pbrBlockAlphaFresnel();
    init_pbrBlockAnisotropic();
    init_pbrBlockReflection();
    init_pbrBlockSheen();
    init_pbrBlockClearcoat();
    init_pbrBlockIridescence();
    init_pbrBlockSubSurface();
    init_clipPlaneFragment();
    init_pbrBlockNormalGeometric();
    init_bumpFragment();
    init_pbrBlockNormalFinal();
    init_depthPrePass();
    init_pbrBlockLightmapInit();
    init_pbrBlockGeometryInfo();
    init_pbrBlockReflectance0();
    init_pbrBlockReflectance();
    init_pbrBlockDirectLighting();
    init_lightFragment();
    init_pbrBlockFinalLitComponents();
    init_pbrBlockFinalUnlitComponents();
    init_pbrBlockFinalColorComposition();
    init_logDepthFragment();
    init_fogFragment();
    init_pbrBlockImageProcessing();
    init_oitFragment();
    init_pbrDebug();
    name106 = "pbrPixelShader";
    shader106 = `#if defined(BUMP) || !defined(NORMAL) || defined(FORCENORMALFORWARD) || defined(SPECULARAA) || defined(CLEARCOAT_BUMP) || defined(ANISOTROPIC)
#extension GL_OES_standard_derivatives : enable
#endif
#ifdef LODBASEDMICROSFURACE
#extension GL_EXT_shader_texture_lod : enable
#endif
#define CUSTOM_FRAGMENT_BEGIN
#ifdef LOGARITHMICDEPTH
#extension GL_EXT_frag_depth : enable
#endif
#include<prePassDeclaration>[SCENE_MRT_COUNT]
precision highp float;
#include<oitDeclaration>
#ifndef FROMLINEARSPACE
#define FROMLINEARSPACE
#endif
#include<__decl__pbrFragment>
#include<pbrFragmentExtraDeclaration>
#include<__decl__lightFragment>[0..maxSimultaneousLights]
#include<pbrFragmentSamplersDeclaration>
#include<imageProcessingDeclaration>
#include<clipPlaneFragmentDeclaration>
#include<logDepthDeclaration>
#include<fogFragmentDeclaration>
#include<helperFunctions>
#include<subSurfaceScatteringFunctions>
#include<importanceSampling>
#include<pbrHelperFunctions>
#include<imageProcessingFunctions>
#include<shadowsFragmentFunctions>
#include<harmonicsFunctions>
#include<pbrDirectLightingSetupFunctions>
#include<pbrDirectLightingFalloffFunctions>
#include<pbrBRDFFunctions>
#include<hdrFilteringFunctions>
#include<pbrDirectLightingFunctions>
#include<pbrIBLFunctions>
#include<bumpFragmentMainFunctions>
#include<bumpFragmentFunctions>
#ifdef REFLECTION
#include<reflectionFunction>
#endif
#define CUSTOM_FRAGMENT_DEFINITIONS
#include<pbrBlockAlbedoOpacity>
#include<pbrBlockReflectivity>
#include<pbrBlockAmbientOcclusion>
#include<pbrBlockAlphaFresnel>
#include<pbrBlockAnisotropic>
#include<pbrBlockReflection>
#include<pbrBlockSheen>
#include<pbrBlockClearcoat>
#include<pbrBlockIridescence>
#include<pbrBlockSubSurface>
void main(void) {
#define CUSTOM_FRAGMENT_MAIN_BEGIN
#include<clipPlaneFragment>
#include<pbrBlockNormalGeometric>
#include<bumpFragment>
#include<pbrBlockNormalFinal>
albedoOpacityOutParams albedoOpacityOut;
#ifdef ALBEDO
vec4 albedoTexture=texture2D(albedoSampler,vAlbedoUV+uvOffset);
#endif
#ifdef OPACITY
vec4 opacityMap=texture2D(opacitySampler,vOpacityUV+uvOffset);
#endif
#ifdef DECAL
vec4 decalColor=texture2D(decalSampler,vDecalUV+uvOffset);
#endif
albedoOpacityBlock(
vAlbedoColor,
#ifdef ALBEDO
albedoTexture,
vAlbedoInfos,
#endif
#ifdef OPACITY
opacityMap,
vOpacityInfos,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
#ifdef DECAL
decalColor,
vDecalInfos,
#endif
albedoOpacityOut
);vec3 surfaceAlbedo=albedoOpacityOut.surfaceAlbedo;float alpha=albedoOpacityOut.alpha;
#define CUSTOM_FRAGMENT_UPDATE_ALPHA
#include<depthPrePass>
#define CUSTOM_FRAGMENT_BEFORE_LIGHTS
ambientOcclusionOutParams aoOut;
#ifdef AMBIENT
vec3 ambientOcclusionColorMap=texture2D(ambientSampler,vAmbientUV+uvOffset).rgb;
#endif
ambientOcclusionBlock(
#ifdef AMBIENT
ambientOcclusionColorMap,
vAmbientInfos,
#endif
aoOut
);
#include<pbrBlockLightmapInit>
#ifdef UNLIT
vec3 diffuseBase=vec3(1.,1.,1.);
#else
vec3 baseColor=surfaceAlbedo;reflectivityOutParams reflectivityOut;
#if defined(REFLECTIVITY)
vec4 surfaceMetallicOrReflectivityColorMap=texture2D(reflectivitySampler,vReflectivityUV+uvOffset);vec4 baseReflectivity=surfaceMetallicOrReflectivityColorMap;
#ifndef METALLICWORKFLOW
#ifdef REFLECTIVITY_GAMMA
surfaceMetallicOrReflectivityColorMap=toLinearSpace(surfaceMetallicOrReflectivityColorMap);
#endif
surfaceMetallicOrReflectivityColorMap.rgb*=vReflectivityInfos.y;
#endif
#endif
#if defined(MICROSURFACEMAP)
vec4 microSurfaceTexel=texture2D(microSurfaceSampler,vMicroSurfaceSamplerUV+uvOffset)*vMicroSurfaceSamplerInfos.y;
#endif
#ifdef METALLICWORKFLOW
vec4 metallicReflectanceFactors=vMetallicReflectanceFactors;
#ifdef REFLECTANCE
vec4 reflectanceFactorsMap=texture2D(reflectanceSampler,vReflectanceUV+uvOffset);
#ifdef REFLECTANCE_GAMMA
reflectanceFactorsMap=toLinearSpace(reflectanceFactorsMap);
#endif
metallicReflectanceFactors.rgb*=reflectanceFactorsMap.rgb;
#endif
#ifdef METALLIC_REFLECTANCE
vec4 metallicReflectanceFactorsMap=texture2D(metallicReflectanceSampler,vMetallicReflectanceUV+uvOffset);
#ifdef METALLIC_REFLECTANCE_GAMMA
metallicReflectanceFactorsMap=toLinearSpace(metallicReflectanceFactorsMap);
#endif
#ifndef METALLIC_REFLECTANCE_USE_ALPHA_ONLY
metallicReflectanceFactors.rgb*=metallicReflectanceFactorsMap.rgb;
#endif
metallicReflectanceFactors*=metallicReflectanceFactorsMap.a;
#endif
#endif
reflectivityBlock(
vReflectivityColor,
#ifdef METALLICWORKFLOW
surfaceAlbedo,
metallicReflectanceFactors,
#endif
#ifdef REFLECTIVITY
vReflectivityInfos,
surfaceMetallicOrReflectivityColorMap,
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor,
#endif
#ifdef MICROSURFACEMAP
microSurfaceTexel,
#endif
#ifdef DETAIL
detailColor,
vDetailInfos,
#endif
reflectivityOut
);float microSurface=reflectivityOut.microSurface;float roughness=reflectivityOut.roughness;
#ifdef METALLICWORKFLOW
surfaceAlbedo=reflectivityOut.surfaceAlbedo;
#endif
#if defined(METALLICWORKFLOW) && defined(REFLECTIVITY) && defined(AOSTOREINMETALMAPRED)
aoOut.ambientOcclusionColor=reflectivityOut.ambientOcclusionColor;
#endif
#ifdef ALPHAFRESNEL
#if defined(ALPHATEST) || defined(ALPHABLEND)
alphaFresnelOutParams alphaFresnelOut;alphaFresnelBlock(
normalW,
viewDirectionW,
alpha,
microSurface,
alphaFresnelOut
);alpha=alphaFresnelOut.alpha;
#endif
#endif
#include<pbrBlockGeometryInfo>
#ifdef ANISOTROPIC
anisotropicOutParams anisotropicOut;
#ifdef ANISOTROPIC_TEXTURE
vec3 anisotropyMapData=texture2D(anisotropySampler,vAnisotropyUV+uvOffset).rgb*vAnisotropyInfos.y;
#endif
anisotropicBlock(
vAnisotropy,
roughness,
#ifdef ANISOTROPIC_TEXTURE
anisotropyMapData,
#endif
TBN,
normalW,
viewDirectionW,
anisotropicOut
);
#endif
#ifdef REFLECTION
reflectionOutParams reflectionOut;
#ifndef USE_CUSTOM_REFLECTION
reflectionBlock(
vPositionW,
normalW,
alphaG,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#if defined(LODINREFLECTIONALPHA) && !defined(REFLECTIONMAP_SKYBOX)
NdotVUnclamped,
#endif
#ifdef LINEARSPECULARREFLECTION
roughness,
#endif
reflectionSampler,
#if defined(NORMAL) && defined(USESPHERICALINVERTEX)
vEnvironmentIrradiance,
#endif
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionMatrix,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
reflectionOut
);
#else
#define CUSTOM_REFLECTION
#endif
#endif
#include<pbrBlockReflectance0>
#ifdef SHEEN
sheenOutParams sheenOut;
#ifdef SHEEN_TEXTURE
vec4 sheenMapData=texture2D(sheenSampler,vSheenUV+uvOffset);
#endif
#if defined(SHEEN_ROUGHNESS) && defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 sheenMapRoughnessData=texture2D(sheenRoughnessSampler,vSheenRoughnessUV+uvOffset)*vSheenInfos.w;
#endif
sheenBlock(
vSheenColor,
#ifdef SHEEN_ROUGHNESS
vSheenRoughness,
#if defined(SHEEN_TEXTURE_ROUGHNESS) && !defined(SHEEN_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(SHEEN_USE_ROUGHNESS_FROM_MAINTEXTURE)
sheenMapRoughnessData,
#endif
#endif
roughness,
#ifdef SHEEN_TEXTURE
sheenMapData,
vSheenInfos.y,
#endif
reflectance,
#ifdef SHEEN_LINKWITHALBEDO
baseColor,
surfaceAlbedo,
#endif
#ifdef ENVIRONMENTBRDF
NdotV,
environmentBrdf,
#endif
#if defined(REFLECTION) && defined(ENVIRONMENTBRDF)
AARoughnessFactors,
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
reflectionOut.reflectionCoords,
NdotVUnclamped,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(RADIANCEOCCLUSION)
seo,
#endif
#if !defined(REFLECTIONMAP_SKYBOX) && defined(HORIZONOCCLUSION) && defined(BUMP) && defined(REFLECTIONMAP_3D)
eho,
#endif
#endif
sheenOut
);
#ifdef SHEEN_LINKWITHALBEDO
surfaceAlbedo=sheenOut.surfaceAlbedo;
#endif
#endif
#ifdef CLEARCOAT
#ifdef CLEARCOAT_TEXTURE
vec2 clearCoatMapData=texture2D(clearCoatSampler,vClearCoatUV+uvOffset).rg*vClearCoatInfos.y;
#endif
#endif
#ifdef IRIDESCENCE
iridescenceOutParams iridescenceOut;
#ifdef IRIDESCENCE_TEXTURE
vec2 iridescenceMapData=texture2D(iridescenceSampler,vIridescenceUV+uvOffset).rg*vIridescenceInfos.y;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
vec2 iridescenceThicknessMapData=texture2D(iridescenceThicknessSampler,vIridescenceThicknessUV+uvOffset).rg*vIridescenceInfos.w;
#endif
iridescenceBlock(
vIridescenceParams,
NdotV,
specularEnvironmentR0,
#ifdef IRIDESCENCE_TEXTURE
iridescenceMapData,
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
iridescenceThicknessMapData,
#endif
#ifdef CLEARCOAT
NdotVUnclamped,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#endif
iridescenceOut
);float iridescenceIntensity=iridescenceOut.iridescenceIntensity;specularEnvironmentR0=iridescenceOut.specularEnvironmentR0;
#endif
clearcoatOutParams clearcoatOut;
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
vec4 clearCoatMapRoughnessData=texture2D(clearCoatRoughnessSampler,vClearCoatRoughnessUV+uvOffset)*vClearCoatInfos.w;
#endif
#if defined(CLEARCOAT_TINT) && defined(CLEARCOAT_TINT_TEXTURE)
vec4 clearCoatTintMapData=texture2D(clearCoatTintSampler,vClearCoatTintUV+uvOffset);
#endif
#ifdef CLEARCOAT_BUMP
vec4 clearCoatBumpMapData=texture2D(clearCoatBumpSampler,vClearCoatBumpUV+uvOffset);
#endif
clearcoatBlock(
vPositionW,
geometricNormalW,
viewDirectionW,
vClearCoatParams,
#if defined(CLEARCOAT_TEXTURE_ROUGHNESS) && !defined(CLEARCOAT_TEXTURE_ROUGHNESS_IDENTICAL) && !defined(CLEARCOAT_USE_ROUGHNESS_FROM_MAINTEXTURE)
clearCoatMapRoughnessData,
#endif
specularEnvironmentR0,
#ifdef CLEARCOAT_TEXTURE
clearCoatMapData,
#endif
#ifdef CLEARCOAT_TINT
vClearCoatTintParams,
clearCoatColorAtDistance,
vClearCoatRefractionParams,
#ifdef CLEARCOAT_TINT_TEXTURE
clearCoatTintMapData,
#endif
#endif
#ifdef CLEARCOAT_BUMP
vClearCoatBumpInfos,
clearCoatBumpMapData,
vClearCoatBumpUV,
#if defined(TANGENT) && defined(NORMAL)
vTBN,
#else
vClearCoatTangentSpaceParams,
#endif
#ifdef OBJECTSPACE_NORMALMAP
normalMatrix,
#endif
#endif
#if defined(FORCENORMALFORWARD) && defined(NORMAL)
faceNormal,
#endif
#ifdef REFLECTION
vReflectionMicrosurfaceInfos,
vReflectionInfos,
vReflectionColor,
vLightingIntensity,
reflectionSampler,
#ifndef LODBASEDMICROSFURACE
reflectionSamplerLow,
reflectionSamplerHigh,
#endif
#ifdef REALTIME_FILTERING
vReflectionFilteringInfo,
#endif
#endif
#if defined(ENVIRONMENTBRDF) && !defined(REFLECTIONMAP_SKYBOX)
#ifdef RADIANCEOCCLUSION
ambientMonochrome,
#endif
#endif
#if defined(CLEARCOAT_BUMP) || defined(TWOSIDEDLIGHTING)
(gl_FrontFacing ? 1. : -1.),
#endif
clearcoatOut
);
#else
clearcoatOut.specularEnvironmentR0=specularEnvironmentR0;
#endif
#include<pbrBlockReflectance>
subSurfaceOutParams subSurfaceOut;
#ifdef SUBSURFACE
#ifdef SS_THICKNESSANDMASK_TEXTURE
vec4 thicknessMap=texture2D(thicknessSampler,vThicknessUV+uvOffset);
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
vec4 refractionIntensityMap=texture2D(refractionIntensitySampler,vRefractionIntensityUV+uvOffset);
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
vec4 translucencyIntensityMap=texture2D(translucencyIntensitySampler,vTranslucencyIntensityUV+uvOffset);
#endif
subSurfaceBlock(
vSubSurfaceIntensity,
vThicknessParam,
vTintColor,
normalW,
specularEnvironmentReflectance,
#ifdef SS_THICKNESSANDMASK_TEXTURE
thicknessMap,
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
refractionIntensityMap,
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
translucencyIntensityMap,
#endif
#ifdef REFLECTION
#ifdef SS_TRANSLUCENCY
reflectionMatrix,
#ifdef USESPHERICALFROMREFLECTIONMAP
#if !defined(NORMAL) || !defined(USESPHERICALINVERTEX)
reflectionOut.irradianceVector,
#endif
#if defined(REALTIME_FILTERING)
reflectionSampler,
vReflectionFilteringInfo,
#endif
#endif
#ifdef USEIRRADIANCEMAP
irradianceSampler,
#endif
#endif
#endif
#if defined(SS_REFRACTION) || defined(SS_TRANSLUCENCY)
surfaceAlbedo,
#endif
#ifdef SS_REFRACTION
vPositionW,
viewDirectionW,
view,
vRefractionInfos,
refractionMatrix,
vRefractionMicrosurfaceInfos,
vLightingIntensity,
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha,
#endif
#ifdef SS_LODINREFRACTIONALPHA
NdotVUnclamped,
#endif
#ifdef SS_LINEARSPECULARREFRACTION
roughness,
#endif
alphaG,
refractionSampler,
#ifndef LODBASEDMICROSFURACE
refractionSamplerLow,
refractionSamplerHigh,
#endif
#ifdef ANISOTROPIC
anisotropicOut,
#endif
#ifdef REALTIME_FILTERING
vRefractionFilteringInfo,
#endif
#ifdef SS_USE_LOCAL_REFRACTIONMAP_CUBIC
vRefractionPosition,
vRefractionSize,
#endif
#endif
#ifdef SS_TRANSLUCENCY
vDiffusionDistance,
#endif
subSurfaceOut
);
#ifdef SS_REFRACTION
surfaceAlbedo=subSurfaceOut.surfaceAlbedo;
#ifdef SS_LINKREFRACTIONTOTRANSPARENCY
alpha=subSurfaceOut.alpha;
#endif
#endif
#else
subSurfaceOut.specularEnvironmentReflectance=specularEnvironmentReflectance;
#endif
#include<pbrBlockDirectLighting>
#include<lightFragment>[0..maxSimultaneousLights]
#include<pbrBlockFinalLitComponents>
#endif 
#include<pbrBlockFinalUnlitComponents>
#define CUSTOM_FRAGMENT_BEFORE_FINALCOLORCOMPOSITION
#include<pbrBlockFinalColorComposition>
#include<logDepthFragment>
#include<fogFragment>(color,finalColor)
#include<pbrBlockImageProcessing>
#define CUSTOM_FRAGMENT_BEFORE_FRAGCOLOR
#ifdef PREPASS
float writeGeometryInfo=finalColor.a>0.4 ? 1.0 : 0.0;
#ifdef PREPASS_POSITION
gl_FragData[PREPASS_POSITION_INDEX]=vec4(vPositionW,writeGeometryInfo);
#endif
#ifdef PREPASS_VELOCITY
vec2 a=(vCurrentPosition.xy/vCurrentPosition.w)*0.5+0.5;vec2 b=(vPreviousPosition.xy/vPreviousPosition.w)*0.5+0.5;vec2 velocity=abs(a-b);velocity=vec2(pow(velocity.x,1.0/3.0),pow(velocity.y,1.0/3.0))*sign(a-b)*0.5+0.5;gl_FragData[PREPASS_VELOCITY_INDEX]=vec4(velocity,0.0,writeGeometryInfo);
#endif
#ifdef PREPASS_ALBEDO_SQRT
vec3 sqAlbedo=sqrt(surfaceAlbedo); 
#endif
#ifdef PREPASS_IRRADIANCE
vec3 irradiance=finalDiffuse;
#ifndef UNLIT
#ifdef REFLECTION
irradiance+=finalIrradiance;
#endif
#endif
#ifdef SS_SCATTERING
gl_FragData[0]=vec4(finalColor.rgb-irradiance,finalColor.a); 
irradiance/=sqAlbedo;
#else
gl_FragData[0]=finalColor; 
float scatteringDiffusionProfile=255.;
#endif
gl_FragData[PREPASS_IRRADIANCE_INDEX]=vec4(clamp(irradiance,vec3(0.),vec3(1.)),writeGeometryInfo*scatteringDiffusionProfile/255.); 
#else
gl_FragData[0]=vec4(finalColor.rgb,finalColor.a);
#endif
#ifdef PREPASS_DEPTH
gl_FragData[PREPASS_DEPTH_INDEX]=vec4(vViewPos.z,0.0,0.0,writeGeometryInfo); 
#endif
#ifdef PREPASS_NORMAL
#ifdef PREPASS_NORMAL_WORLDSPACE
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalW,writeGeometryInfo); 
#else
gl_FragData[PREPASS_NORMAL_INDEX]=vec4(normalize((view*vec4(normalW,0.0)).rgb),writeGeometryInfo); 
#endif
#endif
#ifdef PREPASS_ALBEDO_SQRT
gl_FragData[PREPASS_ALBEDO_SQRT_INDEX]=vec4(sqAlbedo,writeGeometryInfo); 
#endif
#ifdef PREPASS_REFLECTIVITY
#ifndef UNLIT
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4(specularEnvironmentR0,microSurface)*writeGeometryInfo;
#else
gl_FragData[PREPASS_REFLECTIVITY_INDEX]=vec4( 0.0,0.0,0.0,1.0 )*writeGeometryInfo;
#endif
#endif
#endif
#if !defined(PREPASS) || defined(WEBGL2)
gl_FragColor=finalColor;
#endif
#include<oitFragment>
#if ORDER_INDEPENDENT_TRANSPARENCY
if (fragDepth==nearestDepth) {frontColor.rgb+=finalColor.rgb*finalColor.a*alphaMultiplier;frontColor.a=1.0-alphaMultiplier*(1.0-finalColor.a);} else {backColor+=finalColor;}
#endif
#include<pbrDebug>
#define CUSTOM_FRAGMENT_MAIN_END
}
`;
    ShaderStore.ShadersStore[name106] = shader106;
  }
});

// node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js
var name107, shader107;
var init_pbrVertexDeclaration = __esm({
  "node_modules/@babylonjs/core/Shaders/ShadersInclude/pbrVertexDeclaration.js"() {
    init_shaderStore();
    init_decalVertexDeclaration();
    name107 = "pbrVertexDeclaration";
    shader107 = `uniform mat4 view;uniform mat4 viewProjection;
#ifdef ALBEDO
uniform mat4 albedoMatrix;uniform vec2 vAlbedoInfos;
#endif
#ifdef AMBIENT
uniform mat4 ambientMatrix;uniform vec4 vAmbientInfos;
#endif
#ifdef OPACITY
uniform mat4 opacityMatrix;uniform vec2 vOpacityInfos;
#endif
#ifdef EMISSIVE
uniform vec2 vEmissiveInfos;uniform mat4 emissiveMatrix;
#endif
#ifdef LIGHTMAP
uniform vec2 vLightmapInfos;uniform mat4 lightmapMatrix;
#endif
#ifdef REFLECTIVITY 
uniform vec3 vReflectivityInfos;uniform mat4 reflectivityMatrix;
#endif
#ifdef METALLIC_REFLECTANCE
uniform vec2 vMetallicReflectanceInfos;uniform mat4 metallicReflectanceMatrix;
#endif
#ifdef REFLECTANCE
uniform vec2 vReflectanceInfos;uniform mat4 reflectanceMatrix;
#endif
#ifdef MICROSURFACEMAP
uniform vec2 vMicroSurfaceSamplerInfos;uniform mat4 microSurfaceSamplerMatrix;
#endif
#ifdef BUMP
uniform vec3 vBumpInfos;uniform mat4 bumpMatrix;
#endif
#ifdef POINTSIZE
uniform float pointSize;
#endif
#ifdef REFLECTION
uniform vec2 vReflectionInfos;uniform mat4 reflectionMatrix;
#endif
#ifdef CLEARCOAT
#if defined(CLEARCOAT_TEXTURE) || defined(CLEARCOAT_TEXTURE_ROUGHNESS)
uniform vec4 vClearCoatInfos;
#endif
#ifdef CLEARCOAT_TEXTURE
uniform mat4 clearCoatMatrix;
#endif
#ifdef CLEARCOAT_TEXTURE_ROUGHNESS
uniform mat4 clearCoatRoughnessMatrix;
#endif
#ifdef CLEARCOAT_BUMP
uniform vec2 vClearCoatBumpInfos;uniform mat4 clearCoatBumpMatrix;
#endif
#ifdef CLEARCOAT_TINT_TEXTURE
uniform vec2 vClearCoatTintInfos;uniform mat4 clearCoatTintMatrix;
#endif
#endif
#ifdef IRIDESCENCE
#if defined(IRIDESCENCE_TEXTURE) || defined(IRIDESCENCE_THICKNESS_TEXTURE)
uniform vec4 vIridescenceInfos;
#endif
#ifdef IRIDESCENCE_TEXTURE
uniform mat4 iridescenceMatrix;
#endif
#ifdef IRIDESCENCE_THICKNESS_TEXTURE
uniform mat4 iridescenceThicknessMatrix;
#endif
#endif
#ifdef ANISOTROPIC
#ifdef ANISOTROPIC_TEXTURE
uniform vec2 vAnisotropyInfos;uniform mat4 anisotropyMatrix;
#endif
#endif
#ifdef SHEEN
#if defined(SHEEN_TEXTURE) || defined(SHEEN_TEXTURE_ROUGHNESS)
uniform vec4 vSheenInfos;
#endif
#ifdef SHEEN_TEXTURE
uniform mat4 sheenMatrix;
#endif
#ifdef SHEEN_TEXTURE_ROUGHNESS
uniform mat4 sheenRoughnessMatrix;
#endif
#endif
#ifdef SUBSURFACE
#ifdef SS_REFRACTION
uniform vec4 vRefractionInfos;uniform mat4 refractionMatrix;
#endif
#ifdef SS_THICKNESSANDMASK_TEXTURE
uniform vec2 vThicknessInfos;uniform mat4 thicknessMatrix;
#endif
#ifdef SS_REFRACTIONINTENSITY_TEXTURE
uniform vec2 vRefractionIntensityInfos;uniform mat4 refractionIntensityMatrix;
#endif
#ifdef SS_TRANSLUCENCYINTENSITY_TEXTURE
uniform vec2 vTranslucencyIntensityInfos;uniform mat4 translucencyIntensityMatrix;
#endif
#endif
#ifdef NORMAL
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
#ifdef USESPHERICALFROMREFLECTIONMAP
#ifdef SPHERICAL_HARMONICS
uniform vec3 vSphericalL00;uniform vec3 vSphericalL1_1;uniform vec3 vSphericalL10;uniform vec3 vSphericalL11;uniform vec3 vSphericalL2_2;uniform vec3 vSphericalL2_1;uniform vec3 vSphericalL20;uniform vec3 vSphericalL21;uniform vec3 vSphericalL22;
#else
uniform vec3 vSphericalX;uniform vec3 vSphericalY;uniform vec3 vSphericalZ;uniform vec3 vSphericalXX_ZZ;uniform vec3 vSphericalYY_ZZ;uniform vec3 vSphericalZZ;uniform vec3 vSphericalXY;uniform vec3 vSphericalYZ;uniform vec3 vSphericalZX;
#endif
#endif
#endif
#endif
#ifdef DETAIL
uniform vec4 vDetailInfos;uniform mat4 detailMatrix;
#endif
#include<decalVertexDeclaration>
#define ADDITIONAL_VERTEX_DECLARATION
`;
    ShaderStore.IncludesShadersStore[name107] = shader107;
  }
});

// node_modules/@babylonjs/core/Shaders/pbr.vertex.js
var name108, shader108;
var init_pbr_vertex = __esm({
  "node_modules/@babylonjs/core/Shaders/pbr.vertex.js"() {
    init_shaderStore();
    init_pbrVertexDeclaration();
    init_pbrUboDeclaration();
    init_uvAttributeDeclaration();
    init_mainUVVaryingDeclaration();
    init_helperFunctions();
    init_bonesDeclaration();
    init_bakedVertexAnimationDeclaration();
    init_instancesDeclaration();
    init_prePassVertexDeclaration();
    init_samplerVertexDeclaration();
    init_harmonicsFunctions();
    init_bumpVertexDeclaration();
    init_clipPlaneVertexDeclaration();
    init_fogVertexDeclaration();
    init_lightVxFragmentDeclaration();
    init_lightVxUboDeclaration();
    init_morphTargetsVertexGlobalDeclaration();
    init_morphTargetsVertexDeclaration();
    init_logDepthDeclaration();
    init_morphTargetsVertexGlobal();
    init_morphTargetsVertex();
    init_instancesVertex();
    init_bonesVertex();
    init_bakedVertexAnimation();
    init_prePassVertex();
    init_uvVariableDeclaration();
    init_samplerVertexImplementation();
    init_bumpVertex();
    init_clipPlaneVertex();
    init_fogVertex();
    init_shadowsVertex();
    init_vertexColorMixing();
    init_logDepthVertex();
    name108 = "pbrVertexShader";
    shader108 = `precision highp float;
#include<__decl__pbrVertex>
#define CUSTOM_VERTEX_BEGIN
attribute vec3 position;
#ifdef NORMAL
attribute vec3 normal;
#endif
#ifdef TANGENT
attribute vec4 tangent;
#endif
#ifdef UV1
attribute vec2 uv;
#endif
#include<uvAttributeDeclaration>[2..7]
#include<mainUVVaryingDeclaration>[1..7]
#ifdef VERTEXCOLOR
attribute vec4 color;
#endif
#include<helperFunctions>
#include<bonesDeclaration>
#include<bakedVertexAnimationDeclaration>
#include<instancesDeclaration>
#include<prePassVertexDeclaration>
#include<samplerVertexDeclaration>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo)
#include<samplerVertexDeclaration>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail)
#include<samplerVertexDeclaration>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient)
#include<samplerVertexDeclaration>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity)
#include<samplerVertexDeclaration>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive)
#include<samplerVertexDeclaration>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity)
#include<samplerVertexDeclaration>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler)
#include<samplerVertexDeclaration>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance)
#include<samplerVertexDeclaration>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump)
#include<samplerVertexDeclaration>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal)
#ifdef CLEARCOAT
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump)
#include<samplerVertexDeclaration>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence)
#include<samplerVertexDeclaration>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness)
#endif
#ifdef SHEEN
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen)
#include<samplerVertexDeclaration>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexDeclaration>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy)
#endif
#ifdef SUBSURFACE
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity)
#include<samplerVertexDeclaration>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity)
#endif
varying vec3 vPositionW;
#if DEBUGMODE>0
varying vec4 vClipSpacePosition;
#endif
#ifdef NORMAL
varying vec3 vNormalW;
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
varying vec3 vEnvironmentIrradiance;
#include<harmonicsFunctions>
#endif
#endif
#if defined(VERTEXCOLOR) || defined(INSTANCESCOLOR) && defined(INSTANCES)
varying vec4 vColor;
#endif
#include<bumpVertexDeclaration>
#include<clipPlaneVertexDeclaration>
#include<fogVertexDeclaration>
#include<__decl__lightVxFragment>[0..maxSimultaneousLights]
#include<morphTargetsVertexGlobalDeclaration>
#include<morphTargetsVertexDeclaration>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
varying vec3 vPositionUVW;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
varying vec3 vDirectionW;
#endif
#include<logDepthDeclaration>
#define CUSTOM_VERTEX_DEFINITIONS
void main(void) {
#define CUSTOM_VERTEX_MAIN_BEGIN
vec3 positionUpdated=position;
#ifdef NORMAL
vec3 normalUpdated=normal;
#endif
#ifdef TANGENT
vec4 tangentUpdated=tangent;
#endif
#ifdef UV1
vec2 uvUpdated=uv;
#endif
#include<morphTargetsVertexGlobal>
#include<morphTargetsVertex>[0..maxSimultaneousMorphTargets]
#ifdef REFLECTIONMAP_SKYBOX
vPositionUVW=positionUpdated;
#endif
#define CUSTOM_VERTEX_UPDATE_POSITION
#define CUSTOM_VERTEX_UPDATE_NORMAL
#include<instancesVertex>
#if defined(PREPASS) && defined(PREPASS_VELOCITY) && !defined(BONES_VELOCITY_ENABLED)
vCurrentPosition=viewProjection*finalWorld*vec4(positionUpdated,1.0);vPreviousPosition=previousViewProjection*finalPreviousWorld*vec4(positionUpdated,1.0);
#endif
#include<bonesVertex>
#include<bakedVertexAnimation>
vec4 worldPos=finalWorld*vec4(positionUpdated,1.0);vPositionW=vec3(worldPos);
#include<prePassVertex>
#ifdef NORMAL
mat3 normalWorld=mat3(finalWorld);
#if defined(INSTANCES) && defined(THIN_INSTANCES)
vNormalW=normalUpdated/vec3(dot(normalWorld[0],normalWorld[0]),dot(normalWorld[1],normalWorld[1]),dot(normalWorld[2],normalWorld[2]));vNormalW=normalize(normalWorld*vNormalW);
#else
#ifdef NONUNIFORMSCALING
normalWorld=transposeMat3(inverseMat3(normalWorld));
#endif
vNormalW=normalize(normalWorld*normalUpdated);
#endif
#if defined(USESPHERICALFROMREFLECTIONMAP) && defined(USESPHERICALINVERTEX)
vec3 reflectionVector=vec3(reflectionMatrix*vec4(vNormalW,0)).xyz;
#ifdef REFLECTIONMAP_OPPOSITEZ
reflectionVector.z*=-1.0;
#endif
vEnvironmentIrradiance=computeEnvironmentIrradiance(reflectionVector);
#endif
#endif
#define CUSTOM_VERTEX_UPDATE_WORLDPOS
#ifdef MULTIVIEW
if (gl_ViewID_OVR==0u) {gl_Position=viewProjection*worldPos;} else {gl_Position=viewProjectionR*worldPos;}
#else
gl_Position=viewProjection*worldPos;
#endif
#if DEBUGMODE>0
vClipSpacePosition=gl_Position;
#endif
#if defined(REFLECTIONMAP_EQUIRECTANGULAR_FIXED) || defined(REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED)
vDirectionW=normalize(vec3(finalWorld*vec4(positionUpdated,0.0)));
#endif
#ifndef UV1
vec2 uvUpdated=vec2(0.,0.);
#endif
#ifdef MAINUV1
vMainUV1=uvUpdated;
#endif
#include<uvVariableDeclaration>[2..7]
#include<samplerVertexImplementation>(_DEFINENAME_,ALBEDO,_VARYINGNAME_,Albedo,_MATRIXNAME_,albedo,_INFONAME_,AlbedoInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DETAIL,_VARYINGNAME_,Detail,_MATRIXNAME_,detail,_INFONAME_,DetailInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,AMBIENT,_VARYINGNAME_,Ambient,_MATRIXNAME_,ambient,_INFONAME_,AmbientInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,OPACITY,_VARYINGNAME_,Opacity,_MATRIXNAME_,opacity,_INFONAME_,OpacityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,EMISSIVE,_VARYINGNAME_,Emissive,_MATRIXNAME_,emissive,_INFONAME_,EmissiveInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,LIGHTMAP,_VARYINGNAME_,Lightmap,_MATRIXNAME_,lightmap,_INFONAME_,LightmapInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTIVITY,_VARYINGNAME_,Reflectivity,_MATRIXNAME_,reflectivity,_INFONAME_,ReflectivityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,MICROSURFACEMAP,_VARYINGNAME_,MicroSurfaceSampler,_MATRIXNAME_,microSurfaceSampler,_INFONAME_,MicroSurfaceSamplerInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,METALLIC_REFLECTANCE,_VARYINGNAME_,MetallicReflectance,_MATRIXNAME_,metallicReflectance,_INFONAME_,MetallicReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,REFLECTANCE,_VARYINGNAME_,Reflectance,_MATRIXNAME_,reflectance,_INFONAME_,ReflectanceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,BUMP,_VARYINGNAME_,Bump,_MATRIXNAME_,bump,_INFONAME_,BumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,DECAL,_VARYINGNAME_,Decal,_MATRIXNAME_,decal,_INFONAME_,DecalInfos.x)
#ifdef CLEARCOAT
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE,_VARYINGNAME_,ClearCoat,_MATRIXNAME_,clearCoat,_INFONAME_,ClearCoatInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TEXTURE_ROUGHNESS,_VARYINGNAME_,ClearCoatRoughness,_MATRIXNAME_,clearCoatRoughness,_INFONAME_,ClearCoatInfos.z)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_BUMP,_VARYINGNAME_,ClearCoatBump,_MATRIXNAME_,clearCoatBump,_INFONAME_,ClearCoatBumpInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,CLEARCOAT_TINT_TEXTURE,_VARYINGNAME_,ClearCoatTint,_MATRIXNAME_,clearCoatTint,_INFONAME_,ClearCoatTintInfos.x)
#endif
#ifdef IRIDESCENCE
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_TEXTURE,_VARYINGNAME_,Iridescence,_MATRIXNAME_,iridescence,_INFONAME_,IridescenceInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,IRIDESCENCE_THICKNESS_TEXTURE,_VARYINGNAME_,IridescenceThickness,_MATRIXNAME_,iridescenceThickness,_INFONAME_,IridescenceInfos.z)
#endif
#ifdef SHEEN
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE,_VARYINGNAME_,Sheen,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SHEEN_TEXTURE_ROUGHNESS,_VARYINGNAME_,SheenRoughness,_MATRIXNAME_,sheen,_INFONAME_,SheenInfos.z)
#endif
#ifdef ANISOTROPIC
#include<samplerVertexImplementation>(_DEFINENAME_,ANISOTROPIC_TEXTURE,_VARYINGNAME_,Anisotropy,_MATRIXNAME_,anisotropy,_INFONAME_,AnisotropyInfos.x)
#endif
#ifdef SUBSURFACE
#include<samplerVertexImplementation>(_DEFINENAME_,SS_THICKNESSANDMASK_TEXTURE,_VARYINGNAME_,Thickness,_MATRIXNAME_,thickness,_INFONAME_,ThicknessInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_REFRACTIONINTENSITY_TEXTURE,_VARYINGNAME_,RefractionIntensity,_MATRIXNAME_,refractionIntensity,_INFONAME_,RefractionIntensityInfos.x)
#include<samplerVertexImplementation>(_DEFINENAME_,SS_TRANSLUCENCYINTENSITY_TEXTURE,_VARYINGNAME_,TranslucencyIntensity,_MATRIXNAME_,translucencyIntensity,_INFONAME_,TranslucencyIntensityInfos.x)
#endif
#include<bumpVertex>
#include<clipPlaneVertex>
#include<fogVertex>
#include<shadowsVertex>[0..maxSimultaneousLights]
#include<vertexColorMixing>
#if defined(POINTSIZE) && !defined(WEBGPU)
gl_PointSize=pointSize;
#endif
#include<logDepthVertex>
#define CUSTOM_VERTEX_MAIN_END
}`;
    ShaderStore.ShadersStore[name108] = shader108;
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js
var onCreatedEffectParameters3, PBRMaterialDefines, PBRBaseMaterial;
var init_pbrBaseMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrBaseMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_logger();
    init_smartArray();
    init_brdfTextureTools();
    init_scene();
    init_math_vector();
    init_buffer();
    init_pbrBRDFConfiguration();
    init_prePassConfiguration();
    init_math_color();
    init_math_scalar();
    init_imageProcessingConfiguration();
    init_material();
    init_materialPluginEvent();
    init_materialDefines();
    init_pushMaterial();
    init_materialHelper();
    init_texture();
    init_materialFlags();
    init_baseTexture_polynomial();
    init_pbr_fragment();
    init_pbr_vertex();
    init_effectFallbacks();
    init_pbrClearCoatConfiguration();
    init_pbrIridescenceConfiguration();
    init_pbrAnisotropicConfiguration();
    init_pbrSheenConfiguration();
    init_pbrSubSurfaceConfiguration();
    init_material_detailMapConfiguration();
    init_clipPlaneMaterialHelper();
    onCreatedEffectParameters3 = { effect: null, subMesh: null };
    PBRMaterialDefines = class extends MaterialDefines {
      constructor(externalProperties) {
        super(externalProperties);
        this.PBR = true;
        this.NUM_SAMPLES = "0";
        this.REALTIME_FILTERING = false;
        this.MAINUV1 = false;
        this.MAINUV2 = false;
        this.MAINUV3 = false;
        this.MAINUV4 = false;
        this.MAINUV5 = false;
        this.MAINUV6 = false;
        this.UV1 = false;
        this.UV2 = false;
        this.UV3 = false;
        this.UV4 = false;
        this.UV5 = false;
        this.UV6 = false;
        this.ALBEDO = false;
        this.GAMMAALBEDO = false;
        this.ALBEDODIRECTUV = 0;
        this.VERTEXCOLOR = false;
        this.BAKED_VERTEX_ANIMATION_TEXTURE = false;
        this.AMBIENT = false;
        this.AMBIENTDIRECTUV = 0;
        this.AMBIENTINGRAYSCALE = false;
        this.OPACITY = false;
        this.VERTEXALPHA = false;
        this.OPACITYDIRECTUV = 0;
        this.OPACITYRGB = false;
        this.ALPHATEST = false;
        this.DEPTHPREPASS = false;
        this.ALPHABLEND = false;
        this.ALPHAFROMALBEDO = false;
        this.ALPHATESTVALUE = "0.5";
        this.SPECULAROVERALPHA = false;
        this.RADIANCEOVERALPHA = false;
        this.ALPHAFRESNEL = false;
        this.LINEARALPHAFRESNEL = false;
        this.PREMULTIPLYALPHA = false;
        this.EMISSIVE = false;
        this.EMISSIVEDIRECTUV = 0;
        this.GAMMAEMISSIVE = false;
        this.REFLECTIVITY = false;
        this.REFLECTIVITY_GAMMA = false;
        this.REFLECTIVITYDIRECTUV = 0;
        this.SPECULARTERM = false;
        this.MICROSURFACEFROMREFLECTIVITYMAP = false;
        this.MICROSURFACEAUTOMATIC = false;
        this.LODBASEDMICROSFURACE = false;
        this.MICROSURFACEMAP = false;
        this.MICROSURFACEMAPDIRECTUV = 0;
        this.METALLICWORKFLOW = false;
        this.ROUGHNESSSTOREINMETALMAPALPHA = false;
        this.ROUGHNESSSTOREINMETALMAPGREEN = false;
        this.METALLNESSSTOREINMETALMAPBLUE = false;
        this.AOSTOREINMETALMAPRED = false;
        this.METALLIC_REFLECTANCE = false;
        this.METALLIC_REFLECTANCE_GAMMA = false;
        this.METALLIC_REFLECTANCEDIRECTUV = 0;
        this.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = false;
        this.REFLECTANCE = false;
        this.REFLECTANCE_GAMMA = false;
        this.REFLECTANCEDIRECTUV = 0;
        this.ENVIRONMENTBRDF = false;
        this.ENVIRONMENTBRDF_RGBD = false;
        this.NORMAL = false;
        this.TANGENT = false;
        this.BUMP = false;
        this.BUMPDIRECTUV = 0;
        this.OBJECTSPACE_NORMALMAP = false;
        this.PARALLAX = false;
        this.PARALLAXOCCLUSION = false;
        this.NORMALXYSCALE = true;
        this.LIGHTMAP = false;
        this.LIGHTMAPDIRECTUV = 0;
        this.USELIGHTMAPASSHADOWMAP = false;
        this.GAMMALIGHTMAP = false;
        this.RGBDLIGHTMAP = false;
        this.REFLECTION = false;
        this.REFLECTIONMAP_3D = false;
        this.REFLECTIONMAP_SPHERICAL = false;
        this.REFLECTIONMAP_PLANAR = false;
        this.REFLECTIONMAP_CUBIC = false;
        this.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
        this.REFLECTIONMAP_PROJECTION = false;
        this.REFLECTIONMAP_SKYBOX = false;
        this.REFLECTIONMAP_EXPLICIT = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR = false;
        this.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
        this.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
        this.INVERTCUBICMAP = false;
        this.USESPHERICALFROMREFLECTIONMAP = false;
        this.USEIRRADIANCEMAP = false;
        this.USESPHERICALINVERTEX = false;
        this.REFLECTIONMAP_OPPOSITEZ = false;
        this.LODINREFLECTIONALPHA = false;
        this.GAMMAREFLECTION = false;
        this.RGBDREFLECTION = false;
        this.LINEARSPECULARREFLECTION = false;
        this.RADIANCEOCCLUSION = false;
        this.HORIZONOCCLUSION = false;
        this.INSTANCES = false;
        this.THIN_INSTANCES = false;
        this.INSTANCESCOLOR = false;
        this.PREPASS = false;
        this.PREPASS_IRRADIANCE = false;
        this.PREPASS_IRRADIANCE_INDEX = -1;
        this.PREPASS_ALBEDO_SQRT = false;
        this.PREPASS_ALBEDO_SQRT_INDEX = -1;
        this.PREPASS_DEPTH = false;
        this.PREPASS_DEPTH_INDEX = -1;
        this.PREPASS_NORMAL = false;
        this.PREPASS_NORMAL_INDEX = -1;
        this.PREPASS_NORMAL_WORLDSPACE = false;
        this.PREPASS_POSITION = false;
        this.PREPASS_POSITION_INDEX = -1;
        this.PREPASS_VELOCITY = false;
        this.PREPASS_VELOCITY_INDEX = -1;
        this.PREPASS_REFLECTIVITY = false;
        this.PREPASS_REFLECTIVITY_INDEX = -1;
        this.SCENE_MRT_COUNT = 0;
        this.NUM_BONE_INFLUENCERS = 0;
        this.BonesPerMesh = 0;
        this.BONETEXTURE = false;
        this.BONES_VELOCITY_ENABLED = false;
        this.NONUNIFORMSCALING = false;
        this.MORPHTARGETS = false;
        this.MORPHTARGETS_NORMAL = false;
        this.MORPHTARGETS_TANGENT = false;
        this.MORPHTARGETS_UV = false;
        this.NUM_MORPH_INFLUENCERS = 0;
        this.MORPHTARGETS_TEXTURE = false;
        this.IMAGEPROCESSING = false;
        this.VIGNETTE = false;
        this.VIGNETTEBLENDMODEMULTIPLY = false;
        this.VIGNETTEBLENDMODEOPAQUE = false;
        this.TONEMAPPING = false;
        this.TONEMAPPING_ACES = false;
        this.CONTRAST = false;
        this.COLORCURVES = false;
        this.COLORGRADING = false;
        this.COLORGRADING3D = false;
        this.SAMPLER3DGREENDEPTH = false;
        this.SAMPLER3DBGRMAP = false;
        this.DITHER = false;
        this.IMAGEPROCESSINGPOSTPROCESS = false;
        this.SKIPFINALCOLORCLAMP = false;
        this.EXPOSURE = false;
        this.MULTIVIEW = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY = false;
        this.ORDER_INDEPENDENT_TRANSPARENCY_16BITS = false;
        this.USEPHYSICALLIGHTFALLOFF = false;
        this.USEGLTFLIGHTFALLOFF = false;
        this.TWOSIDEDLIGHTING = false;
        this.SHADOWFLOAT = false;
        this.CLIPPLANE = false;
        this.CLIPPLANE2 = false;
        this.CLIPPLANE3 = false;
        this.CLIPPLANE4 = false;
        this.CLIPPLANE5 = false;
        this.CLIPPLANE6 = false;
        this.POINTSIZE = false;
        this.FOG = false;
        this.LOGARITHMICDEPTH = false;
        this.CAMERA_ORTHOGRAPHIC = false;
        this.CAMERA_PERSPECTIVE = false;
        this.FORCENORMALFORWARD = false;
        this.SPECULARAA = false;
        this.UNLIT = false;
        this.DECAL_AFTER_DETAIL = false;
        this.DEBUGMODE = 0;
        this.rebuild();
      }
      reset() {
        super.reset();
        this.ALPHATESTVALUE = "0.5";
        this.PBR = true;
        this.NORMALXYSCALE = true;
      }
    };
    PBRBaseMaterial = class extends PushMaterial {
      get realTimeFiltering() {
        return this._realTimeFiltering;
      }
      set realTimeFiltering(b) {
        this._realTimeFiltering = b;
        this.markAsDirty(1);
      }
      get realTimeFilteringQuality() {
        return this._realTimeFilteringQuality;
      }
      set realTimeFilteringQuality(n) {
        this._realTimeFilteringQuality = n;
        this.markAsDirty(1);
      }
      get canRenderToMRT() {
        return true;
      }
      _attachImageProcessingConfiguration(configuration) {
        if (configuration === this._imageProcessingConfiguration) {
          return;
        }
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        if (!configuration) {
          this._imageProcessingConfiguration = this.getScene().imageProcessingConfiguration;
        } else {
          this._imageProcessingConfiguration = configuration;
        }
        if (this._imageProcessingConfiguration) {
          this._imageProcessingObserver = this._imageProcessingConfiguration.onUpdateParameters.add(() => {
            this._markAllSubMeshesAsImageProcessingDirty();
          });
        }
      }
      constructor(name109, scene) {
        super(name109, scene);
        this._directIntensity = 1;
        this._emissiveIntensity = 1;
        this._environmentIntensity = 1;
        this._specularIntensity = 1;
        this._lightingInfos = new Vector4(this._directIntensity, this._emissiveIntensity, this._environmentIntensity, this._specularIntensity);
        this._disableBumpMap = false;
        this._albedoTexture = null;
        this._ambientTexture = null;
        this._ambientTextureStrength = 1;
        this._ambientTextureImpactOnAnalyticalLights = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        this._opacityTexture = null;
        this._reflectionTexture = null;
        this._emissiveTexture = null;
        this._reflectivityTexture = null;
        this._metallicTexture = null;
        this._metallic = null;
        this._roughness = null;
        this._metallicF0Factor = 1;
        this._metallicReflectanceColor = Color3.White();
        this._useOnlyMetallicFromMetallicReflectanceTexture = false;
        this._metallicReflectanceTexture = null;
        this._reflectanceTexture = null;
        this._microSurfaceTexture = null;
        this._bumpTexture = null;
        this._lightmapTexture = null;
        this._ambientColor = new Color3(0, 0, 0);
        this._albedoColor = new Color3(1, 1, 1);
        this._reflectivityColor = new Color3(1, 1, 1);
        this._reflectionColor = new Color3(1, 1, 1);
        this._emissiveColor = new Color3(0, 0, 0);
        this._microSurface = 0.9;
        this._useLightmapAsShadowmap = false;
        this._useHorizonOcclusion = true;
        this._useRadianceOcclusion = true;
        this._useAlphaFromAlbedoTexture = false;
        this._useSpecularOverAlpha = true;
        this._useMicroSurfaceFromReflectivityMapAlpha = false;
        this._useRoughnessFromMetallicTextureAlpha = true;
        this._useRoughnessFromMetallicTextureGreen = false;
        this._useMetallnessFromMetallicTextureBlue = false;
        this._useAmbientOcclusionFromMetallicTextureRed = false;
        this._useAmbientInGrayScale = false;
        this._useAutoMicroSurfaceFromReflectivityMap = false;
        this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
        this._useRadianceOverAlpha = true;
        this._useObjectSpaceNormalMap = false;
        this._useParallax = false;
        this._useParallaxOcclusion = false;
        this._parallaxScaleBias = 0.05;
        this._disableLighting = false;
        this._maxSimultaneousLights = 4;
        this._invertNormalMapX = false;
        this._invertNormalMapY = false;
        this._twoSidedLighting = false;
        this._alphaCutOff = 0.4;
        this._forceAlphaTest = false;
        this._useAlphaFresnel = false;
        this._useLinearAlphaFresnel = false;
        this._environmentBRDFTexture = null;
        this._forceIrradianceInFragment = false;
        this._realTimeFiltering = false;
        this._realTimeFilteringQuality = 8;
        this._forceNormalForward = false;
        this._enableSpecularAntiAliasing = false;
        this._imageProcessingObserver = null;
        this._renderTargets = new SmartArray(16);
        this._globalAmbientColor = new Color3(0, 0, 0);
        this._useLogarithmicDepth = false;
        this._unlit = false;
        this._applyDecalMapAfterDetailMap = false;
        this._debugMode = 0;
        this.debugMode = 0;
        this.debugLimit = -1;
        this.debugFactor = 1;
        this._cacheHasRenderTargetTextures = false;
        this.brdf = new PBRBRDFConfiguration(this);
        this.clearCoat = new PBRClearCoatConfiguration(this);
        this.iridescence = new PBRIridescenceConfiguration(this);
        this.anisotropy = new PBRAnisotropicConfiguration(this);
        this.sheen = new PBRSheenConfiguration(this);
        this.subSurface = new PBRSubSurfaceConfiguration(this);
        this.detailMap = new DetailMapConfiguration(this);
        this._attachImageProcessingConfiguration(null);
        this.getRenderTargetTextures = () => {
          this._renderTargets.reset();
          if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
            this._renderTargets.push(this._reflectionTexture);
          }
          this._eventInfo.renderTargets = this._renderTargets;
          this._callbackPluginEventFillRenderTargetTextures(this._eventInfo);
          return this._renderTargets;
        };
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
        this.prePassConfiguration = new PrePassConfiguration();
      }
      get hasRenderTargetTextures() {
        if (MaterialFlags.ReflectionTextureEnabled && this._reflectionTexture && this._reflectionTexture.isRenderTarget) {
          return true;
        }
        return this._cacheHasRenderTargetTextures;
      }
      get isPrePassCapable() {
        return !this.disableDepthWrite;
      }
      getClassName() {
        return "PBRBaseMaterial";
      }
      get useLogarithmicDepth() {
        return this._useLogarithmicDepth;
      }
      set useLogarithmicDepth(value) {
        this._useLogarithmicDepth = value && this.getScene().getEngine().getCaps().fragmentDepthSupported;
      }
      get _disableAlphaBlending() {
        var _a;
        return this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_OPAQUE || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST || ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending);
      }
      needAlphaBlending() {
        if (this._disableAlphaBlending) {
          return false;
        }
        return this.alpha < 1 || this._opacityTexture != null || this._shouldUseAlphaFromAlbedoTexture();
      }
      needAlphaTesting() {
        var _a;
        if (this._forceAlphaTest) {
          return true;
        }
        if ((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.disableAlphaBlending) {
          return false;
        }
        return this._hasAlphaChannel() && (this._transparencyMode == null || this._transparencyMode === PBRBaseMaterial.PBRMATERIAL_ALPHATEST);
      }
      _shouldUseAlphaFromAlbedoTexture() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha && this._useAlphaFromAlbedoTexture && this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE;
      }
      _hasAlphaChannel() {
        return this._albedoTexture != null && this._albedoTexture.hasAlpha || this._opacityTexture != null;
      }
      getAlphaTestTexture() {
        return this._albedoTexture;
      }
      isReadyForSubMesh(mesh, subMesh, useInstances) {
        var _a;
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        if (subMesh.effect && this.isFrozen) {
          if (subMesh.effect._wasPreviouslyReady && subMesh.effect._wasPreviouslyUsingInstances === useInstances) {
            return true;
          }
        }
        if (!subMesh.materialDefines) {
          this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
          subMesh.materialDefines = new PBRMaterialDefines(this._eventInfo.defineNames);
        }
        const defines = subMesh.materialDefines;
        if (this._isReadyForSubMesh(subMesh)) {
          return true;
        }
        const scene = this.getScene();
        const engine = scene.getEngine();
        if (defines._areTexturesDirty) {
          this._eventInfo.hasRenderTargetTextures = false;
          this._callbackPluginEventHasRenderTargetTextures(this._eventInfo);
          this._cacheHasRenderTargetTextures = this._eventInfo.hasRenderTargetTextures;
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              if (!this._albedoTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              if (!this._ambientTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              if (!this._opacityTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            const reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!reflectionTexture.isReadyOrNotBlocking()) {
                return false;
              }
              if (reflectionTexture.irradianceTexture) {
                if (!reflectionTexture.irradianceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else {
                if (!reflectionTexture.sphericalPolynomial && ((_a = reflectionTexture.getInternalTexture()) === null || _a === void 0 ? void 0 : _a._sphericalPolynomialPromise)) {
                  return false;
                }
              }
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              if (!this._lightmapTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              if (!this._emissiveTexture.isReadyOrNotBlocking()) {
                return false;
              }
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                if (!this._metallicTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              } else if (this._reflectivityTexture) {
                if (!this._reflectivityTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._metallicReflectanceTexture) {
                if (!this._metallicReflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._reflectanceTexture) {
                if (!this._reflectanceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
              if (this._microSurfaceTexture) {
                if (!this._microSurfaceTexture.isReadyOrNotBlocking()) {
                  return false;
                }
              }
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              if (!this._bumpTexture.isReady()) {
                return false;
              }
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (!this._environmentBRDFTexture.isReady()) {
                return false;
              }
            }
          }
        }
        this._eventInfo.isReadyForSubMesh = true;
        this._eventInfo.defines = defines;
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventIsReadyForSubMesh(this._eventInfo);
        if (!this._eventInfo.isReadyForSubMesh) {
          return false;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          if (!this._imageProcessingConfiguration.isReady()) {
            return false;
          }
        }
        if (!engine.getCaps().standardDerivatives && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          mesh.createNormals(true);
          Logger.Warn("PBRMaterial: Normals have been created for the mesh: " + mesh.name);
        }
        const previousEffect = subMesh.effect;
        const lightDisposed = defines._areLightsDisposed;
        let effect = this._prepareEffect(mesh, defines, this.onCompiled, this.onError, useInstances, null, subMesh.getRenderingMesh().hasThinInstances);
        let forceWasNotReadyPreviously = false;
        if (effect) {
          if (this._onEffectCreatedObservable) {
            onCreatedEffectParameters3.effect = effect;
            onCreatedEffectParameters3.subMesh = subMesh;
            this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters3);
          }
          if (this.allowShaderHotSwapping && previousEffect && !effect.isReady()) {
            effect = previousEffect;
            defines.markAsUnprocessed();
            forceWasNotReadyPreviously = this.isFrozen;
            if (lightDisposed) {
              defines._areLightsDisposed = true;
              return false;
            }
          } else {
            scene.resetCachedMaterial();
            subMesh.setEffect(effect, defines, this._materialContext);
          }
        }
        if (!subMesh.effect || !subMesh.effect.isReady()) {
          return false;
        }
        defines._renderId = scene.getRenderId();
        subMesh.effect._wasPreviouslyReady = forceWasNotReadyPreviously ? false : true;
        subMesh.effect._wasPreviouslyUsingInstances = !!useInstances;
        this._checkScenePerformancePriority();
        return true;
      }
      isMetallicWorkflow() {
        if (this._metallic != null || this._roughness != null || this._metallicTexture) {
          return true;
        }
        return false;
      }
      _prepareEffect(mesh, defines, onCompiled = null, onError = null, useInstances = null, useClipPlane = null, useThinInstances) {
        this._prepareDefines(mesh, defines, useInstances, useClipPlane, useThinInstances);
        if (!defines.isDirty) {
          return null;
        }
        defines.markAsProcessed();
        const scene = this.getScene();
        const engine = scene.getEngine();
        const fallbacks = new EffectFallbacks();
        let fallbackRank = 0;
        if (defines.USESPHERICALINVERTEX) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALINVERTEX");
        }
        if (defines.FOG) {
          fallbacks.addFallback(fallbackRank, "FOG");
        }
        if (defines.SPECULARAA) {
          fallbacks.addFallback(fallbackRank, "SPECULARAA");
        }
        if (defines.POINTSIZE) {
          fallbacks.addFallback(fallbackRank, "POINTSIZE");
        }
        if (defines.LOGARITHMICDEPTH) {
          fallbacks.addFallback(fallbackRank, "LOGARITHMICDEPTH");
        }
        if (defines.PARALLAX) {
          fallbacks.addFallback(fallbackRank, "PARALLAX");
        }
        if (defines.PARALLAXOCCLUSION) {
          fallbacks.addFallback(fallbackRank++, "PARALLAXOCCLUSION");
        }
        if (defines.ENVIRONMENTBRDF) {
          fallbacks.addFallback(fallbackRank++, "ENVIRONMENTBRDF");
        }
        if (defines.TANGENT) {
          fallbacks.addFallback(fallbackRank++, "TANGENT");
        }
        if (defines.BUMP) {
          fallbacks.addFallback(fallbackRank++, "BUMP");
        }
        fallbackRank = MaterialHelper.HandleFallbacksForShadows(defines, fallbacks, this._maxSimultaneousLights, fallbackRank++);
        if (defines.SPECULARTERM) {
          fallbacks.addFallback(fallbackRank++, "SPECULARTERM");
        }
        if (defines.USESPHERICALFROMREFLECTIONMAP) {
          fallbacks.addFallback(fallbackRank++, "USESPHERICALFROMREFLECTIONMAP");
        }
        if (defines.USEIRRADIANCEMAP) {
          fallbacks.addFallback(fallbackRank++, "USEIRRADIANCEMAP");
        }
        if (defines.LIGHTMAP) {
          fallbacks.addFallback(fallbackRank++, "LIGHTMAP");
        }
        if (defines.NORMAL) {
          fallbacks.addFallback(fallbackRank++, "NORMAL");
        }
        if (defines.AMBIENT) {
          fallbacks.addFallback(fallbackRank++, "AMBIENT");
        }
        if (defines.EMISSIVE) {
          fallbacks.addFallback(fallbackRank++, "EMISSIVE");
        }
        if (defines.VERTEXCOLOR) {
          fallbacks.addFallback(fallbackRank++, "VERTEXCOLOR");
        }
        if (defines.MORPHTARGETS) {
          fallbacks.addFallback(fallbackRank++, "MORPHTARGETS");
        }
        if (defines.MULTIVIEW) {
          fallbacks.addFallback(0, "MULTIVIEW");
        }
        const attribs = [VertexBuffer.PositionKind];
        if (defines.NORMAL) {
          attribs.push(VertexBuffer.NormalKind);
        }
        if (defines.TANGENT) {
          attribs.push(VertexBuffer.TangentKind);
        }
        for (let i = 1; i <= 6; ++i) {
          if (defines["UV" + i]) {
            attribs.push(`uv${i === 1 ? "" : i}`);
          }
        }
        if (defines.VERTEXCOLOR) {
          attribs.push(VertexBuffer.ColorKind);
        }
        if (defines.INSTANCESCOLOR) {
          attribs.push(VertexBuffer.ColorInstanceKind);
        }
        MaterialHelper.PrepareAttributesForBones(attribs, mesh, defines, fallbacks);
        MaterialHelper.PrepareAttributesForInstances(attribs, defines);
        MaterialHelper.PrepareAttributesForMorphTargets(attribs, mesh, defines);
        MaterialHelper.PrepareAttributesForBakedVertexAnimation(attribs, mesh, defines);
        let shaderName = "pbr";
        const uniforms = [
          "world",
          "view",
          "viewProjection",
          "vEyePosition",
          "vLightsType",
          "vAmbientColor",
          "vAlbedoColor",
          "vReflectivityColor",
          "vMetallicReflectanceFactors",
          "vEmissiveColor",
          "visibility",
          "vReflectionColor",
          "vFogInfos",
          "vFogColor",
          "pointSize",
          "vAlbedoInfos",
          "vAmbientInfos",
          "vOpacityInfos",
          "vReflectionInfos",
          "vReflectionPosition",
          "vReflectionSize",
          "vEmissiveInfos",
          "vReflectivityInfos",
          "vReflectionFilteringInfo",
          "vMetallicReflectanceInfos",
          "vReflectanceInfos",
          "vMicroSurfaceSamplerInfos",
          "vBumpInfos",
          "vLightmapInfos",
          "mBones",
          "albedoMatrix",
          "ambientMatrix",
          "opacityMatrix",
          "reflectionMatrix",
          "emissiveMatrix",
          "reflectivityMatrix",
          "normalMatrix",
          "microSurfaceSamplerMatrix",
          "bumpMatrix",
          "lightmapMatrix",
          "metallicReflectanceMatrix",
          "reflectanceMatrix",
          "vLightingIntensity",
          "logarithmicDepthConstant",
          "vSphericalX",
          "vSphericalY",
          "vSphericalZ",
          "vSphericalXX_ZZ",
          "vSphericalYY_ZZ",
          "vSphericalZZ",
          "vSphericalXY",
          "vSphericalYZ",
          "vSphericalZX",
          "vSphericalL00",
          "vSphericalL1_1",
          "vSphericalL10",
          "vSphericalL11",
          "vSphericalL2_2",
          "vSphericalL2_1",
          "vSphericalL20",
          "vSphericalL21",
          "vSphericalL22",
          "vReflectionMicrosurfaceInfos",
          "vTangentSpaceParams",
          "boneTextureWidth",
          "vDebugMode",
          "morphTargetTextureInfo",
          "morphTargetTextureIndices"
        ];
        const samplers = [
          "albedoSampler",
          "reflectivitySampler",
          "ambientSampler",
          "emissiveSampler",
          "bumpSampler",
          "lightmapSampler",
          "opacitySampler",
          "reflectionSampler",
          "reflectionSamplerLow",
          "reflectionSamplerHigh",
          "irradianceSampler",
          "microSurfaceSampler",
          "environmentBrdfSampler",
          "boneSampler",
          "metallicReflectanceSampler",
          "reflectanceSampler",
          "morphTargets",
          "oitDepthSampler",
          "oitFrontColorSampler"
        ];
        const uniformBuffers = ["Material", "Scene", "Mesh"];
        const indexParameters = { maxSimultaneousLights: this._maxSimultaneousLights, maxSimultaneousMorphTargets: defines.NUM_MORPH_INFLUENCERS };
        this._eventInfo.fallbacks = fallbacks;
        this._eventInfo.fallbackRank = fallbackRank;
        this._eventInfo.defines = defines;
        this._eventInfo.uniforms = uniforms;
        this._eventInfo.attributes = attribs;
        this._eventInfo.samplers = samplers;
        this._eventInfo.uniformBuffersNames = uniformBuffers;
        this._eventInfo.customCode = void 0;
        this._eventInfo.mesh = mesh;
        this._eventInfo.indexParameters = indexParameters;
        this._callbackPluginEventGeneric(MaterialPluginEvent.PrepareEffect, this._eventInfo);
        PrePassConfiguration.AddUniforms(uniforms);
        PrePassConfiguration.AddSamplers(samplers);
        addClipPlaneUniforms(uniforms);
        if (ImageProcessingConfiguration) {
          ImageProcessingConfiguration.PrepareUniforms(uniforms, defines);
          ImageProcessingConfiguration.PrepareSamplers(samplers, defines);
        }
        MaterialHelper.PrepareUniformsAndSamplersList({
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines,
          maxSimultaneousLights: this._maxSimultaneousLights
        });
        const csnrOptions = {};
        if (this.customShaderNameResolve) {
          shaderName = this.customShaderNameResolve(shaderName, uniforms, uniformBuffers, samplers, defines, attribs, csnrOptions);
        }
        const join = defines.toString();
        const effect = engine.createEffect(shaderName, {
          attributes: attribs,
          uniformsNames: uniforms,
          uniformBuffersNames: uniformBuffers,
          samplers,
          defines: join,
          fallbacks,
          onCompiled,
          onError,
          indexParameters,
          processFinalCode: csnrOptions.processFinalCode,
          processCodeAfterIncludes: this._eventInfo.customCode,
          multiTarget: defines.PREPASS
        }, engine);
        this._eventInfo.customCode = void 0;
        return effect;
      }
      _prepareDefines(mesh, defines, useInstances = null, useClipPlane = null, useThinInstances = false) {
        var _a;
        const scene = this.getScene();
        const engine = scene.getEngine();
        MaterialHelper.PrepareDefinesForLights(scene, mesh, defines, true, this._maxSimultaneousLights, this._disableLighting);
        defines._needNormals = true;
        MaterialHelper.PrepareDefinesForMultiview(scene, defines);
        const oit = this.needAlphaBlendingForMesh(mesh) && this.getScene().useOrderIndependentTransparency;
        MaterialHelper.PrepareDefinesForPrePass(scene, defines, this.canRenderToMRT && !oit);
        MaterialHelper.PrepareDefinesForOIT(scene, defines, oit);
        defines.METALLICWORKFLOW = this.isMetallicWorkflow();
        if (defines._areTexturesDirty) {
          defines._needUVs = false;
          for (let i = 1; i <= 6; ++i) {
            defines["MAINUV" + i] = false;
          }
          if (scene.texturesEnabled) {
            defines.ALBEDODIRECTUV = 0;
            defines.AMBIENTDIRECTUV = 0;
            defines.OPACITYDIRECTUV = 0;
            defines.EMISSIVEDIRECTUV = 0;
            defines.REFLECTIVITYDIRECTUV = 0;
            defines.MICROSURFACEMAPDIRECTUV = 0;
            defines.METALLIC_REFLECTANCEDIRECTUV = 0;
            defines.REFLECTANCEDIRECTUV = 0;
            defines.BUMPDIRECTUV = 0;
            defines.LIGHTMAPDIRECTUV = 0;
            if (engine.getCaps().textureLOD) {
              defines.LODBASEDMICROSFURACE = true;
            }
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._albedoTexture, defines, "ALBEDO");
              defines.GAMMAALBEDO = this._albedoTexture.gammaSpace;
            } else {
              defines.ALBEDO = false;
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._ambientTexture, defines, "AMBIENT");
              defines.AMBIENTINGRAYSCALE = this._useAmbientInGrayScale;
            } else {
              defines.AMBIENT = false;
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._opacityTexture, defines, "OPACITY");
              defines.OPACITYRGB = this._opacityTexture.getAlphaFromRGB;
            } else {
              defines.OPACITY = false;
            }
            const reflectionTexture = this._getReflectionTexture();
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.REFLECTION = true;
              defines.GAMMAREFLECTION = reflectionTexture.gammaSpace;
              defines.RGBDREFLECTION = reflectionTexture.isRGBD;
              defines.LODINREFLECTIONALPHA = reflectionTexture.lodLevelInAlpha;
              defines.LINEARSPECULARREFLECTION = reflectionTexture.linearSpecularLOD;
              if (this.realTimeFiltering && this.realTimeFilteringQuality > 0) {
                defines.NUM_SAMPLES = "" + this.realTimeFilteringQuality;
                if (engine._features.needTypeSuffixInShaderConstants) {
                  defines.NUM_SAMPLES = defines.NUM_SAMPLES + "u";
                }
                defines.REALTIME_FILTERING = true;
              } else {
                defines.REALTIME_FILTERING = false;
              }
              defines.INVERTCUBICMAP = reflectionTexture.coordinatesMode === Texture.INVCUBIC_MODE;
              defines.REFLECTIONMAP_3D = reflectionTexture.isCube;
              defines.REFLECTIONMAP_OPPOSITEZ = defines.REFLECTIONMAP_3D && this.getScene().useRightHandedSystem ? !reflectionTexture.invertZ : reflectionTexture.invertZ;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              switch (reflectionTexture.coordinatesMode) {
                case Texture.EXPLICIT_MODE:
                  defines.REFLECTIONMAP_EXPLICIT = true;
                  break;
                case Texture.PLANAR_MODE:
                  defines.REFLECTIONMAP_PLANAR = true;
                  break;
                case Texture.PROJECTION_MODE:
                  defines.REFLECTIONMAP_PROJECTION = true;
                  break;
                case Texture.SKYBOX_MODE:
                  defines.REFLECTIONMAP_SKYBOX = true;
                  break;
                case Texture.SPHERICAL_MODE:
                  defines.REFLECTIONMAP_SPHERICAL = true;
                  break;
                case Texture.EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MODE:
                  defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.FIXED_EQUIRECTANGULAR_MIRRORED_MODE:
                  defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = true;
                  break;
                case Texture.CUBIC_MODE:
                case Texture.INVCUBIC_MODE:
                default:
                  defines.REFLECTIONMAP_CUBIC = true;
                  defines.USE_LOCAL_REFLECTIONMAP_CUBIC = reflectionTexture.boundingBoxSize ? true : false;
                  break;
              }
              if (reflectionTexture.coordinatesMode !== Texture.SKYBOX_MODE) {
                if (reflectionTexture.irradianceTexture) {
                  defines.USEIRRADIANCEMAP = true;
                  defines.USESPHERICALFROMREFLECTIONMAP = false;
                } else if (reflectionTexture.isCube) {
                  defines.USESPHERICALFROMREFLECTIONMAP = true;
                  defines.USEIRRADIANCEMAP = false;
                  if (this._forceIrradianceInFragment || this.realTimeFiltering || engine.getCaps().maxVaryingVectors <= 8) {
                    defines.USESPHERICALINVERTEX = false;
                  } else {
                    defines.USESPHERICALINVERTEX = true;
                  }
                }
              }
            } else {
              defines.REFLECTION = false;
              defines.REFLECTIONMAP_3D = false;
              defines.REFLECTIONMAP_SPHERICAL = false;
              defines.REFLECTIONMAP_PLANAR = false;
              defines.REFLECTIONMAP_CUBIC = false;
              defines.USE_LOCAL_REFLECTIONMAP_CUBIC = false;
              defines.REFLECTIONMAP_PROJECTION = false;
              defines.REFLECTIONMAP_SKYBOX = false;
              defines.REFLECTIONMAP_EXPLICIT = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR = false;
              defines.REFLECTIONMAP_EQUIRECTANGULAR_FIXED = false;
              defines.REFLECTIONMAP_MIRROREDEQUIRECTANGULAR_FIXED = false;
              defines.INVERTCUBICMAP = false;
              defines.USESPHERICALFROMREFLECTIONMAP = false;
              defines.USEIRRADIANCEMAP = false;
              defines.USESPHERICALINVERTEX = false;
              defines.REFLECTIONMAP_OPPOSITEZ = false;
              defines.LODINREFLECTIONALPHA = false;
              defines.GAMMAREFLECTION = false;
              defines.RGBDREFLECTION = false;
              defines.LINEARSPECULARREFLECTION = false;
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._lightmapTexture, defines, "LIGHTMAP");
              defines.USELIGHTMAPASSHADOWMAP = this._useLightmapAsShadowmap;
              defines.GAMMALIGHTMAP = this._lightmapTexture.gammaSpace;
              defines.RGBDLIGHTMAP = this._lightmapTexture.isRGBD;
            } else {
              defines.LIGHTMAP = false;
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              MaterialHelper.PrepareDefinesForMergedUV(this._emissiveTexture, defines, "EMISSIVE");
              defines.GAMMAEMISSIVE = this._emissiveTexture.gammaSpace;
            } else {
              defines.EMISSIVE = false;
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._metallicTexture, defines, "REFLECTIVITY");
                defines.ROUGHNESSSTOREINMETALMAPALPHA = this._useRoughnessFromMetallicTextureAlpha;
                defines.ROUGHNESSSTOREINMETALMAPGREEN = !this._useRoughnessFromMetallicTextureAlpha && this._useRoughnessFromMetallicTextureGreen;
                defines.METALLNESSSTOREINMETALMAPBLUE = this._useMetallnessFromMetallicTextureBlue;
                defines.AOSTOREINMETALMAPRED = this._useAmbientOcclusionFromMetallicTextureRed;
                defines.REFLECTIVITY_GAMMA = false;
              } else if (this._reflectivityTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._reflectivityTexture, defines, "REFLECTIVITY");
                defines.MICROSURFACEFROMREFLECTIVITYMAP = this._useMicroSurfaceFromReflectivityMapAlpha;
                defines.MICROSURFACEAUTOMATIC = this._useAutoMicroSurfaceFromReflectivityMap;
                defines.REFLECTIVITY_GAMMA = this._reflectivityTexture.gammaSpace;
              } else {
                defines.REFLECTIVITY = false;
              }
              if (this._metallicReflectanceTexture || this._reflectanceTexture) {
                const identicalTextures = this._metallicReflectanceTexture !== null && this._metallicReflectanceTexture._texture === ((_a = this._reflectanceTexture) === null || _a === void 0 ? void 0 : _a._texture) && this._metallicReflectanceTexture.checkTransformsAreIdentical(this._reflectanceTexture);
                defines.METALLIC_REFLECTANCE_USE_ALPHA_ONLY = this._useOnlyMetallicFromMetallicReflectanceTexture && !identicalTextures;
                if (this._metallicReflectanceTexture) {
                  MaterialHelper.PrepareDefinesForMergedUV(this._metallicReflectanceTexture, defines, "METALLIC_REFLECTANCE");
                  defines.METALLIC_REFLECTANCE_GAMMA = this._metallicReflectanceTexture.gammaSpace;
                } else {
                  defines.METALLIC_REFLECTANCE = false;
                }
                if (this._reflectanceTexture && !identicalTextures && (!this._metallicReflectanceTexture || this._metallicReflectanceTexture && this._useOnlyMetallicFromMetallicReflectanceTexture)) {
                  MaterialHelper.PrepareDefinesForMergedUV(this._reflectanceTexture, defines, "REFLECTANCE");
                  defines.REFLECTANCE_GAMMA = this._reflectanceTexture.gammaSpace;
                } else {
                  defines.REFLECTANCE = false;
                }
              } else {
                defines.METALLIC_REFLECTANCE = false;
                defines.REFLECTANCE = false;
              }
              if (this._microSurfaceTexture) {
                MaterialHelper.PrepareDefinesForMergedUV(this._microSurfaceTexture, defines, "MICROSURFACEMAP");
              } else {
                defines.MICROSURFACEMAP = false;
              }
            } else {
              defines.REFLECTIVITY = false;
              defines.MICROSURFACEMAP = false;
            }
            if (engine.getCaps().standardDerivatives && this._bumpTexture && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              MaterialHelper.PrepareDefinesForMergedUV(this._bumpTexture, defines, "BUMP");
              if (this._useParallax && this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                defines.PARALLAX = true;
                defines.PARALLAXOCCLUSION = !!this._useParallaxOcclusion;
              } else {
                defines.PARALLAX = false;
              }
              defines.OBJECTSPACE_NORMALMAP = this._useObjectSpaceNormalMap;
            } else {
              defines.BUMP = false;
              defines.PARALLAX = false;
              defines.PARALLAXOCCLUSION = false;
              defines.OBJECTSPACE_NORMALMAP = false;
            }
            if (this._environmentBRDFTexture && MaterialFlags.ReflectionTextureEnabled) {
              defines.ENVIRONMENTBRDF = true;
              defines.ENVIRONMENTBRDF_RGBD = this._environmentBRDFTexture.isRGBD;
            } else {
              defines.ENVIRONMENTBRDF = false;
              defines.ENVIRONMENTBRDF_RGBD = false;
            }
            if (this._shouldUseAlphaFromAlbedoTexture()) {
              defines.ALPHAFROMALBEDO = true;
            } else {
              defines.ALPHAFROMALBEDO = false;
            }
          }
          defines.SPECULAROVERALPHA = this._useSpecularOverAlpha;
          if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_STANDARD) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = false;
          } else if (this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF) {
            defines.USEPHYSICALLIGHTFALLOFF = false;
            defines.USEGLTFLIGHTFALLOFF = true;
          } else {
            defines.USEPHYSICALLIGHTFALLOFF = true;
            defines.USEGLTFLIGHTFALLOFF = false;
          }
          defines.RADIANCEOVERALPHA = this._useRadianceOverAlpha;
          if (!this.backFaceCulling && this._twoSidedLighting) {
            defines.TWOSIDEDLIGHTING = true;
          } else {
            defines.TWOSIDEDLIGHTING = false;
          }
          defines.SPECULARAA = engine.getCaps().standardDerivatives && this._enableSpecularAntiAliasing;
        }
        if (defines._areTexturesDirty || defines._areMiscDirty) {
          defines.ALPHATESTVALUE = `${this._alphaCutOff}${this._alphaCutOff % 1 === 0 ? "." : ""}`;
          defines.PREMULTIPLYALPHA = this.alphaMode === 7 || this.alphaMode === 8;
          defines.ALPHABLEND = this.needAlphaBlendingForMesh(mesh);
          defines.ALPHAFRESNEL = this._useAlphaFresnel || this._useLinearAlphaFresnel;
          defines.LINEARALPHAFRESNEL = this._useLinearAlphaFresnel;
        }
        if (defines._areImageProcessingDirty && this._imageProcessingConfiguration) {
          this._imageProcessingConfiguration.prepareDefines(defines);
        }
        defines.FORCENORMALFORWARD = this._forceNormalForward;
        defines.RADIANCEOCCLUSION = this._useRadianceOcclusion;
        defines.HORIZONOCCLUSION = this._useHorizonOcclusion;
        if (defines._areMiscDirty) {
          MaterialHelper.PrepareDefinesForMisc(mesh, scene, this._useLogarithmicDepth, this.pointsCloud, this.fogEnabled, this._shouldTurnAlphaTestOn(mesh) || this._forceAlphaTest, defines, this._applyDecalMapAfterDetailMap);
          defines.UNLIT = this._unlit || (this.pointsCloud || this.wireframe) && !mesh.isVerticesDataPresent(VertexBuffer.NormalKind);
          defines.DEBUGMODE = this._debugMode;
        }
        MaterialHelper.PrepareDefinesForFrameBoundValues(scene, engine, this, defines, useInstances ? true : false, useClipPlane, useThinInstances);
        this._eventInfo.defines = defines;
        this._eventInfo.mesh = mesh;
        this._callbackPluginEventPrepareDefinesBeforeAttributes(this._eventInfo);
        MaterialHelper.PrepareDefinesForAttributes(mesh, defines, true, true, true, this._transparencyMode !== PBRBaseMaterial.PBRMATERIAL_OPAQUE);
        this._callbackPluginEventPrepareDefines(this._eventInfo);
      }
      forceCompilation(mesh, onCompiled, options) {
        const localOptions = Object.assign({ clipPlane: false, useInstances: false }, options);
        if (!this._uniformBufferLayoutBuilt) {
          this.buildUniformLayout();
        }
        this._callbackPluginEventGeneric(MaterialPluginEvent.GetDefineNames, this._eventInfo);
        const defines = new PBRMaterialDefines(this._eventInfo.defineNames);
        const effect = this._prepareEffect(mesh, defines, void 0, void 0, localOptions.useInstances, localOptions.clipPlane, mesh.hasThinInstances);
        if (this._onEffectCreatedObservable) {
          onCreatedEffectParameters3.effect = effect;
          onCreatedEffectParameters3.subMesh = null;
          this._onEffectCreatedObservable.notifyObservers(onCreatedEffectParameters3);
        }
        if (effect.isReady()) {
          if (onCompiled) {
            onCompiled(this);
          }
        } else {
          effect.onCompileObservable.add(() => {
            if (onCompiled) {
              onCompiled(this);
            }
          });
        }
      }
      buildUniformLayout() {
        const ubo = this._uniformBuffer;
        ubo.addUniform("vAlbedoInfos", 2);
        ubo.addUniform("vAmbientInfos", 4);
        ubo.addUniform("vOpacityInfos", 2);
        ubo.addUniform("vEmissiveInfos", 2);
        ubo.addUniform("vLightmapInfos", 2);
        ubo.addUniform("vReflectivityInfos", 3);
        ubo.addUniform("vMicroSurfaceSamplerInfos", 2);
        ubo.addUniform("vReflectionInfos", 2);
        ubo.addUniform("vReflectionFilteringInfo", 2);
        ubo.addUniform("vReflectionPosition", 3);
        ubo.addUniform("vReflectionSize", 3);
        ubo.addUniform("vBumpInfos", 3);
        ubo.addUniform("albedoMatrix", 16);
        ubo.addUniform("ambientMatrix", 16);
        ubo.addUniform("opacityMatrix", 16);
        ubo.addUniform("emissiveMatrix", 16);
        ubo.addUniform("lightmapMatrix", 16);
        ubo.addUniform("reflectivityMatrix", 16);
        ubo.addUniform("microSurfaceSamplerMatrix", 16);
        ubo.addUniform("bumpMatrix", 16);
        ubo.addUniform("vTangentSpaceParams", 2);
        ubo.addUniform("reflectionMatrix", 16);
        ubo.addUniform("vReflectionColor", 3);
        ubo.addUniform("vAlbedoColor", 4);
        ubo.addUniform("vLightingIntensity", 4);
        ubo.addUniform("vReflectionMicrosurfaceInfos", 3);
        ubo.addUniform("pointSize", 1);
        ubo.addUniform("vReflectivityColor", 4);
        ubo.addUniform("vEmissiveColor", 3);
        ubo.addUniform("vAmbientColor", 3);
        ubo.addUniform("vDebugMode", 2);
        ubo.addUniform("vMetallicReflectanceFactors", 4);
        ubo.addUniform("vMetallicReflectanceInfos", 2);
        ubo.addUniform("metallicReflectanceMatrix", 16);
        ubo.addUniform("vReflectanceInfos", 2);
        ubo.addUniform("reflectanceMatrix", 16);
        ubo.addUniform("vSphericalL00", 3);
        ubo.addUniform("vSphericalL1_1", 3);
        ubo.addUniform("vSphericalL10", 3);
        ubo.addUniform("vSphericalL11", 3);
        ubo.addUniform("vSphericalL2_2", 3);
        ubo.addUniform("vSphericalL2_1", 3);
        ubo.addUniform("vSphericalL20", 3);
        ubo.addUniform("vSphericalL21", 3);
        ubo.addUniform("vSphericalL22", 3);
        ubo.addUniform("vSphericalX", 3);
        ubo.addUniform("vSphericalY", 3);
        ubo.addUniform("vSphericalZ", 3);
        ubo.addUniform("vSphericalXX_ZZ", 3);
        ubo.addUniform("vSphericalYY_ZZ", 3);
        ubo.addUniform("vSphericalZZ", 3);
        ubo.addUniform("vSphericalXY", 3);
        ubo.addUniform("vSphericalYZ", 3);
        ubo.addUniform("vSphericalZX", 3);
        super.buildUniformLayout();
      }
      bindForSubMesh(world, mesh, subMesh) {
        var _a, _b, _c, _d;
        const scene = this.getScene();
        const defines = subMesh.materialDefines;
        if (!defines) {
          return;
        }
        const effect = subMesh.effect;
        if (!effect) {
          return;
        }
        this._activeEffect = effect;
        mesh.getMeshUniformBuffer().bindToEffect(effect, "Mesh");
        mesh.transferToEffect(world);
        const engine = scene.getEngine();
        this._uniformBuffer.bindToEffect(effect, "Material");
        this.prePassConfiguration.bindForSubMesh(this._activeEffect, scene, mesh, world, this.isFrozen);
        this._eventInfo.subMesh = subMesh;
        this._callbackPluginEventHardBindForSubMesh(this._eventInfo);
        if (defines.OBJECTSPACE_NORMALMAP) {
          world.toNormalMatrix(this._normalMatrix);
          this.bindOnlyNormalMatrix(this._normalMatrix);
        }
        const mustRebind = effect._forceRebindOnNextCall || this._mustRebind(scene, effect, mesh.visibility);
        MaterialHelper.BindBonesParameters(mesh, this._activeEffect, this.prePassConfiguration);
        let reflectionTexture = null;
        const ubo = this._uniformBuffer;
        if (mustRebind) {
          this.bindViewProjection(effect);
          reflectionTexture = this._getReflectionTexture();
          if (!ubo.useUbo || !this.isFrozen || !ubo.isSync || effect._forceRebindOnNextCall) {
            if (scene.texturesEnabled) {
              if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
                ubo.updateFloat2("vAlbedoInfos", this._albedoTexture.coordinatesIndex, this._albedoTexture.level);
                MaterialHelper.BindTextureMatrix(this._albedoTexture, ubo, "albedo");
              }
              if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
                ubo.updateFloat4("vAmbientInfos", this._ambientTexture.coordinatesIndex, this._ambientTexture.level, this._ambientTextureStrength, this._ambientTextureImpactOnAnalyticalLights);
                MaterialHelper.BindTextureMatrix(this._ambientTexture, ubo, "ambient");
              }
              if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
                ubo.updateFloat2("vOpacityInfos", this._opacityTexture.coordinatesIndex, this._opacityTexture.level);
                MaterialHelper.BindTextureMatrix(this._opacityTexture, ubo, "opacity");
              }
              if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
                ubo.updateMatrix("reflectionMatrix", reflectionTexture.getReflectionTextureMatrix());
                ubo.updateFloat2("vReflectionInfos", reflectionTexture.level, 0);
                if (reflectionTexture.boundingBoxSize) {
                  const cubeTexture = reflectionTexture;
                  ubo.updateVector3("vReflectionPosition", cubeTexture.boundingBoxPosition);
                  ubo.updateVector3("vReflectionSize", cubeTexture.boundingBoxSize);
                }
                if (this.realTimeFiltering) {
                  const width = reflectionTexture.getSize().width;
                  ubo.updateFloat2("vReflectionFilteringInfo", width, Scalar.Log2(width));
                }
                if (!defines.USEIRRADIANCEMAP) {
                  const polynomials = reflectionTexture.sphericalPolynomial;
                  if (defines.USESPHERICALFROMREFLECTIONMAP && polynomials) {
                    if (defines.SPHERICAL_HARMONICS) {
                      const preScaledHarmonics = polynomials.preScaledHarmonics;
                      ubo.updateVector3("vSphericalL00", preScaledHarmonics.l00);
                      ubo.updateVector3("vSphericalL1_1", preScaledHarmonics.l1_1);
                      ubo.updateVector3("vSphericalL10", preScaledHarmonics.l10);
                      ubo.updateVector3("vSphericalL11", preScaledHarmonics.l11);
                      ubo.updateVector3("vSphericalL2_2", preScaledHarmonics.l2_2);
                      ubo.updateVector3("vSphericalL2_1", preScaledHarmonics.l2_1);
                      ubo.updateVector3("vSphericalL20", preScaledHarmonics.l20);
                      ubo.updateVector3("vSphericalL21", preScaledHarmonics.l21);
                      ubo.updateVector3("vSphericalL22", preScaledHarmonics.l22);
                    } else {
                      ubo.updateFloat3("vSphericalX", polynomials.x.x, polynomials.x.y, polynomials.x.z);
                      ubo.updateFloat3("vSphericalY", polynomials.y.x, polynomials.y.y, polynomials.y.z);
                      ubo.updateFloat3("vSphericalZ", polynomials.z.x, polynomials.z.y, polynomials.z.z);
                      ubo.updateFloat3("vSphericalXX_ZZ", polynomials.xx.x - polynomials.zz.x, polynomials.xx.y - polynomials.zz.y, polynomials.xx.z - polynomials.zz.z);
                      ubo.updateFloat3("vSphericalYY_ZZ", polynomials.yy.x - polynomials.zz.x, polynomials.yy.y - polynomials.zz.y, polynomials.yy.z - polynomials.zz.z);
                      ubo.updateFloat3("vSphericalZZ", polynomials.zz.x, polynomials.zz.y, polynomials.zz.z);
                      ubo.updateFloat3("vSphericalXY", polynomials.xy.x, polynomials.xy.y, polynomials.xy.z);
                      ubo.updateFloat3("vSphericalYZ", polynomials.yz.x, polynomials.yz.y, polynomials.yz.z);
                      ubo.updateFloat3("vSphericalZX", polynomials.zx.x, polynomials.zx.y, polynomials.zx.z);
                    }
                  }
                }
                ubo.updateFloat3("vReflectionMicrosurfaceInfos", reflectionTexture.getSize().width, reflectionTexture.lodGenerationScale, reflectionTexture.lodGenerationOffset);
              }
              if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
                ubo.updateFloat2("vEmissiveInfos", this._emissiveTexture.coordinatesIndex, this._emissiveTexture.level);
                MaterialHelper.BindTextureMatrix(this._emissiveTexture, ubo, "emissive");
              }
              if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
                ubo.updateFloat2("vLightmapInfos", this._lightmapTexture.coordinatesIndex, this._lightmapTexture.level);
                MaterialHelper.BindTextureMatrix(this._lightmapTexture, ubo, "lightmap");
              }
              if (MaterialFlags.SpecularTextureEnabled) {
                if (this._metallicTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._metallicTexture.coordinatesIndex, this._metallicTexture.level, this._ambientTextureStrength);
                  MaterialHelper.BindTextureMatrix(this._metallicTexture, ubo, "reflectivity");
                } else if (this._reflectivityTexture) {
                  ubo.updateFloat3("vReflectivityInfos", this._reflectivityTexture.coordinatesIndex, this._reflectivityTexture.level, 1);
                  MaterialHelper.BindTextureMatrix(this._reflectivityTexture, ubo, "reflectivity");
                }
                if (this._metallicReflectanceTexture) {
                  ubo.updateFloat2("vMetallicReflectanceInfos", this._metallicReflectanceTexture.coordinatesIndex, this._metallicReflectanceTexture.level);
                  MaterialHelper.BindTextureMatrix(this._metallicReflectanceTexture, ubo, "metallicReflectance");
                }
                if (this._reflectanceTexture && defines.REFLECTANCE) {
                  ubo.updateFloat2("vReflectanceInfos", this._reflectanceTexture.coordinatesIndex, this._reflectanceTexture.level);
                  MaterialHelper.BindTextureMatrix(this._reflectanceTexture, ubo, "reflectance");
                }
                if (this._microSurfaceTexture) {
                  ubo.updateFloat2("vMicroSurfaceSamplerInfos", this._microSurfaceTexture.coordinatesIndex, this._microSurfaceTexture.level);
                  MaterialHelper.BindTextureMatrix(this._microSurfaceTexture, ubo, "microSurfaceSampler");
                }
              }
              if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
                ubo.updateFloat3("vBumpInfos", this._bumpTexture.coordinatesIndex, this._bumpTexture.level, this._parallaxScaleBias);
                MaterialHelper.BindTextureMatrix(this._bumpTexture, ubo, "bump");
                if (scene._mirroredCameraPosition) {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? 1 : -1, this._invertNormalMapY ? 1 : -1);
                } else {
                  ubo.updateFloat2("vTangentSpaceParams", this._invertNormalMapX ? -1 : 1, this._invertNormalMapY ? -1 : 1);
                }
              }
            }
            if (this.pointsCloud) {
              ubo.updateFloat("pointSize", this.pointSize);
            }
            if (defines.METALLICWORKFLOW) {
              TmpColors.Color3[0].r = this._metallic === void 0 || this._metallic === null ? 1 : this._metallic;
              TmpColors.Color3[0].g = this._roughness === void 0 || this._roughness === null ? 1 : this._roughness;
              ubo.updateColor4("vReflectivityColor", TmpColors.Color3[0], 1);
              const ior = (_b = (_a = this.subSurface) === null || _a === void 0 ? void 0 : _a._indexOfRefraction) !== null && _b !== void 0 ? _b : 1.5;
              const outsideIOR = 1;
              const f0 = Math.pow((ior - outsideIOR) / (ior + outsideIOR), 2);
              this._metallicReflectanceColor.scaleToRef(f0 * this._metallicF0Factor, TmpColors.Color3[0]);
              const metallicF90 = this._metallicF0Factor;
              ubo.updateColor4("vMetallicReflectanceFactors", TmpColors.Color3[0], metallicF90);
            } else {
              ubo.updateColor4("vReflectivityColor", this._reflectivityColor, this._microSurface);
            }
            ubo.updateColor3("vEmissiveColor", MaterialFlags.EmissiveTextureEnabled ? this._emissiveColor : Color3.BlackReadOnly);
            ubo.updateColor3("vReflectionColor", this._reflectionColor);
            if (!defines.SS_REFRACTION && ((_c = this.subSurface) === null || _c === void 0 ? void 0 : _c._linkRefractionWithTransparency)) {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, 1);
            } else {
              ubo.updateColor4("vAlbedoColor", this._albedoColor, this.alpha);
            }
            this._lightingInfos.x = this._directIntensity;
            this._lightingInfos.y = this._emissiveIntensity;
            this._lightingInfos.z = this._environmentIntensity * scene.environmentIntensity;
            this._lightingInfos.w = this._specularIntensity;
            ubo.updateVector4("vLightingIntensity", this._lightingInfos);
            scene.ambientColor.multiplyToRef(this._ambientColor, this._globalAmbientColor);
            ubo.updateColor3("vAmbientColor", this._globalAmbientColor);
            ubo.updateFloat2("vDebugMode", this.debugLimit, this.debugFactor);
          }
          if (scene.texturesEnabled) {
            if (this._albedoTexture && MaterialFlags.DiffuseTextureEnabled) {
              ubo.setTexture("albedoSampler", this._albedoTexture);
            }
            if (this._ambientTexture && MaterialFlags.AmbientTextureEnabled) {
              ubo.setTexture("ambientSampler", this._ambientTexture);
            }
            if (this._opacityTexture && MaterialFlags.OpacityTextureEnabled) {
              ubo.setTexture("opacitySampler", this._opacityTexture);
            }
            if (reflectionTexture && MaterialFlags.ReflectionTextureEnabled) {
              if (defines.LODBASEDMICROSFURACE) {
                ubo.setTexture("reflectionSampler", reflectionTexture);
              } else {
                ubo.setTexture("reflectionSampler", reflectionTexture._lodTextureMid || reflectionTexture);
                ubo.setTexture("reflectionSamplerLow", reflectionTexture._lodTextureLow || reflectionTexture);
                ubo.setTexture("reflectionSamplerHigh", reflectionTexture._lodTextureHigh || reflectionTexture);
              }
              if (defines.USEIRRADIANCEMAP) {
                ubo.setTexture("irradianceSampler", reflectionTexture.irradianceTexture);
              }
            }
            if (defines.ENVIRONMENTBRDF) {
              ubo.setTexture("environmentBrdfSampler", this._environmentBRDFTexture);
            }
            if (this._emissiveTexture && MaterialFlags.EmissiveTextureEnabled) {
              ubo.setTexture("emissiveSampler", this._emissiveTexture);
            }
            if (this._lightmapTexture && MaterialFlags.LightmapTextureEnabled) {
              ubo.setTexture("lightmapSampler", this._lightmapTexture);
            }
            if (MaterialFlags.SpecularTextureEnabled) {
              if (this._metallicTexture) {
                ubo.setTexture("reflectivitySampler", this._metallicTexture);
              } else if (this._reflectivityTexture) {
                ubo.setTexture("reflectivitySampler", this._reflectivityTexture);
              }
              if (this._metallicReflectanceTexture) {
                ubo.setTexture("metallicReflectanceSampler", this._metallicReflectanceTexture);
              }
              if (this._reflectanceTexture && defines.REFLECTANCE) {
                ubo.setTexture("reflectanceSampler", this._reflectanceTexture);
              }
              if (this._microSurfaceTexture) {
                ubo.setTexture("microSurfaceSampler", this._microSurfaceTexture);
              }
            }
            if (this._bumpTexture && engine.getCaps().standardDerivatives && MaterialFlags.BumpTextureEnabled && !this._disableBumpMap) {
              ubo.setTexture("bumpSampler", this._bumpTexture);
            }
          }
          if (this.getScene().useOrderIndependentTransparency && this.needAlphaBlendingForMesh(mesh)) {
            this.getScene().depthPeelingRenderer.bind(effect);
          }
          this._eventInfo.subMesh = subMesh;
          this._callbackPluginEventBindForSubMesh(this._eventInfo);
          bindClipPlane(this._activeEffect, this, scene);
          this.bindEyePosition(effect);
        } else if (scene.getEngine()._features.needToAlwaysBindUniformBuffers) {
          this._needToBindSceneUbo = true;
        }
        if (mustRebind || !this.isFrozen) {
          if (scene.lightsEnabled && !this._disableLighting) {
            MaterialHelper.BindLights(scene, mesh, this._activeEffect, defines, this._maxSimultaneousLights);
          }
          if (scene.fogEnabled && mesh.applyFog && scene.fogMode !== Scene.FOGMODE_NONE || reflectionTexture || mesh.receiveShadows || defines.PREPASS) {
            this.bindView(effect);
          }
          MaterialHelper.BindFogParameters(scene, mesh, this._activeEffect, true);
          if (defines.NUM_MORPH_INFLUENCERS) {
            MaterialHelper.BindMorphTargetParameters(mesh, this._activeEffect);
          }
          if (defines.BAKED_VERTEX_ANIMATION_TEXTURE) {
            (_d = mesh.bakedVertexAnimationManager) === null || _d === void 0 ? void 0 : _d.bind(effect, defines.INSTANCES);
          }
          this._imageProcessingConfiguration.bind(this._activeEffect);
          MaterialHelper.BindLogDepth(defines, this._activeEffect, scene);
        }
        this._afterBind(mesh, this._activeEffect);
        ubo.update();
      }
      getAnimatables() {
        const results = super.getAnimatables();
        if (this._albedoTexture && this._albedoTexture.animations && this._albedoTexture.animations.length > 0) {
          results.push(this._albedoTexture);
        }
        if (this._ambientTexture && this._ambientTexture.animations && this._ambientTexture.animations.length > 0) {
          results.push(this._ambientTexture);
        }
        if (this._opacityTexture && this._opacityTexture.animations && this._opacityTexture.animations.length > 0) {
          results.push(this._opacityTexture);
        }
        if (this._reflectionTexture && this._reflectionTexture.animations && this._reflectionTexture.animations.length > 0) {
          results.push(this._reflectionTexture);
        }
        if (this._emissiveTexture && this._emissiveTexture.animations && this._emissiveTexture.animations.length > 0) {
          results.push(this._emissiveTexture);
        }
        if (this._metallicTexture && this._metallicTexture.animations && this._metallicTexture.animations.length > 0) {
          results.push(this._metallicTexture);
        } else if (this._reflectivityTexture && this._reflectivityTexture.animations && this._reflectivityTexture.animations.length > 0) {
          results.push(this._reflectivityTexture);
        }
        if (this._bumpTexture && this._bumpTexture.animations && this._bumpTexture.animations.length > 0) {
          results.push(this._bumpTexture);
        }
        if (this._lightmapTexture && this._lightmapTexture.animations && this._lightmapTexture.animations.length > 0) {
          results.push(this._lightmapTexture);
        }
        if (this._metallicReflectanceTexture && this._metallicReflectanceTexture.animations && this._metallicReflectanceTexture.animations.length > 0) {
          results.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture && this._reflectanceTexture.animations && this._reflectanceTexture.animations.length > 0) {
          results.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture && this._microSurfaceTexture.animations && this._microSurfaceTexture.animations.length > 0) {
          results.push(this._microSurfaceTexture);
        }
        return results;
      }
      _getReflectionTexture() {
        if (this._reflectionTexture) {
          return this._reflectionTexture;
        }
        return this.getScene().environmentTexture;
      }
      getActiveTextures() {
        const activeTextures = super.getActiveTextures();
        if (this._albedoTexture) {
          activeTextures.push(this._albedoTexture);
        }
        if (this._ambientTexture) {
          activeTextures.push(this._ambientTexture);
        }
        if (this._opacityTexture) {
          activeTextures.push(this._opacityTexture);
        }
        if (this._reflectionTexture) {
          activeTextures.push(this._reflectionTexture);
        }
        if (this._emissiveTexture) {
          activeTextures.push(this._emissiveTexture);
        }
        if (this._reflectivityTexture) {
          activeTextures.push(this._reflectivityTexture);
        }
        if (this._metallicTexture) {
          activeTextures.push(this._metallicTexture);
        }
        if (this._metallicReflectanceTexture) {
          activeTextures.push(this._metallicReflectanceTexture);
        }
        if (this._reflectanceTexture) {
          activeTextures.push(this._reflectanceTexture);
        }
        if (this._microSurfaceTexture) {
          activeTextures.push(this._microSurfaceTexture);
        }
        if (this._bumpTexture) {
          activeTextures.push(this._bumpTexture);
        }
        if (this._lightmapTexture) {
          activeTextures.push(this._lightmapTexture);
        }
        return activeTextures;
      }
      hasTexture(texture) {
        if (super.hasTexture(texture)) {
          return true;
        }
        if (this._albedoTexture === texture) {
          return true;
        }
        if (this._ambientTexture === texture) {
          return true;
        }
        if (this._opacityTexture === texture) {
          return true;
        }
        if (this._reflectionTexture === texture) {
          return true;
        }
        if (this._emissiveTexture === texture) {
          return true;
        }
        if (this._reflectivityTexture === texture) {
          return true;
        }
        if (this._metallicTexture === texture) {
          return true;
        }
        if (this._metallicReflectanceTexture === texture) {
          return true;
        }
        if (this._reflectanceTexture === texture) {
          return true;
        }
        if (this._microSurfaceTexture === texture) {
          return true;
        }
        if (this._bumpTexture === texture) {
          return true;
        }
        if (this._lightmapTexture === texture) {
          return true;
        }
        return false;
      }
      setPrePassRenderer() {
        var _a;
        if (!((_a = this.subSurface) === null || _a === void 0 ? void 0 : _a.isScatteringEnabled)) {
          return false;
        }
        const subSurfaceConfiguration = this.getScene().enableSubSurfaceForPrePass();
        if (subSurfaceConfiguration) {
          subSurfaceConfiguration.enabled = true;
        }
        return true;
      }
      dispose(forceDisposeEffect, forceDisposeTextures) {
        var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m;
        if (forceDisposeTextures) {
          if (this._environmentBRDFTexture && this.getScene().environmentBRDFTexture !== this._environmentBRDFTexture) {
            this._environmentBRDFTexture.dispose();
          }
          (_a = this._albedoTexture) === null || _a === void 0 ? void 0 : _a.dispose();
          (_b = this._ambientTexture) === null || _b === void 0 ? void 0 : _b.dispose();
          (_c = this._opacityTexture) === null || _c === void 0 ? void 0 : _c.dispose();
          (_d = this._reflectionTexture) === null || _d === void 0 ? void 0 : _d.dispose();
          (_e = this._emissiveTexture) === null || _e === void 0 ? void 0 : _e.dispose();
          (_f = this._metallicTexture) === null || _f === void 0 ? void 0 : _f.dispose();
          (_g = this._reflectivityTexture) === null || _g === void 0 ? void 0 : _g.dispose();
          (_h = this._bumpTexture) === null || _h === void 0 ? void 0 : _h.dispose();
          (_j = this._lightmapTexture) === null || _j === void 0 ? void 0 : _j.dispose();
          (_k = this._metallicReflectanceTexture) === null || _k === void 0 ? void 0 : _k.dispose();
          (_l = this._reflectanceTexture) === null || _l === void 0 ? void 0 : _l.dispose();
          (_m = this._microSurfaceTexture) === null || _m === void 0 ? void 0 : _m.dispose();
        }
        this._renderTargets.dispose();
        if (this._imageProcessingConfiguration && this._imageProcessingObserver) {
          this._imageProcessingConfiguration.onUpdateParameters.remove(this._imageProcessingObserver);
        }
        super.dispose(forceDisposeEffect, forceDisposeTextures);
      }
    };
    PBRBaseMaterial.PBRMATERIAL_OPAQUE = Material.MATERIAL_OPAQUE;
    PBRBaseMaterial.PBRMATERIAL_ALPHATEST = Material.MATERIAL_ALPHATEST;
    PBRBaseMaterial.PBRMATERIAL_ALPHABLEND = Material.MATERIAL_ALPHABLEND;
    PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND = Material.MATERIAL_ALPHATESTANDBLEND;
    PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = 0;
    PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL = 0;
    PBRBaseMaterial.LIGHTFALLOFF_GLTF = 1;
    PBRBaseMaterial.LIGHTFALLOFF_STANDARD = 2;
    __decorate([
      serializeAsImageProcessingConfiguration()
    ], PBRBaseMaterial.prototype, "_imageProcessingConfiguration", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRBaseMaterial.prototype, "debugMode", void 0);
    __decorate([
      serialize()
    ], PBRBaseMaterial.prototype, "useLogarithmicDepth", null);
  }
});

// node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js
var PBRMaterial;
var init_pbrMaterial = __esm({
  "node_modules/@babylonjs/core/Materials/PBR/pbrMaterial.js"() {
    init_tslib_es6();
    init_decorators();
    init_brdfTextureTools();
    init_math_color();
    init_pbrBaseMaterial();
    init_typeStore();
    init_material();
    PBRMaterial = class extends PBRBaseMaterial {
      get refractionTexture() {
        return this.subSurface.refractionTexture;
      }
      set refractionTexture(value) {
        this.subSurface.refractionTexture = value;
        if (value) {
          this.subSurface.isRefractionEnabled = true;
        } else if (!this.subSurface.linkRefractionWithTransparency) {
          this.subSurface.isRefractionEnabled = false;
        }
      }
      get indexOfRefraction() {
        return this.subSurface.indexOfRefraction;
      }
      set indexOfRefraction(value) {
        this.subSurface.indexOfRefraction = value;
      }
      get invertRefractionY() {
        return this.subSurface.invertRefractionY;
      }
      set invertRefractionY(value) {
        this.subSurface.invertRefractionY = value;
      }
      get linkRefractionWithTransparency() {
        return this.subSurface.linkRefractionWithTransparency;
      }
      set linkRefractionWithTransparency(value) {
        this.subSurface.linkRefractionWithTransparency = value;
        if (value) {
          this.subSurface.isRefractionEnabled = true;
        }
      }
      get usePhysicalLightFalloff() {
        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
      }
      set usePhysicalLightFalloff(value) {
        if (value !== this.usePhysicalLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_PHYSICAL;
          } else {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      get useGLTFLightFalloff() {
        return this._lightFalloff === PBRBaseMaterial.LIGHTFALLOFF_GLTF;
      }
      set useGLTFLightFalloff(value) {
        if (value !== this.useGLTFLightFalloff) {
          this._markAllSubMeshesAsTexturesDirty();
          if (value) {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_GLTF;
          } else {
            this._lightFalloff = PBRBaseMaterial.LIGHTFALLOFF_STANDARD;
          }
        }
      }
      get imageProcessingConfiguration() {
        return this._imageProcessingConfiguration;
      }
      set imageProcessingConfiguration(value) {
        this._attachImageProcessingConfiguration(value);
        this._markAllSubMeshesAsTexturesDirty();
      }
      get cameraColorCurvesEnabled() {
        return this.imageProcessingConfiguration.colorCurvesEnabled;
      }
      set cameraColorCurvesEnabled(value) {
        this.imageProcessingConfiguration.colorCurvesEnabled = value;
      }
      get cameraColorGradingEnabled() {
        return this.imageProcessingConfiguration.colorGradingEnabled;
      }
      set cameraColorGradingEnabled(value) {
        this.imageProcessingConfiguration.colorGradingEnabled = value;
      }
      get cameraToneMappingEnabled() {
        return this._imageProcessingConfiguration.toneMappingEnabled;
      }
      set cameraToneMappingEnabled(value) {
        this._imageProcessingConfiguration.toneMappingEnabled = value;
      }
      get cameraExposure() {
        return this._imageProcessingConfiguration.exposure;
      }
      set cameraExposure(value) {
        this._imageProcessingConfiguration.exposure = value;
      }
      get cameraContrast() {
        return this._imageProcessingConfiguration.contrast;
      }
      set cameraContrast(value) {
        this._imageProcessingConfiguration.contrast = value;
      }
      get cameraColorGradingTexture() {
        return this._imageProcessingConfiguration.colorGradingTexture;
      }
      set cameraColorGradingTexture(value) {
        this._imageProcessingConfiguration.colorGradingTexture = value;
      }
      get cameraColorCurves() {
        return this._imageProcessingConfiguration.colorCurves;
      }
      set cameraColorCurves(value) {
        this._imageProcessingConfiguration.colorCurves = value;
      }
      constructor(name109, scene) {
        super(name109, scene);
        this.directIntensity = 1;
        this.emissiveIntensity = 1;
        this.environmentIntensity = 1;
        this.specularIntensity = 1;
        this.disableBumpMap = false;
        this.ambientTextureStrength = 1;
        this.ambientTextureImpactOnAnalyticalLights = PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
        this.metallicF0Factor = 1;
        this.metallicReflectanceColor = Color3.White();
        this.useOnlyMetallicFromMetallicReflectanceTexture = false;
        this.ambientColor = new Color3(0, 0, 0);
        this.albedoColor = new Color3(1, 1, 1);
        this.reflectivityColor = new Color3(1, 1, 1);
        this.reflectionColor = new Color3(1, 1, 1);
        this.emissiveColor = new Color3(0, 0, 0);
        this.microSurface = 1;
        this.useLightmapAsShadowmap = false;
        this.useAlphaFromAlbedoTexture = false;
        this.forceAlphaTest = false;
        this.alphaCutOff = 0.4;
        this.useSpecularOverAlpha = true;
        this.useMicroSurfaceFromReflectivityMapAlpha = false;
        this.useRoughnessFromMetallicTextureAlpha = true;
        this.useRoughnessFromMetallicTextureGreen = false;
        this.useMetallnessFromMetallicTextureBlue = false;
        this.useAmbientOcclusionFromMetallicTextureRed = false;
        this.useAmbientInGrayScale = false;
        this.useAutoMicroSurfaceFromReflectivityMap = false;
        this.useRadianceOverAlpha = true;
        this.useObjectSpaceNormalMap = false;
        this.useParallax = false;
        this.useParallaxOcclusion = false;
        this.parallaxScaleBias = 0.05;
        this.disableLighting = false;
        this.forceIrradianceInFragment = false;
        this.maxSimultaneousLights = 4;
        this.invertNormalMapX = false;
        this.invertNormalMapY = false;
        this.twoSidedLighting = false;
        this.useAlphaFresnel = false;
        this.useLinearAlphaFresnel = false;
        this.environmentBRDFTexture = null;
        this.forceNormalForward = false;
        this.enableSpecularAntiAliasing = false;
        this.useHorizonOcclusion = true;
        this.useRadianceOcclusion = true;
        this.unlit = false;
        this.applyDecalMapAfterDetailMap = false;
        this._environmentBRDFTexture = GetEnvironmentBRDFTexture(this.getScene());
      }
      getClassName() {
        return "PBRMaterial";
      }
      clone(name109, cloneTexturesOnlyOnce = true, rootUrl = "") {
        const clone = SerializationHelper.Clone(() => new PBRMaterial(name109, this.getScene()), this, { cloneTexturesOnlyOnce });
        clone.id = name109;
        clone.name = name109;
        this.stencil.copyTo(clone.stencil);
        this._clonePlugins(clone, rootUrl);
        return clone;
      }
      serialize() {
        const serializationObject = super.serialize();
        serializationObject.customType = "BABYLON.PBRMaterial";
        return serializationObject;
      }
      static Parse(source, scene, rootUrl) {
        const material = SerializationHelper.Parse(() => new PBRMaterial(source.name, scene), source, scene, rootUrl);
        if (source.stencil) {
          material.stencil.parse(source.stencil, scene, rootUrl);
        }
        Material._parsePlugins(source, material, scene, rootUrl);
        if (source.clearCoat) {
          material.clearCoat.parse(source.clearCoat, scene, rootUrl);
        }
        if (source.anisotropy) {
          material.anisotropy.parse(source.anisotropy, scene, rootUrl);
        }
        if (source.brdf) {
          material.brdf.parse(source.brdf, scene, rootUrl);
        }
        if (source.sheen) {
          material.sheen.parse(source.sheen, scene, rootUrl);
        }
        if (source.subSurface) {
          material.subSurface.parse(source.subSurface, scene, rootUrl);
        }
        if (source.iridescence) {
          material.iridescence.parse(source.iridescence, scene, rootUrl);
        }
        return material;
      }
    };
    PBRMaterial.PBRMATERIAL_OPAQUE = PBRBaseMaterial.PBRMATERIAL_OPAQUE;
    PBRMaterial.PBRMATERIAL_ALPHATEST = PBRBaseMaterial.PBRMATERIAL_ALPHATEST;
    PBRMaterial.PBRMATERIAL_ALPHABLEND = PBRBaseMaterial.PBRMATERIAL_ALPHABLEND;
    PBRMaterial.PBRMATERIAL_ALPHATESTANDBLEND = PBRBaseMaterial.PBRMATERIAL_ALPHATESTANDBLEND;
    PBRMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS = PBRBaseMaterial.DEFAULT_AO_ON_ANALYTICAL_LIGHTS;
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "directIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "environmentIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "specularIntensity", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "disableBumpMap", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "albedoTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTextureStrength", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientTextureImpactOnAnalyticalLights", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "opacityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectionTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectivityTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallic", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "roughness", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicF0Factor", void 0);
    __decorate([
      serializeAsColor3(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicReflectanceColor", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useOnlyMetallicFromMetallicReflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "metallicReflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectanceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "microSurfaceTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "bumpTexture", void 0);
    __decorate([
      serializeAsTexture(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty", null)
    ], PBRMaterial.prototype, "lightmapTexture", void 0);
    __decorate([
      serializeAsColor3("ambient"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "ambientColor", void 0);
    __decorate([
      serializeAsColor3("albedo"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "albedoColor", void 0);
    __decorate([
      serializeAsColor3("reflectivity"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectivityColor", void 0);
    __decorate([
      serializeAsColor3("reflection"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "reflectionColor", void 0);
    __decorate([
      serializeAsColor3("emissive"),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "emissiveColor", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "microSurface", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useLightmapAsShadowmap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "useAlphaFromAlbedoTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "forceAlphaTest", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesAndMiscDirty")
    ], PBRMaterial.prototype, "alphaCutOff", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useSpecularOverAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useMicroSurfaceFromReflectivityMapAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRoughnessFromMetallicTextureAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRoughnessFromMetallicTextureGreen", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useMetallnessFromMetallicTextureBlue", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAmbientOcclusionFromMetallicTextureRed", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAmbientInGrayScale", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAutoMicroSurfaceFromReflectivityMap", void 0);
    __decorate([
      serialize()
    ], PBRMaterial.prototype, "usePhysicalLightFalloff", null);
    __decorate([
      serialize()
    ], PBRMaterial.prototype, "useGLTFLightFalloff", null);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRadianceOverAlpha", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useObjectSpaceNormalMap", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useParallax", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useParallaxOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "parallaxScaleBias", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRMaterial.prototype, "disableLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "forceIrradianceInFragment", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsLightsDirty")
    ], PBRMaterial.prototype, "maxSimultaneousLights", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "invertNormalMapX", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "invertNormalMapY", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "twoSidedLighting", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useAlphaFresnel", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useLinearAlphaFresnel", void 0);
    __decorate([
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "environmentBRDFTexture", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "forceNormalForward", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "enableSpecularAntiAliasing", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useHorizonOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsTexturesDirty")
    ], PBRMaterial.prototype, "useRadianceOcclusion", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRMaterial.prototype, "unlit", void 0);
    __decorate([
      serialize(),
      expandToProperty("_markAllSubMeshesAsMiscDirty")
    ], PBRMaterial.prototype, "applyDecalMapAfterDetailMap", void 0);
    RegisterClass("BABYLON.PBRMaterial", PBRMaterial);
  }
});

// node_modules/@babylonjs/core/Misc/workerPool.js
var WorkerPool, AutoReleaseWorkerPool;
var init_workerPool = __esm({
  "node_modules/@babylonjs/core/Misc/workerPool.js"() {
    WorkerPool = class {
      constructor(workers) {
        this._pendingActions = new Array();
        this._workerInfos = workers.map((worker2) => ({
          workerPromise: Promise.resolve(worker2),
          idle: true
        }));
      }
      dispose() {
        for (const workerInfo of this._workerInfos) {
          workerInfo.workerPromise.then((worker2) => {
            worker2.terminate();
          });
        }
        this._workerInfos.length = 0;
        this._pendingActions.length = 0;
      }
      push(action) {
        if (!this._executeOnIdleWorker(action)) {
          this._pendingActions.push(action);
        }
      }
      _executeOnIdleWorker(action) {
        for (const workerInfo of this._workerInfos) {
          if (workerInfo.idle) {
            this._execute(workerInfo, action);
            return true;
          }
        }
        return false;
      }
      _execute(workerInfo, action) {
        workerInfo.idle = false;
        workerInfo.workerPromise.then((worker2) => {
          action(worker2, () => {
            const nextAction = this._pendingActions.shift();
            if (nextAction) {
              this._execute(workerInfo, nextAction);
            } else {
              workerInfo.idle = true;
            }
          });
        });
      }
    };
    AutoReleaseWorkerPool = class extends WorkerPool {
      constructor(maxWorkers, createWorkerAsync, options = AutoReleaseWorkerPool.DefaultOptions) {
        super([]);
        this._maxWorkers = maxWorkers;
        this._createWorkerAsync = createWorkerAsync;
        this._options = options;
      }
      push(action) {
        if (!this._executeOnIdleWorker(action)) {
          if (this._workerInfos.length < this._maxWorkers) {
            const workerInfo = {
              workerPromise: this._createWorkerAsync(),
              idle: false
            };
            this._workerInfos.push(workerInfo);
            this._execute(workerInfo, action);
          } else {
            this._pendingActions.push(action);
          }
        }
      }
      _execute(workerInfo, action) {
        if (workerInfo.timeoutId) {
          clearTimeout(workerInfo.timeoutId);
          delete workerInfo.timeoutId;
        }
        super._execute(workerInfo, (worker2, onComplete) => {
          action(worker2, () => {
            onComplete();
            if (workerInfo.idle) {
              workerInfo.timeoutId = setTimeout(() => {
                workerInfo.workerPromise.then((worker3) => {
                  worker3.terminate();
                });
                const indexOf = this._workerInfos.indexOf(workerInfo);
                if (indexOf !== -1) {
                  this._workerInfos.splice(indexOf, 1);
                }
              }, this._options.idleTimeElapsedBeforeRelease);
            }
          });
        });
      }
    };
    AutoReleaseWorkerPool.DefaultOptions = {
      idleTimeElapsedBeforeRelease: 1e3
    };
  }
});

// node_modules/@babylonjs/core/Lights/pointLight.js
var PointLight;
var init_pointLight = __esm({
  "node_modules/@babylonjs/core/Lights/pointLight.js"() {
    init_tslib_es6();
    init_decorators();
    init_math_vector();
    init_node();
    init_light();
    init_shadowLight();
    Node.AddNodeConstructor("Light_Type_0", (name109, scene) => {
      return () => new PointLight(name109, Vector3.Zero(), scene);
    });
    PointLight = class extends ShadowLight {
      get shadowAngle() {
        return this._shadowAngle;
      }
      set shadowAngle(value) {
        this._shadowAngle = value;
        this.forceProjectionMatrixCompute();
      }
      get direction() {
        return this._direction;
      }
      set direction(value) {
        const previousNeedCube = this.needCube();
        this._direction = value;
        if (this.needCube() !== previousNeedCube && this._shadowGenerators) {
          const iterator = this._shadowGenerators.values();
          for (let key = iterator.next(); key.done !== true; key = iterator.next()) {
            const shadowGenerator = key.value;
            shadowGenerator.recreateShadowMap();
          }
        }
      }
      constructor(name109, position, scene) {
        super(name109, scene);
        this._shadowAngle = Math.PI / 2;
        this.position = position;
      }
      getClassName() {
        return "PointLight";
      }
      getTypeID() {
        return Light.LIGHTTYPEID_POINTLIGHT;
      }
      needCube() {
        return !this.direction;
      }
      getShadowDirection(faceIndex) {
        if (this.direction) {
          return super.getShadowDirection(faceIndex);
        } else {
          switch (faceIndex) {
            case 0:
              return new Vector3(1, 0, 0);
            case 1:
              return new Vector3(-1, 0, 0);
            case 2:
              return new Vector3(0, -1, 0);
            case 3:
              return new Vector3(0, 1, 0);
            case 4:
              return new Vector3(0, 0, 1);
            case 5:
              return new Vector3(0, 0, -1);
          }
        }
        return Vector3.Zero();
      }
      _setDefaultShadowProjectionMatrix(matrix, viewMatrix, renderList) {
        const activeCamera = this.getScene().activeCamera;
        if (!activeCamera) {
          return;
        }
        const minZ = this.shadowMinZ !== void 0 ? this.shadowMinZ : activeCamera.minZ;
        const maxZ = this.shadowMaxZ !== void 0 ? this.shadowMaxZ : activeCamera.maxZ;
        const useReverseDepthBuffer = this.getScene().getEngine().useReverseDepthBuffer;
        Matrix.PerspectiveFovLHToRef(this.shadowAngle, 1, useReverseDepthBuffer ? maxZ : minZ, useReverseDepthBuffer ? minZ : maxZ, matrix, true, this._scene.getEngine().isNDCHalfZRange, void 0, useReverseDepthBuffer);
      }
      _buildUniformLayout() {
        this._uniformBuffer.addUniform("vLightData", 4);
        this._uniformBuffer.addUniform("vLightDiffuse", 4);
        this._uniformBuffer.addUniform("vLightSpecular", 4);
        this._uniformBuffer.addUniform("vLightFalloff", 4);
        this._uniformBuffer.addUniform("shadowsInfo", 3);
        this._uniformBuffer.addUniform("depthValues", 2);
        this._uniformBuffer.create();
      }
      transferToEffect(effect, lightIndex) {
        if (this.computeTransformedInformation()) {
          this._uniformBuffer.updateFloat4("vLightData", this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z, 0, lightIndex);
        } else {
          this._uniformBuffer.updateFloat4("vLightData", this.position.x, this.position.y, this.position.z, 0, lightIndex);
        }
        this._uniformBuffer.updateFloat4("vLightFalloff", this.range, this._inverseSquaredRange, 0, 0, lightIndex);
        return this;
      }
      transferToNodeMaterialEffect(effect, lightDataUniformName) {
        if (this.computeTransformedInformation()) {
          effect.setFloat3(lightDataUniformName, this.transformedPosition.x, this.transformedPosition.y, this.transformedPosition.z);
        } else {
          effect.setFloat3(lightDataUniformName, this.position.x, this.position.y, this.position.z);
        }
        return this;
      }
      prepareLightSpecificDefines(defines, lightIndex) {
        defines["POINTLIGHT" + lightIndex] = true;
      }
    };
    __decorate([
      serialize()
    ], PointLight.prototype, "shadowAngle", null);
  }
});

// node_modules/@babylonjs/core/Morph/morphTarget.js
var MorphTarget;
var init_morphTarget = __esm({
  "node_modules/@babylonjs/core/Morph/morphTarget.js"() {
    init_tslib_es6();
    init_observable();
    init_engineStore();
    init_buffer();
    init_decorators();
    init_typeStore();
    MorphTarget = class {
      get influence() {
        return this._influence;
      }
      set influence(influence) {
        if (this._influence === influence) {
          return;
        }
        const previous = this._influence;
        this._influence = influence;
        if (this.onInfluenceChanged.hasObservers()) {
          this.onInfluenceChanged.notifyObservers(previous === 0 || influence === 0);
        }
      }
      get animationPropertiesOverride() {
        if (!this._animationPropertiesOverride && this._scene) {
          return this._scene.animationPropertiesOverride;
        }
        return this._animationPropertiesOverride;
      }
      set animationPropertiesOverride(value) {
        this._animationPropertiesOverride = value;
      }
      constructor(name109, influence = 0, scene = null) {
        this.name = name109;
        this.animations = new Array();
        this._positions = null;
        this._normals = null;
        this._tangents = null;
        this._uvs = null;
        this._uniqueId = 0;
        this.onInfluenceChanged = new Observable();
        this._onDataLayoutChanged = new Observable();
        this._animationPropertiesOverride = null;
        this._scene = scene || EngineStore.LastCreatedScene;
        this.influence = influence;
        if (this._scene) {
          this._uniqueId = this._scene.getUniqueId();
        }
      }
      get uniqueId() {
        return this._uniqueId;
      }
      get hasPositions() {
        return !!this._positions;
      }
      get hasNormals() {
        return !!this._normals;
      }
      get hasTangents() {
        return !!this._tangents;
      }
      get hasUVs() {
        return !!this._uvs;
      }
      setPositions(data) {
        const hadPositions = this.hasPositions;
        this._positions = data;
        if (hadPositions !== this.hasPositions) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      getPositions() {
        return this._positions;
      }
      setNormals(data) {
        const hadNormals = this.hasNormals;
        this._normals = data;
        if (hadNormals !== this.hasNormals) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      getNormals() {
        return this._normals;
      }
      setTangents(data) {
        const hadTangents = this.hasTangents;
        this._tangents = data;
        if (hadTangents !== this.hasTangents) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      getTangents() {
        return this._tangents;
      }
      setUVs(data) {
        const hadUVs = this.hasUVs;
        this._uvs = data;
        if (hadUVs !== this.hasUVs) {
          this._onDataLayoutChanged.notifyObservers(void 0);
        }
      }
      getUVs() {
        return this._uvs;
      }
      clone() {
        const newOne = SerializationHelper.Clone(() => new MorphTarget(this.name, this.influence, this._scene), this);
        newOne._positions = this._positions;
        newOne._normals = this._normals;
        newOne._tangents = this._tangents;
        newOne._uvs = this._uvs;
        return newOne;
      }
      serialize() {
        const serializationObject = {};
        serializationObject.name = this.name;
        serializationObject.influence = this.influence;
        serializationObject.positions = Array.prototype.slice.call(this.getPositions());
        if (this.id != null) {
          serializationObject.id = this.id;
        }
        if (this.hasNormals) {
          serializationObject.normals = Array.prototype.slice.call(this.getNormals());
        }
        if (this.hasTangents) {
          serializationObject.tangents = Array.prototype.slice.call(this.getTangents());
        }
        if (this.hasUVs) {
          serializationObject.uvs = Array.prototype.slice.call(this.getUVs());
        }
        SerializationHelper.AppendSerializedAnimations(this, serializationObject);
        return serializationObject;
      }
      getClassName() {
        return "MorphTarget";
      }
      static Parse(serializationObject, scene) {
        const result = new MorphTarget(serializationObject.name, serializationObject.influence);
        result.setPositions(serializationObject.positions);
        if (serializationObject.id != null) {
          result.id = serializationObject.id;
        }
        if (serializationObject.normals) {
          result.setNormals(serializationObject.normals);
        }
        if (serializationObject.tangents) {
          result.setTangents(serializationObject.tangents);
        }
        if (serializationObject.uvs) {
          result.setUVs(serializationObject.uvs);
        }
        if (serializationObject.animations) {
          for (let animationIndex = 0; animationIndex < serializationObject.animations.length; animationIndex++) {
            const parsedAnimation = serializationObject.animations[animationIndex];
            const internalClass = GetClass("BABYLON.Animation");
            if (internalClass) {
              result.animations.push(internalClass.Parse(parsedAnimation));
            }
          }
          if (serializationObject.autoAnimate && scene) {
            scene.beginAnimation(result, serializationObject.autoAnimateFrom, serializationObject.autoAnimateTo, serializationObject.autoAnimateLoop, serializationObject.autoAnimateSpeed || 1);
          }
        }
        return result;
      }
      static FromMesh(mesh, name109, influence) {
        if (!name109) {
          name109 = mesh.name;
        }
        const result = new MorphTarget(name109, influence, mesh.getScene());
        result.setPositions(mesh.getVerticesData(VertexBuffer.PositionKind));
        if (mesh.isVerticesDataPresent(VertexBuffer.NormalKind)) {
          result.setNormals(mesh.getVerticesData(VertexBuffer.NormalKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.TangentKind)) {
          result.setTangents(mesh.getVerticesData(VertexBuffer.TangentKind));
        }
        if (mesh.isVerticesDataPresent(VertexBuffer.UVKind)) {
          result.setUVs(mesh.getVerticesData(VertexBuffer.UVKind));
        }
        return result;
      }
    };
    __decorate([
      serialize()
    ], MorphTarget.prototype, "id", void 0);
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js
var RawTexture2DArray;
var init_rawTexture2DArray = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawTexture2DArray.js"() {
    init_texture();
    init_engine_rawTexture();
    RawTexture2DArray = class extends Texture {
      get depth() {
        return this._depth;
      }
      constructor(data, width, height, depth, format, scene, generateMipMaps = true, invertY = false, samplingMode = Texture.TRILINEAR_SAMPLINGMODE, textureType = 0, creationFlags) {
        super(null, scene, !generateMipMaps, invertY);
        this.format = format;
        this._texture = scene.getEngine().createRawTexture2DArray(data, width, height, depth, format, generateMipMaps, invertY, samplingMode, null, textureType, creationFlags);
        this._depth = depth;
        this.is2DArray = true;
      }
      update(data) {
        if (!this._texture) {
          return;
        }
        this._getEngine().updateRawTexture2DArray(this._texture, data, this._texture.format, this._texture.invertY, null, this._texture.type);
      }
      static CreateRGBATexture(data, width, height, depth, scene, generateMipMaps = true, invertY = false, samplingMode = 3, type = 0) {
        return new RawTexture2DArray(data, width, height, depth, 5, scene, generateMipMaps, invertY, samplingMode, type);
      }
    };
  }
});

// node_modules/@babylonjs/core/Morph/morphTargetManager.js
var MorphTargetManager;
var init_morphTargetManager = __esm({
  "node_modules/@babylonjs/core/Morph/morphTargetManager.js"() {
    init_smartArray();
    init_logger();
    init_engineStore();
    init_morphTarget();
    init_rawTexture2DArray();
    MorphTargetManager = class {
      set areUpdatesFrozen(block) {
        if (block) {
          this._blockCounter++;
        } else {
          this._blockCounter--;
          if (this._blockCounter <= 0) {
            this._blockCounter = 0;
            this._syncActiveTargets(true);
          }
        }
      }
      get areUpdatesFrozen() {
        return this._blockCounter > 0;
      }
      constructor(scene = null) {
        this._targets = new Array();
        this._targetInfluenceChangedObservers = new Array();
        this._targetDataLayoutChangedObservers = new Array();
        this._activeTargets = new SmartArray(16);
        this._supportsNormals = false;
        this._supportsTangents = false;
        this._supportsUVs = false;
        this._vertexCount = 0;
        this._textureVertexStride = 0;
        this._textureWidth = 0;
        this._textureHeight = 1;
        this._uniqueId = 0;
        this._tempInfluences = new Array();
        this._canUseTextureForTargets = false;
        this._blockCounter = 0;
        this._parentContainer = null;
        this.optimizeInfluencers = true;
        this.enableNormalMorphing = true;
        this.enableTangentMorphing = true;
        this.enableUVMorphing = true;
        this._useTextureToStoreTargets = true;
        if (!scene) {
          scene = EngineStore.LastCreatedScene;
        }
        this._scene = scene;
        if (this._scene) {
          this._scene.addMorphTargetManager(this);
          this._uniqueId = this._scene.getUniqueId();
          const engineCaps = this._scene.getEngine().getCaps();
          this._canUseTextureForTargets = engineCaps.canUseGLVertexID && engineCaps.textureFloat && engineCaps.maxVertexTextureImageUnits > 0 && engineCaps.texture2DArrayMaxLayerCount > 1;
        }
      }
      get uniqueId() {
        return this._uniqueId;
      }
      get vertexCount() {
        return this._vertexCount;
      }
      get supportsNormals() {
        return this._supportsNormals && this.enableNormalMorphing;
      }
      get supportsTangents() {
        return this._supportsTangents && this.enableTangentMorphing;
      }
      get supportsUVs() {
        return this._supportsUVs && this.enableUVMorphing;
      }
      get numTargets() {
        return this._targets.length;
      }
      get numInfluencers() {
        return this._activeTargets.length;
      }
      get influences() {
        return this._influences;
      }
      get useTextureToStoreTargets() {
        return this._useTextureToStoreTargets;
      }
      set useTextureToStoreTargets(value) {
        this._useTextureToStoreTargets = value;
      }
      get isUsingTextureForTargets() {
        var _a;
        return MorphTargetManager.EnableTextureStorage && this.useTextureToStoreTargets && this._canUseTextureForTargets && !((_a = this._scene) === null || _a === void 0 ? void 0 : _a.getEngine().getCaps().disableMorphTargetTexture);
      }
      getActiveTarget(index) {
        return this._activeTargets.data[index];
      }
      getTarget(index) {
        return this._targets[index];
      }
      addTarget(target) {
        this._targets.push(target);
        this._targetInfluenceChangedObservers.push(target.onInfluenceChanged.add((needUpdate) => {
          this._syncActiveTargets(needUpdate);
        }));
        this._targetDataLayoutChangedObservers.push(target._onDataLayoutChanged.add(() => {
          this._syncActiveTargets(true);
        }));
        this._syncActiveTargets(true);
      }
      removeTarget(target) {
        const index = this._targets.indexOf(target);
        if (index >= 0) {
          this._targets.splice(index, 1);
          target.onInfluenceChanged.remove(this._targetInfluenceChangedObservers.splice(index, 1)[0]);
          target._onDataLayoutChanged.remove(this._targetDataLayoutChangedObservers.splice(index, 1)[0]);
          this._syncActiveTargets(true);
        }
        if (this._scene) {
          this._scene.stopAnimation(target);
        }
      }
      _bind(effect) {
        effect.setFloat3("morphTargetTextureInfo", this._textureVertexStride, this._textureWidth, this._textureHeight);
        effect.setFloatArray("morphTargetTextureIndices", this._morphTargetTextureIndices);
        effect.setTexture("morphTargets", this._targetStoreTexture);
      }
      clone() {
        const copy = new MorphTargetManager(this._scene);
        for (const target of this._targets) {
          copy.addTarget(target.clone());
        }
        copy.enableNormalMorphing = this.enableNormalMorphing;
        copy.enableTangentMorphing = this.enableTangentMorphing;
        copy.enableUVMorphing = this.enableUVMorphing;
        return copy;
      }
      serialize() {
        const serializationObject = {};
        serializationObject.id = this.uniqueId;
        serializationObject.targets = [];
        for (const target of this._targets) {
          serializationObject.targets.push(target.serialize());
        }
        return serializationObject;
      }
      _syncActiveTargets(needUpdate) {
        if (this.areUpdatesFrozen) {
          return;
        }
        let influenceCount = 0;
        this._activeTargets.reset();
        this._supportsNormals = true;
        this._supportsTangents = true;
        this._supportsUVs = true;
        this._vertexCount = 0;
        if (this._scene && this._targets.length > this._scene.getEngine().getCaps().texture2DArrayMaxLayerCount) {
          this.useTextureToStoreTargets = false;
        }
        if (!this._morphTargetTextureIndices || this._morphTargetTextureIndices.length !== this._targets.length) {
          this._morphTargetTextureIndices = new Float32Array(this._targets.length);
        }
        let targetIndex = -1;
        for (const target of this._targets) {
          targetIndex++;
          if (target.influence === 0 && this.optimizeInfluencers) {
            continue;
          }
          if (this._activeTargets.length >= MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode && !this.isUsingTextureForTargets) {
            break;
          }
          this._activeTargets.push(target);
          this._morphTargetTextureIndices[influenceCount] = targetIndex;
          this._tempInfluences[influenceCount++] = target.influence;
          this._supportsNormals = this._supportsNormals && target.hasNormals;
          this._supportsTangents = this._supportsTangents && target.hasTangents;
          this._supportsUVs = this._supportsUVs && target.hasUVs;
          const positions = target.getPositions();
          if (positions) {
            const vertexCount = positions.length / 3;
            if (this._vertexCount === 0) {
              this._vertexCount = vertexCount;
            } else if (this._vertexCount !== vertexCount) {
              Logger.Error("Incompatible target. Targets must all have the same vertices count.");
              return;
            }
          }
        }
        if (this._morphTargetTextureIndices.length !== influenceCount) {
          this._morphTargetTextureIndices = this._morphTargetTextureIndices.slice(0, influenceCount);
        }
        if (!this._influences || this._influences.length !== influenceCount) {
          this._influences = new Float32Array(influenceCount);
        }
        for (let index = 0; index < influenceCount; index++) {
          this._influences[index] = this._tempInfluences[index];
        }
        if (needUpdate) {
          this.synchronize();
        }
      }
      synchronize() {
        if (!this._scene || this.areUpdatesFrozen) {
          return;
        }
        if (this.isUsingTextureForTargets && this._vertexCount) {
          this._textureVertexStride = 1;
          if (this._supportsNormals) {
            this._textureVertexStride++;
          }
          if (this._supportsTangents) {
            this._textureVertexStride++;
          }
          if (this._supportsUVs) {
            this._textureVertexStride++;
          }
          this._textureWidth = this._vertexCount * this._textureVertexStride;
          this._textureHeight = 1;
          const maxTextureSize = this._scene.getEngine().getCaps().maxTextureSize;
          if (this._textureWidth > maxTextureSize) {
            this._textureHeight = Math.ceil(this._textureWidth / maxTextureSize);
            this._textureWidth = maxTextureSize;
          }
          let mustUpdateTexture = true;
          if (this._targetStoreTexture) {
            const textureSize = this._targetStoreTexture.getSize();
            if (textureSize.width === this._textureWidth && textureSize.height === this._textureHeight && this._targetStoreTexture.depth === this._targets.length) {
              mustUpdateTexture = false;
            }
          }
          if (mustUpdateTexture) {
            if (this._targetStoreTexture) {
              this._targetStoreTexture.dispose();
            }
            const targetCount = this._targets.length;
            const data = new Float32Array(targetCount * this._textureWidth * this._textureHeight * 4);
            let offset = 0;
            for (let index = 0; index < targetCount; index++) {
              const target = this._targets[index];
              const positions = target.getPositions();
              const normals = target.getNormals();
              const uvs = target.getUVs();
              const tangents = target.getTangents();
              if (!positions) {
                if (index === 0) {
                  Logger.Error("Invalid morph target. Target must have positions.");
                }
                return;
              }
              offset = index * this._textureWidth * this._textureHeight * 4;
              for (let vertex = 0; vertex < this._vertexCount; vertex++) {
                data[offset] = positions[vertex * 3];
                data[offset + 1] = positions[vertex * 3 + 1];
                data[offset + 2] = positions[vertex * 3 + 2];
                offset += 4;
                if (this._supportsNormals && normals) {
                  data[offset] = normals[vertex * 3];
                  data[offset + 1] = normals[vertex * 3 + 1];
                  data[offset + 2] = normals[vertex * 3 + 2];
                  offset += 4;
                }
                if (this._supportsUVs && uvs) {
                  data[offset] = uvs[vertex * 2];
                  data[offset + 1] = uvs[vertex * 2 + 1];
                  offset += 4;
                }
                if (this._supportsTangents && tangents) {
                  data[offset] = tangents[vertex * 3];
                  data[offset + 1] = tangents[vertex * 3 + 1];
                  data[offset + 2] = tangents[vertex * 3 + 2];
                  offset += 4;
                }
              }
            }
            this._targetStoreTexture = RawTexture2DArray.CreateRGBATexture(data, this._textureWidth, this._textureHeight, targetCount, this._scene, false, false, 1, 1);
          }
        }
        for (const mesh of this._scene.meshes) {
          if (mesh.morphTargetManager === this) {
            mesh._syncGeometryWithMorphTargetManager();
          }
        }
      }
      dispose() {
        if (this._targetStoreTexture) {
          this._targetStoreTexture.dispose();
        }
        this._targetStoreTexture = null;
        if (this._scene) {
          this._scene.removeMorphTargetManager(this);
          if (this._parentContainer) {
            const index = this._parentContainer.morphTargetManagers.indexOf(this);
            if (index > -1) {
              this._parentContainer.morphTargetManagers.splice(index, 1);
            }
            this._parentContainer = null;
          }
          for (const morph of this._targets) {
            this._scene.stopAnimation(morph);
          }
        }
      }
      static Parse(serializationObject, scene) {
        const result = new MorphTargetManager(scene);
        result._uniqueId = serializationObject.id;
        for (const targetData of serializationObject.targets) {
          result.addTarget(MorphTarget.Parse(targetData, scene));
        }
        return result;
      }
    };
    MorphTargetManager.EnableTextureStorage = true;
    MorphTargetManager.MaxActiveMorphTargetsInVertexAttributeMode = 8;
  }
});

// node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js
var RawCubeTexture;
var init_rawCubeTexture = __esm({
  "node_modules/@babylonjs/core/Materials/Textures/rawCubeTexture.js"() {
    init_decorators();
    init_environmentTextureTools();
    init_internalTexture();
    init_cubeTexture();
    init_engine_rawTexture();
    RawCubeTexture = class extends CubeTexture {
      constructor(scene, data, size, format = 5, type = 0, generateMipMaps = false, invertY = false, samplingMode = 3, compression = null) {
        super("", scene);
        this._texture = scene.getEngine().createRawCubeTexture(data, size, format, type, generateMipMaps, invertY, samplingMode, compression);
      }
      update(data, format, type, invertY, compression = null) {
        this._texture.getEngine().updateRawCubeTexture(this._texture, data, format, type, invertY, compression);
      }
      updateRGBDAsync(data, sphericalPolynomial = null, lodScale = 0.8, lodOffset = 0) {
        return _UpdateRGBDAsync(this._texture, data, sphericalPolynomial, lodScale, lodOffset).then(() => {
        });
      }
      clone() {
        return SerializationHelper.Clone(() => {
          const scene = this.getScene();
          const internalTexture = this._texture;
          const texture = new RawCubeTexture(scene, internalTexture._bufferViewArray, internalTexture.width, internalTexture.format, internalTexture.type, internalTexture.generateMipMaps, internalTexture.invertY, internalTexture.samplingMode, internalTexture._compression);
          if (internalTexture.source === InternalTextureSource.CubeRawRGBD) {
            texture.updateRGBDAsync(internalTexture._bufferViewArrayArray, internalTexture._sphericalPolynomial, internalTexture._lodGenerationScale, internalTexture._lodGenerationOffset);
          }
          return texture;
        }, this);
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js
function createDecoderAsync(wasmBinary) {
  return new Promise((resolve) => {
    DracoDecoderModule({ wasmBinary }).then((module) => {
      resolve({ module });
    });
  });
}
function decodeMesh(decoderModule, dataView, attributes, onIndicesData, onAttributeData, dividers) {
  const buffer = new decoderModule.DecoderBuffer();
  buffer.Init(dataView, dataView.byteLength);
  const decoder = new decoderModule.Decoder();
  let geometry;
  let status;
  try {
    const type = decoder.GetEncodedGeometryType(buffer);
    switch (type) {
      case decoderModule.TRIANGULAR_MESH:
        geometry = new decoderModule.Mesh();
        status = decoder.DecodeBufferToMesh(buffer, geometry);
        break;
      case decoderModule.POINT_CLOUD:
        geometry = new decoderModule.PointCloud();
        status = decoder.DecodeBufferToPointCloud(buffer, geometry);
        break;
      default:
        throw new Error(`Invalid geometry type ${type}`);
    }
    if (!status.ok() || !geometry.ptr) {
      throw new Error(status.error_msg());
    }
    if (type === decoderModule.TRIANGULAR_MESH) {
      const numFaces = geometry.num_faces();
      const numIndices = numFaces * 3;
      const byteLength = numIndices * 4;
      const ptr = decoderModule._malloc(byteLength);
      try {
        decoder.GetTrianglesUInt32Array(geometry, byteLength, ptr);
        const indices = new Uint32Array(numIndices);
        indices.set(new Uint32Array(decoderModule.HEAPF32.buffer, ptr, numIndices));
        onIndicesData(indices);
      } finally {
        decoderModule._free(ptr);
      }
    }
    const processAttribute = (kind, attribute, divider = 1) => {
      const numComponents = attribute.num_components();
      const numPoints = geometry.num_points();
      const numValues = numPoints * numComponents;
      const byteLength = numValues * Float32Array.BYTES_PER_ELEMENT;
      const ptr = decoderModule._malloc(byteLength);
      try {
        decoder.GetAttributeDataArrayForAllPoints(geometry, attribute, decoderModule.DT_FLOAT32, byteLength, ptr);
        const values = new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues);
        if (kind === "color" && numComponents === 3) {
          const babylonData = new Float32Array(numPoints * 4);
          for (let i = 0, j = 0; i < babylonData.length; i += 4, j += numComponents) {
            babylonData[i + 0] = values[j + 0];
            babylonData[i + 1] = values[j + 1];
            babylonData[i + 2] = values[j + 2];
            babylonData[i + 3] = 1;
          }
          onAttributeData(kind, babylonData);
        } else {
          const babylonData = new Float32Array(numValues);
          babylonData.set(new Float32Array(decoderModule.HEAPF32.buffer, ptr, numValues));
          if (divider !== 1) {
            for (let i = 0; i < babylonData.length; i++) {
              babylonData[i] = babylonData[i] / divider;
            }
          }
          onAttributeData(kind, babylonData);
        }
      } finally {
        decoderModule._free(ptr);
      }
    };
    if (attributes) {
      for (const kind in attributes) {
        const id = attributes[kind];
        const attribute = decoder.GetAttributeByUniqueId(geometry, id);
        const divider = dividers && dividers[kind] || 1;
        processAttribute(kind, attribute, divider);
      }
    } else {
      const nativeAttributeTypes = {
        position: "POSITION",
        normal: "NORMAL",
        color: "COLOR",
        uv: "TEX_COORD"
      };
      for (const kind in nativeAttributeTypes) {
        const id = decoder.GetAttributeId(geometry, decoderModule[nativeAttributeTypes[kind]]);
        if (id !== -1) {
          const attribute = decoder.GetAttribute(geometry, id);
          processAttribute(kind, attribute);
        }
      }
    }
  } finally {
    if (geometry) {
      decoderModule.destroy(geometry);
    }
    decoderModule.destroy(decoder);
    decoderModule.destroy(buffer);
  }
}
function worker() {
  let decoderPromise;
  onmessage = (event) => {
    const data = event.data;
    switch (data.id) {
      case "init": {
        const decoder = data.decoder;
        if (decoder.url) {
          importScripts(decoder.url);
          decoderPromise = DracoDecoderModule({ wasmBinary: decoder.wasmBinary });
        }
        postMessage("done");
        break;
      }
      case "decodeMesh": {
        if (!decoderPromise) {
          throw new Error("Draco decoder module is not available");
        }
        decoderPromise.then((decoder) => {
          decodeMesh(decoder, data.dataView, data.attributes, (indices) => {
            postMessage({ id: "indices", value: indices }, [indices.buffer]);
          }, (kind, data2) => {
            postMessage({ id: kind, value: data2 }, [data2.buffer]);
          });
          postMessage("done");
        });
        break;
      }
    }
  };
}
var DracoCompression;
var init_dracoCompression = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/dracoCompression.js"() {
    init_tools();
    init_workerPool();
    init_mesh_vertexData();
    DracoCompression = class {
      static get DecoderAvailable() {
        const decoder = DracoCompression.Configuration.decoder;
        return !!(decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" || decoder.fallbackUrl);
      }
      static GetDefaultNumWorkers() {
        if (typeof navigator !== "object" || !navigator.hardwareConcurrency) {
          return 1;
        }
        return Math.min(Math.floor(navigator.hardwareConcurrency * 0.5), 4);
      }
      static get Default() {
        if (!DracoCompression._Default) {
          DracoCompression._Default = new DracoCompression();
        }
        return DracoCompression._Default;
      }
      constructor(numWorkers = DracoCompression.DefaultNumWorkers) {
        const decoder = DracoCompression.Configuration.decoder;
        const decoderInfo = decoder.wasmUrl && decoder.wasmBinaryUrl && typeof WebAssembly === "object" ? {
          url: Tools.GetAbsoluteUrl(decoder.wasmUrl),
          wasmBinaryPromise: Tools.LoadFileAsync(Tools.GetAbsoluteUrl(decoder.wasmBinaryUrl))
        } : {
          url: Tools.GetAbsoluteUrl(decoder.fallbackUrl),
          wasmBinaryPromise: Promise.resolve(void 0)
        };
        if (numWorkers && typeof Worker === "function" && typeof URL === "function") {
          this._workerPoolPromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {
            const workerContent = `${decodeMesh}(${worker})()`;
            const workerBlobUrl = URL.createObjectURL(new Blob([workerContent], { type: "application/javascript" }));
            return new AutoReleaseWorkerPool(numWorkers, () => {
              return new Promise((resolve, reject) => {
                const worker2 = new Worker(workerBlobUrl);
                const onError = (error) => {
                  worker2.removeEventListener("error", onError);
                  worker2.removeEventListener("message", onMessage);
                  reject(error);
                };
                const onMessage = (message) => {
                  if (message.data === "done") {
                    worker2.removeEventListener("error", onError);
                    worker2.removeEventListener("message", onMessage);
                    resolve(worker2);
                  }
                };
                worker2.addEventListener("error", onError);
                worker2.addEventListener("message", onMessage);
                worker2.postMessage({
                  id: "init",
                  decoder: {
                    url: decoderInfo.url,
                    wasmBinary: decoderWasmBinary
                  }
                });
              });
            });
          });
        } else {
          this._decoderModulePromise = decoderInfo.wasmBinaryPromise.then((decoderWasmBinary) => {
            if (!decoderInfo.url) {
              throw new Error("Draco decoder module is not available");
            }
            return Tools.LoadScriptAsync(decoderInfo.url).then(() => {
              return createDecoderAsync(decoderWasmBinary);
            });
          });
        }
      }
      dispose() {
        if (this._workerPoolPromise) {
          this._workerPoolPromise.then((workerPool) => {
            workerPool.dispose();
          });
        }
        delete this._workerPoolPromise;
        delete this._decoderModulePromise;
      }
      whenReadyAsync() {
        if (this._workerPoolPromise) {
          return this._workerPoolPromise.then(() => {
          });
        }
        if (this._decoderModulePromise) {
          return this._decoderModulePromise.then(() => {
          });
        }
        return Promise.resolve();
      }
      decodeMeshAsync(data, attributes, dividers) {
        const dataView = data instanceof ArrayBuffer ? new Uint8Array(data) : data;
        if (this._workerPoolPromise) {
          return this._workerPoolPromise.then((workerPool) => {
            return new Promise((resolve, reject) => {
              workerPool.push((worker2, onComplete) => {
                const vertexData = new VertexData();
                const onError = (error) => {
                  worker2.removeEventListener("error", onError);
                  worker2.removeEventListener("message", onMessage);
                  reject(error);
                  onComplete();
                };
                const onMessage = (message) => {
                  if (message.data === "done") {
                    worker2.removeEventListener("error", onError);
                    worker2.removeEventListener("message", onMessage);
                    resolve(vertexData);
                    onComplete();
                  } else if (message.data.id === "indices") {
                    vertexData.indices = message.data.value;
                  } else {
                    const divider = dividers && dividers[message.data.id] ? dividers[message.data.id] : 1;
                    if (divider !== 1) {
                      for (let i = 0; i < message.data.value.length; i++) {
                        message.data.value[i] = message.data.value[i] / divider;
                      }
                    }
                    vertexData.set(message.data.value, message.data.id);
                  }
                };
                worker2.addEventListener("error", onError);
                worker2.addEventListener("message", onMessage);
                const dataViewCopy = new Uint8Array(dataView.byteLength);
                dataViewCopy.set(new Uint8Array(dataView.buffer, dataView.byteOffset, dataView.byteLength));
                worker2.postMessage({ id: "decodeMesh", dataView: dataViewCopy, attributes }, [dataViewCopy.buffer]);
              });
            });
          });
        }
        if (this._decoderModulePromise) {
          return this._decoderModulePromise.then((decoder) => {
            const vertexData = new VertexData();
            decodeMesh(decoder.module, dataView, attributes, (indices) => {
              vertexData.indices = indices;
            }, (kind, data2) => {
              vertexData.set(data2, kind);
            }, dividers);
            return vertexData;
          });
        }
        throw new Error("Draco decoder module is not available");
      }
    };
    DracoCompression.Configuration = {
      decoder: {
        wasmUrl: "https://preview.babylonjs.com/draco_wasm_wrapper_gltf.js",
        wasmBinaryUrl: "https://preview.babylonjs.com/draco_decoder_gltf.wasm",
        fallbackUrl: "https://preview.babylonjs.com/draco_decoder_gltf.js"
      }
    };
    DracoCompression.DefaultNumWorkers = DracoCompression.GetDefaultNumWorkers();
    DracoCompression._Default = null;
  }
});

// node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js
var MeshoptCompression;
var init_meshoptCompression = __esm({
  "node_modules/@babylonjs/core/Meshes/Compression/meshoptCompression.js"() {
    init_tools();
    MeshoptCompression = class {
      static get Default() {
        if (!MeshoptCompression._Default) {
          MeshoptCompression._Default = new MeshoptCompression();
        }
        return MeshoptCompression._Default;
      }
      constructor() {
        const decoder = MeshoptCompression.Configuration.decoder;
        this._decoderModulePromise = Tools.LoadScriptAsync(Tools.GetAbsoluteUrl(decoder.url)).then(() => {
          return MeshoptDecoder.ready;
        });
      }
      dispose() {
        delete this._decoderModulePromise;
      }
      decodeGltfBufferAsync(source, count, stride, mode, filter) {
        return this._decoderModulePromise.then(() => {
          const result = new Uint8Array(count * stride);
          MeshoptDecoder.decodeGltfBuffer(result, count, stride, source, mode, filter);
          return result;
        });
      }
    };
    MeshoptCompression.Configuration = {
      decoder: {
        url: "https://preview.babylonjs.com/meshopt_decoder.js"
      }
    };
    MeshoptCompression._Default = null;
  }
});

// node_modules/@babylonjs/core/Misc/deferred.js
var Deferred;
var init_deferred = __esm({
  "node_modules/@babylonjs/core/Misc/deferred.js"() {
    Deferred = class {
      get resolve() {
        return this._resolve;
      }
      get reject() {
        return this._reject;
      }
      constructor() {
        this.promise = new Promise((resolve, reject) => {
          this._resolve = resolve;
          this._reject = reject;
        });
      }
    };
  }
});

// node_modules/@babylonjs/core/Misc/dataReader.js
var DataReader;
var init_dataReader = __esm({
  "node_modules/@babylonjs/core/Misc/dataReader.js"() {
    init_stringTools();
    DataReader = class {
      constructor(buffer) {
        this.byteOffset = 0;
        this.buffer = buffer;
      }
      loadAsync(byteLength) {
        return this.buffer.readAsync(this.byteOffset, byteLength).then((data) => {
          this._dataView = new DataView(data.buffer, data.byteOffset, data.byteLength);
          this._dataByteOffset = 0;
        });
      }
      readUint32() {
        const value = this._dataView.getUint32(this._dataByteOffset, true);
        this._dataByteOffset += 4;
        this.byteOffset += 4;
        return value;
      }
      readUint8Array(byteLength) {
        const value = new Uint8Array(this._dataView.buffer, this._dataView.byteOffset + this._dataByteOffset, byteLength);
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
        return value;
      }
      readString(byteLength) {
        return Decode(this.readUint8Array(byteLength));
      }
      skipBytes(byteLength) {
        this._dataByteOffset += byteLength;
        this.byteOffset += byteLength;
      }
    };
  }
});

// node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js
var init_thinInstanceMesh = __esm({
  "node_modules/@babylonjs/core/Meshes/thinInstanceMesh.js"() {
    init_mesh();
    init_buffer();
    init_math_vector();
    init_logger();
    init_boundingInfo();
    Mesh.prototype.thinInstanceAdd = function(matrix, refresh = true) {
      if (!this.getScene().getEngine().getCaps().instancedArrays) {
        Logger.Error("Thin Instances are not supported on this device as Instanced Array extension not supported");
        return -1;
      }
      this._thinInstanceUpdateBufferSize("matrix", Array.isArray(matrix) ? matrix.length : 1);
      const index = this._thinInstanceDataStorage.instancesCount;
      if (Array.isArray(matrix)) {
        for (let i = 0; i < matrix.length; ++i) {
          this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix[i], i === matrix.length - 1 && refresh);
        }
      } else {
        this.thinInstanceSetMatrixAt(this._thinInstanceDataStorage.instancesCount++, matrix, refresh);
      }
      return index;
    };
    Mesh.prototype.thinInstanceAddSelf = function(refresh = true) {
      return this.thinInstanceAdd(Matrix.IdentityReadOnly, refresh);
    };
    Mesh.prototype.thinInstanceRegisterAttribute = function(kind, stride) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      this.removeVerticesData(kind);
      this._thinInstanceInitializeUserStorage();
      this._userThinInstanceBuffersStorage.strides[kind] = stride;
      this._userThinInstanceBuffersStorage.sizes[kind] = stride * Math.max(32, this._thinInstanceDataStorage.instancesCount);
      this._userThinInstanceBuffersStorage.data[kind] = new Float32Array(this._userThinInstanceBuffersStorage.sizes[kind]);
      this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), this._userThinInstanceBuffersStorage.data[kind], kind, true, false, stride, true);
      this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
    };
    Mesh.prototype.thinInstanceSetMatrixAt = function(index, matrix, refresh = true) {
      if (!this._thinInstanceDataStorage.matrixData || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      const matrixData = this._thinInstanceDataStorage.matrixData;
      matrix.copyToArray(matrixData, index * 16);
      if (this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices[index] = matrix;
      }
      if (refresh) {
        this.thinInstanceBufferUpdated("matrix");
        if (!this.doNotSyncBoundingInfo) {
          this.thinInstanceRefreshBoundingInfo(false);
        }
      }
      return true;
    };
    Mesh.prototype.thinInstanceSetAttributeAt = function(kind, index, value, refresh = true) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      if (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.data[kind] || index >= this._thinInstanceDataStorage.instancesCount) {
        return false;
      }
      this._thinInstanceUpdateBufferSize(kind, 0);
      this._userThinInstanceBuffersStorage.data[kind].set(value, index * this._userThinInstanceBuffersStorage.strides[kind]);
      if (refresh) {
        this.thinInstanceBufferUpdated(kind);
      }
      return true;
    };
    Object.defineProperty(Mesh.prototype, "thinInstanceCount", {
      get: function() {
        return this._thinInstanceDataStorage.instancesCount;
      },
      set: function(value) {
        var _a, _b;
        const matrixData = (_a = this._thinInstanceDataStorage.matrixData) !== null && _a !== void 0 ? _a : (_b = this.source) === null || _b === void 0 ? void 0 : _b._thinInstanceDataStorage.matrixData;
        const numMaxInstances = matrixData ? matrixData.length / 16 : 0;
        if (value <= numMaxInstances) {
          this._thinInstanceDataStorage.instancesCount = value;
        }
      },
      enumerable: true,
      configurable: true
    });
    Mesh.prototype._thinInstanceCreateMatrixBuffer = function(kind, buffer, staticBuffer = false) {
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      const matrixBuffer = new Buffer(this.getEngine(), buffer, !staticBuffer, 16, false, true);
      for (let i = 0; i < 4; i++) {
        this.setVerticesBuffer(matrixBuffer.createVertexBuffer(kind + i, i * 4, 4));
      }
      return matrixBuffer;
    };
    Mesh.prototype.thinInstanceSetBuffer = function(kind, buffer, stride = 0, staticBuffer = false) {
      var _a, _b, _c;
      stride = stride || 16;
      if (kind === "matrix") {
        (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
        this._thinInstanceDataStorage.matrixBufferSize = buffer ? buffer.length : 32 * stride;
        this._thinInstanceDataStorage.matrixData = buffer;
        this._thinInstanceDataStorage.worldMatrices = null;
        if (buffer !== null) {
          this._thinInstanceDataStorage.instancesCount = buffer.length / stride;
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", buffer, staticBuffer);
          if (!this.doNotSyncBoundingInfo) {
            this.thinInstanceRefreshBoundingInfo(false);
          }
        } else {
          this._thinInstanceDataStorage.instancesCount = 0;
          if (!this.doNotSyncBoundingInfo) {
            this.refreshBoundingInfo();
          }
        }
      } else if (kind === "previousMatrix") {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();
        this._thinInstanceDataStorage.previousMatrixBuffer = null;
        this._thinInstanceDataStorage.previousMatrixData = buffer;
        if (buffer !== null) {
          this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", buffer, staticBuffer);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if (buffer === null) {
          if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.data[kind]) {
            this.removeVerticesData(kind);
            delete this._userThinInstanceBuffersStorage.data[kind];
            delete this._userThinInstanceBuffersStorage.strides[kind];
            delete this._userThinInstanceBuffersStorage.sizes[kind];
            delete this._userThinInstanceBuffersStorage.vertexBuffers[kind];
          }
        } else {
          this._thinInstanceInitializeUserStorage();
          this._userThinInstanceBuffersStorage.data[kind] = buffer;
          this._userThinInstanceBuffersStorage.strides[kind] = stride;
          this._userThinInstanceBuffersStorage.sizes[kind] = buffer.length;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), buffer, kind, !staticBuffer, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype.thinInstanceBufferUpdated = function(kind) {
      var _a, _b, _c;
      if (kind === "matrix") {
        (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.updateDirectly(this._thinInstanceDataStorage.matrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else if (kind === "previousMatrix") {
        (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.updateDirectly(this._thinInstanceDataStorage.previousMatrixData, 0, this._thinInstanceDataStorage.instancesCount);
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if ((_c = this._userThinInstanceBuffersStorage) === null || _c === void 0 ? void 0 : _c.vertexBuffers[kind]) {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(this._userThinInstanceBuffersStorage.data[kind], 0);
        }
      }
    };
    Mesh.prototype.thinInstancePartialBufferUpdate = function(kind, data, offset) {
      var _a;
      if (kind === "matrix") {
        if (this._thinInstanceDataStorage.matrixBuffer) {
          this._thinInstanceDataStorage.matrixBuffer.updateDirectly(data, offset);
        }
      } else {
        if (kind === VertexBuffer.ColorKind) {
          kind = VertexBuffer.ColorInstanceKind;
        }
        if ((_a = this._userThinInstanceBuffersStorage) === null || _a === void 0 ? void 0 : _a.vertexBuffers[kind]) {
          this._userThinInstanceBuffersStorage.vertexBuffers[kind].updateDirectly(data, offset);
        }
      }
    };
    Mesh.prototype.thinInstanceGetWorldMatrices = function() {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return [];
      }
      const matrixData = this._thinInstanceDataStorage.matrixData;
      if (!this._thinInstanceDataStorage.worldMatrices) {
        this._thinInstanceDataStorage.worldMatrices = new Array();
        for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
          this._thinInstanceDataStorage.worldMatrices[i] = Matrix.FromArray(matrixData, i * 16);
        }
      }
      return this._thinInstanceDataStorage.worldMatrices;
    };
    Mesh.prototype.thinInstanceRefreshBoundingInfo = function(forceRefreshParentInfo = false, applySkeleton = false, applyMorph = false) {
      if (!this._thinInstanceDataStorage.matrixData || !this._thinInstanceDataStorage.matrixBuffer) {
        return;
      }
      const vectors = this._thinInstanceDataStorage.boundingVectors;
      if (forceRefreshParentInfo || !this.rawBoundingInfo) {
        vectors.length = 0;
        this.refreshBoundingInfo(applySkeleton, applyMorph);
        const boundingInfo2 = this.getBoundingInfo();
        this.rawBoundingInfo = new BoundingInfo(boundingInfo2.minimum, boundingInfo2.maximum);
      }
      const boundingInfo = this.getBoundingInfo();
      const matrixData = this._thinInstanceDataStorage.matrixData;
      if (vectors.length === 0) {
        for (let v = 0; v < boundingInfo.boundingBox.vectors.length; ++v) {
          vectors.push(boundingInfo.boundingBox.vectors[v].clone());
        }
      }
      TmpVectors.Vector3[0].setAll(Number.POSITIVE_INFINITY);
      TmpVectors.Vector3[1].setAll(Number.NEGATIVE_INFINITY);
      for (let i = 0; i < this._thinInstanceDataStorage.instancesCount; ++i) {
        Matrix.FromArrayToRef(matrixData, i * 16, TmpVectors.Matrix[0]);
        for (let v = 0; v < vectors.length; ++v) {
          Vector3.TransformCoordinatesToRef(vectors[v], TmpVectors.Matrix[0], TmpVectors.Vector3[2]);
          TmpVectors.Vector3[0].minimizeInPlace(TmpVectors.Vector3[2]);
          TmpVectors.Vector3[1].maximizeInPlace(TmpVectors.Vector3[2]);
        }
      }
      boundingInfo.reConstruct(TmpVectors.Vector3[0], TmpVectors.Vector3[1]);
      this._updateBoundingInfo();
    };
    Mesh.prototype._thinInstanceUpdateBufferSize = function(kind, numInstances = 1) {
      var _a, _b, _c;
      if (kind === VertexBuffer.ColorKind) {
        kind = VertexBuffer.ColorInstanceKind;
      }
      const kindIsMatrix = kind === "matrix";
      if (!kindIsMatrix && (!this._userThinInstanceBuffersStorage || !this._userThinInstanceBuffersStorage.strides[kind])) {
        return;
      }
      const stride = kindIsMatrix ? 16 : this._userThinInstanceBuffersStorage.strides[kind];
      const currentSize = kindIsMatrix ? this._thinInstanceDataStorage.matrixBufferSize : this._userThinInstanceBuffersStorage.sizes[kind];
      let data = kindIsMatrix ? this._thinInstanceDataStorage.matrixData : this._userThinInstanceBuffersStorage.data[kind];
      const bufferSize = (this._thinInstanceDataStorage.instancesCount + numInstances) * stride;
      let newSize = currentSize;
      while (newSize < bufferSize) {
        newSize *= 2;
      }
      if (!data || currentSize != newSize) {
        if (!data) {
          data = new Float32Array(newSize);
        } else {
          const newData = new Float32Array(newSize);
          newData.set(data, 0);
          data = newData;
        }
        if (kindIsMatrix) {
          (_a = this._thinInstanceDataStorage.matrixBuffer) === null || _a === void 0 ? void 0 : _a.dispose();
          this._thinInstanceDataStorage.matrixBuffer = this._thinInstanceCreateMatrixBuffer("world", data, false);
          this._thinInstanceDataStorage.matrixData = data;
          this._thinInstanceDataStorage.matrixBufferSize = newSize;
          if (this._scene.needsPreviousWorldMatrices && !this._thinInstanceDataStorage.previousMatrixData) {
            (_b = this._thinInstanceDataStorage.previousMatrixBuffer) === null || _b === void 0 ? void 0 : _b.dispose();
            this._thinInstanceDataStorage.previousMatrixBuffer = this._thinInstanceCreateMatrixBuffer("previousWorld", data, false);
          }
        } else {
          (_c = this._userThinInstanceBuffersStorage.vertexBuffers[kind]) === null || _c === void 0 ? void 0 : _c.dispose();
          this._userThinInstanceBuffersStorage.data[kind] = data;
          this._userThinInstanceBuffersStorage.sizes[kind] = newSize;
          this._userThinInstanceBuffersStorage.vertexBuffers[kind] = new VertexBuffer(this.getEngine(), data, kind, true, false, stride, true);
          this.setVerticesBuffer(this._userThinInstanceBuffersStorage.vertexBuffers[kind]);
        }
      }
    };
    Mesh.prototype._thinInstanceInitializeUserStorage = function() {
      if (!this._userThinInstanceBuffersStorage) {
        this._userThinInstanceBuffersStorage = {
          data: {},
          sizes: {},
          vertexBuffers: {},
          strides: {}
        };
      }
    };
    Mesh.prototype._disposeThinInstanceSpecificData = function() {
      var _a;
      if ((_a = this._thinInstanceDataStorage) === null || _a === void 0 ? void 0 : _a.matrixBuffer) {
        this._thinInstanceDataStorage.matrixBuffer.dispose();
        this._thinInstanceDataStorage.matrixBuffer = null;
      }
    };
  }
});

export {
  AnimationKeyInterpolation,
  init_animationKey,
  AnimationRange,
  init_animationRange,
  Node,
  init_node,
  Size,
  init_math_size,
  _IAnimationState,
  Animation,
  init_animation,
  Space,
  Axis,
  Coordinate,
  init_math_axis,
  Bone,
  init_bone,
  Orientation,
  BezierCurve,
  Angle,
  Arc2,
  Path2,
  Path3D,
  Curve3,
  init_math_path,
  AnimationEvent,
  init_animationEvent,
  TargetedAnimation,
  AnimationGroup,
  init_animationGroup,
  inlineScheduler,
  createYieldingScheduler,
  runCoroutine,
  runCoroutineSync,
  runCoroutineAsync,
  makeSyncFunction,
  makeAsyncFunction,
  init_coroutine,
  Viewport,
  init_math_viewport,
  Camera,
  init_camera,
  IntersectionInfo,
  init_intersectionInfo,
  BoundingBox,
  init_boundingBox,
  BoundingSphere,
  init_boundingSphere,
  BoundingInfo,
  init_boundingInfo,
  extractMinAndMaxIndexed,
  extractMinAndMax,
  init_math_functions,
  SubMesh,
  init_subMesh,
  VertexDataMaterialInfo,
  VertexData,
  init_mesh_vertexData,
  SceneLoaderFlags,
  init_sceneLoaderFlags,
  CompatibilityOptions,
  init_compatibilityOptions,
  Geometry,
  init_geometry,
  TransformNode,
  init_transformNode,
  _MeshCollisionData,
  init_meshCollisionData,
  AbstractMesh,
  init_abstractMesh,
  addClipPlaneUniforms,
  prepareStringDefinesForClipPlanes,
  prepareDefinesForClipPlanes,
  bindClipPlane,
  init_clipPlaneMaterialHelper,
  MaterialHelper,
  init_materialHelper,
  MaterialPluginEvent,
  init_materialPluginEvent,
  Material,
  init_material,
  MultiMaterial,
  init_multiMaterial,
  MeshLODLevel,
  init_meshLODLevel,
  _CreationDataStorage,
  _InstancesBatch,
  Mesh,
  init_mesh,
  InstancedMesh,
  init_instancedMesh,
  Light,
  init_light,
  KeepAssets,
  InstantiatedEntries,
  AssetContainer,
  init_assetContainer,
  Sound,
  init_sound,
  WeightedSound,
  init_weightedsound,
  ThinTexture,
  init_thinTexture,
  BaseTexture,
  init_baseTexture,
  GenerateBase64StringFromPixelData,
  GenerateBase64StringFromTexture,
  GenerateBase64StringFromTextureAsync,
  CopyTools,
  init_copyTools,
  Texture,
  init_texture,
  init_engine_rawTexture,
  RawTexture,
  init_rawTexture,
  SceneLoaderAnimationGroupLoadingMode,
  SceneLoader,
  init_sceneLoader,
  PushMaterial,
  init_pushMaterial,
  PositionNormalVertex,
  PositionNormalTextureVertex,
  init_math,
  EffectFallbacks,
  init_effectFallbacks,
  init_postprocess_vertex,
  RenderTargetWrapper,
  init_renderTargetWrapper,
  init_engine_renderTarget,
  PostProcess,
  init_postProcess,
  init_engine_renderTargetCube,
  EffectRenderer,
  EffectWrapper,
  init_effectRenderer,
  DumpTools,
  init_dumpTools,
  RenderTargetTexture,
  init_renderTargetTexture,
  Skeleton,
  init_skeleton,
  BaseCameraMouseWheelInput,
  init_BaseCameraMouseWheelInput,
  CameraInputTypes,
  CameraInputsManager,
  init_cameraInputsManager,
  FreeCameraKeyboardMoveInput,
  init_freeCameraKeyboardMoveInput,
  FreeCameraMouseInput,
  init_freeCameraMouseInput,
  FreeCameraMouseWheelInput,
  init_freeCameraMouseWheelInput,
  FreeCameraTouchInput,
  init_freeCameraTouchInput,
  FreeCameraInputsManager,
  init_freeCameraInputsManager,
  TargetCamera,
  init_targetCamera,
  FreeCamera,
  init_freeCamera,
  PassPostProcess,
  PassCubePostProcess,
  init_passPostProcess,
  HemisphericLight,
  init_hemisphericLight,
  MaterialFlags,
  init_materialFlags,
  init_sceneUboDeclaration,
  init_meshUboDeclaration,
  init_helperFunctions,
  init_lightFragmentDeclaration,
  init_lightUboDeclaration,
  init_lightsFragmentFunctions,
  init_shadowsFragmentFunctions,
  init_fresnelFunction,
  init_reflectionFunction,
  init_imageProcessingDeclaration,
  init_imageProcessingFunctions,
  init_bumpFragmentMainFunctions,
  init_bumpFragmentFunctions,
  init_clipPlaneFragmentDeclaration,
  init_logDepthDeclaration,
  init_fogFragmentDeclaration,
  init_clipPlaneFragment,
  init_bumpFragment,
  init_depthPrePass,
  init_lightFragment,
  init_logDepthFragment,
  init_fogFragment,
  init_bonesDeclaration,
  init_bakedVertexAnimationDeclaration,
  init_instancesDeclaration,
  init_clipPlaneVertexDeclaration,
  init_fogVertexDeclaration,
  init_lightVxFragmentDeclaration,
  init_lightVxUboDeclaration,
  init_morphTargetsVertexGlobalDeclaration,
  init_morphTargetsVertexDeclaration,
  init_morphTargetsVertexGlobal,
  init_morphTargetsVertex,
  init_instancesVertex,
  init_bonesVertex,
  init_bakedVertexAnimation,
  init_bumpVertex,
  init_clipPlaneVertex,
  init_fogVertex,
  init_shadowsVertex,
  init_vertexColorMixing,
  init_logDepthVertex,
  MaterialPluginManager,
  RegisterMaterialPlugin,
  UnregisterMaterialPlugin,
  UnregisterAllMaterialPlugins,
  init_materialPluginManager,
  MaterialPluginBase,
  init_materialPluginBase,
  MaterialDetailMapDefines,
  DetailMapConfiguration,
  init_material_detailMapConfiguration,
  StandardMaterialDefines,
  StandardMaterial,
  init_standardMaterial,
  ShaderMaterial,
  init_shaderMaterial,
  Constants,
  init_constants,
  init_engine_cubeTexture,
  SphericalHarmonics,
  SphericalPolynomial,
  init_sphericalPolynomial,
  CreateResizedCopy,
  ApplyPostProcess,
  ToHalfFloat,
  FromHalfFloat,
  TextureTools,
  init_textureTools,
  RGBDTextureTools,
  init_rgbdTextureTools,
  CubeMapToSphericalPolynomialTools,
  init_cubemapToSphericalPolynomial,
  init_baseTexture_polynomial,
  GetEnvInfo,
  normalizeEnvInfo,
  CreateEnvTextureAsync,
  CreateImageDataArrayBufferViews,
  UploadEnvLevelsAsync,
  UploadLevelsAsync,
  UploadEnvSpherical,
  _UpdateRGBDAsync,
  EnvironmentTextureTools,
  init_environmentTextureTools,
  ShadowLight,
  init_shadowLight,
  DirectionalLight,
  init_directionalLight,
  SpotLight,
  init_spotLight,
  CubeTexture,
  init_cubeTexture,
  GetEnvironmentBRDFTexture,
  BRDFTextureTools,
  init_brdfTextureTools,
  PBRBRDFConfiguration,
  init_pbrBRDFConfiguration,
  init_subSurfaceScatteringFunctions,
  init_importanceSampling,
  init_pbrBRDFFunctions,
  init_hdrFilteringFunctions,
  MaterialClearCoatDefines,
  PBRClearCoatConfiguration,
  init_pbrClearCoatConfiguration,
  MaterialIridescenceDefines,
  PBRIridescenceConfiguration,
  init_pbrIridescenceConfiguration,
  MaterialAnisotropicDefines,
  PBRAnisotropicConfiguration,
  init_pbrAnisotropicConfiguration,
  MaterialSheenDefines,
  PBRSheenConfiguration,
  init_pbrSheenConfiguration,
  MaterialSubSurfaceDefines,
  PBRSubSurfaceConfiguration,
  init_pbrSubSurfaceConfiguration,
  PBRMaterialDefines,
  PBRBaseMaterial,
  init_pbrBaseMaterial,
  PBRMaterial,
  init_pbrMaterial,
  WorkerPool,
  AutoReleaseWorkerPool,
  init_workerPool,
  PointLight,
  init_pointLight,
  MorphTarget,
  init_morphTarget,
  RawTexture2DArray,
  init_rawTexture2DArray,
  MorphTargetManager,
  init_morphTargetManager,
  RawCubeTexture,
  init_rawCubeTexture,
  DracoCompression,
  init_dracoCompression,
  MeshoptCompression,
  init_meshoptCompression,
  init_thinInstanceMesh,
  Deferred,
  init_deferred,
  DataReader,
  init_dataReader
};
//# sourceMappingURL=chunk-W4WU7HOY.js.map
